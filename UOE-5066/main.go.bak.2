package main

import (
	"fmt"
	"math"
	"strconv"
)

//AdPod
type AdPod struct {
	MinAds          int `json:"minads,omitempty"`      //Default 1 if not specified
	MaxAds          int `json:"maxads,omitempty"`      //Default 1 if not specified
	SlotMinDuration int `json:"minduration,omitempty"` // adpod.minduration*adpod.minads should be greater than or equal to video.minduration
	SlotMaxDuration int `json:"maxduration,omitempty"` // adpod.maxduration*adpod.maxads should be less than or equal to video.maxduration + video.maxextended
	//	AdvertiserExclusionPercent  int `json:"excladv,omitempty"`     // Percent value 0 means none of the ads can be from same advertiser 100 means can have all same advertisers
	//IABCategoryExclusionPercent int `json:"excliabcat,omitempty"`  // Percent value 0 means all ads should be of different IAB categories.
	Minduration int
	MaxDuration int
	slots       []int
}

func main() {
	pod := AdPod{}
	pod.Minduration = 35
	pod.MaxDuration = 35
	pod.SlotMinDuration = 10
	pod.SlotMaxDuration = 35
	pod.MinAds = 3
	pod.MaxAds = 4
	fmt.Printf("%+v\n\n", pod)
	pod.maxAdBaseCount()
}

func (pod AdPod) maxAdBaseCount() int {
	// compute imp count based
	impCntByMinAdSlotDuration := pod.MaxDuration / pod.SlotMinDuration
	impCntByMaxAdSlotDuration := pod.MaxDuration / pod.SlotMaxDuration

	// get max impression count
	impCnt := 0
	if impCntByMaxAdSlotDuration > impCntByMinAdSlotDuration {
		impCnt = impCntByMaxAdSlotDuration
	} else {
		impCnt = impCntByMinAdSlotDuration
	}

	if impCnt > pod.MaxAds {
		fmt.Println("max impression count ", impCnt, ">", pod.MaxAds, "Max allowed ads. Hence, setting to max allowed")
		impCnt = pod.MaxAds
	}
	//fmt.Println(impCnt)

	// get time for each slot
	//durationForEachSlot := float64(pod.MaxDuration) / float64(impCnt)
	//fmt.Println(durationForEachSlot)
	//abs := math.Abs(math.Round(durationForEachSlot))

	//durationForEachSlot := float64(pod.MaxDuration) / float64(impCnt)
	absslottime, mantissa := math.Modf(float64(pod.MaxDuration) / float64(impCnt))
	var freeTime float64 = 0

	if int(absslottime) > pod.SlotMaxDuration {
		// add  subtracted time for each slot  in   freeTime
		freeTime += (absslottime - float64(pod.SlotMaxDuration)) * float64(impCnt)
		absslottime = float64(pod.SlotMaxDuration)
	}

	//mantissa := math.Abs(abs - durationForEachSlot)
	//mantissa := float64(abs) - durationForEachSlot
	// fmt.Printf("mantissa = %f", mantissa)

	// adjust mantissa
	freeTime += mantissa * float64(impCnt)

	// fmt.Println(freeTime)
	// create list
	pod.slots = make([]int, impCnt)
	for i := 0; i < impCnt; i++ {
		pod.slots[i] = int(absslottime)
	}

	pod.print(freeTime)

	// adjust mantissa
	freeTime = float64(pod.adjustFreeTime(freeTime))

	pod.print(freeTime)

	fmt.Println("Total Impressions =", impCnt)

	return 1
}

func (pod AdPod) print(freeTime float64) {
	setEq := false

	totalTime := 0

	for i := 0; i < len(pod.slots); i++ {
		if setEq {
			fmt.Print(" + ")
		}
		fmt.Print(pod.slots[i])
		totalTime += pod.slots[i]
		setEq = true
	}
	totalTime += int(freeTime)
	fmt.Print(" + ", freeTime, "           = ", totalTime, "sec (Max Duration =", pod.MaxDuration, "sec)")
	fmt.Println()
	setEq = false
	for i := 1; i <= len(pod.slots); i++ {
		if setEq {
			fmt.Print("   ")
		}
		fmt.Print("S" + strconv.Itoa(i))
		setEq = true
	}
	fmt.Println("  (free)")
}

// return 1 -> freetime
func (pod AdPod) adjustFreeTime(frtime float64) int {

	freeTime := int(frtime)
	if freeTime == 0 {
		return freeTime
	}

	// check slot0
	slot0 := pod.slots[0]
	// current alloed slottime < max allowed slot time and current +freetime <= max allowed slot time
	if slot0 < pod.SlotMaxDuration && (slot0+int(freeTime)) <= pod.SlotMaxDuration {
		pod.slots[0] = slot0 + freeTime
		fmt.Println("Free time is adusted by slot1")
		return 0
	}

	// slot0 can not be used
	// check next immidiete slot which
	for i := 1; i < len(pod.slots); i++ {
		if pod.slots[i] < pod.SlotMaxDuration && (slot0+int(freeTime)) < pod.SlotMaxDuration {
			pod.slots[i] = slot0 + freeTime
			fmt.Println("\n\nFree time is adusted by slot", i+1)
			return 0
		}
	}

	// none of the slot is able adust free time
	fmt.Println("\n\n**** Free time", freeTime, "sec, is not adjusted by any slot, because each slot time  is reached max limit")

	// check if we have opportunity to create slots
	// based on
	// 1. max no of slots
	// 2. min slotduratoin
	// 3. max slot duaration
	if len(pod.slots) < pod.MaxAds && (pod.SlotMinDuration <= freeTime && freeTime <= pod.SlotMaxDuration) {
		//	pod.slots[len(po)]
	}

	return freeTime
}
