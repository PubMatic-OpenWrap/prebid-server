diff --git a/.github/CODEOWNERS b/.github/CODEOWNERS
new file mode 100644
index 000000000..0ea4f4c43
--- /dev/null
+++ b/.github/CODEOWNERS
@@ -0,0 +1 @@
+*	@viral-vala @shriprasad-marathe @ganesh-salpure
diff --git a/.github/pull_request_template.md b/.github/pull_request_template.md
new file mode 100644
index 000000000..d124f544b
--- /dev/null
+++ b/.github/pull_request_template.md
@@ -0,0 +1,12 @@
+# Description
+
+Please add change description or link to ticket, docs, etc.
+
+# Checklist:
+
+- [ ] PR commit list is unique (rebase/pull with the origin branch to keep master clean).
+- [ ] JIRA number is added in the PR title and the commit message.
+- [ ] Updated the `header-bidding` repo with appropiate commit id.
+- [ ] Documented the new changes.
+
+For Prebid upgrade, refer: https://inside.pubmatic.com:8443/confluence/display/Products/Prebid-server+upgrade
diff --git a/.gitignore b/.gitignore
index 514e217b4..9adcfb130 100644
--- a/.gitignore
+++ b/.gitignore
@@ -40,6 +40,7 @@ inventory_url.yaml
 
 # generated log files during tests
 analytics/config/testFiles/
+analytics/config/xyz*
 analytics/filesystem/testFiles/
 
 # autogenerated version file
@@ -51,3 +52,6 @@ analytics/filesystem/testFiles/
 # autogenerated mac file
 
 .DS_Store
+
+pbsimage
+manual_build
\ No newline at end of file
diff --git a/Makefile b/Makefile
index baf69cafb..46f33ecf2 100644
--- a/Makefile
+++ b/Makefile
@@ -29,3 +29,18 @@ build: test
 # image will build a docker image
 image:
 	docker build -t prebid-server .
+
+mockgen: mockgeninstall mockgendb
+
+# export GOBIN=~/go/bin; export PATH=$PATH:$GOBIN
+mockgeninstall:
+	go install github.com/golang/mock/mockgen@v1.6.0
+
+mockgendb:
+	mkdir -p modules/pubmatic/openwrap/database/mock modules/pubmatic/openwrap/database/mock_driver
+	mockgen database/sql/driver Driver,Connector,Conn,DriverContext > modules/pubmatic/openwrap/database/mock_driver/mock.go
+	mockgen github.com/pm-nilesh-chate/prebid-server/modules/pubmatic/openwrap/database Database > modules/pubmatic/openwrap/database/mock/mock.go
+
+mockgencache:
+	mkdir -p modules/pubmatic/openwrap/cache/mock
+	mockgen github.com/pm-nilesh-chate/prebid-server/modules/pubmatic/openwrap/cache Cache > modules/pubmatic/openwrap/cache/mock/mock.go
\ No newline at end of file
diff --git a/README.md b/README.md
index 4ec6792c0..d9625b100 100644
--- a/README.md
+++ b/README.md
@@ -30,8 +30,8 @@ Download and prepare Prebid Server:
 
 ```bash
 cd YOUR_DIRECTORY
-git clone https://github.com/prebid/prebid-server src/github.com/prebid/prebid-server
-cd src/github.com/prebid/prebid-server
+git clone https://github.com/PubMatic-OpenWrap/prebid-server src/github.com/PubMatic-OpenWrap/prebid-server
+cd src/github.com/PubMatic-OpenWrap/prebid-server
 ```
 
 Run the automated tests:
@@ -60,11 +60,10 @@ of exported types.
 
 Want to [add an adapter](https://docs.prebid.org/prebid-server/developers/add-new-bidder-go.html)? Found a bug? Great!
 
-Report bugs, request features, and suggest improvements [on Github](https://github.com/prebid/prebid-server/issues).
-
-Or better yet, [open a pull request](https://github.com/prebid/prebid-server/compare) with the changes you'd like to see.
+Or better yet, [open a pull request](https://github.com/PubMatic-OpenWrap/prebid-server/compare) with the changes you'd like to see.
 
 ## IDE Recommendations
 
 The quickest way to start developing Prebid Server in a reproducible environment isolated from your host OS
 is by using Visual Studio Code with [Remote Container Setup](devcontainer.md).
+
diff --git a/adapters/appnexus/appnexus.go b/adapters/appnexus/appnexus.go
index f70914a19..7753b982f 100644
--- a/adapters/appnexus/appnexus.go
+++ b/adapters/appnexus/appnexus.go
@@ -146,16 +146,17 @@ func (a *adapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *adapters.E
 	reqExt.Appnexus.IsAMP = isAMP
 	reqExt.Appnexus.HeaderBiddingSource = a.hbSource + isVIDEO
 
+	// Commenting out the following piece of code to avoid populating adpod_id in the Appnexus request (ref: https://inside.pubmatic.com:9443/jira/browse/UOE-6196)
 	// For long form requests if adpodId feature enabled, adpod_id must be sent downstream.
 	// Adpod id is a unique identifier for pod
 	// All impressions in the same pod must have the same pod id in request extension
 	// For this all impressions in  request should belong to the same pod
 	// If impressions number per pod is more than maxImpsPerReq - divide those imps to several requests but keep pod id the same
 	// If  adpodId feature disabled and impressions number per pod is more than maxImpsPerReq  - divide those imps to several requests but do not include ad pod id
-	if isVIDEO == 1 && *shouldGenerateAdPodId {
+	/*if isVIDEO == 1 && *shouldGenerateAdPodId {
 		requests, errors := a.buildAdPodRequests(request.Imp, request, reqExt, requestURI.String())
 		return requests, append(errs, errors...)
-	}
+	}*/
 
 	requests, errors := splitRequests(request.Imp, request, reqExt, requestURI.String())
 	return requests, append(errs, errors...)
@@ -407,7 +408,7 @@ func buildDisplayManageVer(req *openrtb2.BidRequest) string {
 	return fmt.Sprintf("%s-%s", source, version)
 }
 
-func (a *adapter) buildAdPodRequests(imps []openrtb2.Imp, request *openrtb2.BidRequest, requestExtension appnexusReqExt, uri string) ([]*adapters.RequestData, []error) {
+/*func (a *adapter) buildAdPodRequests(imps []openrtb2.Imp, request *openrtb2.BidRequest, requestExtension appnexusReqExt, uri string) ([]*adapters.RequestData, []error) {
 	var errs []error
 	podImps := groupByPods(imps)
 	requests := make([]*adapters.RequestData, 0, len(podImps))
@@ -420,4 +421,4 @@ func (a *adapter) buildAdPodRequests(imps []openrtb2.Imp, request *openrtb2.BidR
 	}
 
 	return requests, errs
-}
+}*/
diff --git a/adapters/appnexus/appnexustest/video/video-same-adpodid-two-imps-same-pod.json b/adapters/appnexus/appnexustest/video/video-same-adpodid-two-imps-same-pod.json
index 86fa14aac..d0940a234 100644
--- a/adapters/appnexus/appnexustest/video/video-same-adpodid-two-imps-same-pod.json
+++ b/adapters/appnexus/appnexustest/video/video-same-adpodid-two-imps-same-pod.json
@@ -47,7 +47,6 @@
 			"id": "test-request-id",
 			"ext": {
 				"appnexus": {
-				 "adpod_id": "10",
 				  "hb_source": 6
 				},
 				"prebid": {}
diff --git a/adapters/bidder.go b/adapters/bidder.go
index 28fb555d5..9ee68dfed 100644
--- a/adapters/bidder.go
+++ b/adapters/bidder.go
@@ -101,6 +101,7 @@ type TypedBid struct {
 	BidMeta      *openrtb_ext.ExtBidPrebidMeta
 	BidType      openrtb_ext.BidType
 	BidVideo     *openrtb_ext.ExtBidPrebidVideo
+	BidTargets   map[string]string
 	DealPriority int
 	Seat         openrtb_ext.BidderName
 }
@@ -116,12 +117,20 @@ type ResponseData struct {
 	Headers    http.Header
 }
 
+type BidRequestParams struct {
+	ImpIndex     int
+	VASTTagIndex int
+}
+
 // RequestData packages together the fields needed to make an http.Request.
 type RequestData struct {
+	Params  *BidRequestParams
 	Method  string
 	Uri     string
 	Body    []byte
 	Headers http.Header
+
+	BidderName openrtb_ext.BidderName `json:"-"`
 }
 
 // ExtImpBidder can be used by Bidders to unmarshal any request.imp[i].ext.
@@ -149,6 +158,7 @@ type ExtraRequestInfo struct {
 	BidderRequestStartTime     time.Time
 	GlobalPrivacyControlHeader string
 	CurrencyConversions        currency.Conversions
+	BidAdjustmentFactor        float64
 	MakeBidsTimeInfo           MakeBidsTimeInfo
 }
 
diff --git a/adapters/conversant/conversant.go b/adapters/conversant/conversant.go
index ec4d2078d..3623dc655 100644
--- a/adapters/conversant/conversant.go
+++ b/adapters/conversant/conversant.go
@@ -73,7 +73,7 @@ func (c *ConversantAdapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *
 }
 
 func parseCnvrParams(imp *openrtb2.Imp, cnvrExt openrtb_ext.ExtImpConversant) {
-	imp.DisplayManager = "prebid-s2s"
+	imp.DisplayManager = "pubmatic-openwrap"
 	imp.DisplayManagerVer = "2.0.0"
 
 	if imp.BidFloor <= 0 && cnvrExt.BidFloor > 0 {
diff --git a/adapters/conversant/conversanttest/exemplary/banner.json b/adapters/conversant/conversanttest/exemplary/banner.json
index 472e18f71..9c3569eb4 100644
--- a/adapters/conversant/conversanttest/exemplary/banner.json
+++ b/adapters/conversant/conversanttest/exemplary/banner.json
@@ -41,7 +41,7 @@
               "tagid": "mytag",
               "secure": 1,
               "bidfloor": 0.01,
-              "displaymanager": "prebid-s2s",
+              "displaymanager": "pubmatic-openwrap",
               "displaymanagerver": "2.0.0",
               "banner": {
                 "format": [{"w": 300, "h": 250}]
diff --git a/adapters/conversant/conversanttest/exemplary/simple_app.json b/adapters/conversant/conversanttest/exemplary/simple_app.json
index 303c60f75..d094f1f2c 100644
--- a/adapters/conversant/conversanttest/exemplary/simple_app.json
+++ b/adapters/conversant/conversanttest/exemplary/simple_app.json
@@ -45,7 +45,7 @@
               "tagid": "mytag",
               "secure": 1,
               "bidfloor": 0.01,
-              "displaymanager": "prebid-s2s",
+              "displaymanager": "pubmatic-openwrap",
               "displaymanagerver": "2.0.0",
               "banner": {
                 "format": [{"w": 300, "h": 250}]
diff --git a/adapters/conversant/conversanttest/exemplary/video.json b/adapters/conversant/conversanttest/exemplary/video.json
index 475dd7962..56606aab4 100644
--- a/adapters/conversant/conversanttest/exemplary/video.json
+++ b/adapters/conversant/conversanttest/exemplary/video.json
@@ -49,7 +49,7 @@
               "tagid": "mytag",
               "secure": 1,
               "bidfloor": 0.01,
-              "displaymanager": "prebid-s2s",
+              "displaymanager": "pubmatic-openwrap",
               "displaymanagerver": "2.0.0",
               "video": {
                 "w": 300,
diff --git a/adapters/conversant/conversanttest/supplemental/server_badresponse.json b/adapters/conversant/conversanttest/supplemental/server_badresponse.json
index 96cb4b464..0cab9523b 100644
--- a/adapters/conversant/conversanttest/supplemental/server_badresponse.json
+++ b/adapters/conversant/conversanttest/supplemental/server_badresponse.json
@@ -30,7 +30,7 @@
         "imp": [
           {
             "id": "1",
-            "displaymanager": "prebid-s2s",
+            "displaymanager": "pubmatic-openwrap",
             "displaymanagerver": "2.0.0",
             "banner": {
               "format": [{"w": 300, "h": 250}]
diff --git a/adapters/conversant/conversanttest/supplemental/server_nocontent.json b/adapters/conversant/conversanttest/supplemental/server_nocontent.json
index ad86d19d6..15707c757 100644
--- a/adapters/conversant/conversanttest/supplemental/server_nocontent.json
+++ b/adapters/conversant/conversanttest/supplemental/server_nocontent.json
@@ -30,7 +30,7 @@
         "imp": [
           {
             "id": "1",
-            "displaymanager": "prebid-s2s",
+            "displaymanager": "pubmatic-openwrap",
             "displaymanagerver": "2.0.0",
             "banner": {
               "format": [{"w": 300, "h": 250}]
diff --git a/adapters/conversant/conversanttest/supplemental/server_unknownstatus.json b/adapters/conversant/conversanttest/supplemental/server_unknownstatus.json
index 85586f066..cabfeaf32 100644
--- a/adapters/conversant/conversanttest/supplemental/server_unknownstatus.json
+++ b/adapters/conversant/conversanttest/supplemental/server_unknownstatus.json
@@ -30,7 +30,7 @@
         "imp": [
           {
             "id": "1",
-            "displaymanager": "prebid-s2s",
+            "displaymanager": "pubmatic-openwrap",
             "displaymanagerver": "2.0.0",
             "banner": {
               "format": [{"w": 300, "h": 250}]
diff --git a/adapters/conversant/conversanttest/supplemental/test_params.json b/adapters/conversant/conversanttest/supplemental/test_params.json
index 403bcc422..cf71299df 100644
--- a/adapters/conversant/conversanttest/supplemental/test_params.json
+++ b/adapters/conversant/conversanttest/supplemental/test_params.json
@@ -107,7 +107,7 @@
             "bidfloor": 7,
             "secure": 1,
             "tagid": "mytag",
-            "displaymanager": "prebid-s2s",
+            "displaymanager": "pubmatic-openwrap",
             "displaymanagerver": "2.0.0",
             "video": {
               "api": [1,2],
@@ -126,7 +126,7 @@
             "bidfloor": 1,
             "secure": 1,
             "tagid": "mytag",
-            "displaymanager": "prebid-s2s",
+            "displaymanager": "pubmatic-openwrap",
             "displaymanagerver": "2.0.0",
             "video": {
               "api": [1,2],
@@ -154,7 +154,7 @@
             "bidfloor": 7,
             "secure": 1,
             "tagid": "mytag",
-            "displaymanager": "prebid-s2s",
+            "displaymanager": "pubmatic-openwrap",
             "displaymanagerver": "2.0.0",
             "video": {
               "api": [1,2],
@@ -182,7 +182,7 @@
             "bidfloor": -3,
             "secure": 1,
             "tagid": "mytag",
-            "displaymanager": "prebid-s2s",
+            "displaymanager": "pubmatic-openwrap",
             "displaymanagerver": "2.0.0",
             "video": {
               "api": [1,2],
diff --git a/adapters/infoawarebidder_ow_test.go b/adapters/infoawarebidder_ow_test.go
new file mode 100644
index 000000000..0668784e5
--- /dev/null
+++ b/adapters/infoawarebidder_ow_test.go
@@ -0,0 +1,194 @@
+package adapters
+
+import (
+	"errors"
+	"testing"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/errortypes"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestAppNotSupportedOW(t *testing.T) {
+	bidder := &mockBidder{}
+	info := config.BidderInfo{
+		Capabilities: &config.CapabilitiesInfo{
+			Site: &config.PlatformInfo{
+				MediaTypes: []openrtb_ext.BidType{openrtb_ext.BidTypeBanner},
+			},
+		},
+	}
+	constrained := BuildInfoAwareBidder(bidder, info)
+	bids, errs := constrained.MakeRequests(&openrtb2.BidRequest{
+		Imp: []openrtb2.Imp{{ID: "imp-1", Banner: &openrtb2.Banner{}}},
+		App: &openrtb2.App{},
+	}, &ExtraRequestInfo{})
+	if !assert.Len(t, errs, 1) {
+		return
+	}
+	assert.EqualError(t, errs[0], "this bidder does not support app requests")
+	assert.IsType(t, &errortypes.Warning{}, errs[0])
+	assert.Len(t, bids, 0)
+}
+
+func TestSiteNotSupported(t *testing.T) {
+	bidder := &mockBidder{}
+	info := config.BidderInfo{
+		Capabilities: &config.CapabilitiesInfo{
+			App: &config.PlatformInfo{
+				MediaTypes: []openrtb_ext.BidType{openrtb_ext.BidTypeBanner},
+			},
+		},
+	}
+	constrained := BuildInfoAwareBidder(bidder, info)
+	bids, errs := constrained.MakeRequests(&openrtb2.BidRequest{
+		Imp:  []openrtb2.Imp{{ID: "imp-1", Banner: &openrtb2.Banner{}}},
+		Site: &openrtb2.Site{},
+	}, &ExtraRequestInfo{})
+	if !assert.Len(t, errs, 1) {
+		return
+	}
+	assert.EqualError(t, errs[0], "this bidder does not support site requests")
+	assert.IsType(t, &errortypes.Warning{}, errs[0])
+	assert.Len(t, bids, 0)
+}
+
+func TestImpFiltering(t *testing.T) {
+	bidder := &mockBidder{}
+	info := config.BidderInfo{
+		Capabilities: &config.CapabilitiesInfo{
+			Site: &config.PlatformInfo{
+				MediaTypes: []openrtb_ext.BidType{openrtb_ext.BidTypeVideo},
+			},
+			App: &config.PlatformInfo{
+				MediaTypes: []openrtb_ext.BidType{openrtb_ext.BidTypeBanner},
+			},
+		},
+	}
+
+	constrained := BuildInfoAwareBidder(bidder, info)
+
+	testCases := []struct {
+		description    string
+		inBidRequest   *openrtb2.BidRequest
+		expectedErrors []error
+		expectedImpLen int
+	}{
+		{
+			description: "Empty Imp array. MakeRequest() call not expected",
+			inBidRequest: &openrtb2.BidRequest{
+				Imp:  []openrtb2.Imp{},
+				Site: &openrtb2.Site{},
+			},
+			expectedErrors: []error{
+				&errortypes.BadInput{Message: "Bid request didn't contain media types supported by the bidder"},
+			},
+			expectedImpLen: 0,
+		},
+		{
+			description: "Sole imp in bid request is of wrong media type. MakeRequest() call not expected",
+			inBidRequest: &openrtb2.BidRequest{
+				Imp: []openrtb2.Imp{{ID: "imp-1", Video: &openrtb2.Video{}}},
+				App: &openrtb2.App{},
+			},
+			expectedErrors: []error{
+				&errortypes.BadInput{Message: "request.imp[0] uses video, but this bidder doesn't support it"},
+				&errortypes.BadInput{Message: "Bid request didn't contain media types supported by the bidder"},
+			},
+			expectedImpLen: 0,
+		},
+		{
+			description: "All imps in bid request of wrong media type, MakeRequest() call not expected",
+			inBidRequest: &openrtb2.BidRequest{
+				Imp: []openrtb2.Imp{
+					{ID: "imp-1", Video: &openrtb2.Video{}},
+					{ID: "imp-2", Native: &openrtb2.Native{}},
+					{ID: "imp-3", Audio: &openrtb2.Audio{}},
+				},
+				App: &openrtb2.App{},
+			},
+			expectedErrors: []error{
+				&errortypes.BadInput{Message: "request.imp[0] uses video, but this bidder doesn't support it"},
+				&errortypes.BadInput{Message: "request.imp[1] uses native, but this bidder doesn't support it"},
+				&errortypes.BadInput{Message: "request.imp[2] uses audio, but this bidder doesn't support it"},
+				&errortypes.BadInput{Message: "Bid request didn't contain media types supported by the bidder"},
+			},
+			expectedImpLen: 0,
+		},
+		{
+			description: "Some imps with correct media type, MakeRequest() call expected",
+			inBidRequest: &openrtb2.BidRequest{
+				Imp: []openrtb2.Imp{
+					{
+						ID:    "imp-1",
+						Video: &openrtb2.Video{},
+					},
+					{
+						Native: &openrtb2.Native{},
+					},
+					{
+						ID:     "imp-2",
+						Video:  &openrtb2.Video{},
+						Native: &openrtb2.Native{},
+					},
+					{
+						Banner: &openrtb2.Banner{},
+					},
+				},
+				Site: &openrtb2.Site{},
+			},
+			expectedErrors: []error{
+				&errortypes.BadInput{Message: "request.imp[1] uses native, but this bidder doesn't support it"},
+				&errortypes.BadInput{Message: "request.imp[2] uses native, but this bidder doesn't support it"},
+				&errortypes.BadInput{Message: "request.imp[3] uses banner, but this bidder doesn't support it"},
+				&errortypes.BadInput{Message: "request.imp[1] has no supported MediaTypes. It will be ignored"},
+				&errortypes.BadInput{Message: "request.imp[3] has no supported MediaTypes. It will be ignored"},
+			},
+			expectedImpLen: 2,
+		},
+		{
+			description: "All imps with correct media type, MakeRequest() call expected",
+			inBidRequest: &openrtb2.BidRequest{
+				Imp: []openrtb2.Imp{
+					{ID: "imp-1", Video: &openrtb2.Video{}},
+					{ID: "imp-2", Video: &openrtb2.Video{}},
+				},
+				Site: &openrtb2.Site{},
+			},
+			expectedErrors: nil,
+			expectedImpLen: 2,
+		},
+	}
+
+	for _, test := range testCases {
+		actualAdapterRequests, actualErrs := constrained.MakeRequests(test.inBidRequest, &ExtraRequestInfo{})
+
+		// Assert the request.Imp slice was correctly filtered and if MakeRequest() was called by asserting
+		// the corresponding error messages were returned
+		for i, expectedErr := range test.expectedErrors {
+			assert.EqualError(t, expectedErr, actualErrs[i].Error(), "Test failed. Error[%d] in error list mismatch: %s", i, test.description)
+		}
+
+		// Extra MakeRequests() call check: our mockBidder returns an adapter request for every imp
+		assert.Len(t, actualAdapterRequests, test.expectedImpLen, "Test failed. Incorrect length of filtered imps: %s", test.description)
+	}
+}
+
+type mockBidder struct {
+}
+
+func (m *mockBidder) MakeRequests(request *openrtb2.BidRequest, reqInfo *ExtraRequestInfo) ([]*RequestData, []error) {
+	var adapterRequests []*RequestData
+
+	for i := 0; i < len(request.Imp); i++ {
+		adapterRequests = append(adapterRequests, &RequestData{})
+	}
+
+	return adapterRequests, nil
+}
+
+func (m *mockBidder) MakeBids(internalRequest *openrtb2.BidRequest, externalRequest *RequestData, response *ResponseData) (*BidderResponse, []error) {
+	return nil, []error{errors.New("mock MakeBids error")}
+}
diff --git a/adapters/pubmatic/pubmatic.go b/adapters/pubmatic/pubmatic.go
index 8084b2bca..7de6aee49 100644
--- a/adapters/pubmatic/pubmatic.go
+++ b/adapters/pubmatic/pubmatic.go
@@ -6,6 +6,7 @@ import (
 	"fmt"
 	"math"
 	"net/http"
+	"net/url"
 	"strconv"
 	"strings"
 
@@ -20,6 +21,19 @@ import (
 
 const MAX_IMPRESSIONS_PUBMATIC = 30
 
+const (
+	PUBMATIC            = "[PUBMATIC]"
+	buyId               = "buyid"
+	buyIdTargetingKey   = "hb_buyid_"
+	skAdnetworkKey      = "skadn"
+	rewardKey           = "reward"
+	dctrKeywordName     = "dctr"
+	urlEncodedEqualChar = "%3D"
+	AdServerKey         = "adserver"
+	PBAdslotKey         = "pbadslot"
+	bidViewability      = "bidViewability"
+)
+
 type PubmaticAdapter struct {
 	URI string
 }
@@ -29,11 +43,15 @@ type pubmaticBidExt struct {
 	VideoCreativeInfo  *pubmaticBidExtVideo `json:"video,omitempty"`
 	Marketplace        string               `json:"marketplace,omitempty"`
 	PrebidDealPriority int                  `json:"prebiddealpriority,omitempty"`
+	DspId              int                  `json:"dspid,omitempty"`
+	AdvertiserID       int                  `json:"advid,omitempty"`
 }
 
 type pubmaticWrapperExt struct {
 	ProfileID int `json:"profile,omitempty"`
 	VersionID int `json:"version,omitempty"`
+
+	WrapperImpID string `json:"wiid,omitempty"`
 }
 
 type pubmaticBidExtVideo struct {
@@ -42,7 +60,8 @@ type pubmaticBidExtVideo struct {
 
 type ExtImpBidderPubmatic struct {
 	adapters.ExtImpBidder
-	Data json.RawMessage `json:"data,omitempty"`
+	Data        json.RawMessage `json:"data,omitempty"`
+	SKAdnetwork json.RawMessage `json:"skadn,omitempty"`
 }
 
 type ExtAdServer struct {
@@ -62,13 +81,11 @@ type extRequestAdServer struct {
 }
 
 const (
-	dctrKeyName        = "key_val"
-	pmZoneIDKeyName    = "pmZoneId"
-	pmZoneIDKeyNameOld = "pmZoneID"
-	ImpExtAdUnitKey    = "dfp_ad_unit_code"
-	AdServerGAM        = "gam"
-	AdServerKey        = "adserver"
-	PBAdslotKey        = "pbadslot"
+	dctrKeyName              = "key_val"
+	pmZoneIDKeyName          = "pmZoneId"
+	pmZoneIDRequestParamName = "pmzoneid"
+	ImpExtAdUnitKey          = "dfp_ad_unit_code"
+	AdServerGAM              = "gam"
 )
 
 func (a *PubmaticAdapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *adapters.ExtraRequestInfo) ([]*adapters.RequestData, []error) {
@@ -78,7 +95,7 @@ func (a *PubmaticAdapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *ad
 	extractWrapperExtFromImp := true
 	extractPubIDFromImp := true
 
-	newReqExt, err := extractPubmaticExtFromRequest(request)
+	newReqExt, cookies, err := extractPubmaticExtFromRequest(request)
 	if err != nil {
 		return nil, []error{err}
 	}
@@ -88,7 +105,7 @@ func (a *PubmaticAdapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *ad
 	}
 
 	for i := 0; i < len(request.Imp); i++ {
-		wrapperExtFromImp, pubIDFromImp, err := parseImpressionObject(&request.Imp[i], extractWrapperExtFromImp, extractPubIDFromImp)
+		wrapperExtFromImp, pubIDFromImp, err := parseImpressionObject(&request.Imp[i], extractWrapperExtFromImp, extractPubIDFromImp, reqInfo.BidAdjustmentFactor)
 
 		// If the parsing is failed, remove imp and add the error.
 		if err != nil {
@@ -110,6 +127,10 @@ func (a *PubmaticAdapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *ad
 					wrapperExt.VersionID = wrapperExtFromImp.VersionID
 				}
 
+				if wrapperExt.WrapperImpID == "" {
+					wrapperExt.WrapperImpID = wrapperExtFromImp.WrapperImpID
+				}
+
 				if wrapperExt != nil && wrapperExt.ProfileID != 0 && wrapperExt.VersionID != 0 {
 					extractWrapperExtFromImp = false
 				}
@@ -156,6 +177,48 @@ func (a *PubmaticAdapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *ad
 		request.App = &appCopy
 	}
 
+	// move user.ext.eids to user.eids
+	if request.User != nil && request.User.Ext != nil {
+		var userExt *openrtb_ext.ExtUser
+		if err = json.Unmarshal(request.User.Ext, &userExt); err == nil {
+			if userExt != nil && userExt.Eids != nil {
+				var eidArr []openrtb2.EID
+				for _, eid := range userExt.Eids {
+					newEid := &openrtb2.EID{
+						ID:     eid.ID,
+						Source: eid.Source,
+						Ext:    eid.Ext,
+					}
+					var uidArr []openrtb2.UID
+					for _, uid := range eid.UIDs {
+						newUID := &openrtb2.UID{
+							ID:    uid.ID,
+							AType: uid.AType,
+							Ext:   uid.Ext,
+						}
+						uidArr = append(uidArr, *newUID)
+					}
+					newEid.UIDs = uidArr
+					eidArr = append(eidArr, *newEid)
+				}
+
+				user := *request.User
+				user.EIDs = eidArr
+				userExt.Eids = nil
+				updatedUserExt, err1 := json.Marshal(userExt)
+				if err1 == nil {
+					user.Ext = updatedUserExt
+				}
+				request.User = &user
+			}
+		}
+	}
+
+	//adding hack to support DNT, since hbopenbid does not support lmt
+	if request.Device != nil && request.Device.Lmt != nil && *request.Device.Lmt != 0 {
+		request.Device.DNT = request.Device.Lmt
+	}
+
 	reqJSON, err := json.Marshal(request)
 	if err != nil {
 		errs = append(errs, err)
@@ -165,6 +228,9 @@ func (a *PubmaticAdapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *ad
 	headers := http.Header{}
 	headers.Add("Content-Type", "application/json;charset=utf-8")
 	headers.Add("Accept", "application/json")
+	for _, line := range cookies {
+		headers.Add("Cookie", line)
+	}
 	return []*adapters.RequestData{{
 		Method:  "POST",
 		Uri:     a.URI,
@@ -193,26 +259,26 @@ func validateAdSlot(adslot string, imp *openrtb2.Imp) error {
 
 		adSize := strings.Split(strings.ToLower(adSlot[1]), "x")
 		if len(adSize) != 2 {
-			return fmt.Errorf("Invalid size provided in adSlot %v", adSlotStr)
+			return errors.New(fmt.Sprintf("Invalid size provided in adSlot %v", adSlotStr))
 		}
 
 		width, err := strconv.Atoi(strings.TrimSpace(adSize[0]))
 		if err != nil {
-			return fmt.Errorf("Invalid width provided in adSlot %v", adSlotStr)
+			return errors.New(fmt.Sprintf("Invalid width provided in adSlot %v", adSlotStr))
 		}
 
 		heightStr := strings.Split(adSize[1], ":")
 		height, err := strconv.Atoi(strings.TrimSpace(heightStr[0]))
 		if err != nil {
-			return fmt.Errorf("Invalid height provided in adSlot %v", adSlotStr)
+			return errors.New(fmt.Sprintf("Invalid height provided in adSlot %v", adSlotStr))
 		}
 
 		//In case of video, size could be derived from the player size
-		if imp.Banner != nil {
+		if imp.Banner != nil && width != 0 && height != 0 && !(imp.Native != nil && width == 1 && height == 1) {
 			imp.Banner = assignBannerWidthAndHeight(imp.Banner, int64(width), int64(height))
 		}
 	} else {
-		return fmt.Errorf("Invalid adSlot %v", adSlotStr)
+		return errors.New(fmt.Sprintf("Invalid adSlot %v", adSlotStr))
 	}
 
 	return nil
@@ -223,6 +289,10 @@ func assignBannerSize(banner *openrtb2.Banner) (*openrtb2.Banner, error) {
 		return banner, nil
 	}
 
+	if len(banner.Format) == 0 {
+		return nil, errors.New(fmt.Sprintf("No sizes provided for Banner %v", banner.Format))
+	}
+
 	return assignBannerWidthAndHeight(banner, banner.Format[0].W, banner.Format[0].H), nil
 }
 
@@ -234,7 +304,7 @@ func assignBannerWidthAndHeight(banner *openrtb2.Banner, w, h int64) *openrtb2.B
 }
 
 // parseImpressionObject parse the imp to get it ready to send to pubmatic
-func parseImpressionObject(imp *openrtb2.Imp, extractWrapperExtFromImp, extractPubIDFromImp bool) (*pubmaticWrapperExt, string, error) {
+func parseImpressionObject(imp *openrtb2.Imp, extractWrapperExtFromImp, extractPubIDFromImp bool, bidAdjustmentFactor float64) (*pubmaticWrapperExt, string, error) {
 	var wrapExt *pubmaticWrapperExt
 	var pubID string
 
@@ -289,6 +359,10 @@ func parseImpressionObject(imp *openrtb2.Imp, extractWrapperExtFromImp, extractP
 		}
 	}
 
+	if bidAdjustmentFactor > 0 && imp.BidFloor > 0 {
+		imp.BidFloor = roundToFourDecimals(imp.BidFloor / bidAdjustmentFactor)
+	}
+
 	extMap := make(map[string]interface{}, 0)
 	if pubmaticExt.Keywords != nil && len(pubmaticExt.Keywords) != 0 {
 		addKeywordsToExt(pubmaticExt.Keywords, extMap)
@@ -301,9 +375,21 @@ func parseImpressionObject(imp *openrtb2.Imp, extractWrapperExtFromImp, extractP
 		extMap[pmZoneIDKeyName] = pubmaticExt.PmZoneID
 	}
 
+	if bidderExt.SKAdnetwork != nil {
+		extMap[skAdnetworkKey] = bidderExt.SKAdnetwork
+	}
+
+	if bidderExt.Prebid != nil && bidderExt.Prebid.IsRewardedInventory != nil && *bidderExt.Prebid.IsRewardedInventory == 1 {
+		extMap[rewardKey] = *bidderExt.Prebid.IsRewardedInventory
+	}
+
 	if len(bidderExt.Data) > 0 {
 		populateFirstPartyDataImpAttributes(bidderExt.Data, extMap)
 	}
+	// If bidViewabilityScore param is populated, pass it to imp[i].ext
+	if pubmaticExt.BidViewabilityScore != nil {
+		extMap[bidViewability] = pubmaticExt.BidViewabilityScore
+	}
 
 	imp.Ext = nil
 	if len(extMap) > 0 {
@@ -316,19 +402,25 @@ func parseImpressionObject(imp *openrtb2.Imp, extractWrapperExtFromImp, extractP
 	return wrapExt, pubID, nil
 }
 
+// roundToFourDecimals retuns given value to 4 decimal points
+func roundToFourDecimals(in float64) float64 {
+	return math.Round(in*10000) / 10000
+}
+
 // extractPubmaticExtFromRequest parse the req.ext to fetch wrapper and acat params
-func extractPubmaticExtFromRequest(request *openrtb2.BidRequest) (extRequestAdServer, error) {
+func extractPubmaticExtFromRequest(request *openrtb2.BidRequest) (extRequestAdServer, []string, error) {
+	var cookies []string
 	// req.ext.prebid would always be there and Less nil cases to handle, more safe!
 	var pmReqExt extRequestAdServer
 
 	if request == nil || len(request.Ext) == 0 {
-		return pmReqExt, nil
+		return pmReqExt, cookies, nil
 	}
 
 	reqExt := &openrtb_ext.ExtRequest{}
 	err := json.Unmarshal(request.Ext, &reqExt)
 	if err != nil {
-		return pmReqExt, fmt.Errorf("error decoding Request.ext : %s", err.Error())
+		return pmReqExt, cookies, fmt.Errorf("error decoding Request.ext : %s", err.Error())
 	}
 	pmReqExt.ExtRequest = *reqExt
 
@@ -336,7 +428,7 @@ func extractPubmaticExtFromRequest(request *openrtb2.BidRequest) (extRequestAdSe
 	if reqExt.Prebid.BidderParams != nil {
 		err = json.Unmarshal(reqExt.Prebid.BidderParams, &reqExtBidderParams)
 		if err != nil {
-			return pmReqExt, err
+			return pmReqExt, cookies, err
 		}
 	}
 
@@ -345,7 +437,7 @@ func extractPubmaticExtFromRequest(request *openrtb2.BidRequest) (extRequestAdSe
 		wrpExt := &pubmaticWrapperExt{}
 		err = json.Unmarshal(wrapperObj, wrpExt)
 		if err != nil {
-			return pmReqExt, err
+			return pmReqExt, cookies, err
 		}
 		pmReqExt.Wrapper = wrpExt
 	}
@@ -354,7 +446,7 @@ func extractPubmaticExtFromRequest(request *openrtb2.BidRequest) (extRequestAdSe
 		var acat []string
 		err = json.Unmarshal(acatBytes, &acat)
 		if err != nil {
-			return pmReqExt, err
+			return pmReqExt, cookies, err
 		}
 		for i := 0; i < len(acat); i++ {
 			acat[i] = strings.TrimSpace(acat[i])
@@ -366,7 +458,19 @@ func extractPubmaticExtFromRequest(request *openrtb2.BidRequest) (extRequestAdSe
 		pmReqExt.Marketplace = &marketplaceReqExt{AllowedBidders: allowedBidders}
 	}
 
-	return pmReqExt, nil
+	// OW patch -start-
+	if wiid, ok := reqExtBidderParams["wiid"]; ok {
+		if pmReqExt.Wrapper == nil {
+			pmReqExt.Wrapper = &pubmaticWrapperExt{}
+		}
+		pmReqExt.Wrapper.WrapperImpID, _ = strconv.Unquote(string(wiid))
+	}
+	if wrapperObj, present := reqExtBidderParams["Cookie"]; present && len(wrapperObj) != 0 {
+		err = json.Unmarshal(wrapperObj, &cookies)
+	}
+	// OW patch -end-
+
+	return pmReqExt, cookies, nil
 }
 
 func getAlternateBidderCodesFromRequestExt(reqExt *openrtb_ext.ExtRequest) []string {
@@ -394,10 +498,20 @@ func addKeywordsToExt(keywords []*openrtb_ext.ExtImpPubmaticKeyVal, extMap map[s
 			continue
 		} else {
 			key := keyVal.Key
-			if keyVal.Key == pmZoneIDKeyNameOld {
+			val := strings.Join(keyVal.Values[:], ",")
+			if strings.EqualFold(key, pmZoneIDRequestParamName) {
 				key = pmZoneIDKeyName
+			} else if key == dctrKeywordName {
+				key = dctrKeyName
+				// URL-decode dctr value if it is url-encoded
+				if strings.Contains(val, urlEncodedEqualChar) {
+					urlDecodedVal, err := url.QueryUnescape(val)
+					if err == nil {
+						val = urlDecodedVal
+					}
+				}
 			}
-			extMap[key] = strings.Join(keyVal.Values[:], ",")
+			extMap[key] = val
 		}
 	}
 }
@@ -426,16 +540,18 @@ func (a *PubmaticAdapter) MakeBids(internalRequest *openrtb2.BidRequest, externa
 
 	var errs []error
 	for _, sb := range bidResp.SeatBid {
+		targets := getTargetingKeys(sb.Ext, string(externalRequest.BidderName))
 		for i := 0; i < len(sb.Bid); i++ {
 			bid := sb.Bid[i]
-			if len(bid.Cat) > 1 {
-				bid.Cat = bid.Cat[0:1]
-			}
+
+			// Copy SeatBid Ext to Bid.Ext
+			bid.Ext = copySBExtToBidExt(sb.Ext, bid.Ext)
 
 			typedBid := &adapters.TypedBid{
-				Bid:      &bid,
-				BidType:  openrtb_ext.BidTypeBanner,
-				BidVideo: &openrtb_ext.ExtBidPrebidVideo{},
+				Bid:        &bid,
+				BidType:    openrtb_ext.BidTypeBanner,
+				BidVideo:   &openrtb_ext.ExtBidPrebidVideo{},
+				BidTargets: targets,
 			}
 
 			var bidExt *pubmaticBidExt
@@ -452,6 +568,11 @@ func (a *PubmaticAdapter) MakeBids(internalRequest *openrtb2.BidRequest, externa
 				if bidExt.VideoCreativeInfo != nil && bidExt.VideoCreativeInfo.Duration != nil {
 					typedBid.BidVideo.Duration = *bidExt.VideoCreativeInfo.Duration
 				}
+				//prepares ExtBidPrebidMeta with Values got from bidresponse
+				typedBid.BidMeta = prepareMetaObject(bid, bidExt, sb.Seat)
+			}
+			if len(bid.Cat) > 1 {
+				bid.Cat = bid.Cat[0:1]
 			}
 
 			if typedBid.BidType == openrtb_ext.BidTypeNative {
diff --git a/adapters/pubmatic/pubmatic_ow.go b/adapters/pubmatic/pubmatic_ow.go
new file mode 100644
index 000000000..88a51b094
--- /dev/null
+++ b/adapters/pubmatic/pubmatic_ow.go
@@ -0,0 +1,76 @@
+package pubmatic
+
+import (
+	"encoding/json"
+	"strconv"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func getTargetingKeys(bidExt json.RawMessage, bidderName string) map[string]string {
+	targets := map[string]string{}
+	if bidExt != nil {
+		bidExtMap := make(map[string]interface{})
+		err := json.Unmarshal(bidExt, &bidExtMap)
+		if err == nil && bidExtMap[buyId] != nil {
+			targets[buyIdTargetingKey+bidderName], _ = bidExtMap[buyId].(string)
+		}
+	}
+	return targets
+}
+
+func copySBExtToBidExt(sbExt json.RawMessage, bidExt json.RawMessage) json.RawMessage {
+	if sbExt != nil {
+		sbExtMap := getMapFromJSON(sbExt)
+		bidExtMap := make(map[string]interface{})
+		if bidExt != nil {
+			bidExtMap = getMapFromJSON(bidExt)
+		}
+		if bidExtMap != nil && sbExtMap != nil {
+			if sbExtMap[buyId] != nil && bidExtMap[buyId] == nil {
+				bidExtMap[buyId] = sbExtMap[buyId]
+			}
+		}
+		byteAra, _ := json.Marshal(bidExtMap)
+		return json.RawMessage(byteAra)
+	}
+	return bidExt
+}
+
+// prepareMetaObject prepares the Meta structure using Bid Response
+func prepareMetaObject(bid openrtb2.Bid, bidExt *pubmaticBidExt, seat string) *openrtb_ext.ExtBidPrebidMeta {
+
+	meta := &openrtb_ext.ExtBidPrebidMeta{
+		NetworkID:    bidExt.DspId,
+		AdvertiserID: bidExt.AdvertiserID,
+		MediaType:    string(getBidType(bidExt)),
+	}
+
+	if meta.NetworkID != 0 {
+		meta.DemandSource = strconv.Itoa(meta.NetworkID)
+	}
+
+	if len(seat) > 0 {
+		meta.AdvertiserID, _ = strconv.Atoi(seat)
+	}
+
+	meta.AgencyID = meta.AdvertiserID
+
+	if len(bid.Cat) > 0 {
+		meta.PrimaryCategoryID = bid.Cat[0]
+		meta.SecondaryCategoryIDs = bid.Cat
+	}
+
+	// NOTE: We will not recieve below fields from the translator response also not sure on what will be the key names for these in the response,
+	// when we needed we can add it back.
+	// New fields added, assignee fields name may change
+	// Assign meta.BrandId to bidExt.ADomain[0]  //BrandID is of Type int and ADomain values if string type like "mystartab.com"
+	// meta.NetworkName = bidExt.NetworkName;
+	// meta.AdvertiserName = bidExt.AdvertiserName;
+	// meta.AgencyName = bidExt.AgencyName;
+	// meta.BrandName = bidExt.BrandName;
+	// meta.DChain = bidExt.DChain;
+
+	return meta
+}
diff --git a/adapters/pubmatic/pubmatic_ow_test.go b/adapters/pubmatic/pubmatic_ow_test.go
new file mode 100644
index 000000000..62f00fdc6
--- /dev/null
+++ b/adapters/pubmatic/pubmatic_ow_test.go
@@ -0,0 +1,249 @@
+package pubmatic
+
+import (
+	"encoding/json"
+	"reflect"
+	"testing"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func TestGetAdServerTargetingForEmptyExt(t *testing.T) {
+	ext := json.RawMessage(`{}`)
+	targets := getTargetingKeys(ext, "pubmatic")
+	// banner is the default bid type when no bidType key is present in the bid.ext
+	if targets != nil && targets["hb_buyid_pubmatic"] != "" {
+		t.Errorf("It should not contained AdserverTageting")
+	}
+}
+
+func TestGetAdServerTargetingForValidExt(t *testing.T) {
+	ext := json.RawMessage("{\"buyid\":\"testBuyId\"}")
+	targets := getTargetingKeys(ext, "pubmatic")
+	// banner is the default bid type when no bidType key is present in the bid.ext
+	if targets == nil {
+		t.Error("It should have targets")
+		t.FailNow()
+	}
+	if targets != nil && targets["hb_buyid_pubmatic"] != "testBuyId" {
+		t.Error("It should have testBuyId as targeting")
+		t.FailNow()
+	}
+}
+
+func TestGetAdServerTargetingForPubmaticAlias(t *testing.T) {
+	ext := json.RawMessage("{\"buyid\":\"testBuyId-alias\"}")
+	targets := getTargetingKeys(ext, "dummy-alias")
+	// banner is the default bid type when no bidType key is present in the bid.ext
+	if targets == nil {
+		t.Error("It should have targets")
+		t.FailNow()
+	}
+	if targets != nil && targets["hb_buyid_dummy-alias"] != "testBuyId-alias" {
+		t.Error("It should have testBuyId as targeting")
+		t.FailNow()
+	}
+}
+
+func TestCopySBExtToBidExtWithBidExt(t *testing.T) {
+	sbext := json.RawMessage("{\"buyid\":\"testBuyId\"}")
+	bidext := json.RawMessage("{\"dspId\":\"9\"}")
+	// expectedbid := json.RawMessage("{\"dspId\":\"9\",\"buyid\":\"testBuyId\"}")
+	bidextnew := copySBExtToBidExt(sbext, bidext)
+	if bidextnew == nil {
+		t.Errorf("it should not be nil")
+	}
+}
+
+func TestCopySBExtToBidExtWithNoBidExt(t *testing.T) {
+	sbext := json.RawMessage("{\"buyid\":\"testBuyId\"}")
+	bidext := json.RawMessage("{\"dspId\":\"9\"}")
+	// expectedbid := json.RawMessage("{\"dspId\":\"9\",\"buyid\":\"testBuyId\"}")
+	bidextnew := copySBExtToBidExt(sbext, bidext)
+	if bidextnew == nil {
+		t.Errorf("it should not be nil")
+	}
+}
+
+func TestCopySBExtToBidExtWithNoSeatExt(t *testing.T) {
+	bidext := json.RawMessage("{\"dspId\":\"9\"}")
+	// expectedbid := json.RawMessage("{\"dspId\":\"9\",\"buyid\":\"testBuyId\"}")
+	bidextnew := copySBExtToBidExt(nil, bidext)
+	if bidextnew == nil {
+		t.Errorf("it should not be nil")
+	}
+}
+
+func TestPrepareMetaObject(t *testing.T) {
+	typebanner := 0
+	typevideo := 1
+	typenative := 2
+	typeinvalid := 233
+	type args struct {
+		bid    openrtb2.Bid
+		bidExt *pubmaticBidExt
+		seat   string
+	}
+	tests := []struct {
+		name string
+		args args
+		want *openrtb_ext.ExtBidPrebidMeta
+	}{
+		{
+			name: "Empty Meta Object and default BidType banner",
+			args: args{
+				bid: openrtb2.Bid{
+					Cat: []string{},
+				},
+				bidExt: &pubmaticBidExt{},
+				seat:   "",
+			},
+			want: &openrtb_ext.ExtBidPrebidMeta{
+				MediaType: "banner",
+			},
+		},
+		{
+			name: "Valid Meta Object with Empty Seatbid.seat",
+			args: args{
+				bid: openrtb2.Bid{
+					Cat: []string{"IAB-1", "IAB-2"},
+				},
+				bidExt: &pubmaticBidExt{
+					DspId:        80,
+					AdvertiserID: 139,
+					BidType:      &typeinvalid,
+				},
+				seat: "",
+			},
+			want: &openrtb_ext.ExtBidPrebidMeta{
+				NetworkID:            80,
+				DemandSource:         "80",
+				PrimaryCategoryID:    "IAB-1",
+				SecondaryCategoryIDs: []string{"IAB-1", "IAB-2"},
+				AdvertiserID:         139,
+				AgencyID:             139,
+				MediaType:            "banner",
+			},
+		},
+		{
+			name: "Valid Meta Object with Empty bidExt.DspId",
+			args: args{
+				bid: openrtb2.Bid{
+					Cat: []string{"IAB-1", "IAB-2"},
+				},
+				bidExt: &pubmaticBidExt{
+					DspId:        0,
+					AdvertiserID: 139,
+				},
+				seat: "124",
+			},
+			want: &openrtb_ext.ExtBidPrebidMeta{
+				NetworkID:            0,
+				DemandSource:         "",
+				PrimaryCategoryID:    "IAB-1",
+				SecondaryCategoryIDs: []string{"IAB-1", "IAB-2"},
+				AdvertiserID:         124,
+				AgencyID:             124,
+				MediaType:            "banner",
+			},
+		},
+		{
+			name: "Valid Meta Object with Empty Seatbid.seat and Empty bidExt.AdvertiserID",
+			args: args{
+				bid: openrtb2.Bid{
+					Cat: []string{"IAB-1", "IAB-2"},
+				},
+				bidExt: &pubmaticBidExt{
+					DspId:        80,
+					AdvertiserID: 0,
+				},
+				seat: "",
+			},
+			want: &openrtb_ext.ExtBidPrebidMeta{
+				NetworkID:            80,
+				DemandSource:         "80",
+				PrimaryCategoryID:    "IAB-1",
+				SecondaryCategoryIDs: []string{"IAB-1", "IAB-2"},
+				AdvertiserID:         0,
+				AgencyID:             0,
+				MediaType:            "banner",
+			},
+		},
+		{
+			name: "Valid Meta Object with Empty CategoryIds and BidType video",
+			args: args{
+				bid: openrtb2.Bid{
+					Cat: []string{},
+				},
+				bidExt: &pubmaticBidExt{
+					DspId:        80,
+					AdvertiserID: 139,
+					BidType:      &typevideo,
+				},
+				seat: "124",
+			},
+			want: &openrtb_ext.ExtBidPrebidMeta{
+				NetworkID:         80,
+				DemandSource:      "80",
+				PrimaryCategoryID: "",
+				AdvertiserID:      124,
+				AgencyID:          124,
+				MediaType:         "video",
+			},
+		},
+		{
+			name: "Valid Meta Object with Single CategoryId and BidType native",
+			args: args{
+				bid: openrtb2.Bid{
+					Cat: []string{"IAB-1"},
+				},
+				bidExt: &pubmaticBidExt{
+					DspId:        80,
+					AdvertiserID: 139,
+					BidType:      &typenative,
+				},
+				seat: "124",
+			},
+			want: &openrtb_ext.ExtBidPrebidMeta{
+				NetworkID:            80,
+				DemandSource:         "80",
+				PrimaryCategoryID:    "IAB-1",
+				SecondaryCategoryIDs: []string{"IAB-1"},
+				AdvertiserID:         124,
+				AgencyID:             124,
+				MediaType:            "native",
+			},
+		},
+		{
+			name: "Valid Meta Object and BidType banner",
+			args: args{
+				bid: openrtb2.Bid{
+					Cat: []string{"IAB-1", "IAB-2"},
+				},
+				bidExt: &pubmaticBidExt{
+					DspId:        80,
+					AdvertiserID: 139,
+					BidType:      &typebanner,
+				},
+				seat: "124",
+			},
+			want: &openrtb_ext.ExtBidPrebidMeta{
+				NetworkID:            80,
+				DemandSource:         "80",
+				PrimaryCategoryID:    "IAB-1",
+				SecondaryCategoryIDs: []string{"IAB-1", "IAB-2"},
+				AdvertiserID:         124,
+				AgencyID:             124,
+				MediaType:            "banner",
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := prepareMetaObject(tt.args.bid, tt.args.bidExt, tt.args.seat); !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("prepareMetaObject() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/adapters/pubmatic/pubmatic_test.go b/adapters/pubmatic/pubmatic_test.go
index 7553519f9..7aa2f397b 100644
--- a/adapters/pubmatic/pubmatic_test.go
+++ b/adapters/pubmatic/pubmatic_test.go
@@ -80,6 +80,7 @@ func TestParseImpressionObject(t *testing.T) {
 		imp                      *openrtb2.Imp
 		extractWrapperExtFromImp bool
 		extractPubIDFromImp      bool
+		bidAdjustmentFactor      float64
 	}
 	tests := []struct {
 		name                string
@@ -88,6 +89,7 @@ func TestParseImpressionObject(t *testing.T) {
 		expectedPublisherId string
 		wantErr             bool
 		expectedBidfloor    float64
+		expectedImpExt      json.RawMessage
 	}{
 		{
 			name: "imp.bidfloor empty and kadfloor set",
@@ -98,6 +100,7 @@ func TestParseImpressionObject(t *testing.T) {
 				},
 			},
 			expectedBidfloor: 0.12,
+			expectedImpExt:   json.RawMessage(nil),
 		},
 		{
 			name: "imp.bidfloor set and kadfloor empty",
@@ -109,6 +112,7 @@ func TestParseImpressionObject(t *testing.T) {
 				},
 			},
 			expectedBidfloor: 0.12,
+			expectedImpExt:   json.RawMessage(nil),
 		},
 		{
 			name: "imp.bidfloor set and kadfloor invalid",
@@ -120,6 +124,7 @@ func TestParseImpressionObject(t *testing.T) {
 				},
 			},
 			expectedBidfloor: 0.12,
+			expectedImpExt:   json.RawMessage(nil),
 		},
 		{
 			name: "imp.bidfloor set and kadfloor set, higher imp.bidfloor",
@@ -142,6 +147,7 @@ func TestParseImpressionObject(t *testing.T) {
 				},
 			},
 			expectedBidfloor: 0.13,
+			expectedImpExt:   json.RawMessage(nil),
 		},
 		{
 			name: "kadfloor string set with whitespace",
@@ -153,15 +159,39 @@ func TestParseImpressionObject(t *testing.T) {
 				},
 			},
 			expectedBidfloor: 0.13,
+			expectedImpExt:   json.RawMessage(nil),
+		},
+		{
+			name: "kadfloor with bidAdjustmentFactor",
+			args: args{
+				imp: &openrtb2.Imp{
+					Video: &openrtb2.Video{},
+					Ext:   json.RawMessage(`{"bidder":{"kadfloor":"0.13"}}`),
+				},
+				bidAdjustmentFactor: 0.9,
+			},
+			expectedBidfloor: 0.1444,
+			expectedImpExt:   json.RawMessage(nil),
+		},
+		{
+			name: "bidViewability Object is set in imp.ext.prebid.pubmatic, pass to imp.ext",
+			args: args{
+				imp: &openrtb2.Imp{
+					Video: &openrtb2.Video{},
+					Ext:   json.RawMessage(`{"bidder":{"bidViewability":{"adSizes":{"728x90":{"createdAt":1679993940011,"rendered":20,"totalViewTime":424413,"viewed":17}},"adUnit":{"createdAt":1679993940011,"rendered":25,"totalViewTime":424413,"viewed":17}}}}`),
+				},
+			},
+			expectedImpExt: json.RawMessage(`{"bidViewability":{"adSizes":{"728x90":{"createdAt":1679993940011,"rendered":20,"totalViewTime":424413,"viewed":17}},"adUnit":{"createdAt":1679993940011,"rendered":25,"totalViewTime":424413,"viewed":17}}}`),
 		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			receivedWrapperExt, receivedPublisherId, err := parseImpressionObject(tt.args.imp, tt.args.extractWrapperExtFromImp, tt.args.extractPubIDFromImp)
+			receivedWrapperExt, receivedPublisherId, err := parseImpressionObject(tt.args.imp, tt.args.extractWrapperExtFromImp, tt.args.extractPubIDFromImp, tt.args.bidAdjustmentFactor)
 			assert.Equal(t, tt.wantErr, err != nil)
 			assert.Equal(t, tt.expectedWrapperExt, receivedWrapperExt)
 			assert.Equal(t, tt.expectedPublisherId, receivedPublisherId)
 			assert.Equal(t, tt.expectedBidfloor, tt.args.imp.BidFloor)
+			assert.Equal(t, tt.expectedImpExt, tt.args.imp.Ext)
 		})
 	}
 }
@@ -174,6 +204,7 @@ func TestExtractPubmaticExtFromRequest(t *testing.T) {
 		name           string
 		args           args
 		expectedReqExt extRequestAdServer
+		expectedCookie []string
 		wantErr        bool
 	}{
 		{
@@ -289,9 +320,10 @@ func TestExtractPubmaticExtFromRequest(t *testing.T) {
 	}
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			gotReqExt, err := extractPubmaticExtFromRequest(tt.args.request)
+			gotReqExt, gotCookie, err := extractPubmaticExtFromRequest(tt.args.request)
 			assert.Equal(t, tt.wantErr, err != nil)
 			assert.Equal(t, tt.expectedReqExt, gotReqExt)
+			assert.Equal(t, tt.expectedCookie, gotCookie)
 		})
 	}
 }
@@ -354,8 +386,9 @@ func TestPubmaticAdapter_MakeBids(t *testing.T) {
 			args: args{
 				response: &adapters.ResponseData{
 					StatusCode: http.StatusOK,
-					Body:       []byte(`{"id": "test-request-id", "seatbid":[{"seat": "958", "bid":[{"id": "7706636740145184841", "impid": "test-imp-id", "price": 0.500000, "adid": "29681110", "adm": "some-test-ad", "adomain":["pubmatic.com"], "crid": "29681110", "h": 250, "w": 300, "dealid": "testdeal", "ext":{"dspid": 6, "deal_channel": 1, "prebiddealpriority": 1}}]}], "bidid": "5778926625248726496", "cur": "USD"}`),
+					Body:       []byte(`{"id": "test-request-id", "seatbid":[{"seat": "958", "bid":[{"id": "7706636740145184841", "impid": "test-imp-id", "price": 0.500000, "adid": "29681110", "adm": "some-test-ad", "adomain":["pubmatic.com"], "crid": "29681110", "h": 250, "w": 300, "dealid": "testdeal", "ext":{"dspid": 6, "deal_channel": 1, "prebiddealpriority": 1}}], "ext": {"buyid": "testBuyId"}}], "bidid": "5778926625248726496", "cur": "USD"}`),
 				},
+				externalRequest: &adapters.RequestData{BidderName: openrtb_ext.BidderPubmatic},
 			},
 			wantErr: nil,
 			wantResp: &adapters.BidderResponse{
@@ -372,11 +405,19 @@ func TestPubmaticAdapter_MakeBids(t *testing.T) {
 							H:       250,
 							W:       300,
 							DealID:  "testdeal",
-							Ext:     json.RawMessage(`{"dspid": 6, "deal_channel": 1, "prebiddealpriority": 1}`),
+							Ext:     json.RawMessage(`{"buyid":"testBuyId","deal_channel":1,"dspid":6,"prebiddealpriority":1}`),
 						},
 						DealPriority: 1,
 						BidType:      openrtb_ext.BidTypeBanner,
 						BidVideo:     &openrtb_ext.ExtBidPrebidVideo{},
+						BidTargets:   map[string]string{"hb_buyid_pubmatic": "testBuyId"},
+						BidMeta: &openrtb_ext.ExtBidPrebidMeta{
+							AdvertiserID: 958,
+							AgencyID:     958,
+							NetworkID:    6,
+							DemandSource: "6",
+							MediaType:    "banner",
+						},
 					},
 				},
 				Currency: "USD",
@@ -389,6 +430,7 @@ func TestPubmaticAdapter_MakeBids(t *testing.T) {
 					StatusCode: http.StatusOK,
 					Body:       []byte(`{"id": "test-request-id", "seatbid":[{"seat": "958", "bid":[{"id": "7706636740145184841", "impid": "test-imp-id", "price": 0.500000, "adid": "29681110", "adm": "some-test-ad", "adomain":["pubmatic.com"], "crid": "29681110", "h": 250, "w": 300, "dealid": "testdeal", "ext":{"dspid": 6, "deal_channel": 1, "prebiddealpriority": -1}}]}], "bidid": "5778926625248726496", "cur": "USD"}`),
 				},
+				externalRequest: &adapters.RequestData{BidderName: openrtb_ext.BidderPubmatic},
 			},
 			wantErr: nil,
 			wantResp: &adapters.BidderResponse{
@@ -407,8 +449,50 @@ func TestPubmaticAdapter_MakeBids(t *testing.T) {
 							DealID:  "testdeal",
 							Ext:     json.RawMessage(`{"dspid": 6, "deal_channel": 1, "prebiddealpriority": -1}`),
 						},
-						BidType:  openrtb_ext.BidTypeBanner,
-						BidVideo: &openrtb_ext.ExtBidPrebidVideo{},
+						BidType:    openrtb_ext.BidTypeBanner,
+						BidVideo:   &openrtb_ext.ExtBidPrebidVideo{},
+						BidTargets: map[string]string{},
+						BidMeta: &openrtb_ext.ExtBidPrebidMeta{
+							AdvertiserID: 958,
+							AgencyID:     958,
+							NetworkID:    6,
+							DemandSource: "6",
+							MediaType:    "banner",
+						},
+					},
+				},
+				Currency: "USD",
+			},
+		},
+		{
+			name: "BidExt Nil cases",
+			args: args{
+				response: &adapters.ResponseData{
+					StatusCode: http.StatusOK,
+					Body:       []byte(`{"id": "test-request-id", "seatbid":[{"seat": "958", "bid":[{"id": "7706636740145184841", "impid": "test-imp-id", "price": 0.500000, "adid": "29681110", "adm": "some-test-ad", "adomain":["pubmatic.com"], "crid": "29681110", "h": 250, "w": 300, "dealid": "testdeal", "ext":null}]}], "bidid": "5778926625248726496", "cur": "USD"}`),
+				},
+				externalRequest: &adapters.RequestData{BidderName: openrtb_ext.BidderPubmatic},
+			},
+			wantErr: nil,
+			wantResp: &adapters.BidderResponse{
+				Bids: []*adapters.TypedBid{
+					{
+						Bid: &openrtb2.Bid{
+							ID:      "7706636740145184841",
+							ImpID:   "test-imp-id",
+							Price:   0.500000,
+							AdID:    "29681110",
+							AdM:     "some-test-ad",
+							ADomain: []string{"pubmatic.com"},
+							CrID:    "29681110",
+							H:       250,
+							W:       300,
+							DealID:  "testdeal",
+							Ext:     json.RawMessage(`null`),
+						},
+						BidType:    openrtb_ext.BidTypeBanner,
+						BidVideo:   &openrtb_ext.ExtBidPrebidVideo{},
+						BidTargets: map[string]string{},
 					},
 				},
 				Currency: "USD",
diff --git a/adapters/pubmatic/pubmatictest/exemplary/banner.json b/adapters/pubmatic/pubmatictest/exemplary/banner.json
index 74150f5aa..1e2ad911a 100644
--- a/adapters/pubmatic/pubmatictest/exemplary/banner.json
+++ b/adapters/pubmatic/pubmatictest/exemplary/banner.json
@@ -36,7 +36,8 @@
         "ext": {
           "prebid": {
             "bidderparams": {
-              "acat": ["drg","dlu","ssr"]
+              "acat": ["drg","dlu","ssr"],
+              "wiid": "dwzafakjflan-tygannnvlla-mlljvj"
             }
           }
         },
@@ -45,7 +46,7 @@
 		    	  "publisher": {
 			        	"id": "1234"
 		      	}
-		      }
+          }
      },
   
     "httpCalls": [
@@ -87,12 +88,14 @@
             "ext": {
                 "wrapper": {
                     "profile": 5123,
-                    "version":1
+                    "version":1,
+                    "wiid" : "dwzafakjflan-tygannnvlla-mlljvj"
                 },
                 "acat": ["drg","dlu","ssr"],
                 "prebid": {
                   "bidderparams": {
-                    "acat": ["drg","dlu","ssr"]
+                    "acat": ["drg","dlu","ssr"],
+                    "wiid": "dwzafakjflan-tygannnvlla-mlljvj"
                   }
                 }
             }
@@ -158,4 +161,4 @@
         ]
       }
     ]
-  }
\ No newline at end of file
+  }
diff --git a/adapters/pubmatic/pubmatictest/exemplary/video-rewarded.json b/adapters/pubmatic/pubmatictest/exemplary/video-rewarded.json
new file mode 100644
index 000000000..cf51e3851
--- /dev/null
+++ b/adapters/pubmatic/pubmatictest/exemplary/video-rewarded.json
@@ -0,0 +1,175 @@
+{
+    "mockBidRequest": {
+        "id": "test-video-request",
+        "imp": [{
+            "id": "test-video-imp",
+            "video": {
+                "w":640,
+                "h":480,
+                "mimes": ["video/mp4", "video/x-flv"],
+                "minduration": 5,
+                "maxduration": 30,
+                "startdelay": 5,
+                "playbackmethod": [1, 3],
+                "api": [1, 2],
+                "protocols": [2, 3],
+                "battr": [13, 14],
+                "linearity": 1,
+                "placement": 2,
+                "minbitrate": 10,
+                "maxbitrate": 10
+            },
+            "ext": {
+                "prebid": {
+                    "is_rewarded_inventory": 1
+                },
+                "bidder": {
+                    "adSlot": "AdTag_Div1@0x0",
+                    "publisherId": "999",
+                    "keywords": [{
+                        "key": "pmZoneID",
+                        "value": ["Zone1", "Zone2"]
+                      }
+                    ],
+                    "wrapper": {
+                        "version": 1,
+                        "profile": 5123
+                    }
+                }
+            }
+        }],
+        "device":{
+            "ua": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"
+        },
+        "site": {
+			    "id": "siteID",
+		    	"publisher": {
+			    	"id": "1234"
+		  	}
+	  	}
+    },
+  
+    "httpCalls": [
+      {
+        "expectedRequest": {
+          "uri": "https://hbopenbid.pubmatic.com/translator?source=prebid-server",
+          "body": {
+            "id": "test-video-request",
+            "imp": [
+              {
+                "id": "test-video-imp",
+                "tagid":"AdTag_Div1",
+                "video": {
+                    "w":640,
+                    "h":480,
+                    "mimes": ["video/mp4", "video/x-flv"],
+                    "minduration": 5,
+                    "maxduration": 30,
+                    "startdelay": 5,
+                    "playbackmethod": [1, 3],
+                    "api": [1, 2],
+                    "protocols": [2, 3],
+                    "battr": [13, 14],
+                    "linearity": 1,
+                    "placement": 2,
+                    "minbitrate": 10,
+                    "maxbitrate": 10
+                },
+                "ext": {
+                    "pmZoneId": "Zone1,Zone2",
+                    "reward": 1
+                }
+              }
+            ], 
+            "device":{
+                "ua": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"
+            },
+            "site": {
+                "id": "siteID",
+                "publisher": {
+                    "id": "999"
+                }
+            },
+            "ext": {
+                "prebid": {},
+                "wrapper": {
+                    "profile": 5123,
+                    "version":1
+                }
+            }
+          }
+        },
+        "mockResponse": {
+          "status": 200,
+          "body": {
+            "id": "test-video-request",
+            "seatbid": [
+              {
+                "seat": "958",
+                "bid": [{
+                  "id": "7706636740145184841",
+                  "impid": "test-video-imp",
+                  "price": 0.500000,
+                  "adid": "29681110",
+                  "adm": "some-test-ad",
+                  "adomain": ["pubmatic.com"],
+                  "crid": "29681110",
+                  "h": 250,
+                  "w": 300,
+                  "dealid":"test deal",
+                  "cat" : ["IAB-1", "IAB-2"], 
+                  "ext": {
+                    "dspid": 6,
+                    "deal_channel": 1,
+                    "BidType": 1,
+                    "video" : {
+                      "duration" : 5  
+                    }
+                  }
+                }]
+              }
+            ],
+            "bidid": "5778926625248726496",
+            "cur": "USD"
+          }
+        }
+      }
+    ],
+  
+    "expectedBidResponses": [
+      {
+        "currency": "USD",
+        "bids": [
+          {
+            "bid": {
+              "id": "7706636740145184841",
+              "impid": "test-video-imp",
+              "price": 0.5,
+              "adid": "29681110",
+              "adm": "some-test-ad",
+              "adomain": ["pubmatic.com"],
+              "cat": [
+                "IAB-1"
+              ],
+              "crid": "29681110",
+              "w": 300,
+              "h": 250,
+              "dealid":"test deal",
+              "ext": {
+                "dspid": 6,
+                "deal_channel": 1,
+                "BidType": 1,
+                "video" : {
+                  "duration" : 5  
+                }
+              }
+            },
+            "type": "video",
+            "video" :{
+              "duration" : 5
+            }
+          }
+        ]
+      }
+    ]
+  }
diff --git a/adapters/pubmatic/pubmatictest/params/race/banner.json b/adapters/pubmatic/pubmatictest/params/race/banner.json
new file mode 100644
index 000000000..86317f86e
--- /dev/null
+++ b/adapters/pubmatic/pubmatictest/params/race/banner.json
@@ -0,0 +1,15 @@
+{
+	"publisherId": "156209",
+	"adSlot": "pubmatic_test2@300x250",
+	"pmzoneid": "drama,sport",
+	"dctr": "abBucket=4|adType=page|entity=|paidByCategory=|sku=|userLevel=free|platform=android|majorVersion=3.54|version=3.54.0|mobileApplication=true|showId=20166|show=Kisah Untuk Geri|genre=Drama|contentUrl=https://www.iflix.com/title/show/20166|rating=TV-MA|contentLanguage=id",
+	"keywords": {
+		"pmzoneid": "Zone1,Zone2",
+		"dctr": "abBucket=4|adType=page|entity=|paidByCategory=|sku=|userLevel=free|platform=android|majorVersion=3.54|version=3.54.0|mobileApplication=true|showId=20166|show=Kisah Untuk Geri|genre=Drama|contentUrl=https://www.iflix.com/title/show/20166|rating=TV-MA|contentLanguage=id",
+		"preference": "sports,movies"
+	},
+	"wrapper": {
+		"version": 2,
+		"profile": 595
+	}
+}
diff --git a/adapters/pubmatic/pubmatictest/params/race/video.json b/adapters/pubmatic/pubmatictest/params/race/video.json
new file mode 100644
index 000000000..86317f86e
--- /dev/null
+++ b/adapters/pubmatic/pubmatictest/params/race/video.json
@@ -0,0 +1,15 @@
+{
+	"publisherId": "156209",
+	"adSlot": "pubmatic_test2@300x250",
+	"pmzoneid": "drama,sport",
+	"dctr": "abBucket=4|adType=page|entity=|paidByCategory=|sku=|userLevel=free|platform=android|majorVersion=3.54|version=3.54.0|mobileApplication=true|showId=20166|show=Kisah Untuk Geri|genre=Drama|contentUrl=https://www.iflix.com/title/show/20166|rating=TV-MA|contentLanguage=id",
+	"keywords": {
+		"pmzoneid": "Zone1,Zone2",
+		"dctr": "abBucket=4|adType=page|entity=|paidByCategory=|sku=|userLevel=free|platform=android|majorVersion=3.54|version=3.54.0|mobileApplication=true|showId=20166|show=Kisah Untuk Geri|genre=Drama|contentUrl=https://www.iflix.com/title/show/20166|rating=TV-MA|contentLanguage=id",
+		"preference": "sports,movies"
+	},
+	"wrapper": {
+		"version": 2,
+		"profile": 595
+	}
+}
diff --git a/adapters/pubmatic/pubmatictest/supplemental/app.json b/adapters/pubmatic/pubmatictest/supplemental/app.json
index 3a2f7a1fb..4f6e810e2 100644
--- a/adapters/pubmatic/pubmatictest/supplemental/app.json
+++ b/adapters/pubmatic/pubmatictest/supplemental/app.json
@@ -27,6 +27,10 @@
                         "version": 1,
                         "profile": 5123
                     }
+                },
+                "skadn": {
+                  "skadnetids": ["k674qkevps.skadnetwork"],
+                  "version": "2.0"
                 }
             }
         }],
@@ -64,7 +68,11 @@
                 "bidfloor": 0.12,
                 "ext": {
                     "pmZoneId": "Zone1,Zone2",
-                    "preference": "sports,movies"
+                    "preference": "sports,movies",
+                    "skadn": {
+                      "skadnetids": ["k674qkevps.skadnetwork"],
+                      "version": "2.0"
+                    }
                 }
               }
             ], 
@@ -103,7 +111,21 @@
                   "crid": "29681110",
                   "h": 250,
                   "w": 300,
-                  "dealid":"test deal"
+                  "dealid":"test deal",
+                  "ext": {
+                    "dspid": 6,
+                    "deal_channel": 1,
+                    "skadn": {
+                      "signature": "MDUCGQDreBN5/xBN547tJeUdqcMSBtBA+Lk06b8CGFkjR1V56rh/H9osF8iripkuZApeDsZ+lQ==",
+                      "campaign": "4",
+                      "network": "k674qkevps.skadnetwork",
+                      "nonce": "D0EC0F04-A4BF-445B-ADF1-E010430C29FD",
+                      "timestamp": "1596695461984",
+                      "sourceapp": "525463029",
+                      "itunesitem": "1499436635",
+                      "version": "2.0"
+                  }
+                  }
                 }]
               }
             ],
@@ -129,17 +151,25 @@
               "crid": "29681110",
               "w": 300,
               "h": 250,
-              "dealid":"test deal"
+              "dealid":"test deal",
+              "ext": {
+                "dspid": 6,
+                "deal_channel": 1,
+                "skadn": {
+                  "signature": "MDUCGQDreBN5/xBN547tJeUdqcMSBtBA+Lk06b8CGFkjR1V56rh/H9osF8iripkuZApeDsZ+lQ==",
+                  "campaign": "4",
+                  "network": "k674qkevps.skadnetwork",
+                  "nonce": "D0EC0F04-A4BF-445B-ADF1-E010430C29FD",
+                  "timestamp": "1596695461984",
+                  "sourceapp": "525463029",
+                  "itunesitem": "1499436635",
+                  "version": "2.0"
+              }
+              }
             },
             "type": "banner"
           }
         ]
       }
-    ],
-    "expectedMakeBidsErrors": [
-      {
-        "value": "unexpected end of JSON input",
-        "comparison": "literal"
-      }
     ]
-  }
\ No newline at end of file
+  }
diff --git a/adapters/pubmatic/pubmatictest/supplemental/banner-video.json b/adapters/pubmatic/pubmatictest/supplemental/banner-video.json
new file mode 100644
index 000000000..4c43fcaf8
--- /dev/null
+++ b/adapters/pubmatic/pubmatictest/supplemental/banner-video.json
@@ -0,0 +1,129 @@
+{
+    "mockBidRequest": {
+      "id": "multiple-media-request",
+      "imp": [
+        {
+          "id": "multiple-media-imp",
+          "video": {
+            "mimes": ["video/mp4"]
+          },
+          "banner": {
+            "format": [{
+                "w": 300,
+                "h": 250
+            },
+            {
+              "w": 728,
+              "h": 90
+          }]
+          },
+          "ext": {
+            "bidder": {
+                "adSlot": "AdTag_Div1@0x0",
+                "publisherId": "999"			
+             }
+          }
+        }
+      ], 
+      "site": {
+        "id": "siteID"
+        }
+    },
+  
+    "httpCalls": [
+        {
+          "expectedRequest": {
+            "uri": "https://hbopenbid.pubmatic.com/translator?source=prebid-server",
+            "body": {
+              "id": "multiple-media-request",
+              "imp": [
+                {
+                  "id": "multiple-media-imp",
+                  "tagid":"AdTag_Div1",
+                  "video": {
+                    "mimes": ["video/mp4"]
+                  },
+                   "banner": {
+                    "format": [
+                      {
+                        "w": 300,
+                        "h": 250
+                      },
+                      {
+                        "w": 728,
+                        "h": 90
+                      }
+                  ],
+                  "h": 250,
+                  "w": 300
+              }
+                }
+              ], 
+              "site": {
+                  "id": "siteID",
+                  "publisher": {
+                      "id": "999"
+                  }
+              },
+              "ext":{"prebid": {}}
+            }
+          },
+          "mockResponse": {
+            "status": 200,
+            "body": {
+              "id": "multiple-media-request",
+              "seatbid": [
+                {
+                  "seat": "958",
+                  "bid": [{
+                    "id": "7706636740145184841",
+                    "impid": "multiple-media-imp",
+                    "price": 0.500000,
+                    "adid": "29681110",
+                    "adm": "some-test-ad",
+                    "adomain": ["pubmatic.com"],
+                    "crid": "29681110",
+                    "h": 250,
+                    "w": 300,
+                    "dealid":"test deal",
+                    "ext": {
+                      "dspid": 6,
+                      "deal_channel": 1
+                    }
+                  }]
+                }
+              ],
+              "bidid": "5778926625248726496",
+              "cur": "USD"
+            }
+          }
+        }
+      ],
+    
+      "expectedBidResponses": [
+        {
+          "currency": "USD",
+          "bids": [
+            {
+              "bid": {
+                "id": "7706636740145184841",
+                "impid": "multiple-media-imp",
+                "price": 0.5,
+                "adid": "29681110",
+                "adm": "some-test-ad",
+                "adomain": ["pubmatic.com"],
+                "crid": "29681110",
+                "w": 300,
+                "h": 250,
+                "dealid":"test deal",
+                "ext": {
+                  "dspid": 6,
+                  "deal_channel": 1
+                }
+              },
+              "type": "banner"
+            }
+          ]
+        }
+      ]
+    }
\ No newline at end of file
diff --git a/adapters/pubmatic/pubmatictest/supplemental/bidExtMeta.json b/adapters/pubmatic/pubmatictest/supplemental/bidExtMeta.json
new file mode 100644
index 000000000..7ec552d63
--- /dev/null
+++ b/adapters/pubmatic/pubmatictest/supplemental/bidExtMeta.json
@@ -0,0 +1,179 @@
+{
+    "mockBidRequest": {
+        "id": "test-request-id",
+        "imp": [
+            {
+                "id": "test-imp-id",
+                "banner": {
+                    "format": [
+                        {
+                            "w": 300,
+                            "h": 250
+                        }
+                    ]
+                },
+                "ext": {
+                    "bidder": {
+                        "adSlot": "AdTag_Div1@300x250",
+                        "publisherId": "999",
+                        "wrapper": {
+                            "version": 1,
+                            "profile": 5123
+                        },
+                        "dctr": "k1=v1|k2=v2"
+                    },
+                    "data": {
+                        "adserver": {
+                            "name": "gam",
+                            "adslot": "/1111/home"
+                        },
+                        "pbadslot": "/2222/home",
+                        "sport": [
+                            "rugby",
+                            "cricket"
+                        ]
+                    }
+                }
+            }
+        ],
+        "device": {
+            "ua": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"
+        },
+        "site": {
+            "id": "siteID",
+            "publisher": {
+                "id": "1234"
+            }
+        }
+    },
+    "httpCalls": [
+        {
+            "expectedRequest": {
+                "uri": "https://hbopenbid.pubmatic.com/translator?source=prebid-server",
+                "body": {
+                    "id": "test-request-id",
+                    "imp": [
+                        {
+                            "id": "test-imp-id",
+                            "tagid": "AdTag_Div1",
+                            "banner": {
+                                "format": [
+                                    {
+                                        "w": 300,
+                                        "h": 250
+                                    }
+                                ],
+                                "h": 250,
+                                "w": 300
+                            },
+                            "ext": {
+                                "dfp_ad_unit_code": "/1111/home",
+                                "key_val": "k1=v1|k2=v2|sport=rugby,cricket"
+                            }
+                        }
+                    ],
+                    "device": {
+                        "ua": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"
+                    },
+                    "site": {
+                        "id": "siteID",
+                        "publisher": {
+                            "id": "999"
+                        }
+                    },
+                    "ext": {
+                        "prebid": {},
+                        "wrapper": {
+                            "profile": 5123,
+                            "version": 1
+                        }
+                    }
+                }
+            },
+            "mockResponse": {
+                "status": 200,
+                "body": {
+                    "id": "test-request-id",
+                    "seatbid": [
+                        {
+                            "seat": "958",
+                            "bid": [
+                                {
+                                    "id": "7706636740145184841",
+                                    "impid": "test-imp-id",
+                                    "price": 0.500000,
+                                    "adid": "29681110",
+                                    "adm": "some-test-ad",
+                                    "adomain": [
+                                        "pubmatic.com"
+                                    ],
+                                    "crid": "29681110",
+                                    "cat":[
+                                        "IAB-1",
+                                        "IAB-2"
+                                    ],
+                                    "h": 250,
+                                    "w": 300,
+                                    "dealid": "test deal",
+                                    "ext": {
+                                        "dspid": 6,
+                                        "advid": 125,
+                                        "deal_channel": 1,
+                                        "BidType":0
+                                    }
+                                }
+                            ]
+                        }
+                    ],
+                    "bidid": "5778926625248726496",
+                    "cur": "USD"
+                }
+            }
+        }
+    ],
+    "expectedBidResponses": [
+        {
+            "currency": "USD",
+            "bids": [
+                {
+                    "bid": {
+                        "id": "7706636740145184841",
+                        "impid": "test-imp-id",
+                        "price": 0.5,
+                        "adid": "29681110",
+                        "adm": "some-test-ad",
+                        "adomain": [
+                            "pubmatic.com"
+                        ],
+                        "crid": "29681110",
+                        "cat":[
+                            "IAB-1"
+                        ],
+                        "w": 300,
+                        "h": 250,
+                        "dealid": "test deal",
+                        "ext": {
+                            "dspid": 6,
+                            "advid": 125,
+                            "deal_channel": 1,
+                            "BidType":0
+                        }
+                    },
+                    "type": "banner",
+                    "meta": {
+                        "advertiserId": 958,
+                        "agencyId": 958,
+                        "networkId": 6,
+                        "demandSource": "6",
+                        "primaryCatId": "IAB-1",
+                        "secondaryCatIds": [
+                            "IAB-1",
+                            "IAB-2"
+                        ],
+                        "mediaType":"banner"
+                    }
+                }
+            ]
+        }
+    ]
+}
\ No newline at end of file
diff --git a/adapters/pubmatic/pubmatictest/supplemental/eid.json b/adapters/pubmatic/pubmatictest/supplemental/eid.json
new file mode 100644
index 000000000..88f82f1cc
--- /dev/null
+++ b/adapters/pubmatic/pubmatictest/supplemental/eid.json
@@ -0,0 +1,223 @@
+{
+    "mockBidRequest": {
+        "id": "test-request-eid-id",
+        "imp": [{
+            "id": "test-imp-id",
+            "banner": {
+                "format": [{
+                    "w": 300,
+                    "h": 250
+                }]
+            },
+            "ext": {
+                "bidder": {
+                    "adSlot": "AdTag_Div1@300x250",
+                    "publisherId": "999",
+                    "keywords": [{
+                        "key": "pmZoneID",
+                        "value": ["Zone1", "Zone2"]
+                      },
+                      {
+                         "key": "preference",
+                         "value": ["sports", "movies"]
+                      }
+                    ],
+                    "kadfloor": "0.12",
+                    "wrapper": {
+                        "version": 1,
+                        "profile": 5123
+                    }
+                }
+            }
+        }],
+        "device":{
+            "ua": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"
+        },
+        "ext": {
+          "prebid": {
+            "bidderparams": {
+              "acat": ["drg","dlu","ssr"],
+              "wiid": "dwzafakjflan-tygannnvlla-mlljvj"
+            }
+          }
+        },
+        "site": {
+		      	"id": "siteID",
+		    	  "publisher": {
+			        	"id": "1234"
+		      	}
+          },
+        "user": {
+          "ext": {
+              "eids": [
+                  {
+                      "source": "bvod.connect",
+                      "uids": [
+                          {
+                              "atype": 501,
+                              "id": "OztamSession-123456"
+                          },
+                          {
+                              "ext": {
+                                  "demgid": "1234",
+                                  "seq": 1
+                              },
+                              "atype": 2,
+                              "id": "7D92078A-8246-4BA4-AE5B-76104861E7DC"
+                          },
+                          {
+                              "ext": {
+                                  "demgid": "2345",
+                                  "seq": 2
+                              },
+                              "atype": 2,
+                              "id": "8D92078A-8246-4BA4-AE5B-76104861E7DC"
+                          }
+                      ]
+                  }
+              ]
+          }
+        }
+     },
+  
+    "httpCalls": [
+      {
+        "expectedRequest": {
+          "uri": "https://hbopenbid.pubmatic.com/translator?source=prebid-server",
+          "body": {
+            "id": "test-request-eid-id",
+            "imp": [
+              {
+                "id": "test-imp-id",
+                "tagid":"AdTag_Div1",
+                 "banner": {
+                  "format": [
+                    {
+                      "w": 300,
+                      "h": 250
+                    }
+                  ],
+                  "h": 250,
+                  "w": 300
+                },
+                "bidfloor": 0.12,
+                "ext": {
+                    "pmZoneId": "Zone1,Zone2",
+                    "preference": "sports,movies"
+                }
+              }
+            ], 
+            "device":{
+                "ua": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"
+            },
+            "site": {
+                "id": "siteID",
+                "publisher": {
+                    "id": "999"
+                }
+            },
+            "user": {
+              "eids": [
+                  {
+                      "source": "bvod.connect",
+                      "uids": [
+                          {
+                              "atype": 501,
+                              "id": "OztamSession-123456"
+                          },
+                          {
+                              "ext": {
+                                  "demgid": "1234",
+                                  "seq": 1
+                              },
+                              "atype": 2,
+                              "id": "7D92078A-8246-4BA4-AE5B-76104861E7DC"
+                          },
+                          {
+                              "ext": {
+                                  "demgid": "2345",
+                                  "seq": 2
+                              },
+                              "atype": 2,
+                              "id": "8D92078A-8246-4BA4-AE5B-76104861E7DC"
+                          }
+                      ]
+                  }
+              ],
+              "ext":{}
+            },
+            "ext": {
+              "prebid": {
+                "bidderparams": {
+                  "acat": ["drg","dlu","ssr"],
+                  "wiid": "dwzafakjflan-tygannnvlla-mlljvj"
+                }
+              },
+                "wrapper": {
+                    "profile": 5123,
+                    "version":1,
+                    "wiid" : "dwzafakjflan-tygannnvlla-mlljvj"
+                },
+                "acat": ["drg","dlu","ssr"]
+            }
+          }
+        },
+        "mockResponse": {
+          "status": 200,
+          "body": {
+            "id": "test-request-id",
+            "seatbid": [
+              {
+                "seat": "958",
+                "bid": [{
+                  "id": "7706636740145184841",
+                  "impid": "test-imp-id",
+                  "price": 0.500000,
+                  "adid": "29681110",
+                  "adm": "some-test-ad",
+                  "adomain": ["pubmatic.com"],
+                  "crid": "29681110",
+                  "h": 250,
+                  "w": 300,
+                  "dealid":"test deal",
+                  "ext": {
+                    "dspid": 6,
+                    "deal_channel": 1
+                  }
+                }]
+              }
+            ],
+            "bidid": "5778926625248726496",
+            "cur": "USD"
+          }
+        }
+      }
+    ],
+  
+    "expectedBidResponses": [
+      {
+        "currency": "USD",
+        "bids": [
+          {
+            "bid": {
+              "id": "7706636740145184841",
+              "impid": "test-imp-id",
+              "price": 0.5,
+              "adid": "29681110",
+              "adm": "some-test-ad",
+              "adomain": ["pubmatic.com"],
+              "crid": "29681110",
+              "w": 300,
+              "h": 250,
+              "dealid":"test deal",
+              "ext": {
+                "dspid": 6,
+                "deal_channel": 1
+              }
+            },
+            "type": "banner"
+          }
+        ]
+      }
+    ]
+  }
diff --git a/adapters/pubmatic/pubmatictest/supplemental/gptSlotNameInImpExt.json b/adapters/pubmatic/pubmatictest/supplemental/gptSlotNameInImpExt.json
index f4891d904..ce516b684 100644
--- a/adapters/pubmatic/pubmatictest/supplemental/gptSlotNameInImpExt.json
+++ b/adapters/pubmatic/pubmatictest/supplemental/gptSlotNameInImpExt.json
@@ -55,6 +55,13 @@
       "publisher": {
         "id": "1234"
       }
+    },
+    "ext": {
+      "prebid": {
+        "bidderparams": {
+          "wiid": "dwzafakjflan-tygannnvlla-mlljvj"
+        }
+      }
     }
   },
   "httpCalls": [
@@ -96,9 +103,14 @@
           "ext": {
             "wrapper": {
               "profile": 5123,
-              "version": 1
+              "version": 1,
+              "wiid": "dwzafakjflan-tygannnvlla-mlljvj"
             },
-            "prebid": {}
+            "prebid": {
+              "bidderparams": {
+                "wiid": "dwzafakjflan-tygannnvlla-mlljvj"
+              }
+            }
           }
         }
       },
diff --git a/adapters/pubmatic/pubmatictest/supplemental/gptSlotNameInImpExtPbAdslot.json b/adapters/pubmatic/pubmatictest/supplemental/gptSlotNameInImpExtPbAdslot.json
index 90df5a58f..437efcec0 100644
--- a/adapters/pubmatic/pubmatictest/supplemental/gptSlotNameInImpExtPbAdslot.json
+++ b/adapters/pubmatic/pubmatictest/supplemental/gptSlotNameInImpExtPbAdslot.json
@@ -51,6 +51,13 @@
       "publisher": {
         "id": "1234"
       }
+    },
+    "ext": {
+      "prebid": {
+        "bidderparams": {
+          "wiid": "dwzafakjflan-tygannnvlla-mlljvj"
+        }
+      }
     }
   },
   "httpCalls": [
@@ -92,9 +99,14 @@
           "ext": {
             "wrapper": {
               "profile": 5123,
-              "version": 1
+              "version": 1,
+              "wiid": "dwzafakjflan-tygannnvlla-mlljvj"
             },
-            "prebid": {}
+            "prebid": {
+              "bidderparams": {
+                "wiid": "dwzafakjflan-tygannnvlla-mlljvj"
+              }
+            }
           }
         }
       },
@@ -161,4 +173,4 @@
       ]
     }
   ]
-}
\ No newline at end of file
+}
diff --git a/adapters/pubmatic/pubmatictest/supplemental/multiformat.json b/adapters/pubmatic/pubmatictest/supplemental/multiformat.json
new file mode 100644
index 000000000..2747f4b48
--- /dev/null
+++ b/adapters/pubmatic/pubmatictest/supplemental/multiformat.json
@@ -0,0 +1,135 @@
+{
+    "mockBidRequest": {
+      "id": "multiple-media-request",
+      "imp": [
+        {
+          "id": "multiple-media-imp",
+          "video": {
+            "mimes": ["video/mp4"]
+          },
+          "banner": {
+            "format": [{
+                "w": 300,
+                "h": 250
+            },
+            {
+              "w": 728,
+              "h": 90
+          }]
+          },
+          "native": {
+            "request": "{\"assets\":[{\"id\":1,\"img\":{\"ext\":{\"image1\":\"image2\"},\"h\": 250,\"mimes\":[\"image\/gif\",\"image\/png\"],\"type\":3,\"w\":300},\"required\":1}]}"
+          },
+          "ext": {
+            "bidder": {
+                "adSlot": "AdTag_Div1@1x1",
+                "publisherId": "999"			
+             }
+          }
+        }
+      ], 
+      "site": {
+        "id": "siteID"
+        }
+    },
+  
+    "httpCalls": [
+        {
+          "expectedRequest": {
+            "uri": "https://hbopenbid.pubmatic.com/translator?source=prebid-server",
+            "body": {
+              "id": "multiple-media-request",
+              "imp": [
+                {
+                  "id": "multiple-media-imp",
+                  "tagid":"AdTag_Div1",
+                  "video": {
+                    "mimes": ["video/mp4"]
+                  },
+                  "banner": {
+                    "format": [
+                      {
+                        "w": 300,
+                        "h": 250
+                      },
+                      {
+                        "w": 728,
+                        "h": 90
+                      }
+                    ],
+                    "h": 250,
+                    "w": 300
+                   },
+                    "native": {
+                        "request": "{\"assets\":[{\"id\":1,\"img\":{\"ext\":{\"image1\":\"image2\"},\"h\": 250,\"mimes\":[\"image\/gif\",\"image\/png\"],\"type\":3,\"w\":300},\"required\":1}]}"
+                    }
+                }
+              ], 
+              "site": {
+                  "id": "siteID",
+                  "publisher": {
+                      "id": "999"
+                  }
+              },
+              "ext":{"prebid": {}}
+            }
+          },
+          "mockResponse": {
+            "status": 200,
+            "body": {
+              "id": "multiple-media-request",
+              "seatbid": [
+                {
+                  "seat": "958",
+                  "bid": [{
+                    "id": "7706636740145184841",
+                    "impid": "multiple-media-imp",
+                    "price": 0.500000,
+                    "adid": "29681110",
+                    "adm": "some-test-ad",
+                    "adomain": ["pubmatic.com"],
+                    "crid": "29681110",
+                    "h": 250,
+                    "w": 300,
+                    "dealid":"test deal",
+                    "ext": {
+                      "dspid": 6,
+                      "deal_channel": 1
+                    }
+                  }]
+                }
+              ],
+              "bidid": "5778926625248726496",
+              "cur": "USD"
+            }
+          }
+        }
+      ],
+    
+      "expectedBidResponses": [
+        {
+          "currency": "USD",
+          "bids": [
+            {
+              "bid": {
+                "id": "7706636740145184841",
+                "impid": "multiple-media-imp",
+                "price": 0.5,
+                "adid": "29681110",
+                "adm": "some-test-ad",
+                "adomain": ["pubmatic.com"],
+                "crid": "29681110",
+                "w": 300,
+                "h": 250,
+                "dealid":"test deal",
+                "ext": {
+                  "dspid": 6,
+                  "deal_channel": 1
+                }
+              },
+              "type": "banner"
+            }
+          ]
+        }
+      ]
+    }
\ No newline at end of file
diff --git a/adapters/pubmatic/pubmatictest/supplemental/pmZoneIDInKeywords.json b/adapters/pubmatic/pubmatictest/supplemental/pmZoneIDInKeywords.json
index 660ec82df..4a201b7da 100644
--- a/adapters/pubmatic/pubmatictest/supplemental/pmZoneIDInKeywords.json
+++ b/adapters/pubmatic/pubmatictest/supplemental/pmZoneIDInKeywords.json
@@ -19,7 +19,7 @@
             "dctr": "key1=V1,V2,V3|key2=v1|key3=v3,v5",
             "keywords": [
               {
-                "key": "pmZoneID",
+                "key": "pmzoneid",
                 "value": [
                   "Zone1",
                   "Zone2"
diff --git a/adapters/pubmatic/pubmatictest/supplemental/urlEncodedDCTR.json b/adapters/pubmatic/pubmatictest/supplemental/urlEncodedDCTR.json
new file mode 100644
index 000000000..2f4d04bb7
--- /dev/null
+++ b/adapters/pubmatic/pubmatictest/supplemental/urlEncodedDCTR.json
@@ -0,0 +1,167 @@
+{
+  "mockBidRequest": {
+    "id": "test-request-id",
+    "imp": [
+      {
+        "id": "test-imp-id",
+        "banner": {
+          "format": [
+            {
+              "w": 300,
+              "h": 250
+            }
+          ]
+        },
+        "ext": {
+          "bidder": {
+            "adSlot": "AdTag_Div1@300x250",
+            "publisherId": "  999  ",
+            "keywords": [
+              {
+                "key": "pmZoneID",
+                "value": [
+                  "Zone1",
+                  "Zone2"
+                ]
+              },
+              {
+                "key": "preference",
+                "value": [
+                  "sports",
+                  "movies"
+                ]
+              },
+              {
+                "key":"dctr",
+                "value":[
+                  "title%3DThe%20Hunt%7Cgenre%3Danimation%2Cadventure"
+                ]
+              }
+            ],
+            "wrapper": {
+              "version": 1,
+              "profile": 5123
+            }
+          }
+        }
+      }
+    ],
+    "device": {
+      "ua": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"
+    },
+    "site": {
+      "id": "siteID",
+      "publisher": {
+        "id": "1234"
+      }
+    }
+  },
+  "httpCalls": [
+    {
+      "expectedRequest": {
+        "uri": "https://hbopenbid.pubmatic.com/translator?source=prebid-server",
+        "body": {
+          "id": "test-request-id",
+          "imp": [
+            {
+              "id": "test-imp-id",
+              "tagid": "AdTag_Div1",
+              "banner": {
+                "format": [
+                  {
+                    "w": 300,
+                    "h": 250
+                  }
+                ],
+                "h": 250,
+                "w": 300
+              },
+              "ext": {
+                "key_val": "title=The Hunt|genre=animation,adventure",
+                "pmZoneId": "Zone1,Zone2",
+                "preference": "sports,movies"
+              }
+            }
+          ],
+          "device": {
+            "ua": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"
+          },
+          "site": {
+            "id": "siteID",
+            "publisher": {
+              "id": "999"
+            }
+          },
+          "ext": {
+            "prebid": {},
+            "wrapper": {
+              "profile": 5123,
+              "version": 1
+            }
+          }
+        }
+      },
+      "mockResponse": {
+        "status": 200,
+        "body": {
+          "id": "test-request-id",
+          "seatbid": [
+            {
+              "seat": "958",
+              "bid": [
+                {
+                  "id": "7706636740145184841",
+                  "impid": "test-imp-id",
+                  "price": 0.500000,
+                  "adid": "29681110",
+                  "adm": "some-test-ad",
+                  "adomain": [
+                    "pubmatic.com"
+                  ],
+                  "crid": "29681110",
+                  "h": 250,
+                  "w": 300,
+                  "dealid": "test deal",
+                  "ext": {
+                    "dspid": 6,
+                    "deal_channel": 1
+                  }
+                }
+              ]
+            }
+          ],
+          "bidid": "5778926625248726496",
+          "cur": "USD"
+        }
+      }
+    }
+  ],
+  "expectedBidResponses": [
+    {
+      "currency": "USD",
+      "bids": [
+        {
+          "bid": {
+            "id": "7706636740145184841",
+            "impid": "test-imp-id",
+            "price": 0.5,
+            "adid": "29681110",
+            "adm": "some-test-ad",
+            "adomain": [
+              "pubmatic.com"
+            ],
+            "crid": "29681110",
+            "w": 300,
+            "h": 250,
+            "dealid": "test deal",
+            "ext": {
+              "dspid": 6,
+              "deal_channel": 1
+            }
+          },
+          "type": "banner"
+        }
+      ]
+    }
+  ]
+}
\ No newline at end of file
diff --git a/adapters/spotx/params_test.go b/adapters/spotx/params_test.go
new file mode 100644
index 000000000..de96ebe79
--- /dev/null
+++ b/adapters/spotx/params_test.go
@@ -0,0 +1,58 @@
+package spotx
+
+import (
+	"encoding/json"
+	"testing"
+
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func TestSpotxParams(t *testing.T) {
+	testValidParams(t)
+	testInvalidParams(t)
+}
+
+func testValidParams(t *testing.T) {
+
+	params := []string{
+		`{"channel_id": "12345", "ad_unit": "instream"}`,
+		`{"channel_id": "12345", "ad_unit": "instream", "secure": true}`,
+		`{"channel_id": "12345", "ad_unit": "instream", "secure": true, "ad_volume": 0.4}`,
+		`{"channel_id": "12345", "ad_unit": "instream", "secure": true, "ad_volume": 0.4, "price_floor": 10}`,
+		`{"channel_id": "12345", "ad_unit": "instream", "secure": true, "ad_volume": 0.4, "price_floor": 10, "hide_skin": false}`,
+	}
+	validator, err := openrtb_ext.NewBidderParamsValidator("../../static/bidder-params")
+	if err != nil {
+		t.Fatalf("Error loading json schema for spotx paramaters: %v", err)
+	}
+
+	for _, param := range params {
+		if err := validator.Validate(openrtb_ext.BidderSpotX, json.RawMessage(param)); err != nil {
+			t.Errorf("Params schema mismatch - %s: %v", param, err)
+		}
+	}
+}
+
+// TestInvalidParams makes sure that the 33Across schema rejects all the imp.ext fields we don't support.
+func testInvalidParams(t *testing.T) {
+	params := []string{
+		`{"channel_id": "1234", "ad_unit": "instream", "secure": true, "ad_volume": 0.4, "price_floor": 10, "hide_skin": false}`,
+		`{"channel_id": "12345", "ad_unit": "outstream1", "secure": true, "ad_volume": 0.4, "price_floor": 10, "hide_skin": false}`,
+		`{"ad_unit": "instream", "secure": true, "ad_volume": 0.4, "price_floor": 10, "hide_skin": false}`,
+		`{"channel_id": "12345", "secure": true, "ad_volume": 0.4, "price_floor": 10, "hide_skin": false}`,
+		`{"channel_id": "12345", "ad_unit": "instream", "secure": 1, "ad_volume": 0.4, "price_floor": 10, "hide_skin": false}`,
+		`{"channel_id": "12345", "ad_unit": "instream", "secure": true, "ad_volume": "0.4", "price_floor": 10, "hide_skin": false}`,
+		`{"channel_id": "12345", "ad_unit": "instream", "secure": true, "ad_volume": 0.4, "price_floor": 10.12, "hide_skin": false}`,
+		`{"channel_id": "12345", "ad_unit": "instream", "secure": true, "ad_volume": 0.4, "price_floor": 10, "hide_skin": 0}`,
+	}
+	validator, err := openrtb_ext.NewBidderParamsValidator("../../static/bidder-params")
+	if err != nil {
+		t.Fatalf("Error loading json schema for spotx paramaters: %v", err)
+	}
+
+	for _, param := range params {
+		if err := validator.Validate(openrtb_ext.BidderSpotX, json.RawMessage(param)); err == nil {
+			t.Errorf("Unexpexted params schema match - %s", param)
+		}
+	}
+}
diff --git a/adapters/spotx/spotx.go b/adapters/spotx/spotx.go
new file mode 100644
index 000000000..0d94f1fa1
--- /dev/null
+++ b/adapters/spotx/spotx.go
@@ -0,0 +1,179 @@
+package spotx
+
+import (
+	"encoding/json"
+	"errors"
+	"fmt"
+	"net/http"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/adapters"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/errortypes"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+type Adapter struct {
+	url string
+}
+
+func (a *Adapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *adapters.ExtraRequestInfo) ([]*adapters.RequestData, []error) {
+	var errs []error
+	var adapterRequests []*adapters.RequestData
+
+	if len(request.Imp) == 0 {
+		errs = append(errs, &errortypes.BadInput{Message: "No impression in the bid request"})
+		return nil, errs
+	}
+
+	for i, imp := range request.Imp {
+		if imp.Video == nil {
+			errs = append(errs, errors.New(fmt.Sprintf("non video impression at index %d", i)))
+			continue
+		}
+
+		adapterReq, err := makeRequest(a, request, imp)
+		if adapterReq != nil {
+			adapterRequests = append(adapterRequests, adapterReq)
+		}
+		errs = append(errs, err...)
+	}
+
+	return adapterRequests, errs
+}
+
+func makeRequest(a *Adapter, originalReq *openrtb2.BidRequest, imp openrtb2.Imp) (*adapters.RequestData, []error) {
+	var errs []error
+
+	var bidderExt adapters.ExtImpBidder
+	if err := json.Unmarshal(imp.Ext, &bidderExt); err != nil {
+		errs = append(errs, &errortypes.BadInput{
+			Message: err.Error(),
+		})
+		return &adapters.RequestData{}, errs
+	}
+
+	var spotxExt openrtb_ext.ExtImpSpotX
+	if err := json.Unmarshal(bidderExt.Bidder, &spotxExt); err != nil {
+		errs = append(errs, &errortypes.BadInput{
+			Message: err.Error(),
+		})
+		return &adapters.RequestData{}, errs
+	}
+
+	reqCopy := *originalReq
+	reqCopy.ID = spotxExt.ChannelID
+
+	intermediateReq, _ := json.Marshal(reqCopy)
+	reqMap := make(map[string]interface{})
+	_ = json.Unmarshal(intermediateReq, &reqMap)
+
+	intermediateImp, _ := json.Marshal(imp)
+	impMap := make(map[string]interface{})
+	_ = json.Unmarshal(intermediateImp, &impMap)
+
+	if spotxExt.Secure {
+		impMap["secure"] = 1
+	} else {
+		impMap["secure"] = 0
+	}
+
+	impVideoExt := map[string]interface{}{}
+	if impMap["video"].(map[string]interface{})["ext"] != nil {
+		_ = json.Unmarshal(impMap["video"].(map[string]interface{})["ext"].([]byte), &impVideoExt)
+	}
+	impVideoExt["ad_volume"] = spotxExt.AdVolume
+	impVideoExt["ad_unit"] = spotxExt.AdUnit
+	if spotxExt.HideSkin {
+		impVideoExt["hide_skin"] = 1
+	} else {
+		impVideoExt["hide_skin"] = 0
+	}
+	impMap["video"].(map[string]interface{})["ext"] = impVideoExt
+	impMap["bidfloor"] = float64(spotxExt.PriceFloor)
+
+	// remove bidder from imp.Ext
+	if bidderExt.Prebid != nil {
+		byteExt, _ := json.Marshal(bidderExt)
+		impMap["ext"] = byteExt
+	} else {
+		delete(impMap, "ext")
+	}
+	reqMap["imp"] = impMap
+
+	reqJSON, err := json.Marshal(reqMap)
+	if err != nil {
+		errs = append(errs, err)
+		return nil, errs
+	}
+
+	headers := http.Header{}
+	headers.Add("Content-Type", "application/json;charset=utf-8")
+
+	return &adapters.RequestData{
+		Method:  "POST",
+		Uri:     fmt.Sprintf("%s/%s", a.url, spotxExt.ChannelID),
+		Body:    reqJSON, //TODO: This is a custom request struct, other adapters are sending this openrtb2.BidRequest
+		Headers: headers,
+	}, errs
+}
+
+func (a *Adapter) MakeBids(internalRequest *openrtb2.BidRequest, externalRequest *adapters.RequestData, response *adapters.ResponseData) (*adapters.BidderResponse, []error) {
+	if response.StatusCode == http.StatusNoContent {
+		return nil, nil
+	}
+
+	if response.StatusCode == http.StatusBadRequest {
+		return nil, []error{&errortypes.BadInput{
+			Message: fmt.Sprintf("Unexpected status code: %d. Run with request.debug = 1 for more info", response.StatusCode),
+		}}
+	}
+
+	if response.StatusCode != http.StatusOK {
+		return nil, []error{&errortypes.BadServerResponse{
+			Message: fmt.Sprintf("Unexpected status code: %d. Run with request.debug = 1 for more info", response.StatusCode),
+		}}
+	}
+
+	var bidResp openrtb2.BidResponse
+	if err := json.Unmarshal(response.Body, &bidResp); err != nil {
+		return nil, []error{err}
+	}
+
+	bidResponse := adapters.NewBidderResponseWithBidsCapacity(len(bidResp.SeatBid[0].Bid))
+	for _, sb := range bidResp.SeatBid {
+		for i := range sb.Bid {
+			if mediaType, err := getMediaTypeForImp(bidResp.ID, internalRequest.Imp); err != nil {
+				bid := sb.Bid[i]
+				bidResponse.Bids = append(bidResponse.Bids, &adapters.TypedBid{
+					Bid:     &bid,
+					BidType: mediaType,
+				})
+			}
+		}
+	}
+	return bidResponse, nil
+}
+
+func getMediaTypeForImp(impID string, imps []openrtb2.Imp) (openrtb_ext.BidType, error) {
+	for _, imp := range imps {
+		if imp.ID == impID && imp.Video != nil {
+			return openrtb_ext.BidTypeVideo, nil
+		}
+	}
+	return "", errors.New("only videos supported")
+}
+
+func NewSpotxBidder(url string) *Adapter {
+	return &Adapter{
+		url: url,
+	}
+}
+
+// Builder builds a new instance of the Sovrn adapter for the given bidder with the given config.
+func Builder(bidderName openrtb_ext.BidderName, config config.Adapter, _ config.Server) (adapters.Bidder, error) {
+	bidder := &Adapter{
+		url: config.Endpoint,
+	}
+	return bidder, nil
+}
diff --git a/adapters/spotx/spotx_test.go b/adapters/spotx/spotx_test.go
new file mode 100644
index 000000000..90ce110f4
--- /dev/null
+++ b/adapters/spotx/spotx_test.go
@@ -0,0 +1,66 @@
+package spotx
+
+import (
+	"encoding/json"
+	"testing"
+
+	"github.com/magiconair/properties/assert"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/adapters"
+)
+
+func TestSpotxMakeBid(t *testing.T) {
+
+	var secure int8 = 1
+
+	parmsJSON := []byte(`{
+        "bidder": {
+          "channel_id": "85394",
+          "ad_unit": "instream",
+          "secure": true,
+          "ad_volume": 0.800000,
+          "price_floor": 9,
+          "hide_skin": false
+        }
+      }`)
+
+	request := &openrtb2.BidRequest{
+		ID: "1559039248176",
+		Imp: []openrtb2.Imp{
+			{
+				ID: "28635736ddc2bb",
+				Video: &openrtb2.Video{
+					MIMEs: []string{"video/3gpp"},
+				},
+				Secure: &secure,
+				Exp:    2,
+				Ext:    parmsJSON,
+			},
+		},
+	}
+
+	extReq := adapters.ExtraRequestInfo{}
+	reqData, err := NewSpotxBidder("https://search.spotxchange.com/openrtb/2.3/dados").MakeRequests(request, &extReq)
+	if err != nil {
+		t.Error("Some err occurred while forming request")
+		t.FailNow()
+	}
+
+	assert.Equal(t, reqData[0].Method, "POST")
+	assert.Equal(t, reqData[0].Uri, "https://search.spotxchange.com/openrtb/2.3/dados/85394")
+	assert.Equal(t, reqData[0].Headers.Get("Content-Type"), "application/json;charset=utf-8")
+
+	var bodyMap map[string]interface{}
+	_ = json.Unmarshal(reqData[0].Body, &bodyMap)
+	assert.Equal(t, bodyMap["id"].(string), "85394")
+
+	impMap := bodyMap["imp"].(map[string]interface{})
+	assert.Equal(t, impMap["bidfloor"].(float64), float64(9))
+	assert.Equal(t, impMap["secure"].(float64), float64(1))
+
+	extMap := impMap["video"].(map[string]interface{})["ext"].(map[string]interface{})
+	assert.Equal(t, extMap["ad_unit"], "instream")
+	assert.Equal(t, extMap["ad_volume"], 0.8)
+	assert.Equal(t, extMap["hide_skin"].(float64), float64(0))
+
+}
diff --git a/adapters/vastbidder/bidder_macro.go b/adapters/vastbidder/bidder_macro.go
new file mode 100644
index 000000000..c346852ac
--- /dev/null
+++ b/adapters/vastbidder/bidder_macro.go
@@ -0,0 +1,1252 @@
+package vastbidder
+
+import (
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/prebid/openrtb/v19/adcom1"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/adapters"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// BidderMacro default implementation
+type BidderMacro struct {
+	IBidderMacro
+
+	//Configuration Parameters
+	Conf *config.Adapter
+
+	//OpenRTB Specific Parameters
+	Request   *openrtb2.BidRequest
+	IsApp     bool
+	HasGeo    bool
+	Imp       *openrtb2.Imp
+	Publisher *openrtb2.Publisher
+	Content   *openrtb2.Content
+
+	//Extensions
+	ImpBidderExt openrtb_ext.ExtImpVASTBidder
+	VASTTag      *openrtb_ext.ExtImpVASTBidderTag
+	UserExt      *openrtb_ext.ExtUser
+	RegsExt      *openrtb_ext.ExtRegs
+	DeviceExt    *openrtb_ext.ExtDevice
+
+	//Impression level Request Headers
+	ImpReqHeaders http.Header
+}
+
+// NewBidderMacro contains definition for all openrtb macro's
+func NewBidderMacro() IBidderMacro {
+	obj := &BidderMacro{}
+	obj.IBidderMacro = obj
+	return obj
+}
+
+func (tag *BidderMacro) init() {
+	if nil != tag.Request.App {
+		tag.IsApp = true
+		tag.Publisher = tag.Request.App.Publisher
+		tag.Content = tag.Request.App.Content
+	} else {
+		tag.Publisher = tag.Request.Site.Publisher
+		tag.Content = tag.Request.Site.Content
+	}
+	tag.HasGeo = nil != tag.Request.Device && nil != tag.Request.Device.Geo
+
+	//Read User Extensions
+	if nil != tag.Request.User && nil != tag.Request.User.Ext {
+		var ext openrtb_ext.ExtUser
+		err := json.Unmarshal(tag.Request.User.Ext, &ext)
+		if nil == err {
+			tag.UserExt = &ext
+		}
+	}
+
+	//Read Regs Extensions
+	if nil != tag.Request.Regs && nil != tag.Request.Regs.Ext {
+		var ext openrtb_ext.ExtRegs
+		err := json.Unmarshal(tag.Request.Regs.Ext, &ext)
+		if nil == err {
+			tag.RegsExt = &ext
+		}
+	}
+
+	//Read Device Extensions
+	if nil != tag.Request.Device && nil != tag.Request.Device.Ext {
+		var ext openrtb_ext.ExtDevice
+		err := json.Unmarshal(tag.Request.Device.Ext, &ext)
+		if nil == err {
+			tag.DeviceExt = &ext
+		}
+	}
+}
+
+// InitBidRequest will initialise BidRequest
+func (tag *BidderMacro) InitBidRequest(request *openrtb2.BidRequest) {
+	tag.Request = request
+	tag.init()
+}
+
+// LoadImpression will set current imp
+func (tag *BidderMacro) LoadImpression(imp *openrtb2.Imp) (*openrtb_ext.ExtImpVASTBidder, error) {
+	tag.Imp = imp
+
+	var bidderExt adapters.ExtImpBidder
+	if err := json.Unmarshal(imp.Ext, &bidderExt); err != nil {
+		return nil, err
+	}
+
+	tag.ImpBidderExt = openrtb_ext.ExtImpVASTBidder{}
+	if err := json.Unmarshal(bidderExt.Bidder, &tag.ImpBidderExt); err != nil {
+		return nil, err
+	}
+	return &tag.ImpBidderExt, nil
+}
+
+// LoadVASTTag will set current VAST Tag details in bidder keys
+func (tag *BidderMacro) LoadVASTTag(vastTag *openrtb_ext.ExtImpVASTBidderTag) {
+	tag.VASTTag = vastTag
+}
+
+// GetBidderKeys will set bidder level keys
+func (tag *BidderMacro) GetBidderKeys() map[string]string {
+	//Adding VAST Tag Bidder Parameters
+	keys := NormalizeJSON(tag.VASTTag.Params)
+
+	//Adding VAST Tag Standard Params
+	keys["dur"] = strconv.Itoa(tag.VASTTag.Duration)
+
+	//Adding Headers as Custom Macros
+
+	//Adding Cookies as Custom Macros
+
+	//Adding Default Empty for standard keys
+	for i := range ParamKeys {
+		if _, ok := keys[ParamKeys[i]]; !ok {
+			keys[ParamKeys[i]] = ""
+		}
+	}
+	return keys
+}
+
+// SetAdapterConfig will set Adapter config
+func (tag *BidderMacro) SetAdapterConfig(conf *config.Adapter) {
+	tag.Conf = conf
+}
+
+// GetURI get URL
+func (tag *BidderMacro) GetURI() string {
+
+	//check for URI at impression level
+	if nil != tag.VASTTag {
+		return tag.VASTTag.URL
+	}
+
+	//check for URI at config level
+	return tag.Conf.Endpoint
+}
+
+// GetHeaders returns list of custom request headers
+// Override this method if your Vast bidder needs custom  request headers
+func (tag *BidderMacro) GetHeaders() http.Header {
+	return http.Header{}
+}
+
+/********************* Request *********************/
+
+// MacroTest contains definition for Test Parameter
+func (tag *BidderMacro) MacroTest(key string) string {
+	if tag.Request.Test > 0 {
+		return strconv.Itoa(int(tag.Request.Test))
+	}
+	return ""
+}
+
+// MacroTimeout contains definition for Timeout Parameter
+func (tag *BidderMacro) MacroTimeout(key string) string {
+	if tag.Request.TMax > 0 {
+		return strconv.FormatInt(tag.Request.TMax, intBase)
+	}
+	return ""
+}
+
+// MacroWhitelistSeat contains definition for WhitelistSeat Parameter
+func (tag *BidderMacro) MacroWhitelistSeat(key string) string {
+	return strings.Join(tag.Request.WSeat, comma)
+}
+
+// MacroWhitelistLang contains definition for WhitelistLang Parameter
+func (tag *BidderMacro) MacroWhitelistLang(key string) string {
+	return strings.Join(tag.Request.WLang, comma)
+}
+
+// MacroBlockedSeat contains definition for Blockedseat Parameter
+func (tag *BidderMacro) MacroBlockedSeat(key string) string {
+	return strings.Join(tag.Request.BSeat, comma)
+}
+
+// MacroCurrency contains definition for Currency Parameter
+func (tag *BidderMacro) MacroCurrency(key string) string {
+	return strings.Join(tag.Request.Cur, comma)
+}
+
+// MacroBlockedCategory contains definition for BlockedCategory Parameter
+func (tag *BidderMacro) MacroBlockedCategory(key string) string {
+	return strings.Join(tag.Request.BCat, comma)
+}
+
+// MacroBlockedAdvertiser contains definition for BlockedAdvertiser Parameter
+func (tag *BidderMacro) MacroBlockedAdvertiser(key string) string {
+	return strings.Join(tag.Request.BAdv, comma)
+}
+
+// MacroBlockedApp contains definition for BlockedApp Parameter
+func (tag *BidderMacro) MacroBlockedApp(key string) string {
+	return strings.Join(tag.Request.BApp, comma)
+}
+
+/********************* Source *********************/
+
+// MacroFD contains definition for FD Parameter
+func (tag *BidderMacro) MacroFD(key string) string {
+	if nil != tag.Request.Source {
+		return strconv.Itoa(int(tag.Request.Source.FD))
+	}
+	return ""
+}
+
+// MacroTransactionID contains definition for TransactionID Parameter
+func (tag *BidderMacro) MacroTransactionID(key string) string {
+	if nil != tag.Request.Source {
+		return tag.Request.Source.TID
+	}
+	return ""
+}
+
+// MacroPaymentIDChain contains definition for PaymentIDChain Parameter
+func (tag *BidderMacro) MacroPaymentIDChain(key string) string {
+	if nil != tag.Request.Source {
+		return tag.Request.Source.PChain
+	}
+	return ""
+}
+
+/********************* Regs *********************/
+
+// MacroCoppa contains definition for Coppa Parameter
+func (tag *BidderMacro) MacroCoppa(key string) string {
+	if nil != tag.Request.Regs {
+		return strconv.Itoa(int(tag.Request.Regs.COPPA))
+	}
+	return ""
+}
+
+/********************* Impression *********************/
+
+// MacroDisplayManager contains definition for DisplayManager Parameter
+func (tag *BidderMacro) MacroDisplayManager(key string) string {
+	return tag.Imp.DisplayManager
+}
+
+// MacroDisplayManagerVersion contains definition for DisplayManagerVersion Parameter
+func (tag *BidderMacro) MacroDisplayManagerVersion(key string) string {
+	return tag.Imp.DisplayManagerVer
+}
+
+// MacroInterstitial contains definition for Interstitial Parameter
+func (tag *BidderMacro) MacroInterstitial(key string) string {
+	if tag.Imp.Instl > 0 {
+		return strconv.Itoa(int(tag.Imp.Instl))
+	}
+	return ""
+}
+
+// MacroTagID contains definition for TagID Parameter
+func (tag *BidderMacro) MacroTagID(key string) string {
+	return tag.Imp.TagID
+}
+
+// MacroBidFloor contains definition for BidFloor Parameter
+func (tag *BidderMacro) MacroBidFloor(key string) string {
+	if tag.Imp.BidFloor > 0 {
+		return fmt.Sprintf("%g", tag.Imp.BidFloor)
+	}
+	return ""
+}
+
+// MacroBidFloorCurrency contains definition for BidFloorCurrency Parameter
+func (tag *BidderMacro) MacroBidFloorCurrency(key string) string {
+	return tag.Imp.BidFloorCur
+}
+
+// MacroSecure contains definition for Secure Parameter
+func (tag *BidderMacro) MacroSecure(key string) string {
+	if nil != tag.Imp.Secure {
+		return strconv.Itoa(int(*tag.Imp.Secure))
+	}
+	return ""
+}
+
+// MacroPMP contains definition for PMP Parameter
+func (tag *BidderMacro) MacroPMP(key string) string {
+	if nil != tag.Imp.PMP {
+		data, _ := json.Marshal(tag.Imp.PMP)
+		return string(data)
+	}
+	return ""
+}
+
+/********************* Video *********************/
+
+// MacroVideoMIMES contains definition for VideoMIMES Parameter
+func (tag *BidderMacro) MacroVideoMIMES(key string) string {
+	if nil != tag.Imp.Video {
+		return strings.Join(tag.Imp.Video.MIMEs, comma)
+	}
+	return ""
+}
+
+// MacroVideoMinimumDuration contains definition for VideoMinimumDuration Parameter
+func (tag *BidderMacro) MacroVideoMinimumDuration(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.MinDuration > 0 {
+		return strconv.FormatInt(tag.Imp.Video.MinDuration, intBase)
+	}
+	return ""
+}
+
+// MacroVideoMaximumDuration contains definition for VideoMaximumDuration Parameter
+func (tag *BidderMacro) MacroVideoMaximumDuration(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.MaxDuration > 0 {
+		return strconv.FormatInt(tag.Imp.Video.MaxDuration, intBase)
+	}
+	return ""
+}
+
+// MacroVideoProtocols contains definition for VideoProtocols Parameter
+func (tag *BidderMacro) MacroVideoProtocols(key string) string {
+	if nil != tag.Imp.Video {
+		value := tag.Imp.Video.Protocols
+		return ObjectArrayToString(len(value), comma, func(i int) string {
+			return strconv.FormatInt(int64(value[i]), intBase)
+		})
+	}
+	return ""
+}
+
+// MacroVideoPlayerWidth contains definition for VideoPlayerWidth Parameter
+func (tag *BidderMacro) MacroVideoPlayerWidth(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.W > 0 {
+		return strconv.FormatInt(int64(tag.Imp.Video.W), intBase)
+	}
+	return ""
+}
+
+// MacroVideoPlayerHeight contains definition for VideoPlayerHeight Parameter
+func (tag *BidderMacro) MacroVideoPlayerHeight(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.H > 0 {
+		return strconv.FormatInt(int64(tag.Imp.Video.H), intBase)
+	}
+	return ""
+}
+
+// MacroVideoStartDelay contains definition for VideoStartDelay Parameter
+func (tag *BidderMacro) MacroVideoStartDelay(key string) string {
+	if nil != tag.Imp.Video && nil != tag.Imp.Video.StartDelay {
+		return strconv.FormatInt(int64(*tag.Imp.Video.StartDelay), intBase)
+	}
+	return ""
+}
+
+// MacroVideoPlacement contains definition for VideoPlacement Parameter
+func (tag *BidderMacro) MacroVideoPlacement(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.Placement > 0 {
+		return strconv.FormatInt(int64(tag.Imp.Video.Placement), intBase)
+	}
+	return ""
+}
+
+// MacroVideoLinearity contains definition for VideoLinearity Parameter
+func (tag *BidderMacro) MacroVideoLinearity(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.Linearity > 0 {
+		return strconv.FormatInt(int64(tag.Imp.Video.Linearity), intBase)
+	}
+	return ""
+}
+
+// MacroVideoSkip contains definition for VideoSkip Parameter
+func (tag *BidderMacro) MacroVideoSkip(key string) string {
+	if nil != tag.Imp.Video && nil != tag.Imp.Video.Skip {
+		return strconv.FormatInt(int64(*tag.Imp.Video.Skip), intBase)
+	}
+	return ""
+}
+
+// MacroVideoSkipMinimum contains definition for VideoSkipMinimum Parameter
+func (tag *BidderMacro) MacroVideoSkipMinimum(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.SkipMin > 0 {
+		return strconv.FormatInt(tag.Imp.Video.SkipMin, intBase)
+	}
+	return ""
+}
+
+// MacroVideoSkipAfter contains definition for VideoSkipAfter Parameter
+func (tag *BidderMacro) MacroVideoSkipAfter(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.SkipAfter > 0 {
+		return strconv.FormatInt(tag.Imp.Video.SkipAfter, intBase)
+	}
+	return ""
+}
+
+// MacroVideoSequence contains definition for VideoSequence Parameter
+func (tag *BidderMacro) MacroVideoSequence(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.Sequence > 0 {
+		return strconv.FormatInt(int64(tag.Imp.Video.Sequence), intBase)
+	}
+	return ""
+}
+
+// MacroVideoBlockedAttribute contains definition for VideoBlockedAttribute Parameter
+func (tag *BidderMacro) MacroVideoBlockedAttribute(key string) string {
+	if nil != tag.Imp.Video {
+		value := tag.Imp.Video.BAttr
+		return ObjectArrayToString(len(value), comma, func(i int) string {
+			return strconv.FormatInt(int64(value[i]), intBase)
+		})
+	}
+	return ""
+}
+
+// MacroVideoMaximumExtended contains definition for VideoMaximumExtended Parameter
+func (tag *BidderMacro) MacroVideoMaximumExtended(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.MaxExtended > 0 {
+		return strconv.FormatInt(tag.Imp.Video.MaxExtended, intBase)
+	}
+	return ""
+}
+
+// MacroVideoMinimumBitRate contains definition for VideoMinimumBitRate Parameter
+func (tag *BidderMacro) MacroVideoMinimumBitRate(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.MinBitRate > 0 {
+		return strconv.FormatInt(int64(tag.Imp.Video.MinBitRate), intBase)
+	}
+	return ""
+}
+
+// MacroVideoMaximumBitRate contains definition for VideoMaximumBitRate Parameter
+func (tag *BidderMacro) MacroVideoMaximumBitRate(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.MaxBitRate > 0 {
+		return strconv.FormatInt(int64(tag.Imp.Video.MaxBitRate), intBase)
+	}
+	return ""
+}
+
+// MacroVideoBoxing contains definition for VideoBoxing Parameter
+func (tag *BidderMacro) MacroVideoBoxing(key string) string {
+	if nil != tag.Imp.Video && tag.Imp.Video.BoxingAllowed > 0 {
+		return strconv.FormatInt(int64(tag.Imp.Video.BoxingAllowed), intBase)
+	}
+	return ""
+}
+
+// MacroVideoPlaybackMethod contains definition for VideoPlaybackMethod Parameter
+func (tag *BidderMacro) MacroVideoPlaybackMethod(key string) string {
+	if nil != tag.Imp.Video {
+		value := tag.Imp.Video.PlaybackMethod
+		return ObjectArrayToString(len(value), comma, func(i int) string {
+			return strconv.FormatInt(int64(value[i]), intBase)
+		})
+	}
+	return ""
+}
+
+// MacroVideoDelivery contains definition for VideoDelivery Parameter
+func (tag *BidderMacro) MacroVideoDelivery(key string) string {
+	if nil != tag.Imp.Video {
+		value := tag.Imp.Video.Delivery
+		return ObjectArrayToString(len(value), comma, func(i int) string {
+			return strconv.FormatInt(int64(value[i]), intBase)
+		})
+	}
+	return ""
+}
+
+// MacroVideoPosition contains definition for VideoPosition Parameter
+func (tag *BidderMacro) MacroVideoPosition(key string) string {
+	if nil != tag.Imp.Video && nil != tag.Imp.Video.Pos {
+		return strconv.FormatInt(int64(*tag.Imp.Video.Pos), intBase)
+	}
+	return ""
+}
+
+// MacroVideoAPI contains definition for VideoAPI Parameter
+func (tag *BidderMacro) MacroVideoAPI(key string) string {
+	if nil != tag.Imp.Video {
+		value := tag.Imp.Video.API
+		return ObjectArrayToString(len(value), comma, func(i int) string {
+			return strconv.FormatInt(int64(value[i]), intBase)
+		})
+	}
+	return ""
+}
+
+/********************* Site *********************/
+
+// MacroSiteID contains definition for SiteID Parameter
+func (tag *BidderMacro) MacroSiteID(key string) string {
+	if !tag.IsApp {
+		return tag.Request.Site.ID
+	}
+	return ""
+}
+
+// MacroSiteName contains definition for SiteName Parameter
+func (tag *BidderMacro) MacroSiteName(key string) string {
+	if !tag.IsApp {
+		return tag.Request.Site.Name
+	}
+	return ""
+}
+
+// MacroSitePage contains definition for SitePage Parameter
+func (tag *BidderMacro) MacroSitePage(key string) string {
+	if !tag.IsApp && nil != tag.Request && nil != tag.Request.Site {
+		return tag.Request.Site.Page
+	}
+	return ""
+}
+
+// MacroSiteReferrer contains definition for SiteReferrer Parameter
+func (tag *BidderMacro) MacroSiteReferrer(key string) string {
+	if !tag.IsApp {
+		return tag.Request.Site.Ref
+	}
+	return ""
+}
+
+// MacroSiteSearch contains definition for SiteSearch Parameter
+func (tag *BidderMacro) MacroSiteSearch(key string) string {
+	if !tag.IsApp {
+		return tag.Request.Site.Search
+	}
+	return ""
+}
+
+// MacroSiteMobile contains definition for SiteMobile Parameter
+func (tag *BidderMacro) MacroSiteMobile(key string) string {
+	if !tag.IsApp && tag.Request.Site.Mobile > 0 {
+		return strconv.FormatInt(int64(tag.Request.Site.Mobile), intBase)
+	}
+	return ""
+}
+
+/********************* App *********************/
+
+// MacroAppID contains definition for AppID Parameter
+func (tag *BidderMacro) MacroAppID(key string) string {
+	if tag.IsApp {
+		return tag.Request.App.ID
+	}
+	return ""
+}
+
+// MacroAppName contains definition for AppName Parameter
+func (tag *BidderMacro) MacroAppName(key string) string {
+	if tag.IsApp {
+		return tag.Request.App.Name
+	}
+	return ""
+}
+
+// MacroAppBundle contains definition for AppBundle Parameter
+func (tag *BidderMacro) MacroAppBundle(key string) string {
+	if tag.IsApp {
+		return tag.Request.App.Bundle
+	}
+	return ""
+}
+
+// MacroAppStoreURL contains definition for AppStoreURL Parameter
+func (tag *BidderMacro) MacroAppStoreURL(key string) string {
+	if tag.IsApp {
+		return tag.Request.App.StoreURL
+	}
+	return ""
+}
+
+// MacroAppVersion contains definition for AppVersion Parameter
+func (tag *BidderMacro) MacroAppVersion(key string) string {
+	if tag.IsApp {
+		return tag.Request.App.Ver
+	}
+	return ""
+}
+
+// MacroAppPaid contains definition for AppPaid Parameter
+func (tag *BidderMacro) MacroAppPaid(key string) string {
+	if tag.IsApp && tag.Request.App.Paid != 0 {
+		return strconv.FormatInt(int64(tag.Request.App.Paid), intBase)
+	}
+	return ""
+}
+
+/********************* Site/App Common *********************/
+
+// MacroCategory contains definition for Category Parameter
+func (tag *BidderMacro) MacroCategory(key string) string {
+	if tag.IsApp {
+		return strings.Join(tag.Request.App.Cat, comma)
+	}
+	return strings.Join(tag.Request.Site.Cat, comma)
+}
+
+// MacroDomain contains definition for Domain Parameter
+func (tag *BidderMacro) MacroDomain(key string) string {
+	if tag.IsApp {
+		return tag.Request.App.Domain
+	}
+	return tag.Request.Site.Domain
+}
+
+// MacroSectionCategory contains definition for SectionCategory Parameter
+func (tag *BidderMacro) MacroSectionCategory(key string) string {
+	if tag.IsApp {
+		return strings.Join(tag.Request.App.SectionCat, comma)
+	}
+	return strings.Join(tag.Request.Site.SectionCat, comma)
+}
+
+// MacroPageCategory contains definition for PageCategory Parameter
+func (tag *BidderMacro) MacroPageCategory(key string) string {
+	if tag.IsApp {
+		return strings.Join(tag.Request.App.PageCat, comma)
+	}
+	return strings.Join(tag.Request.Site.PageCat, comma)
+}
+
+// MacroPrivacyPolicy contains definition for PrivacyPolicy Parameter
+func (tag *BidderMacro) MacroPrivacyPolicy(key string) string {
+	var value int8 = 0
+	if tag.IsApp {
+		value = tag.Request.App.PrivacyPolicy
+	} else {
+		value = tag.Request.Site.PrivacyPolicy
+	}
+	if value > 0 {
+		return strconv.FormatInt(int64(value), intBase)
+	}
+	return ""
+}
+
+// MacroKeywords contains definition for Keywords Parameter
+func (tag *BidderMacro) MacroKeywords(key string) string {
+	if tag.IsApp {
+		return tag.Request.App.Keywords
+	}
+	return tag.Request.Site.Keywords
+}
+
+/********************* Publisher *********************/
+
+// MacroPubID contains definition for PubID Parameter
+func (tag *BidderMacro) MacroPubID(key string) string {
+	if nil != tag.Publisher {
+		return tag.Publisher.ID
+	}
+	return ""
+}
+
+// MacroPubName contains definition for PubName Parameter
+func (tag *BidderMacro) MacroPubName(key string) string {
+	if nil != tag.Publisher {
+		return tag.Publisher.Name
+	}
+	return ""
+}
+
+// MacroPubDomain contains definition for PubDomain Parameter
+func (tag *BidderMacro) MacroPubDomain(key string) string {
+	if nil != tag.Publisher {
+		return tag.Publisher.Domain
+	}
+	return ""
+}
+
+/********************* Content *********************/
+
+// MacroContentID contains definition for ContentID Parameter
+func (tag *BidderMacro) MacroContentID(key string) string {
+	if nil != tag.Content {
+		return tag.Content.ID
+	}
+	return ""
+}
+
+// MacroContentEpisode contains definition for ContentEpisode Parameter
+func (tag *BidderMacro) MacroContentEpisode(key string) string {
+	if nil != tag.Content {
+		return strconv.FormatInt(int64(tag.Content.Episode), intBase)
+	}
+	return ""
+}
+
+// MacroContentTitle contains definition for ContentTitle Parameter
+func (tag *BidderMacro) MacroContentTitle(key string) string {
+	if nil != tag.Content {
+		return tag.Content.Title
+	}
+	return ""
+}
+
+// MacroContentSeries contains definition for ContentSeries Parameter
+func (tag *BidderMacro) MacroContentSeries(key string) string {
+	if nil != tag.Content {
+		return tag.Content.Series
+	}
+	return ""
+}
+
+// MacroContentSeason contains definition for ContentSeason Parameter
+func (tag *BidderMacro) MacroContentSeason(key string) string {
+	if nil != tag.Content {
+		return tag.Content.Season
+	}
+	return ""
+}
+
+// MacroContentArtist contains definition for ContentArtist Parameter
+func (tag *BidderMacro) MacroContentArtist(key string) string {
+	if nil != tag.Content {
+		return tag.Content.Artist
+	}
+	return ""
+}
+
+// MacroContentGenre contains definition for ContentGenre Parameter
+func (tag *BidderMacro) MacroContentGenre(key string) string {
+	if nil != tag.Content {
+		return tag.Content.Genre
+	}
+	return ""
+}
+
+// MacroContentAlbum contains definition for ContentAlbum Parameter
+func (tag *BidderMacro) MacroContentAlbum(key string) string {
+	if nil != tag.Content {
+		return tag.Content.Album
+	}
+	return ""
+}
+
+// MacroContentISrc contains definition for ContentISrc Parameter
+func (tag *BidderMacro) MacroContentISrc(key string) string {
+	if nil != tag.Content {
+		return tag.Content.ISRC
+	}
+	return ""
+}
+
+// MacroContentURL contains definition for ContentURL Parameter
+func (tag *BidderMacro) MacroContentURL(key string) string {
+	if nil != tag.Content {
+		return tag.Content.URL
+	}
+	return ""
+}
+
+// MacroContentCategory contains definition for ContentCategory Parameter
+func (tag *BidderMacro) MacroContentCategory(key string) string {
+	if nil != tag.Content {
+		return strings.Join(tag.Content.Cat, comma)
+	}
+	return ""
+}
+
+// MacroContentProductionQuality contains definition for ContentProductionQuality Parameter
+func (tag *BidderMacro) MacroContentProductionQuality(key string) string {
+	if nil != tag.Content && nil != tag.Content.ProdQ {
+		return strconv.FormatInt(int64(*tag.Content.ProdQ), intBase)
+	}
+	return ""
+}
+
+// MacroContentVideoQuality contains definition for ContentVideoQuality Parameter
+func (tag *BidderMacro) MacroContentVideoQuality(key string) string {
+	if nil != tag.Content && nil != tag.Content.VideoQuality {
+		return strconv.FormatInt(int64(*tag.Content.VideoQuality), intBase)
+	}
+	return ""
+}
+
+// MacroContentContext contains definition for ContentContext Parameter
+func (tag *BidderMacro) MacroContentContext(key string) string {
+	if nil != tag.Content && tag.Content.Context > 0 {
+		return strconv.FormatInt(int64(tag.Content.Context), intBase)
+	}
+	return ""
+}
+
+// MacroContentContentRating contains definition for ContentContentRating Parameter
+func (tag *BidderMacro) MacroContentContentRating(key string) string {
+	if nil != tag.Content {
+		return tag.Content.ContentRating
+	}
+	return ""
+}
+
+// MacroContentUserRating contains definition for ContentUserRating Parameter
+func (tag *BidderMacro) MacroContentUserRating(key string) string {
+	if nil != tag.Content {
+		return tag.Content.UserRating
+	}
+	return ""
+}
+
+// MacroContentQAGMediaRating contains definition for ContentQAGMediaRating Parameter
+func (tag *BidderMacro) MacroContentQAGMediaRating(key string) string {
+	if nil != tag.Content && tag.Content.QAGMediaRating > 0 {
+		return strconv.FormatInt(int64(tag.Content.QAGMediaRating), intBase)
+	}
+	return ""
+}
+
+// MacroContentKeywords contains definition for ContentKeywords Parameter
+func (tag *BidderMacro) MacroContentKeywords(key string) string {
+	if nil != tag.Content {
+		return tag.Content.Keywords
+	}
+	return ""
+}
+
+// MacroContentLiveStream contains definition for ContentLiveStream Parameter
+func (tag *BidderMacro) MacroContentLiveStream(key string) string {
+	if nil != tag.Content {
+		return strconv.FormatInt(int64(tag.Content.LiveStream), intBase)
+	}
+	return ""
+}
+
+// MacroContentSourceRelationship contains definition for ContentSourceRelationship Parameter
+func (tag *BidderMacro) MacroContentSourceRelationship(key string) string {
+	if nil != tag.Content {
+		return strconv.FormatInt(int64(tag.Content.SourceRelationship), intBase)
+	}
+	return ""
+}
+
+// MacroContentLength contains definition for ContentLength Parameter
+func (tag *BidderMacro) MacroContentLength(key string) string {
+	if nil != tag.Content {
+		return strconv.FormatInt(int64(tag.Content.Len), intBase)
+	}
+	return ""
+}
+
+// MacroContentLanguage contains definition for ContentLanguage Parameter
+func (tag *BidderMacro) MacroContentLanguage(key string) string {
+	if nil != tag.Content {
+		return tag.Content.Language
+	}
+	return ""
+}
+
+// MacroContentEmbeddable contains definition for ContentEmbeddable Parameter
+func (tag *BidderMacro) MacroContentEmbeddable(key string) string {
+	if nil != tag.Content {
+		return strconv.FormatInt(int64(tag.Content.Embeddable), intBase)
+	}
+	return ""
+}
+
+/********************* Producer *********************/
+
+// MacroProducerID contains definition for ProducerID Parameter
+func (tag *BidderMacro) MacroProducerID(key string) string {
+	if nil != tag.Content && nil != tag.Content.Producer {
+		return tag.Content.Producer.ID
+	}
+	return ""
+}
+
+// MacroProducerName contains definition for ProducerName Parameter
+func (tag *BidderMacro) MacroProducerName(key string) string {
+	if nil != tag.Content && nil != tag.Content.Producer {
+		return tag.Content.Producer.Name
+	}
+	return ""
+}
+
+/********************* Device *********************/
+
+// MacroUserAgent contains definition for UserAgent Parameter
+func (tag *BidderMacro) MacroUserAgent(key string) string {
+	if nil != tag.Request && nil != tag.Request.Device {
+		return tag.Request.Device.UA
+	}
+	return ""
+}
+
+// MacroDNT contains definition for DNT Parameter
+func (tag *BidderMacro) MacroDNT(key string) string {
+	if nil != tag.Request.Device && nil != tag.Request.Device.DNT {
+		return strconv.FormatInt(int64(*tag.Request.Device.DNT), intBase)
+	}
+	return ""
+}
+
+// MacroLMT contains definition for LMT Parameter
+func (tag *BidderMacro) MacroLMT(key string) string {
+	if nil != tag.Request.Device && nil != tag.Request.Device.Lmt {
+		return strconv.FormatInt(int64(*tag.Request.Device.Lmt), intBase)
+	}
+	return ""
+}
+
+// MacroIP contains definition for IP Parameter
+func (tag *BidderMacro) MacroIP(key string) string {
+	if nil != tag.Request && nil != tag.Request.Device {
+		if len(tag.Request.Device.IP) > 0 {
+			return tag.Request.Device.IP
+		} else if len(tag.Request.Device.IPv6) > 0 {
+			return tag.Request.Device.IPv6
+		}
+	}
+	return ""
+}
+
+// MacroDeviceType contains definition for DeviceType Parameter
+func (tag *BidderMacro) MacroDeviceType(key string) string {
+	if nil != tag.Request.Device && tag.Request.Device.DeviceType > 0 {
+		return strconv.FormatInt(int64(tag.Request.Device.DeviceType), intBase)
+	}
+	return ""
+}
+
+// MacroMake contains definition for Make Parameter
+func (tag *BidderMacro) MacroMake(key string) string {
+	if nil != tag.Request.Device {
+		return tag.Request.Device.Make
+	}
+	return ""
+}
+
+// MacroModel contains definition for Model Parameter
+func (tag *BidderMacro) MacroModel(key string) string {
+	if nil != tag.Request.Device {
+		return tag.Request.Device.Model
+	}
+	return ""
+}
+
+// MacroDeviceOS contains definition for DeviceOS Parameter
+func (tag *BidderMacro) MacroDeviceOS(key string) string {
+	if nil != tag.Request.Device {
+		return tag.Request.Device.OS
+	}
+	return ""
+}
+
+// MacroDeviceOSVersion contains definition for DeviceOSVersion Parameter
+func (tag *BidderMacro) MacroDeviceOSVersion(key string) string {
+	if nil != tag.Request.Device {
+		return tag.Request.Device.OSV
+	}
+	return ""
+}
+
+// MacroDeviceWidth contains definition for DeviceWidth Parameter
+func (tag *BidderMacro) MacroDeviceWidth(key string) string {
+	if nil != tag.Request.Device {
+		return strconv.FormatInt(int64(tag.Request.Device.W), intBase)
+	}
+	return ""
+}
+
+// MacroDeviceHeight contains definition for DeviceHeight Parameter
+func (tag *BidderMacro) MacroDeviceHeight(key string) string {
+	if nil != tag.Request.Device {
+		return strconv.FormatInt(int64(tag.Request.Device.H), intBase)
+	}
+	return ""
+}
+
+// MacroDeviceJS contains definition for DeviceJS Parameter
+func (tag *BidderMacro) MacroDeviceJS(key string) string {
+	if nil != tag.Request.Device {
+		return strconv.FormatInt(int64(tag.Request.Device.JS), intBase)
+	}
+	return ""
+}
+
+// MacroDeviceLanguage contains definition for DeviceLanguage Parameter
+func (tag *BidderMacro) MacroDeviceLanguage(key string) string {
+	if nil != tag.Request && nil != tag.Request.Device {
+		return tag.Request.Device.Language
+	}
+	return ""
+}
+
+// MacroDeviceIFA contains definition for DeviceIFA Parameter
+func (tag *BidderMacro) MacroDeviceIFA(key string) string {
+	if nil != tag.Request.Device {
+		return tag.Request.Device.IFA
+	}
+	return ""
+}
+
+// MacroDeviceIFAType contains definition for DeviceIFAType
+func (tag *BidderMacro) MacroDeviceIFAType(key string) string {
+	if nil != tag.DeviceExt {
+		return tag.DeviceExt.IFAType
+	}
+	return ""
+}
+
+// MacroDeviceDIDSHA1 contains definition for DeviceDIDSHA1 Parameter
+func (tag *BidderMacro) MacroDeviceDIDSHA1(key string) string {
+	if nil != tag.Request.Device {
+		return tag.Request.Device.DIDSHA1
+	}
+	return ""
+}
+
+// MacroDeviceDIDMD5 contains definition for DeviceDIDMD5 Parameter
+func (tag *BidderMacro) MacroDeviceDIDMD5(key string) string {
+	if nil != tag.Request.Device {
+		return tag.Request.Device.DIDMD5
+	}
+	return ""
+}
+
+// MacroDeviceDPIDSHA1 contains definition for DeviceDPIDSHA1 Parameter
+func (tag *BidderMacro) MacroDeviceDPIDSHA1(key string) string {
+	if nil != tag.Request.Device {
+		return tag.Request.Device.DPIDSHA1
+	}
+	return ""
+}
+
+// MacroDeviceDPIDMD5 contains definition for DeviceDPIDMD5 Parameter
+func (tag *BidderMacro) MacroDeviceDPIDMD5(key string) string {
+	if nil != tag.Request.Device {
+		return tag.Request.Device.DPIDMD5
+	}
+	return ""
+}
+
+// MacroDeviceMACSHA1 contains definition for DeviceMACSHA1 Parameter
+func (tag *BidderMacro) MacroDeviceMACSHA1(key string) string {
+	if nil != tag.Request.Device {
+		return tag.Request.Device.MACSHA1
+	}
+	return ""
+}
+
+// MacroDeviceMACMD5 contains definition for DeviceMACMD5 Parameter
+func (tag *BidderMacro) MacroDeviceMACMD5(key string) string {
+	if nil != tag.Request.Device {
+		return tag.Request.Device.MACMD5
+	}
+	return ""
+}
+
+/********************* Geo *********************/
+
+// MacroLatitude contains definition for Latitude Parameter
+func (tag *BidderMacro) MacroLatitude(key string) string {
+	if tag.HasGeo {
+		return fmt.Sprintf("%g", tag.Request.Device.Geo.Lat)
+	}
+	return ""
+}
+
+// MacroLongitude contains definition for Longitude Parameter
+func (tag *BidderMacro) MacroLongitude(key string) string {
+	if tag.HasGeo {
+		return fmt.Sprintf("%g", tag.Request.Device.Geo.Lon)
+	}
+	return ""
+}
+
+// MacroCountry contains definition for Country Parameter
+func (tag *BidderMacro) MacroCountry(key string) string {
+	if tag.HasGeo {
+		return tag.Request.Device.Geo.Country
+	}
+	return ""
+}
+
+// MacroRegion contains definition for Region Parameter
+func (tag *BidderMacro) MacroRegion(key string) string {
+	if tag.HasGeo {
+		return tag.Request.Device.Geo.Region
+	}
+	return ""
+}
+
+// MacroCity contains definition for City Parameter
+func (tag *BidderMacro) MacroCity(key string) string {
+	if tag.HasGeo {
+		return tag.Request.Device.Geo.City
+	}
+	return ""
+}
+
+// MacroZip contains definition for Zip Parameter
+func (tag *BidderMacro) MacroZip(key string) string {
+	if tag.HasGeo {
+		return tag.Request.Device.Geo.ZIP
+	}
+	return ""
+}
+
+// MacroUTCOffset contains definition for UTCOffset Parameter
+func (tag *BidderMacro) MacroUTCOffset(key string) string {
+	if tag.HasGeo {
+		return strconv.FormatInt(tag.Request.Device.Geo.UTCOffset, intBase)
+	}
+	return ""
+}
+
+/********************* User *********************/
+
+// MacroUserID contains definition for UserID Parameter
+func (tag *BidderMacro) MacroUserID(key string) string {
+	if nil != tag.Request.User {
+		return tag.Request.User.ID
+	}
+	return ""
+}
+
+// MacroYearOfBirth contains definition for YearOfBirth Parameter
+func (tag *BidderMacro) MacroYearOfBirth(key string) string {
+	if nil != tag.Request.User && tag.Request.User.Yob > 0 {
+		return strconv.FormatInt(tag.Request.User.Yob, intBase)
+	}
+	return ""
+}
+
+// MacroGender contains definition for Gender Parameter
+func (tag *BidderMacro) MacroGender(key string) string {
+	if nil != tag.Request.User {
+		return tag.Request.User.Gender
+	}
+	return ""
+}
+
+/********************* Extension *********************/
+
+// MacroGDPRConsent contains definition for GDPRConsent Parameter
+func (tag *BidderMacro) MacroGDPRConsent(key string) string {
+	if nil != tag.UserExt {
+		return tag.UserExt.Consent
+	}
+	return ""
+}
+
+// MacroGDPR contains definition for GDPR Parameter
+func (tag *BidderMacro) MacroGDPR(key string) string {
+	if nil != tag.RegsExt && nil != tag.RegsExt.GDPR {
+		return strconv.FormatInt(int64(*tag.RegsExt.GDPR), intBase)
+	}
+	return ""
+}
+
+// MacroUSPrivacy contains definition for USPrivacy Parameter
+func (tag *BidderMacro) MacroUSPrivacy(key string) string {
+	if nil != tag.RegsExt {
+		return tag.RegsExt.USPrivacy
+	}
+	return ""
+}
+
+/********************* Additional *********************/
+
+// MacroCacheBuster contains definition for CacheBuster Parameter
+func (tag *BidderMacro) MacroCacheBuster(key string) string {
+	//change implementation
+	return strconv.FormatInt(time.Now().UnixNano(), intBase)
+}
+
+/********************* Request Headers *********************/
+
+// setDefaultHeaders sets following default headers based on VAST protocol version
+//
+//	X-device-IP; end users IP address, per VAST 4.x
+//	X-Forwarded-For; end users IP address, prior VAST versions
+//	X-Device-User-Agent; End users user agent, per VAST 4.x
+//	User-Agent; End users user agent, prior VAST versions
+//	X-Device-Referer; Referer value from the original request, per VAST 4.x
+//	X-device-Accept-Language, Accept-language value from the original request, per VAST 4.x
+func setDefaultHeaders(tag *BidderMacro) {
+	// openrtb2. auction.go setDeviceImplicitly
+	// already populates OpenRTB bid request based on http request headers
+	// reusing the same information to set these headers via Macro* methods
+	headers := http.Header{}
+	ip := tag.IBidderMacro.MacroIP("")
+	userAgent := tag.IBidderMacro.MacroUserAgent("")
+	referer := tag.IBidderMacro.MacroSitePage("")
+	language := tag.IBidderMacro.MacroDeviceLanguage("")
+
+	// 1 - vast 1 - 3 expected, 2 - vast 4 expected
+	expectedVastTags := 0
+	if nil != tag.Imp && nil != tag.Imp.Video && nil != tag.Imp.Video.Protocols && len(tag.Imp.Video.Protocols) > 0 {
+		for _, protocol := range tag.Imp.Video.Protocols {
+			if protocol == adcom1.CreativeVAST40 || protocol == adcom1.CreativeVAST40Wrapper {
+				expectedVastTags |= 1 << 1
+			}
+			if protocol <= adcom1.CreativeVAST30Wrapper {
+				expectedVastTags |= 1 << 0
+			}
+		}
+	} else {
+		// not able to detect protocols. set all headers
+		expectedVastTags = 3
+	}
+
+	if expectedVastTags == 1 || expectedVastTags == 3 {
+		// vast prior to version 3 headers
+		setHeaders(headers, "X-Forwarded-For", ip)
+		setHeaders(headers, "User-Agent", userAgent)
+	}
+
+	if expectedVastTags == 2 || expectedVastTags == 3 {
+		// vast 4 specific headers
+		setHeaders(headers, "X-device-Ip", ip)
+		setHeaders(headers, "X-Device-User-Agent", userAgent)
+		setHeaders(headers, "X-Device-Referer", referer)
+		setHeaders(headers, "X-Device-Accept-Language", language)
+	}
+	tag.ImpReqHeaders = headers
+}
+
+func setHeaders(headers http.Header, key, value string) {
+	if len(value) > 0 {
+		headers.Set(key, value)
+	}
+}
+
+// getAllHeaders combines default and custom headers and returns common list
+// It internally calls GetHeaders() method for obtaining list of custom headers
+func (tag *BidderMacro) getAllHeaders() http.Header {
+	setDefaultHeaders(tag)
+	customHeaders := tag.IBidderMacro.GetHeaders()
+	if nil != customHeaders {
+		for k, v := range customHeaders {
+			// custom header may contains default header key with value
+			// in such case custom value will be prefered
+			if nil != v && len(v) > 0 {
+				tag.ImpReqHeaders.Set(k, v[0])
+				for i := 1; i < len(v); i++ {
+					tag.ImpReqHeaders.Add(k, v[i])
+				}
+			}
+		}
+	}
+	return tag.ImpReqHeaders
+}
diff --git a/adapters/vastbidder/bidder_macro_test.go b/adapters/vastbidder/bidder_macro_test.go
new file mode 100644
index 000000000..3e0a5f703
--- /dev/null
+++ b/adapters/vastbidder/bidder_macro_test.go
@@ -0,0 +1,1265 @@
+package vastbidder
+
+import (
+	"fmt"
+	"net/http"
+	"testing"
+
+	"github.com/prebid/openrtb/v19/adcom1"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/config"
+	"github.com/stretchr/testify/assert"
+)
+
+// TestSetDefaultHeaders verifies SetDefaultHeaders
+func TestSetDefaultHeaders(t *testing.T) {
+	type args struct {
+		req *openrtb2.BidRequest
+	}
+	type want struct {
+		headers http.Header
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "check all default headers",
+			args: args{req: &openrtb2.BidRequest{
+				Device: &openrtb2.Device{
+					IP:       "1.1.1.1",
+					UA:       "user-agent",
+					Language: "en",
+				},
+				Site: &openrtb2.Site{
+					Page: "http://test.com/",
+				},
+			}},
+			want: want{
+				headers: http.Header{
+					"X-Device-Ip":              []string{"1.1.1.1"},
+					"X-Forwarded-For":          []string{"1.1.1.1"},
+					"X-Device-User-Agent":      []string{"user-agent"},
+					"User-Agent":               []string{"user-agent"},
+					"X-Device-Referer":         []string{"http://test.com/"},
+					"X-Device-Accept-Language": []string{"en"},
+				},
+			},
+		},
+		{
+			name: "nil bid request",
+			args: args{req: nil},
+			want: want{
+				headers: http.Header{},
+			},
+		},
+		{
+			name: "no headers set",
+			args: args{req: &openrtb2.BidRequest{}},
+			want: want{
+				headers: http.Header{},
+			},
+		}, {
+			name: "vast 4 protocol",
+			args: args{
+				req: &openrtb2.BidRequest{
+					Device: &openrtb2.Device{
+						IP:       "1.1.1.1",
+						UA:       "user-agent",
+						Language: "en",
+					},
+					Site: &openrtb2.Site{
+						Page: "http://test.com/",
+					},
+					Imp: []openrtb2.Imp{
+						{
+							Video: &openrtb2.Video{
+								Protocols: []adcom1.MediaCreativeSubtype{
+									adcom1.CreativeVAST40,
+									adcom1.CreativeDAAST10,
+								},
+							},
+						},
+					},
+				},
+			},
+			want: want{
+				headers: http.Header{
+					"X-Device-Ip":              []string{"1.1.1.1"},
+					"X-Device-User-Agent":      []string{"user-agent"},
+					"X-Device-Referer":         []string{"http://test.com/"},
+					"X-Device-Accept-Language": []string{"en"},
+				},
+			},
+		}, {
+			name: "< vast 4",
+			args: args{
+				req: &openrtb2.BidRequest{
+					Device: &openrtb2.Device{
+						IP:       "1.1.1.1",
+						UA:       "user-agent",
+						Language: "en",
+					},
+					Site: &openrtb2.Site{
+						Page: "http://test.com/",
+					},
+					Imp: []openrtb2.Imp{
+						{
+							Video: &openrtb2.Video{
+								Protocols: []adcom1.MediaCreativeSubtype{
+									adcom1.CreativeVAST20,
+									adcom1.CreativeDAAST10,
+								},
+							},
+						},
+					},
+				},
+			},
+			want: want{
+				headers: http.Header{
+					"X-Forwarded-For": []string{"1.1.1.1"},
+					"User-Agent":      []string{"user-agent"},
+				},
+			},
+		}, {
+			name: "vast 4.0 and 4.0 wrapper",
+			args: args{
+				req: &openrtb2.BidRequest{
+					Device: &openrtb2.Device{
+						IP:       "1.1.1.1",
+						UA:       "user-agent",
+						Language: "en",
+					},
+					Site: &openrtb2.Site{
+						Page: "http://test.com/",
+					},
+					Imp: []openrtb2.Imp{
+						{
+							Video: &openrtb2.Video{
+								Protocols: []adcom1.MediaCreativeSubtype{
+									adcom1.CreativeVAST40,
+									adcom1.CreativeVAST40Wrapper,
+								},
+							},
+						},
+					},
+				},
+			},
+			want: want{
+				headers: http.Header{
+					"X-Device-Ip":              []string{"1.1.1.1"},
+					"X-Device-User-Agent":      []string{"user-agent"},
+					"X-Device-Referer":         []string{"http://test.com/"},
+					"X-Device-Accept-Language": []string{"en"},
+				},
+			},
+		},
+		{
+			name: "vast 2.0 and 4.0",
+			args: args{
+				req: &openrtb2.BidRequest{
+					Device: &openrtb2.Device{
+						IP:       "1.1.1.1",
+						UA:       "user-agent",
+						Language: "en",
+					},
+					Site: &openrtb2.Site{
+						Page: "http://test.com/",
+					},
+					Imp: []openrtb2.Imp{
+						{
+							Video: &openrtb2.Video{
+								Protocols: []adcom1.MediaCreativeSubtype{
+									adcom1.CreativeVAST40,
+									adcom1.CreativeVAST20Wrapper,
+								},
+							},
+						},
+					},
+				},
+			},
+			want: want{
+				headers: http.Header{
+					"X-Device-Ip":              []string{"1.1.1.1"},
+					"X-Forwarded-For":          []string{"1.1.1.1"},
+					"X-Device-User-Agent":      []string{"user-agent"},
+					"User-Agent":               []string{"user-agent"},
+					"X-Device-Referer":         []string{"http://test.com/"},
+					"X-Device-Accept-Language": []string{"en"},
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			tag := new(BidderMacro)
+			tag.IBidderMacro = tag
+			tag.IsApp = false
+			tag.Request = tt.args.req
+			if nil != tt.args.req && nil != tt.args.req.Imp && len(tt.args.req.Imp) > 0 {
+				tag.Imp = &tt.args.req.Imp[0]
+			}
+			setDefaultHeaders(tag)
+			assert.Equal(t, tt.want.headers, tag.ImpReqHeaders)
+		})
+	}
+}
+
+// TestGetAllHeaders verifies default and custom headers are returned
+func TestGetAllHeaders(t *testing.T) {
+	type args struct {
+		req      *openrtb2.BidRequest
+		myBidder IBidderMacro
+	}
+	type want struct {
+		headers http.Header
+	}
+
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "Default and custom headers check",
+			args: args{
+				req: &openrtb2.BidRequest{
+					Device: &openrtb2.Device{
+						IP:       "1.1.1.1",
+						UA:       "user-agent",
+						Language: "en",
+					},
+					Site: &openrtb2.Site{
+						Page: "http://test.com/",
+					},
+				},
+				myBidder: newMyVastBidderMacro(map[string]string{
+					"my-custom-header": "some-value",
+				}),
+			},
+			want: want{
+				headers: http.Header{
+					"X-Device-Ip":              []string{"1.1.1.1"},
+					"X-Forwarded-For":          []string{"1.1.1.1"},
+					"X-Device-User-Agent":      []string{"user-agent"},
+					"User-Agent":               []string{"user-agent"},
+					"X-Device-Referer":         []string{"http://test.com/"},
+					"X-Device-Accept-Language": []string{"en"},
+					"My-Custom-Header":         []string{"some-value"},
+				},
+			},
+		},
+		{
+			name: "override default header value",
+			args: args{
+				req: &openrtb2.BidRequest{
+					Site: &openrtb2.Site{
+						Page: "http://test.com/", // default header value
+					},
+				},
+				myBidder: newMyVastBidderMacro(map[string]string{
+					"X-Device-Referer": "my-custom-value",
+				}),
+			},
+			want: want{
+				headers: http.Header{
+					// http://test.com/ is not expected here as value
+					"X-Device-Referer": []string{"my-custom-value"},
+				},
+			},
+		},
+		{
+			name: "no custom headers",
+			args: args{
+				req: &openrtb2.BidRequest{
+					Device: &openrtb2.Device{
+						IP:       "1.1.1.1",
+						UA:       "user-agent",
+						Language: "en",
+					},
+					Site: &openrtb2.Site{
+						Page: "http://test.com/",
+					},
+				},
+				myBidder: newMyVastBidderMacro(nil), // nil - no custom headers
+			},
+			want: want{
+				headers: http.Header{ // expect default headers
+					"X-Device-Ip":              []string{"1.1.1.1"},
+					"X-Forwarded-For":          []string{"1.1.1.1"},
+					"X-Device-User-Agent":      []string{"user-agent"},
+					"User-Agent":               []string{"user-agent"},
+					"X-Device-Referer":         []string{"http://test.com/"},
+					"X-Device-Accept-Language": []string{"en"},
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			tag := tt.args.myBidder
+			tag.(*myVastBidderMacro).Request = tt.args.req
+			allHeaders := tag.getAllHeaders()
+			assert.Equal(t, tt.want.headers, allHeaders)
+		})
+	}
+}
+
+type myVastBidderMacro struct {
+	*BidderMacro
+	customHeaders map[string]string
+}
+
+func newMyVastBidderMacro(customHeaders map[string]string) IBidderMacro {
+	obj := &myVastBidderMacro{
+		BidderMacro:   &BidderMacro{},
+		customHeaders: customHeaders,
+	}
+	obj.IBidderMacro = obj
+	return obj
+}
+
+func (tag *myVastBidderMacro) GetHeaders() http.Header {
+	if nil == tag.customHeaders {
+		return nil
+	}
+	h := http.Header{}
+	for k, v := range tag.customHeaders {
+		h.Set(k, v)
+	}
+	return h
+}
+
+type testBidderMacro struct {
+	*BidderMacro
+}
+
+func (tag *testBidderMacro) MacroCacheBuster(key string) string {
+	return `cachebuster`
+}
+
+func newTestBidderMacro() IBidderMacro {
+	obj := &testBidderMacro{
+		BidderMacro: &BidderMacro{},
+	}
+	obj.IBidderMacro = obj
+	return obj
+}
+
+func TestBidderMacro_MacroTest(t *testing.T) {
+	type args struct {
+		tag        IBidderMacro
+		conf       *config.Adapter
+		bidRequest *openrtb2.BidRequest
+	}
+	tests := []struct {
+		name   string
+		args   args
+		macros map[string]string
+	}{
+		{
+			name: `App:EmptyBasicRequest`,
+			args: args{
+				tag:  newTestBidderMacro(),
+				conf: &config.Adapter{},
+				bidRequest: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{
+							Video: &openrtb2.Video{},
+						},
+					},
+					App: &openrtb2.App{
+						Publisher: &openrtb2.Publisher{},
+					},
+				},
+			},
+			macros: map[string]string{
+				MacroTest:                      ``,
+				MacroTimeout:                   ``,
+				MacroWhitelistSeat:             ``,
+				MacroWhitelistLang:             ``,
+				MacroBlockedSeat:               ``,
+				MacroCurrency:                  ``,
+				MacroBlockedCategory:           ``,
+				MacroBlockedAdvertiser:         ``,
+				MacroBlockedApp:                ``,
+				MacroFD:                        ``,
+				MacroTransactionID:             ``,
+				MacroPaymentIDChain:            ``,
+				MacroCoppa:                     ``,
+				MacroDisplayManager:            ``,
+				MacroDisplayManagerVersion:     ``,
+				MacroInterstitial:              ``,
+				MacroTagID:                     ``,
+				MacroBidFloor:                  ``,
+				MacroBidFloorCurrency:          ``,
+				MacroSecure:                    ``,
+				MacroPMP:                       ``,
+				MacroVideoMIMES:                ``,
+				MacroVideoMinimumDuration:      ``,
+				MacroVideoMaximumDuration:      ``,
+				MacroVideoProtocols:            ``,
+				MacroVideoPlayerWidth:          ``,
+				MacroVideoPlayerHeight:         ``,
+				MacroVideoStartDelay:           ``,
+				MacroVideoPlacement:            ``,
+				MacroVideoLinearity:            ``,
+				MacroVideoSkip:                 ``,
+				MacroVideoSkipMinimum:          ``,
+				MacroVideoSkipAfter:            ``,
+				MacroVideoSequence:             ``,
+				MacroVideoBlockedAttribute:     ``,
+				MacroVideoMaximumExtended:      ``,
+				MacroVideoMinimumBitRate:       ``,
+				MacroVideoMaximumBitRate:       ``,
+				MacroVideoBoxing:               ``,
+				MacroVideoPlaybackMethod:       ``,
+				MacroVideoDelivery:             ``,
+				MacroVideoPosition:             ``,
+				MacroVideoAPI:                  ``,
+				MacroSiteID:                    ``,
+				MacroSiteName:                  ``,
+				MacroSitePage:                  ``,
+				MacroSiteReferrer:              ``,
+				MacroSiteSearch:                ``,
+				MacroSiteMobile:                ``,
+				MacroAppID:                     ``,
+				MacroAppName:                   ``,
+				MacroAppBundle:                 ``,
+				MacroAppStoreURL:               ``,
+				MacroAppVersion:                ``,
+				MacroAppPaid:                   ``,
+				MacroCategory:                  ``,
+				MacroDomain:                    ``,
+				MacroSectionCategory:           ``,
+				MacroPageCategory:              ``,
+				MacroPrivacyPolicy:             ``,
+				MacroKeywords:                  ``,
+				MacroPubID:                     ``,
+				MacroPubName:                   ``,
+				MacroPubDomain:                 ``,
+				MacroContentID:                 ``,
+				MacroContentEpisode:            ``,
+				MacroContentTitle:              ``,
+				MacroContentSeries:             ``,
+				MacroContentSeason:             ``,
+				MacroContentArtist:             ``,
+				MacroContentGenre:              ``,
+				MacroContentAlbum:              ``,
+				MacroContentISrc:               ``,
+				MacroContentURL:                ``,
+				MacroContentCategory:           ``,
+				MacroContentProductionQuality:  ``,
+				MacroContentVideoQuality:       ``,
+				MacroContentContext:            ``,
+				MacroContentContentRating:      ``,
+				MacroContentUserRating:         ``,
+				MacroContentQAGMediaRating:     ``,
+				MacroContentKeywords:           ``,
+				MacroContentLiveStream:         ``,
+				MacroContentSourceRelationship: ``,
+				MacroContentLength:             ``,
+				MacroContentLanguage:           ``,
+				MacroContentEmbeddable:         ``,
+				MacroProducerID:                ``,
+				MacroProducerName:              ``,
+				MacroUserAgent:                 ``,
+				MacroDNT:                       ``,
+				MacroLMT:                       ``,
+				MacroIP:                        ``,
+				MacroDeviceType:                ``,
+				MacroMake:                      ``,
+				MacroModel:                     ``,
+				MacroDeviceOS:                  ``,
+				MacroDeviceOSVersion:           ``,
+				MacroDeviceWidth:               ``,
+				MacroDeviceHeight:              ``,
+				MacroDeviceJS:                  ``,
+				MacroDeviceLanguage:            ``,
+				MacroDeviceIFA:                 ``,
+				MacroDeviceIFAType:             ``,
+				MacroDeviceDIDSHA1:             ``,
+				MacroDeviceDIDMD5:              ``,
+				MacroDeviceDPIDSHA1:            ``,
+				MacroDeviceDPIDMD5:             ``,
+				MacroDeviceMACSHA1:             ``,
+				MacroDeviceMACMD5:              ``,
+				MacroLatitude:                  ``,
+				MacroLongitude:                 ``,
+				MacroCountry:                   ``,
+				MacroRegion:                    ``,
+				MacroCity:                      ``,
+				MacroZip:                       ``,
+				MacroUTCOffset:                 ``,
+				MacroUserID:                    ``,
+				MacroYearOfBirth:               ``,
+				MacroGender:                    ``,
+				MacroGDPRConsent:               ``,
+				MacroGDPR:                      ``,
+				MacroUSPrivacy:                 ``,
+				MacroCacheBuster:               `cachebuster`,
+			},
+		},
+		{
+			name: `Site:EmptyBasicRequest`,
+			args: args{
+				tag:  newTestBidderMacro(),
+				conf: &config.Adapter{},
+				bidRequest: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{
+							Video: &openrtb2.Video{},
+						},
+					},
+					Site: &openrtb2.Site{
+						Publisher: &openrtb2.Publisher{},
+					},
+				},
+			},
+			macros: map[string]string{
+				MacroTest:                      ``,
+				MacroTimeout:                   ``,
+				MacroWhitelistSeat:             ``,
+				MacroWhitelistLang:             ``,
+				MacroBlockedSeat:               ``,
+				MacroCurrency:                  ``,
+				MacroBlockedCategory:           ``,
+				MacroBlockedAdvertiser:         ``,
+				MacroBlockedApp:                ``,
+				MacroFD:                        ``,
+				MacroTransactionID:             ``,
+				MacroPaymentIDChain:            ``,
+				MacroCoppa:                     ``,
+				MacroDisplayManager:            ``,
+				MacroDisplayManagerVersion:     ``,
+				MacroInterstitial:              ``,
+				MacroTagID:                     ``,
+				MacroBidFloor:                  ``,
+				MacroBidFloorCurrency:          ``,
+				MacroSecure:                    ``,
+				MacroPMP:                       ``,
+				MacroVideoMIMES:                ``,
+				MacroVideoMinimumDuration:      ``,
+				MacroVideoMaximumDuration:      ``,
+				MacroVideoProtocols:            ``,
+				MacroVideoPlayerWidth:          ``,
+				MacroVideoPlayerHeight:         ``,
+				MacroVideoStartDelay:           ``,
+				MacroVideoPlacement:            ``,
+				MacroVideoLinearity:            ``,
+				MacroVideoSkip:                 ``,
+				MacroVideoSkipMinimum:          ``,
+				MacroVideoSkipAfter:            ``,
+				MacroVideoSequence:             ``,
+				MacroVideoBlockedAttribute:     ``,
+				MacroVideoMaximumExtended:      ``,
+				MacroVideoMinimumBitRate:       ``,
+				MacroVideoMaximumBitRate:       ``,
+				MacroVideoBoxing:               ``,
+				MacroVideoPlaybackMethod:       ``,
+				MacroVideoDelivery:             ``,
+				MacroVideoPosition:             ``,
+				MacroVideoAPI:                  ``,
+				MacroSiteID:                    ``,
+				MacroSiteName:                  ``,
+				MacroSitePage:                  ``,
+				MacroSiteReferrer:              ``,
+				MacroSiteSearch:                ``,
+				MacroSiteMobile:                ``,
+				MacroAppID:                     ``,
+				MacroAppName:                   ``,
+				MacroAppBundle:                 ``,
+				MacroAppStoreURL:               ``,
+				MacroAppVersion:                ``,
+				MacroAppPaid:                   ``,
+				MacroCategory:                  ``,
+				MacroDomain:                    ``,
+				MacroSectionCategory:           ``,
+				MacroPageCategory:              ``,
+				MacroPrivacyPolicy:             ``,
+				MacroKeywords:                  ``,
+				MacroPubID:                     ``,
+				MacroPubName:                   ``,
+				MacroPubDomain:                 ``,
+				MacroContentID:                 ``,
+				MacroContentEpisode:            ``,
+				MacroContentTitle:              ``,
+				MacroContentSeries:             ``,
+				MacroContentSeason:             ``,
+				MacroContentArtist:             ``,
+				MacroContentGenre:              ``,
+				MacroContentAlbum:              ``,
+				MacroContentISrc:               ``,
+				MacroContentURL:                ``,
+				MacroContentCategory:           ``,
+				MacroContentProductionQuality:  ``,
+				MacroContentVideoQuality:       ``,
+				MacroContentContext:            ``,
+				MacroContentContentRating:      ``,
+				MacroContentUserRating:         ``,
+				MacroContentQAGMediaRating:     ``,
+				MacroContentKeywords:           ``,
+				MacroContentLiveStream:         ``,
+				MacroContentSourceRelationship: ``,
+				MacroContentLength:             ``,
+				MacroContentLanguage:           ``,
+				MacroContentEmbeddable:         ``,
+				MacroProducerID:                ``,
+				MacroProducerName:              ``,
+				MacroUserAgent:                 ``,
+				MacroDNT:                       ``,
+				MacroLMT:                       ``,
+				MacroIP:                        ``,
+				MacroDeviceType:                ``,
+				MacroMake:                      ``,
+				MacroModel:                     ``,
+				MacroDeviceOS:                  ``,
+				MacroDeviceOSVersion:           ``,
+				MacroDeviceWidth:               ``,
+				MacroDeviceHeight:              ``,
+				MacroDeviceJS:                  ``,
+				MacroDeviceLanguage:            ``,
+				MacroDeviceIFA:                 ``,
+				MacroDeviceIFAType:             ``,
+				MacroDeviceDIDSHA1:             ``,
+				MacroDeviceDIDMD5:              ``,
+				MacroDeviceDPIDSHA1:            ``,
+				MacroDeviceDPIDMD5:             ``,
+				MacroDeviceMACSHA1:             ``,
+				MacroDeviceMACMD5:              ``,
+				MacroLatitude:                  ``,
+				MacroLongitude:                 ``,
+				MacroCountry:                   ``,
+				MacroRegion:                    ``,
+				MacroCity:                      ``,
+				MacroZip:                       ``,
+				MacroUTCOffset:                 ``,
+				MacroUserID:                    ``,
+				MacroYearOfBirth:               ``,
+				MacroGender:                    ``,
+				MacroGDPRConsent:               ``,
+				MacroGDPR:                      ``,
+				MacroUSPrivacy:                 ``,
+				MacroCacheBuster:               `cachebuster`,
+			},
+		},
+		{
+			name: `Site:RequestLevelMacros`,
+			args: args{
+				tag:  newTestBidderMacro(),
+				conf: &config.Adapter{},
+				bidRequest: &openrtb2.BidRequest{
+					Test:  1,
+					TMax:  1000,
+					WSeat: []string{`wseat-1`, `wseat-2`},
+					WLang: []string{`wlang-1`, `wlang-2`},
+					BSeat: []string{`bseat-1`, `bseat-2`},
+					Cur:   []string{`usd`, `inr`},
+					BCat:  []string{`bcat-1`, `bcat-2`},
+					BAdv:  []string{`badv-1`, `badv-2`},
+					BApp:  []string{`bapp-1`, `bapp-2`},
+					Source: &openrtb2.Source{
+						FD:     1,
+						TID:    `source-tid`,
+						PChain: `source-pchain`,
+					},
+					Regs: &openrtb2.Regs{
+						COPPA: 1,
+						Ext:   []byte(`{"gdpr":1,"us_privacy":"user-privacy"}`),
+					},
+					Imp: []openrtb2.Imp{
+						{
+							DisplayManager:    `disp-mgr`,
+							DisplayManagerVer: `1.2`,
+							Instl:             1,
+							TagID:             `tag-id`,
+							BidFloor:          3.0,
+							BidFloorCur:       `usd`,
+							Secure:            new(int8),
+							PMP: &openrtb2.PMP{
+								PrivateAuction: 1,
+								Deals: []openrtb2.Deal{
+									{
+										ID:          `deal-1`,
+										BidFloor:    4.0,
+										BidFloorCur: `usd`,
+										AT:          1,
+										WSeat:       []string{`wseat-11`, `wseat-12`},
+										WADomain:    []string{`wdomain-11`, `wdomain-12`},
+									},
+									{
+										ID:          `deal-2`,
+										BidFloor:    5.0,
+										BidFloorCur: `inr`,
+										AT:          1,
+										WSeat:       []string{`wseat-21`, `wseat-22`},
+										WADomain:    []string{`wdomain-21`, `wdomain-22`},
+									},
+								},
+							},
+							Video: &openrtb2.Video{
+								MIMEs:          []string{`mp4`, `flv`},
+								MinDuration:    30,
+								MaxDuration:    60,
+								Protocols:      []adcom1.MediaCreativeSubtype{adcom1.CreativeVAST30, adcom1.CreativeVAST40Wrapper},
+								Protocol:       adcom1.CreativeVAST40Wrapper,
+								W:              640,
+								H:              480,
+								StartDelay:     new(adcom1.StartDelay),
+								Placement:      adcom1.VideoPlacementInStream,
+								Linearity:      adcom1.LinearityLinear,
+								Skip:           new(int8),
+								SkipMin:        10,
+								SkipAfter:      5,
+								Sequence:       1,
+								BAttr:          []adcom1.CreativeAttribute{adcom1.AttrAudioAuto, adcom1.AttrAudioUser},
+								MaxExtended:    10,
+								MinBitRate:     360,
+								MaxBitRate:     1080,
+								BoxingAllowed:  1,
+								PlaybackMethod: []adcom1.PlaybackMethod{adcom1.PlaybackPageLoadSoundOn, adcom1.PlaybackClickSoundOn},
+								PlaybackEnd:    adcom1.PlaybackCompletion,
+								Delivery:       []adcom1.DeliveryMethod{adcom1.DeliveryStreaming, adcom1.DeliveryDownload},
+								Pos:            new(adcom1.PlacementPosition),
+								API:            []adcom1.APIFramework{adcom1.APIVPAID10, adcom1.APIVPAID20},
+							},
+						},
+					},
+					Site: &openrtb2.Site{
+						ID:            `site-id`,
+						Name:          `site-name`,
+						Domain:        `site-domain`,
+						Cat:           []string{`site-cat1`, `site-cat2`},
+						SectionCat:    []string{`site-sec-cat1`, `site-sec-cat2`},
+						PageCat:       []string{`site-page-cat1`, `site-page-cat2`},
+						Page:          `site-page-url`,
+						Ref:           `site-referer-url`,
+						Search:        `site-search-keywords`,
+						Mobile:        1,
+						PrivacyPolicy: 2,
+						Keywords:      `site-keywords`,
+						Publisher: &openrtb2.Publisher{
+							ID:     `site-pub-id`,
+							Name:   `site-pub-name`,
+							Domain: `site-pub-domain`,
+						},
+						Content: &openrtb2.Content{
+							ID:                 `site-cnt-id`,
+							Episode:            2,
+							Title:              `site-cnt-title`,
+							Series:             `site-cnt-series`,
+							Season:             `site-cnt-season`,
+							Artist:             `site-cnt-artist`,
+							Genre:              `site-cnt-genre`,
+							Album:              `site-cnt-album`,
+							ISRC:               `site-cnt-isrc`,
+							URL:                `site-cnt-url`,
+							Cat:                []string{`site-cnt-cat1`, `site-cnt-cat2`},
+							ProdQ:              new(adcom1.ProductionQuality),
+							VideoQuality:       new(adcom1.ProductionQuality),
+							Context:            adcom1.ContentVideo,
+							ContentRating:      `1.2`,
+							UserRating:         `2.2`,
+							QAGMediaRating:     adcom1.MediaRatingAll,
+							Keywords:           `site-cnt-keywords`,
+							LiveStream:         1,
+							SourceRelationship: 1,
+							Len:                100,
+							Language:           `english`,
+							Embeddable:         1,
+							Producer: &openrtb2.Producer{
+								ID:   `site-cnt-prod-id`,
+								Name: `site-cnt-prod-name`,
+							},
+						},
+					},
+					Device: &openrtb2.Device{
+						UA:             `user-agent`,
+						DNT:            new(int8),
+						Lmt:            new(int8),
+						IP:             `ipv4`,
+						IPv6:           `ipv6`,
+						DeviceType:     adcom1.DeviceTV,
+						Make:           `device-make`,
+						Model:          `device-model`,
+						OS:             `os`,
+						OSV:            `os-version`,
+						H:              1024,
+						W:              2048,
+						JS:             1,
+						Language:       `device-lang`,
+						ConnectionType: new(adcom1.ConnectionType),
+						IFA:            `ifa`,
+						DIDSHA1:        `didsha1`,
+						DIDMD5:         `didmd5`,
+						DPIDSHA1:       `dpidsha1`,
+						DPIDMD5:        `dpidmd5`,
+						MACSHA1:        `macsha1`,
+						MACMD5:         `macmd5`,
+						Geo: &openrtb2.Geo{
+							Lat:       1.1,
+							Lon:       2.2,
+							Country:   `country`,
+							Region:    `region`,
+							City:      `city`,
+							ZIP:       `zip`,
+							UTCOffset: 1000,
+						},
+						Ext: []byte(`{"ifa_type":"idfa"}`),
+					},
+					User: &openrtb2.User{
+						ID:     `user-id`,
+						Yob:    1990,
+						Gender: `M`,
+						Ext:    []byte(`{"consent":"user-gdpr-consent"}`),
+					},
+				},
+			},
+			macros: map[string]string{
+				MacroTest:                      `1`,
+				MacroTimeout:                   `1000`,
+				MacroWhitelistSeat:             `wseat-1,wseat-2`,
+				MacroWhitelistLang:             `wlang-1,wlang-2`,
+				MacroBlockedSeat:               `bseat-1,bseat-2`,
+				MacroCurrency:                  `usd,inr`,
+				MacroBlockedCategory:           `bcat-1,bcat-2`,
+				MacroBlockedAdvertiser:         `badv-1,badv-2`,
+				MacroBlockedApp:                `bapp-1,bapp-2`,
+				MacroFD:                        `1`,
+				MacroTransactionID:             `source-tid`,
+				MacroPaymentIDChain:            `source-pchain`,
+				MacroCoppa:                     `1`,
+				MacroDisplayManager:            `disp-mgr`,
+				MacroDisplayManagerVersion:     `1.2`,
+				MacroInterstitial:              `1`,
+				MacroTagID:                     `tag-id`,
+				MacroBidFloor:                  `3`,
+				MacroBidFloorCurrency:          `usd`,
+				MacroSecure:                    `0`,
+				MacroPMP:                       `{"private_auction":1,"deals":[{"id":"deal-1","bidfloor":4,"bidfloorcur":"usd","at":1,"wseat":["wseat-11","wseat-12"],"wadomain":["wdomain-11","wdomain-12"]},{"id":"deal-2","bidfloor":5,"bidfloorcur":"inr","at":1,"wseat":["wseat-21","wseat-22"],"wadomain":["wdomain-21","wdomain-22"]}]}`,
+				MacroVideoMIMES:                `mp4,flv`,
+				MacroVideoMinimumDuration:      `30`,
+				MacroVideoMaximumDuration:      `60`,
+				MacroVideoProtocols:            `3,8`,
+				MacroVideoPlayerWidth:          `640`,
+				MacroVideoPlayerHeight:         `480`,
+				MacroVideoStartDelay:           `0`,
+				MacroVideoPlacement:            `1`,
+				MacroVideoLinearity:            `1`,
+				MacroVideoSkip:                 `0`,
+				MacroVideoSkipMinimum:          `10`,
+				MacroVideoSkipAfter:            `5`,
+				MacroVideoSequence:             `1`,
+				MacroVideoBlockedAttribute:     `1,2`,
+				MacroVideoMaximumExtended:      `10`,
+				MacroVideoMinimumBitRate:       `360`,
+				MacroVideoMaximumBitRate:       `1080`,
+				MacroVideoBoxing:               `1`,
+				MacroVideoPlaybackMethod:       `1,3`,
+				MacroVideoDelivery:             `1,3`,
+				MacroVideoPosition:             `0`,
+				MacroVideoAPI:                  `1,2`,
+				MacroSiteID:                    `site-id`,
+				MacroSiteName:                  `site-name`,
+				MacroSitePage:                  `site-page-url`,
+				MacroSiteReferrer:              `site-referer-url`,
+				MacroSiteSearch:                `site-search-keywords`,
+				MacroSiteMobile:                `1`,
+				MacroAppID:                     ``,
+				MacroAppName:                   ``,
+				MacroAppBundle:                 ``,
+				MacroAppStoreURL:               ``,
+				MacroAppVersion:                ``,
+				MacroAppPaid:                   ``,
+				MacroCategory:                  `site-cat1,site-cat2`,
+				MacroDomain:                    `site-domain`,
+				MacroSectionCategory:           `site-sec-cat1,site-sec-cat2`,
+				MacroPageCategory:              `site-page-cat1,site-page-cat2`,
+				MacroPrivacyPolicy:             `2`,
+				MacroKeywords:                  `site-keywords`,
+				MacroPubID:                     `site-pub-id`,
+				MacroPubName:                   `site-pub-name`,
+				MacroPubDomain:                 `site-pub-domain`,
+				MacroContentID:                 `site-cnt-id`,
+				MacroContentEpisode:            `2`,
+				MacroContentTitle:              `site-cnt-title`,
+				MacroContentSeries:             `site-cnt-series`,
+				MacroContentSeason:             `site-cnt-season`,
+				MacroContentArtist:             `site-cnt-artist`,
+				MacroContentGenre:              `site-cnt-genre`,
+				MacroContentAlbum:              `site-cnt-album`,
+				MacroContentISrc:               `site-cnt-isrc`,
+				MacroContentURL:                `site-cnt-url`,
+				MacroContentCategory:           `site-cnt-cat1,site-cnt-cat2`,
+				MacroContentProductionQuality:  `0`,
+				MacroContentVideoQuality:       `0`,
+				MacroContentContext:            `1`,
+				MacroContentContentRating:      `1.2`,
+				MacroContentUserRating:         `2.2`,
+				MacroContentQAGMediaRating:     `1`,
+				MacroContentKeywords:           `site-cnt-keywords`,
+				MacroContentLiveStream:         `1`,
+				MacroContentSourceRelationship: `1`,
+				MacroContentLength:             `100`,
+				MacroContentLanguage:           `english`,
+				MacroContentEmbeddable:         `1`,
+				MacroProducerID:                `site-cnt-prod-id`,
+				MacroProducerName:              `site-cnt-prod-name`,
+				MacroUserAgent:                 `user-agent`,
+				MacroDNT:                       `0`,
+				MacroLMT:                       `0`,
+				MacroIP:                        `ipv4`,
+				MacroDeviceType:                `3`,
+				MacroMake:                      `device-make`,
+				MacroModel:                     `device-model`,
+				MacroDeviceOS:                  `os`,
+				MacroDeviceOSVersion:           `os-version`,
+				MacroDeviceWidth:               `2048`,
+				MacroDeviceHeight:              `1024`,
+				MacroDeviceJS:                  `1`,
+				MacroDeviceLanguage:            `device-lang`,
+				MacroDeviceIFA:                 `ifa`,
+				MacroDeviceIFAType:             `idfa`,
+				MacroDeviceDIDSHA1:             `didsha1`,
+				MacroDeviceDIDMD5:              `didmd5`,
+				MacroDeviceDPIDSHA1:            `dpidsha1`,
+				MacroDeviceDPIDMD5:             `dpidmd5`,
+				MacroDeviceMACSHA1:             `macsha1`,
+				MacroDeviceMACMD5:              `macmd5`,
+				MacroLatitude:                  `1.1`,
+				MacroLongitude:                 `2.2`,
+				MacroCountry:                   `country`,
+				MacroRegion:                    `region`,
+				MacroCity:                      `city`,
+				MacroZip:                       `zip`,
+				MacroUTCOffset:                 `1000`,
+				MacroUserID:                    `user-id`,
+				MacroYearOfBirth:               `1990`,
+				MacroGender:                    `M`,
+				MacroGDPRConsent:               `user-gdpr-consent`,
+				MacroGDPR:                      `1`,
+				MacroUSPrivacy:                 `user-privacy`,
+				MacroCacheBuster:               `cachebuster`,
+			},
+		},
+		{
+			name: `App:RequestLevelMacros`,
+			args: args{
+				tag:  newTestBidderMacro(),
+				conf: &config.Adapter{},
+				bidRequest: &openrtb2.BidRequest{
+					Test:  1,
+					TMax:  1000,
+					WSeat: []string{`wseat-1`, `wseat-2`},
+					WLang: []string{`wlang-1`, `wlang-2`},
+					BSeat: []string{`bseat-1`, `bseat-2`},
+					Cur:   []string{`usd`, `inr`},
+					BCat:  []string{`bcat-1`, `bcat-2`},
+					BAdv:  []string{`badv-1`, `badv-2`},
+					BApp:  []string{`bapp-1`, `bapp-2`},
+					Source: &openrtb2.Source{
+						FD:     1,
+						TID:    `source-tid`,
+						PChain: `source-pchain`,
+					},
+					Regs: &openrtb2.Regs{
+						COPPA: 1,
+						Ext:   []byte(`{"gdpr":1,"us_privacy":"user-privacy"}`),
+					},
+					Imp: []openrtb2.Imp{
+						{
+							DisplayManager:    `disp-mgr`,
+							DisplayManagerVer: `1.2`,
+							Instl:             1,
+							TagID:             `tag-id`,
+							BidFloor:          3.0,
+							BidFloorCur:       `usd`,
+							Secure:            new(int8),
+							PMP: &openrtb2.PMP{
+								PrivateAuction: 1,
+								Deals: []openrtb2.Deal{
+									{
+										ID:          `deal-1`,
+										BidFloor:    4.0,
+										BidFloorCur: `usd`,
+										AT:          1,
+										WSeat:       []string{`wseat-11`, `wseat-12`},
+										WADomain:    []string{`wdomain-11`, `wdomain-12`},
+									},
+									{
+										ID:          `deal-2`,
+										BidFloor:    5.0,
+										BidFloorCur: `inr`,
+										AT:          1,
+										WSeat:       []string{`wseat-21`, `wseat-22`},
+										WADomain:    []string{`wdomain-21`, `wdomain-22`},
+									},
+								},
+							},
+							Video: &openrtb2.Video{
+								MIMEs:          []string{`mp4`, `flv`},
+								MinDuration:    30,
+								MaxDuration:    60,
+								Protocols:      []adcom1.MediaCreativeSubtype{adcom1.CreativeVAST30, adcom1.CreativeVAST40Wrapper},
+								Protocol:       adcom1.CreativeVAST40Wrapper,
+								W:              640,
+								H:              480,
+								StartDelay:     new(adcom1.StartDelay),
+								Placement:      adcom1.VideoPlacementInStream,
+								Linearity:      adcom1.LinearityLinear,
+								Skip:           new(int8),
+								SkipMin:        10,
+								SkipAfter:      5,
+								Sequence:       1,
+								BAttr:          []adcom1.CreativeAttribute{adcom1.AttrAudioAuto, adcom1.AttrAudioUser},
+								MaxExtended:    10,
+								MinBitRate:     360,
+								MaxBitRate:     1080,
+								BoxingAllowed:  1,
+								PlaybackMethod: []adcom1.PlaybackMethod{adcom1.PlaybackPageLoadSoundOn, adcom1.PlaybackClickSoundOn},
+								PlaybackEnd:    adcom1.PlaybackCompletion,
+								Delivery:       []adcom1.DeliveryMethod{adcom1.DeliveryStreaming, adcom1.DeliveryDownload},
+								Pos:            new(adcom1.PlacementPosition),
+								API:            []adcom1.APIFramework{adcom1.APIVPAID10, adcom1.APIVPAID20},
+							},
+						},
+					},
+					App: &openrtb2.App{
+						ID:            `app-id`,
+						Bundle:        `app-bundle`,
+						StoreURL:      `app-store-url`,
+						Ver:           `app-version`,
+						Paid:          1,
+						Name:          `app-name`,
+						Domain:        `app-domain`,
+						Cat:           []string{`app-cat1`, `app-cat2`},
+						SectionCat:    []string{`app-sec-cat1`, `app-sec-cat2`},
+						PageCat:       []string{`app-page-cat1`, `app-page-cat2`},
+						PrivacyPolicy: 2,
+						Keywords:      `app-keywords`,
+						Publisher: &openrtb2.Publisher{
+							ID:     `app-pub-id`,
+							Name:   `app-pub-name`,
+							Domain: `app-pub-domain`,
+						},
+						Content: &openrtb2.Content{
+							ID:                 `app-cnt-id`,
+							Episode:            2,
+							Title:              `app-cnt-title`,
+							Series:             `app-cnt-series`,
+							Season:             `app-cnt-season`,
+							Artist:             `app-cnt-artist`,
+							Genre:              `app-cnt-genre`,
+							Album:              `app-cnt-album`,
+							ISRC:               `app-cnt-isrc`,
+							URL:                `app-cnt-url`,
+							Cat:                []string{`app-cnt-cat1`, `app-cnt-cat2`},
+							ProdQ:              new(adcom1.ProductionQuality),
+							VideoQuality:       new(adcom1.ProductionQuality),
+							Context:            adcom1.ContentVideo,
+							ContentRating:      `1.2`,
+							UserRating:         `2.2`,
+							QAGMediaRating:     adcom1.MediaRatingAll,
+							Keywords:           `app-cnt-keywords`,
+							LiveStream:         1,
+							SourceRelationship: 1,
+							Len:                100,
+							Language:           `english`,
+							Embeddable:         1,
+							Producer: &openrtb2.Producer{
+								ID:   `app-cnt-prod-id`,
+								Name: `app-cnt-prod-name`,
+							},
+						},
+					},
+					Device: &openrtb2.Device{
+						UA:             `user-agent`,
+						DNT:            new(int8),
+						Lmt:            new(int8),
+						IPv6:           `ipv6`,
+						DeviceType:     adcom1.DeviceTV,
+						Make:           `device-make`,
+						Model:          `device-model`,
+						OS:             `os`,
+						OSV:            `os-version`,
+						H:              1024,
+						W:              2048,
+						JS:             1,
+						Language:       `device-lang`,
+						ConnectionType: new(adcom1.ConnectionType),
+						IFA:            `ifa`,
+						DIDSHA1:        `didsha1`,
+						DIDMD5:         `didmd5`,
+						DPIDSHA1:       `dpidsha1`,
+						DPIDMD5:        `dpidmd5`,
+						MACSHA1:        `macsha1`,
+						MACMD5:         `macmd5`,
+						Geo: &openrtb2.Geo{
+							Lat:       1.1,
+							Lon:       2.2,
+							Country:   `country`,
+							Region:    `region`,
+							City:      `city`,
+							ZIP:       `zip`,
+							UTCOffset: 1000,
+						},
+						Ext: []byte(`{"ifa_type":"idfa"}`),
+					},
+					User: &openrtb2.User{
+						ID:     `user-id`,
+						Yob:    1990,
+						Gender: `M`,
+						Ext:    []byte(`{"consent":"user-gdpr-consent"}`),
+					},
+				},
+			},
+			macros: map[string]string{
+				MacroTest:                      `1`,
+				MacroTimeout:                   `1000`,
+				MacroWhitelistSeat:             `wseat-1,wseat-2`,
+				MacroWhitelistLang:             `wlang-1,wlang-2`,
+				MacroBlockedSeat:               `bseat-1,bseat-2`,
+				MacroCurrency:                  `usd,inr`,
+				MacroBlockedCategory:           `bcat-1,bcat-2`,
+				MacroBlockedAdvertiser:         `badv-1,badv-2`,
+				MacroBlockedApp:                `bapp-1,bapp-2`,
+				MacroFD:                        `1`,
+				MacroTransactionID:             `source-tid`,
+				MacroPaymentIDChain:            `source-pchain`,
+				MacroCoppa:                     `1`,
+				MacroDisplayManager:            `disp-mgr`,
+				MacroDisplayManagerVersion:     `1.2`,
+				MacroInterstitial:              `1`,
+				MacroTagID:                     `tag-id`,
+				MacroBidFloor:                  `3`,
+				MacroBidFloorCurrency:          `usd`,
+				MacroSecure:                    `0`,
+				MacroPMP:                       `{"private_auction":1,"deals":[{"id":"deal-1","bidfloor":4,"bidfloorcur":"usd","at":1,"wseat":["wseat-11","wseat-12"],"wadomain":["wdomain-11","wdomain-12"]},{"id":"deal-2","bidfloor":5,"bidfloorcur":"inr","at":1,"wseat":["wseat-21","wseat-22"],"wadomain":["wdomain-21","wdomain-22"]}]}`,
+				MacroVideoMIMES:                `mp4,flv`,
+				MacroVideoMinimumDuration:      `30`,
+				MacroVideoMaximumDuration:      `60`,
+				MacroVideoProtocols:            `3,8`,
+				MacroVideoPlayerWidth:          `640`,
+				MacroVideoPlayerHeight:         `480`,
+				MacroVideoStartDelay:           `0`,
+				MacroVideoPlacement:            `1`,
+				MacroVideoLinearity:            `1`,
+				MacroVideoSkip:                 `0`,
+				MacroVideoSkipMinimum:          `10`,
+				MacroVideoSkipAfter:            `5`,
+				MacroVideoSequence:             `1`,
+				MacroVideoBlockedAttribute:     `1,2`,
+				MacroVideoMaximumExtended:      `10`,
+				MacroVideoMinimumBitRate:       `360`,
+				MacroVideoMaximumBitRate:       `1080`,
+				MacroVideoBoxing:               `1`,
+				MacroVideoPlaybackMethod:       `1,3`,
+				MacroVideoDelivery:             `1,3`,
+				MacroVideoPosition:             `0`,
+				MacroVideoAPI:                  `1,2`,
+				MacroSiteID:                    ``,
+				MacroSiteName:                  ``,
+				MacroSitePage:                  ``,
+				MacroSiteReferrer:              ``,
+				MacroSiteSearch:                ``,
+				MacroSiteMobile:                ``,
+				MacroAppID:                     `app-id`,
+				MacroAppName:                   `app-name`,
+				MacroAppBundle:                 `app-bundle`,
+				MacroAppStoreURL:               `app-store-url`,
+				MacroAppVersion:                `app-version`,
+				MacroAppPaid:                   `1`,
+				MacroCategory:                  `app-cat1,app-cat2`,
+				MacroDomain:                    `app-domain`,
+				MacroSectionCategory:           `app-sec-cat1,app-sec-cat2`,
+				MacroPageCategory:              `app-page-cat1,app-page-cat2`,
+				MacroPrivacyPolicy:             `2`,
+				MacroKeywords:                  `app-keywords`,
+				MacroPubID:                     `app-pub-id`,
+				MacroPubName:                   `app-pub-name`,
+				MacroPubDomain:                 `app-pub-domain`,
+				MacroContentID:                 `app-cnt-id`,
+				MacroContentEpisode:            `2`,
+				MacroContentTitle:              `app-cnt-title`,
+				MacroContentSeries:             `app-cnt-series`,
+				MacroContentSeason:             `app-cnt-season`,
+				MacroContentArtist:             `app-cnt-artist`,
+				MacroContentGenre:              `app-cnt-genre`,
+				MacroContentAlbum:              `app-cnt-album`,
+				MacroContentISrc:               `app-cnt-isrc`,
+				MacroContentURL:                `app-cnt-url`,
+				MacroContentCategory:           `app-cnt-cat1,app-cnt-cat2`,
+				MacroContentProductionQuality:  `0`,
+				MacroContentVideoQuality:       `0`,
+				MacroContentContext:            `1`,
+				MacroContentContentRating:      `1.2`,
+				MacroContentUserRating:         `2.2`,
+				MacroContentQAGMediaRating:     `1`,
+				MacroContentKeywords:           `app-cnt-keywords`,
+				MacroContentLiveStream:         `1`,
+				MacroContentSourceRelationship: `1`,
+				MacroContentLength:             `100`,
+				MacroContentLanguage:           `english`,
+				MacroContentEmbeddable:         `1`,
+				MacroProducerID:                `app-cnt-prod-id`,
+				MacroProducerName:              `app-cnt-prod-name`,
+				MacroUserAgent:                 `user-agent`,
+				MacroDNT:                       `0`,
+				MacroLMT:                       `0`,
+				MacroIP:                        `ipv6`,
+				MacroDeviceType:                `3`,
+				MacroMake:                      `device-make`,
+				MacroModel:                     `device-model`,
+				MacroDeviceOS:                  `os`,
+				MacroDeviceOSVersion:           `os-version`,
+				MacroDeviceWidth:               `2048`,
+				MacroDeviceHeight:              `1024`,
+				MacroDeviceJS:                  `1`,
+				MacroDeviceLanguage:            `device-lang`,
+				MacroDeviceIFA:                 `ifa`,
+				MacroDeviceIFAType:             `idfa`,
+				MacroDeviceDIDSHA1:             `didsha1`,
+				MacroDeviceDIDMD5:              `didmd5`,
+				MacroDeviceDPIDSHA1:            `dpidsha1`,
+				MacroDeviceDPIDMD5:             `dpidmd5`,
+				MacroDeviceMACSHA1:             `macsha1`,
+				MacroDeviceMACMD5:              `macmd5`,
+				MacroLatitude:                  `1.1`,
+				MacroLongitude:                 `2.2`,
+				MacroCountry:                   `country`,
+				MacroRegion:                    `region`,
+				MacroCity:                      `city`,
+				MacroZip:                       `zip`,
+				MacroUTCOffset:                 `1000`,
+				MacroUserID:                    `user-id`,
+				MacroYearOfBirth:               `1990`,
+				MacroGender:                    `M`,
+				MacroGDPRConsent:               `user-gdpr-consent`,
+				MacroGDPR:                      `1`,
+				MacroUSPrivacy:                 `user-privacy`,
+				MacroCacheBuster:               `cachebuster`,
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			macroMappings := GetDefaultMapper()
+
+			tag := tt.args.tag
+			tag.InitBidRequest(tt.args.bidRequest)
+			tag.SetAdapterConfig(tt.args.conf)
+			tag.LoadImpression(&tt.args.bidRequest.Imp[0])
+
+			for key, result := range tt.macros {
+				cb, ok := macroMappings[key]
+				if !ok {
+					assert.NotEmpty(t, result)
+				} else {
+					actual := cb.callback(tag, key)
+					assert.Equal(t, result, actual, fmt.Sprintf("MacroFunction: %v", key))
+				}
+			}
+		})
+	}
+}
diff --git a/adapters/vastbidder/constant.go b/adapters/vastbidder/constant.go
new file mode 100644
index 000000000..2d8270805
--- /dev/null
+++ b/adapters/vastbidder/constant.go
@@ -0,0 +1,167 @@
+package vastbidder
+
+const (
+	intBase = 10
+	comma   = `,`
+)
+
+// List of Tag Bidder Macros
+const (
+	//Request
+	MacroTest              = `test`
+	MacroTimeout           = `timeout`
+	MacroWhitelistSeat     = `wseat`
+	MacroWhitelistLang     = `wlang`
+	MacroBlockedSeat       = `bseat`
+	MacroCurrency          = `cur`
+	MacroBlockedCategory   = `bcat`
+	MacroBlockedAdvertiser = `badv`
+	MacroBlockedApp        = `bapp`
+
+	//Source
+	MacroFD             = `fd`
+	MacroTransactionID  = `tid`
+	MacroPaymentIDChain = `pchain`
+
+	//Regs
+	MacroCoppa = `coppa`
+
+	//Impression
+	MacroDisplayManager        = `displaymanager`
+	MacroDisplayManagerVersion = `displaymanagerver`
+	MacroInterstitial          = `instl`
+	MacroTagID                 = `tagid`
+	MacroBidFloor              = `bidfloor`
+	MacroBidFloorCurrency      = `bidfloorcur`
+	MacroSecure                = `secure`
+	MacroPMP                   = `pmp`
+
+	//Video
+	MacroVideoMIMES            = `mimes`
+	MacroVideoMinimumDuration  = `minduration`
+	MacroVideoMaximumDuration  = `maxduration`
+	MacroVideoProtocols        = `protocols`
+	MacroVideoPlayerWidth      = `playerwidth`
+	MacroVideoPlayerHeight     = `playerheight`
+	MacroVideoStartDelay       = `startdelay`
+	MacroVideoPlacement        = `placement`
+	MacroVideoLinearity        = `linearity`
+	MacroVideoSkip             = `skip`
+	MacroVideoSkipMinimum      = `skipmin`
+	MacroVideoSkipAfter        = `skipafter`
+	MacroVideoSequence         = `sequence`
+	MacroVideoBlockedAttribute = `battr`
+	MacroVideoMaximumExtended  = `maxextended`
+	MacroVideoMinimumBitRate   = `minbitrate`
+	MacroVideoMaximumBitRate   = `maxbitrate`
+	MacroVideoBoxing           = `boxingallowed`
+	MacroVideoPlaybackMethod   = `playbackmethod`
+	MacroVideoDelivery         = `delivery`
+	MacroVideoPosition         = `position`
+	MacroVideoAPI              = `api`
+
+	//Site
+	MacroSiteID       = `siteid`
+	MacroSiteName     = `sitename`
+	MacroSitePage     = `page`
+	MacroSiteReferrer = `ref`
+	MacroSiteSearch   = `search`
+	MacroSiteMobile   = `mobile`
+
+	//App
+	MacroAppID       = `appid`
+	MacroAppName     = `appname`
+	MacroAppBundle   = `bundle`
+	MacroAppStoreURL = `storeurl`
+	MacroAppVersion  = `appver`
+	MacroAppPaid     = `paid`
+
+	//SiteAppCommon
+	MacroCategory        = `cat`
+	MacroDomain          = `domain`
+	MacroSectionCategory = `sectioncat`
+	MacroPageCategory    = `pagecat`
+	MacroPrivacyPolicy   = `privacypolicy`
+	MacroKeywords        = `keywords`
+
+	//Publisher
+	MacroPubID     = `pubid`
+	MacroPubName   = `pubname`
+	MacroPubDomain = `pubdomain`
+
+	//Content
+	MacroContentID                 = `contentid`
+	MacroContentEpisode            = `episode`
+	MacroContentTitle              = `title`
+	MacroContentSeries             = `series`
+	MacroContentSeason             = `season`
+	MacroContentArtist             = `artist`
+	MacroContentGenre              = `genre`
+	MacroContentAlbum              = `album`
+	MacroContentISrc               = `isrc`
+	MacroContentURL                = `contenturl`
+	MacroContentCategory           = `contentcat`
+	MacroContentProductionQuality  = `contentprodq`
+	MacroContentVideoQuality       = `contentvideoquality`
+	MacroContentContext            = `context`
+	MacroContentContentRating      = `contentrating`
+	MacroContentUserRating         = `userrating`
+	MacroContentQAGMediaRating     = `qagmediarating`
+	MacroContentKeywords           = `contentkeywords`
+	MacroContentLiveStream         = `livestream`
+	MacroContentSourceRelationship = `sourcerelationship`
+	MacroContentLength             = `contentlen`
+	MacroContentLanguage           = `contentlanguage`
+	MacroContentEmbeddable         = `contentembeddable`
+
+	//Producer
+	MacroProducerID   = `prodid`
+	MacroProducerName = `prodname`
+
+	//Device
+	MacroUserAgent       = `useragent`
+	MacroDNT             = `dnt`
+	MacroLMT             = `lmt`
+	MacroIP              = `ip`
+	MacroDeviceType      = `devicetype`
+	MacroMake            = `make`
+	MacroModel           = `model`
+	MacroDeviceOS        = `os`
+	MacroDeviceOSVersion = `osv`
+	MacroDeviceWidth     = `devicewidth`
+	MacroDeviceHeight    = `deviceheight`
+	MacroDeviceJS        = `js`
+	MacroDeviceLanguage  = `lang`
+	MacroDeviceIFA       = `ifa`
+	MacroDeviceIFAType   = `ifa_type`
+	MacroDeviceDIDSHA1   = `didsha1`
+	MacroDeviceDIDMD5    = `didmd5`
+	MacroDeviceDPIDSHA1  = `dpidsha1`
+	MacroDeviceDPIDMD5   = `dpidmd5`
+	MacroDeviceMACSHA1   = `macsha1`
+	MacroDeviceMACMD5    = `macmd5`
+
+	//Geo
+	MacroLatitude  = `lat`
+	MacroLongitude = `lon`
+	MacroCountry   = `country`
+	MacroRegion    = `region`
+	MacroCity      = `city`
+	MacroZip       = `zip`
+	MacroUTCOffset = `utcoffset`
+
+	//User
+	MacroUserID      = `uid`
+	MacroYearOfBirth = `yob`
+	MacroGender      = `gender`
+
+	//Extension
+	MacroGDPRConsent = `consent`
+	MacroGDPR        = `gdpr`
+	MacroUSPrivacy   = `usprivacy`
+
+	//Additional
+	MacroCacheBuster = `cachebuster`
+)
+
+var ParamKeys = []string{"param1", "param2", "param3", "param4", "param5"}
diff --git a/adapters/vastbidder/ibidder_macro.go b/adapters/vastbidder/ibidder_macro.go
new file mode 100644
index 000000000..5c68c6320
--- /dev/null
+++ b/adapters/vastbidder/ibidder_macro.go
@@ -0,0 +1,195 @@
+package vastbidder
+
+import (
+	"net/http"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// IBidderMacro interface will capture all macro definition
+type IBidderMacro interface {
+	//Helper Function
+	InitBidRequest(request *openrtb2.BidRequest)
+	LoadImpression(imp *openrtb2.Imp) (*openrtb_ext.ExtImpVASTBidder, error)
+	LoadVASTTag(tag *openrtb_ext.ExtImpVASTBidderTag)
+	GetBidderKeys() map[string]string
+	SetAdapterConfig(*config.Adapter)
+	GetURI() string
+	GetHeaders() http.Header
+	//getAllHeaders returns default and custom heades
+	getAllHeaders() http.Header
+
+	//Request
+	MacroTest(string) string
+	MacroTimeout(string) string
+	MacroWhitelistSeat(string) string
+	MacroWhitelistLang(string) string
+	MacroBlockedSeat(string) string
+	MacroCurrency(string) string
+	MacroBlockedCategory(string) string
+	MacroBlockedAdvertiser(string) string
+	MacroBlockedApp(string) string
+
+	//Source
+	MacroFD(string) string
+	MacroTransactionID(string) string
+	MacroPaymentIDChain(string) string
+
+	//Regs
+	MacroCoppa(string) string
+
+	//Impression
+	MacroDisplayManager(string) string
+	MacroDisplayManagerVersion(string) string
+	MacroInterstitial(string) string
+	MacroTagID(string) string
+	MacroBidFloor(string) string
+	MacroBidFloorCurrency(string) string
+	MacroSecure(string) string
+	MacroPMP(string) string
+
+	//Video
+	MacroVideoMIMES(string) string
+	MacroVideoMinimumDuration(string) string
+	MacroVideoMaximumDuration(string) string
+	MacroVideoProtocols(string) string
+	MacroVideoPlayerWidth(string) string
+	MacroVideoPlayerHeight(string) string
+	MacroVideoStartDelay(string) string
+	MacroVideoPlacement(string) string
+	MacroVideoLinearity(string) string
+	MacroVideoSkip(string) string
+	MacroVideoSkipMinimum(string) string
+	MacroVideoSkipAfter(string) string
+	MacroVideoSequence(string) string
+	MacroVideoBlockedAttribute(string) string
+	MacroVideoMaximumExtended(string) string
+	MacroVideoMinimumBitRate(string) string
+	MacroVideoMaximumBitRate(string) string
+	MacroVideoBoxing(string) string
+	MacroVideoPlaybackMethod(string) string
+	MacroVideoDelivery(string) string
+	MacroVideoPosition(string) string
+	MacroVideoAPI(string) string
+
+	//Site
+	MacroSiteID(string) string
+	MacroSiteName(string) string
+	MacroSitePage(string) string
+	MacroSiteReferrer(string) string
+	MacroSiteSearch(string) string
+	MacroSiteMobile(string) string
+
+	//App
+	MacroAppID(string) string
+	MacroAppName(string) string
+	MacroAppBundle(string) string
+	MacroAppStoreURL(string) string
+	MacroAppVersion(string) string
+	MacroAppPaid(string) string
+
+	//SiteAppCommon
+	MacroCategory(string) string
+	MacroDomain(string) string
+	MacroSectionCategory(string) string
+	MacroPageCategory(string) string
+	MacroPrivacyPolicy(string) string
+	MacroKeywords(string) string
+
+	//Publisher
+	MacroPubID(string) string
+	MacroPubName(string) string
+	MacroPubDomain(string) string
+
+	//Content
+	MacroContentID(string) string
+	MacroContentEpisode(string) string
+	MacroContentTitle(string) string
+	MacroContentSeries(string) string
+	MacroContentSeason(string) string
+	MacroContentArtist(string) string
+	MacroContentGenre(string) string
+	MacroContentAlbum(string) string
+	MacroContentISrc(string) string
+	MacroContentURL(string) string
+	MacroContentCategory(string) string
+	MacroContentProductionQuality(string) string
+	MacroContentVideoQuality(string) string
+	MacroContentContext(string) string
+	MacroContentContentRating(string) string
+	MacroContentUserRating(string) string
+	MacroContentQAGMediaRating(string) string
+	MacroContentKeywords(string) string
+	MacroContentLiveStream(string) string
+	MacroContentSourceRelationship(string) string
+	MacroContentLength(string) string
+	MacroContentLanguage(string) string
+	MacroContentEmbeddable(string) string
+
+	//Producer
+	MacroProducerID(string) string
+	MacroProducerName(string) string
+
+	//Device
+	MacroUserAgent(string) string
+	MacroDNT(string) string
+	MacroLMT(string) string
+	MacroIP(string) string
+	MacroDeviceType(string) string
+	MacroMake(string) string
+	MacroModel(string) string
+	MacroDeviceOS(string) string
+	MacroDeviceOSVersion(string) string
+	MacroDeviceWidth(string) string
+	MacroDeviceHeight(string) string
+	MacroDeviceJS(string) string
+	MacroDeviceLanguage(string) string
+	MacroDeviceIFA(string) string
+	MacroDeviceIFAType(string) string
+	MacroDeviceDIDSHA1(string) string
+	MacroDeviceDIDMD5(string) string
+	MacroDeviceDPIDSHA1(string) string
+	MacroDeviceDPIDMD5(string) string
+	MacroDeviceMACSHA1(string) string
+	MacroDeviceMACMD5(string) string
+
+	//Geo
+	MacroLatitude(string) string
+	MacroLongitude(string) string
+	MacroCountry(string) string
+	MacroRegion(string) string
+	MacroCity(string) string
+	MacroZip(string) string
+	MacroUTCOffset(string) string
+
+	//User
+	MacroUserID(string) string
+	MacroYearOfBirth(string) string
+	MacroGender(string) string
+
+	//Extension
+	MacroGDPRConsent(string) string
+	MacroGDPR(string) string
+	MacroUSPrivacy(string) string
+
+	//Additional
+	MacroCacheBuster(string) string
+}
+
+var bidderMacroMap = map[openrtb_ext.BidderName]func() IBidderMacro{}
+
+// RegisterNewBidderMacro will be used by each bidder to set its respective macro IBidderMacro
+func RegisterNewBidderMacro(bidder openrtb_ext.BidderName, macro func() IBidderMacro) {
+	bidderMacroMap[bidder] = macro
+}
+
+// GetNewBidderMacro will return IBidderMacro of specific bidder
+func GetNewBidderMacro(bidder openrtb_ext.BidderName) IBidderMacro {
+	callback, ok := bidderMacroMap[bidder]
+	if ok {
+		return callback()
+	}
+	return NewBidderMacro()
+}
diff --git a/adapters/vastbidder/itag_response_handler.go b/adapters/vastbidder/itag_response_handler.go
new file mode 100644
index 000000000..2e50b9245
--- /dev/null
+++ b/adapters/vastbidder/itag_response_handler.go
@@ -0,0 +1,43 @@
+package vastbidder
+
+import (
+	"errors"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/adapters"
+)
+
+// ITagRequestHandler parse bidder request
+type ITagRequestHandler interface {
+	MakeRequests(request *openrtb2.BidRequest, reqInfo *adapters.ExtraRequestInfo) ([]*adapters.RequestData, []error)
+}
+
+// ITagResponseHandler parse bidder response
+type ITagResponseHandler interface {
+	Validate(internalRequest *openrtb2.BidRequest, externalRequest *adapters.RequestData, response *adapters.ResponseData) []error
+	MakeBids(internalRequest *openrtb2.BidRequest, externalRequest *adapters.RequestData, response *adapters.ResponseData) (*adapters.BidderResponse, []error)
+}
+
+// HandlerType list of tag based response handlers
+type HandlerType string
+
+const (
+	VASTTagHandlerType HandlerType = `vasttag`
+)
+
+// GetResponseHandler returns response handler
+func GetResponseHandler(responseType HandlerType) (ITagResponseHandler, error) {
+	switch responseType {
+	case VASTTagHandlerType:
+		return NewVASTTagResponseHandler(), nil
+	}
+	return nil, errors.New(`Unkown Response Handler`)
+}
+
+func GetRequestHandler(responseType HandlerType) (ITagRequestHandler, error) {
+	switch responseType {
+	case VASTTagHandlerType:
+		return nil, nil
+	}
+	return nil, errors.New(`Unkown Response Handler`)
+}
diff --git a/adapters/vastbidder/macro_processor.go b/adapters/vastbidder/macro_processor.go
new file mode 100644
index 000000000..ed720058c
--- /dev/null
+++ b/adapters/vastbidder/macro_processor.go
@@ -0,0 +1,176 @@
+package vastbidder
+
+import (
+	"bytes"
+	"net/url"
+	"strings"
+
+	"github.com/golang/glog"
+)
+
+const (
+	macroPrefix          string = `{` //macro prefix can not be empty
+	macroSuffix          string = `}` //macro suffix can not be empty
+	macroEscapeSuffix    string = `_ESC`
+	macroPrefixLen       int    = len(macroPrefix)
+	macroSuffixLen       int    = len(macroSuffix)
+	macroEscapeSuffixLen int    = len(macroEscapeSuffix)
+)
+
+//Flags to customize macro processing wrappers
+
+// MacroProcessor struct to hold openrtb request and cache values
+type MacroProcessor struct {
+	bidderMacro IBidderMacro
+	mapper      Mapper
+	macroCache  map[string]string
+	bidderKeys  map[string]string
+}
+
+// NewMacroProcessor will process macro's of openrtb bid request
+func NewMacroProcessor(bidderMacro IBidderMacro, mapper Mapper) *MacroProcessor {
+	return &MacroProcessor{
+		bidderMacro: bidderMacro,
+		mapper:      mapper,
+		macroCache:  make(map[string]string),
+	}
+}
+
+// SetMacro Adding Custom Macro Manually
+func (mp *MacroProcessor) SetMacro(key, value string) {
+	mp.macroCache[key] = value
+}
+
+// SetBidderKeys will flush and set bidder specific keys
+func (mp *MacroProcessor) SetBidderKeys(keys map[string]string) {
+	mp.bidderKeys = keys
+}
+
+// processKey : returns value of key macro and status found or not
+func (mp *MacroProcessor) processKey(key string) (string, bool) {
+	var valueCallback *macroCallBack
+	var value string
+	nEscaping := 0
+	tmpKey := key
+	found := false
+
+	for {
+		//Search in macro cache
+		if value, found = mp.macroCache[tmpKey]; found {
+			break
+		}
+
+		//Search for bidder keys
+		if nil != mp.bidderKeys {
+			if value, found = mp.bidderKeys[tmpKey]; found {
+				//default escaping of bidder keys
+				if len(value) > 0 && nEscaping == 0 {
+					//escape parameter only if _ESC is not present
+					value = url.QueryEscape(value)
+				}
+				break
+			}
+		}
+
+		valueCallback, found = mp.mapper[tmpKey]
+		if found {
+			//found callback function
+			value = valueCallback.callback(mp.bidderMacro, tmpKey)
+
+			//checking if default escaping needed or not
+			if len(value) > 0 && valueCallback.escape && nEscaping == 0 {
+				//escape parameter only if defaultescaping is true and _ESC is not present
+				value = url.QueryEscape(value)
+			}
+
+			break
+		} else if strings.HasSuffix(tmpKey, macroEscapeSuffix) {
+			//escaping macro found
+			tmpKey = tmpKey[0 : len(tmpKey)-macroEscapeSuffixLen]
+			nEscaping++
+			continue
+		}
+		break
+	}
+
+	if found {
+		if len(value) > 0 {
+			if nEscaping > 0 {
+				//escaping string nEscaping times
+				value = escape(value, nEscaping)
+			}
+			if nil != valueCallback && valueCallback.cached {
+				//cached value if its cached flag is true
+				mp.macroCache[key] = value
+			}
+		}
+	}
+
+	return value, found
+}
+
+// Process : Substitute macros in input string
+func (mp *MacroProcessor) Process(in string) (response string) {
+	var out bytes.Buffer
+	pos, start, end, size := 0, 0, 0, len(in)
+
+	for pos < size {
+		//find macro prefix index
+		if start = strings.Index(in[pos:], macroPrefix); -1 == start {
+			//[prefix_not_found] append remaining string to response
+			out.WriteString(in[pos:])
+
+			//macro prefix not found
+			break
+		}
+
+		//prefix index w.r.t original string
+		start = start + pos
+
+		//append non macro prefix content
+		out.WriteString(in[pos:start])
+
+		if (end - macroSuffixLen) <= (start + macroPrefixLen) {
+			//string contains {{TEXT_{{MACRO}} -> it should replace it with{{TEXT_MACROVALUE
+			//find macro suffix index
+			if end = strings.Index(in[start+macroPrefixLen:], macroSuffix); -1 == end {
+				//[suffix_not_found] append remaining string to response
+				out.WriteString(in[start:])
+
+				// We Found First %% and Not Found Second %% But We are in between of string
+				break
+			}
+
+			end = start + macroPrefixLen + end + macroSuffixLen
+		}
+
+		//get actual macro key by removing macroPrefix and macroSuffix from key itself
+		key := in[start+macroPrefixLen : end-macroSuffixLen]
+
+		//process macro
+		value, found := mp.processKey(key)
+		if found {
+			out.WriteString(value)
+			pos = end
+		} else {
+			out.WriteByte(macroPrefix[0])
+			pos = start + 1
+		}
+		//glog.Infof("\nSearch[%d] <start,end,key>: [%d,%d,%s]", count, start, end, key)
+	}
+	response = out.String()
+	glog.V(3).Infof("[MACRO]:in:[%s] replaced:[%s]", in, response)
+	return
+}
+
+// GetMacroKey will return macro formatted key
+func GetMacroKey(key string) string {
+	return macroPrefix + key + macroSuffix
+}
+
+func escape(str string, n int) string {
+	for ; n > 0; n-- {
+		str = url.QueryEscape(str)
+	}
+	return str[:]
+}
diff --git a/adapters/vastbidder/macro_processor_test.go b/adapters/vastbidder/macro_processor_test.go
new file mode 100644
index 000000000..d4f77f43f
--- /dev/null
+++ b/adapters/vastbidder/macro_processor_test.go
@@ -0,0 +1,304 @@
+package vastbidder
+
+import (
+	"testing"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestMacroProcessor_Process(t *testing.T) {
+	bidRequestValues := map[string]string{
+		MacroPubID: `pubID`,
+		MacroTagID: `tagid value`,
+	}
+
+	testMacroValues := map[string]string{
+		MacroPubID:                     `pubID`,
+		MacroTagID:                     `tagid+value`, //default escaping
+		MacroTagID + macroEscapeSuffix: `tagid+value`, //single escaping explicitly
+		MacroTagID + macroEscapeSuffix + macroEscapeSuffix: `tagid%2Bvalue`,
+	}
+
+	sampleBidRequest := &openrtb2.BidRequest{
+		Imp: []openrtb2.Imp{
+			{TagID: bidRequestValues[MacroTagID]},
+		},
+		Site: &openrtb2.Site{
+			Publisher: &openrtb2.Publisher{
+				ID: bidRequestValues[MacroPubID],
+			},
+		},
+	}
+
+	tests := []struct {
+		name     string
+		in       string
+		expected string
+	}{
+		{
+			name:     "EmptyInput",
+			in:       "",
+			expected: "",
+		},
+		{
+			name:     "NoMacroReplacement",
+			in:       "Hello Test No Macro",
+			expected: "Hello Test No Macro",
+		},
+		{
+			name:     "StartMacro",
+			in:       GetMacroKey(MacroTagID) + "HELLO",
+			expected: testMacroValues[MacroTagID] + "HELLO",
+		},
+		{
+			name:     "EndMacro",
+			in:       "HELLO" + GetMacroKey(MacroTagID),
+			expected: "HELLO" + testMacroValues[MacroTagID],
+		},
+		{
+			name:     "StartEndMacro",
+			in:       GetMacroKey(MacroTagID) + "HELLO" + GetMacroKey(MacroTagID),
+			expected: testMacroValues[MacroTagID] + "HELLO" + testMacroValues[MacroTagID],
+		},
+		{
+			name:     "HalfStartMacro",
+			in:       macroPrefix + GetMacroKey(MacroTagID) + "HELLO",
+			expected: macroPrefix + testMacroValues[MacroTagID] + "HELLO",
+		},
+		{
+			name:     "HalfEndMacro",
+			in:       "HELLO" + GetMacroKey(MacroTagID) + macroSuffix,
+			expected: "HELLO" + testMacroValues[MacroTagID] + macroSuffix,
+		},
+		{
+			name:     "ConcatenatedMacro",
+			in:       GetMacroKey(MacroTagID) + GetMacroKey(MacroTagID) + "HELLO",
+			expected: testMacroValues[MacroTagID] + testMacroValues[MacroTagID] + "HELLO",
+		},
+		{
+			name:     "IncompleteConcatenationMacro",
+			in:       GetMacroKey(MacroTagID) + macroSuffix + "LINKHELLO",
+			expected: testMacroValues[MacroTagID] + macroSuffix + "LINKHELLO",
+		},
+		{
+			name:     "ConcatenationWithSuffixMacro",
+			in:       GetMacroKey(MacroTagID) + macroPrefix + GetMacroKey(MacroTagID) + "HELLO",
+			expected: testMacroValues[MacroTagID] + macroPrefix + testMacroValues[MacroTagID] + "HELLO",
+		},
+		{
+			name:     "UnknownMacro",
+			in:       GetMacroKey(`UNKNOWN`) + `ABC`,
+			expected: GetMacroKey(`UNKNOWN`) + `ABC`,
+		},
+		{
+			name:     "IncompleteMacroSuffix",
+			in:       "START" + macroSuffix,
+			expected: "START" + macroSuffix,
+		},
+		{
+			name:     "IncompleteStartAndEnd",
+			in:       string(macroPrefix[0]) + GetMacroKey(MacroTagID) + " Value " + GetMacroKey(MacroTagID) + string(macroSuffix[0]),
+			expected: string(macroPrefix[0]) + testMacroValues[MacroTagID] + " Value " + testMacroValues[MacroTagID] + string(macroSuffix[0]),
+		},
+		{
+			name:     "SpecialCharacter",
+			in:       macroPrefix + MacroTagID + `\n` + macroSuffix + "Sample \"" + GetMacroKey(MacroTagID) + "\" Data",
+			expected: macroPrefix + MacroTagID + `\n` + macroSuffix + "Sample \"" + testMacroValues[MacroTagID] + "\" Data",
+		},
+		{
+			name:     "EmptyValue",
+			in:       GetMacroKey(MacroTimeout) + "Hello",
+			expected: "Hello",
+		},
+		{
+			name:     "EscapingMacro",
+			in:       GetMacroKey(MacroTagID),
+			expected: testMacroValues[MacroTagID],
+		},
+		{
+			name:     "SingleEscapingMacro",
+			in:       GetMacroKey(MacroTagID + macroEscapeSuffix),
+			expected: testMacroValues[MacroTagID+macroEscapeSuffix],
+		},
+		{
+			name:     "DoubleEscapingMacro",
+			in:       GetMacroKey(MacroTagID + macroEscapeSuffix + macroEscapeSuffix),
+			expected: testMacroValues[MacroTagID+macroEscapeSuffix+macroEscapeSuffix],
+		},
+
+		// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			bidderMacro := NewBidderMacro()
+			mapper := GetDefaultMapper()
+			mp := NewMacroProcessor(bidderMacro, mapper)
+
+			//Init Bidder Macro
+			bidderMacro.InitBidRequest(sampleBidRequest)
+			bidderMacro.LoadImpression(&sampleBidRequest.Imp[0])
+
+			gotResponse := mp.Process(tt.in)
+			assert.Equal(t, tt.expected, gotResponse)
+		})
+	}
+}
+
+func TestMacroProcessor_processKey(t *testing.T) {
+	bidRequestValues := map[string]string{
+		MacroPubID: `1234`,
+		MacroTagID: `tagid value`,
+	}
+
+	testMacroValues := map[string]string{
+		MacroPubID:                     `1234`,
+		MacroPubID + macroEscapeSuffix: `1234`,
+		MacroTagID:                     `tagid+value`,
+		MacroTagID + macroEscapeSuffix: `tagid+value`,
+		MacroTagID + macroEscapeSuffix + macroEscapeSuffix: `tagid%2Bvalue`,
+	}
+
+	sampleBidRequest := &openrtb2.BidRequest{
+		Imp: []openrtb2.Imp{
+			{TagID: bidRequestValues[MacroTagID]},
+		},
+		Site: &openrtb2.Site{
+			Publisher: &openrtb2.Publisher{
+				ID: bidRequestValues[MacroPubID],
+			},
+		},
+	}
+	type args struct {
+		cache map[string]string
+		key   string
+	}
+	type want struct {
+		expected string
+		ok       bool
+		cache    map[string]string
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: `emptyKey`,
+			args: args{},
+			want: want{
+				expected: "",
+				ok:       false,
+				cache:    map[string]string{},
+			},
+		},
+		{
+			name: `cachedKeyFound`,
+			args: args{
+				cache: map[string]string{
+					MacroPubID: testMacroValues[MacroPubID],
+				},
+				key: MacroPubID,
+			},
+			want: want{
+				expected: testMacroValues[MacroPubID],
+				ok:       true,
+				cache: map[string]string{
+					MacroPubID: testMacroValues[MacroPubID],
+				},
+			},
+		},
+		{
+			name: `valueFound`,
+			args: args{
+				key: MacroTagID,
+			},
+			want: want{
+				expected: testMacroValues[MacroTagID],
+				ok:       true,
+				cache:    map[string]string{},
+			},
+		},
+		{
+			name: `2TimesEscaping`,
+			args: args{
+				key: MacroTagID + macroEscapeSuffix + macroEscapeSuffix,
+			},
+			want: want{
+				expected: testMacroValues[MacroTagID+macroEscapeSuffix+macroEscapeSuffix],
+				ok:       true,
+				cache:    map[string]string{},
+			},
+		},
+		{
+			name: `macroNotPresent`,
+			args: args{
+				key: `Unknown`,
+			},
+			want: want{
+				expected: "",
+				ok:       false,
+				cache:    map[string]string{},
+			},
+		},
+		{
+			name: `macroNotPresentInEscaping`,
+			args: args{
+				key: `Unknown` + macroEscapeSuffix,
+			},
+			want: want{
+				expected: "",
+				ok:       false,
+				cache:    map[string]string{},
+			},
+		},
+		{
+			name: `cachedKey`,
+			args: args{
+				key: MacroPubID,
+			},
+			want: want{
+				expected: testMacroValues[MacroPubID],
+				ok:       true,
+				cache: map[string]string{
+					MacroPubID: testMacroValues[MacroPubID],
+				},
+			},
+		},
+		{
+			name: `cachedEscapingKey`,
+			args: args{
+				key: MacroPubID + macroEscapeSuffix,
+			},
+			want: want{
+				expected: testMacroValues[MacroPubID+macroEscapeSuffix],
+				ok:       true,
+				cache: map[string]string{
+					MacroPubID + macroEscapeSuffix: testMacroValues[MacroPubID+macroEscapeSuffix],
+				},
+			},
+		},
+		// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			bidderMacro := NewBidderMacro()
+			mapper := GetDefaultMapper()
+			mp := NewMacroProcessor(bidderMacro, mapper)
+
+			//init bidder macro
+			bidderMacro.InitBidRequest(sampleBidRequest)
+			bidderMacro.LoadImpression(&sampleBidRequest.Imp[0])
+
+			//init cache of macro processor
+			if nil != tt.args.cache {
+				mp.macroCache = tt.args.cache
+			}
+
+			actual, ok := mp.processKey(tt.args.key)
+			assert.Equal(t, tt.want.expected, actual)
+			assert.Equal(t, tt.want.ok, ok)
+			assert.Equal(t, tt.want.cache, mp.macroCache)
+		})
+	}
+}
diff --git a/adapters/vastbidder/mapper.go b/adapters/vastbidder/mapper.go
new file mode 100644
index 000000000..f5ff5b3b4
--- /dev/null
+++ b/adapters/vastbidder/mapper.go
@@ -0,0 +1,182 @@
+package vastbidder
+
+type macroCallBack struct {
+	cached   bool
+	escape   bool
+	callback func(IBidderMacro, string) string
+}
+
+// Mapper will map macro with its respective call back function
+type Mapper map[string]*macroCallBack
+
+func (obj Mapper) clone() Mapper {
+	cloned := make(Mapper, len(obj))
+	for k, v := range obj {
+		newCallback := *v
+		cloned[k] = &newCallback
+	}
+	return cloned
+}
+
+var _defaultMapper = Mapper{
+	//Request
+	MacroTest:              &macroCallBack{cached: true, callback: IBidderMacro.MacroTest},
+	MacroTimeout:           &macroCallBack{cached: true, callback: IBidderMacro.MacroTimeout},
+	MacroWhitelistSeat:     &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroWhitelistSeat},
+	MacroWhitelistLang:     &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroWhitelistLang},
+	MacroBlockedSeat:       &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroBlockedSeat},
+	MacroCurrency:          &macroCallBack{cached: true, callback: IBidderMacro.MacroCurrency},
+	MacroBlockedCategory:   &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroBlockedCategory},
+	MacroBlockedAdvertiser: &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroBlockedAdvertiser},
+	MacroBlockedApp:        &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroBlockedApp},
+
+	//Source
+	MacroFD:             &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroFD},
+	MacroTransactionID:  &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroTransactionID},
+	MacroPaymentIDChain: &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroPaymentIDChain},
+
+	//Regs
+	MacroCoppa: &macroCallBack{cached: true, callback: IBidderMacro.MacroCoppa},
+
+	//Impression
+	MacroDisplayManager:        &macroCallBack{cached: false, escape: true, callback: IBidderMacro.MacroDisplayManager},
+	MacroDisplayManagerVersion: &macroCallBack{cached: false, escape: true, callback: IBidderMacro.MacroDisplayManagerVersion},
+	MacroInterstitial:          &macroCallBack{cached: false, callback: IBidderMacro.MacroInterstitial},
+	MacroTagID:                 &macroCallBack{cached: false, escape: true, callback: IBidderMacro.MacroTagID},
+	MacroBidFloor:              &macroCallBack{cached: false, callback: IBidderMacro.MacroBidFloor},
+	MacroBidFloorCurrency:      &macroCallBack{cached: false, callback: IBidderMacro.MacroBidFloorCurrency},
+	MacroSecure:                &macroCallBack{cached: false, callback: IBidderMacro.MacroSecure},
+	MacroPMP:                   &macroCallBack{cached: false, escape: true, callback: IBidderMacro.MacroPMP},
+
+	//Video
+	MacroVideoMIMES:            &macroCallBack{cached: false, escape: true, callback: IBidderMacro.MacroVideoMIMES},
+	MacroVideoMinimumDuration:  &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoMinimumDuration},
+	MacroVideoMaximumDuration:  &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoMaximumDuration},
+	MacroVideoProtocols:        &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoProtocols},
+	MacroVideoPlayerWidth:      &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoPlayerWidth},
+	MacroVideoPlayerHeight:     &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoPlayerHeight},
+	MacroVideoStartDelay:       &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoStartDelay},
+	MacroVideoPlacement:        &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoPlacement},
+	MacroVideoLinearity:        &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoLinearity},
+	MacroVideoSkip:             &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoSkip},
+	MacroVideoSkipMinimum:      &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoSkipMinimum},
+	MacroVideoSkipAfter:        &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoSkipAfter},
+	MacroVideoSequence:         &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoSequence},
+	MacroVideoBlockedAttribute: &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoBlockedAttribute},
+	MacroVideoMaximumExtended:  &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoMaximumExtended},
+	MacroVideoMinimumBitRate:   &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoMinimumBitRate},
+	MacroVideoMaximumBitRate:   &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoMaximumBitRate},
+	MacroVideoBoxing:           &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoBoxing},
+	MacroVideoPlaybackMethod:   &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoPlaybackMethod},
+	MacroVideoDelivery:         &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoDelivery},
+	MacroVideoPosition:         &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoPosition},
+	MacroVideoAPI:              &macroCallBack{cached: false, callback: IBidderMacro.MacroVideoAPI},
+
+	//Site
+	MacroSiteID:       &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroSiteID},
+	MacroSiteName:     &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroSiteName},
+	MacroSitePage:     &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroSitePage},
+	MacroSiteReferrer: &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroSiteReferrer},
+	MacroSiteSearch:   &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroSiteSearch},
+	MacroSiteMobile:   &macroCallBack{cached: true, callback: IBidderMacro.MacroSiteMobile},
+
+	//App
+	MacroAppID:       &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroAppID},
+	MacroAppName:     &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroAppName},
+	MacroAppBundle:   &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroAppBundle},
+	MacroAppStoreURL: &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroAppStoreURL},
+	MacroAppVersion:  &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroAppVersion},
+	MacroAppPaid:     &macroCallBack{cached: true, callback: IBidderMacro.MacroAppPaid},
+
+	//SiteAppCommon
+	MacroCategory:        &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroCategory},
+	MacroDomain:          &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDomain},
+	MacroSectionCategory: &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroSectionCategory},
+	MacroPageCategory:    &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroPageCategory},
+	MacroPrivacyPolicy:   &macroCallBack{cached: true, callback: IBidderMacro.MacroPrivacyPolicy},
+	MacroKeywords:        &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroKeywords},
+
+	//Publisher
+	MacroPubID:     &macroCallBack{cached: true, callback: IBidderMacro.MacroPubID},
+	MacroPubName:   &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroPubName},
+	MacroPubDomain: &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroPubDomain},
+
+	//Content
+	MacroContentID:                 &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentID},
+	MacroContentEpisode:            &macroCallBack{cached: true, callback: IBidderMacro.MacroContentEpisode},
+	MacroContentTitle:              &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentTitle},
+	MacroContentSeries:             &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentSeries},
+	MacroContentSeason:             &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentSeason},
+	MacroContentArtist:             &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentArtist},
+	MacroContentGenre:              &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentGenre},
+	MacroContentAlbum:              &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentAlbum},
+	MacroContentISrc:               &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentISrc},
+	MacroContentURL:                &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentURL},
+	MacroContentCategory:           &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentCategory},
+	MacroContentProductionQuality:  &macroCallBack{cached: true, callback: IBidderMacro.MacroContentProductionQuality},
+	MacroContentVideoQuality:       &macroCallBack{cached: true, callback: IBidderMacro.MacroContentVideoQuality},
+	MacroContentContext:            &macroCallBack{cached: true, callback: IBidderMacro.MacroContentContext},
+	MacroContentContentRating:      &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentContentRating},
+	MacroContentUserRating:         &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentUserRating},
+	MacroContentQAGMediaRating:     &macroCallBack{cached: true, callback: IBidderMacro.MacroContentQAGMediaRating},
+	MacroContentKeywords:           &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentKeywords},
+	MacroContentLiveStream:         &macroCallBack{cached: true, callback: IBidderMacro.MacroContentLiveStream},
+	MacroContentSourceRelationship: &macroCallBack{cached: true, callback: IBidderMacro.MacroContentSourceRelationship},
+	MacroContentLength:             &macroCallBack{cached: true, callback: IBidderMacro.MacroContentLength},
+	MacroContentLanguage:           &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroContentLanguage},
+	MacroContentEmbeddable:         &macroCallBack{cached: true, callback: IBidderMacro.MacroContentEmbeddable},
+
+	//Producer
+	MacroProducerID:   &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroProducerID},
+	MacroProducerName: &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroProducerName},
+
+	//Device
+	MacroUserAgent:       &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroUserAgent},
+	MacroDNT:             &macroCallBack{cached: true, callback: IBidderMacro.MacroDNT},
+	MacroLMT:             &macroCallBack{cached: true, callback: IBidderMacro.MacroLMT},
+	MacroIP:              &macroCallBack{cached: true, callback: IBidderMacro.MacroIP},
+	MacroDeviceType:      &macroCallBack{cached: true, callback: IBidderMacro.MacroDeviceType},
+	MacroMake:            &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroMake},
+	MacroModel:           &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroModel},
+	MacroDeviceOS:        &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDeviceOS},
+	MacroDeviceOSVersion: &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDeviceOSVersion},
+	MacroDeviceWidth:     &macroCallBack{cached: true, callback: IBidderMacro.MacroDeviceWidth},
+	MacroDeviceHeight:    &macroCallBack{cached: true, callback: IBidderMacro.MacroDeviceHeight},
+	MacroDeviceJS:        &macroCallBack{cached: true, callback: IBidderMacro.MacroDeviceJS},
+	MacroDeviceLanguage:  &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDeviceLanguage},
+	MacroDeviceIFA:       &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDeviceIFA},
+	MacroDeviceIFAType:   &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDeviceIFAType},
+	MacroDeviceDIDSHA1:   &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDeviceDIDSHA1},
+	MacroDeviceDIDMD5:    &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDeviceDIDMD5},
+	MacroDeviceDPIDSHA1:  &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDeviceDPIDSHA1},
+	MacroDeviceDPIDMD5:   &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDeviceDPIDMD5},
+	MacroDeviceMACSHA1:   &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDeviceMACSHA1},
+	MacroDeviceMACMD5:    &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroDeviceMACMD5},
+
+	//Geo
+	MacroLatitude:  &macroCallBack{cached: true, callback: IBidderMacro.MacroLatitude},
+	MacroLongitude: &macroCallBack{cached: true, callback: IBidderMacro.MacroLongitude},
+	MacroCountry:   &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroCountry},
+	MacroRegion:    &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroRegion},
+	MacroCity:      &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroCity},
+	MacroZip:       &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroZip},
+	MacroUTCOffset: &macroCallBack{cached: true, callback: IBidderMacro.MacroUTCOffset},
+
+	//User
+	MacroUserID:      &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroUserID},
+	MacroYearOfBirth: &macroCallBack{cached: true, callback: IBidderMacro.MacroYearOfBirth},
+	MacroGender:      &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroGender},
+
+	//Extension
+	MacroGDPRConsent: &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroGDPRConsent},
+	MacroGDPR:        &macroCallBack{cached: true, callback: IBidderMacro.MacroGDPR},
+	MacroUSPrivacy:   &macroCallBack{cached: true, escape: true, callback: IBidderMacro.MacroUSPrivacy},
+
+	//Additional
+	MacroCacheBuster: &macroCallBack{cached: false, callback: IBidderMacro.MacroCacheBuster},
+}
+
+// GetDefaultMapper will return clone of default Mapper function
+func GetDefaultMapper() Mapper {
+	return _defaultMapper.clone()
+}
diff --git a/adapters/vastbidder/sample_spotx_macro.go.bak b/adapters/vastbidder/sample_spotx_macro.go.bak
new file mode 100644
index 000000000..8f3aafbdc
--- /dev/null
+++ b/adapters/vastbidder/sample_spotx_macro.go.bak
@@ -0,0 +1,28 @@
+package vastbidder
+
+import (
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+//SpotxMacro default implementation
+type SpotxMacro struct {
+	*BidderMacro
+}
+
+//NewSpotxMacro contains definition for all openrtb macro's
+func NewSpotxMacro() IBidderMacro {
+	obj := &SpotxMacro{
+		BidderMacro: &BidderMacro{},
+	}
+	obj.IBidderMacro = obj
+	return obj
+}
+
+//GetBidderKeys will set bidder level keys
+func (tag *SpotxMacro) GetBidderKeys() map[string]string {
+	return NormalizeJSON(tag.ImpBidderExt)
+}
+
+func init() {
+	RegisterNewBidderMacro(openrtb_ext.BidderSpotX, NewSpotxMacro)
+}
diff --git a/adapters/vastbidder/tagbidder.go b/adapters/vastbidder/tagbidder.go
new file mode 100644
index 000000000..bf3f4af1b
--- /dev/null
+++ b/adapters/vastbidder/tagbidder.go
@@ -0,0 +1,87 @@
+package vastbidder
+
+import (
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/adapters"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// TagBidder is default implementation of ITagBidder
+type TagBidder struct {
+	adapters.Bidder
+	bidderName    openrtb_ext.BidderName
+	adapterConfig *config.Adapter
+}
+
+// MakeRequests will contains default definition for processing queries
+func (a *TagBidder) MakeRequests(request *openrtb2.BidRequest, reqInfo *adapters.ExtraRequestInfo) ([]*adapters.RequestData, []error) {
+	bidderMacro := GetNewBidderMacro(a.bidderName)
+	bidderMapper := GetDefaultMapper()
+	macroProcessor := NewMacroProcessor(bidderMacro, bidderMapper)
+
+	//Setting config parameters
+	//bidderMacro.SetBidderConfig(a.bidderConfig)
+	bidderMacro.SetAdapterConfig(a.adapterConfig)
+	bidderMacro.InitBidRequest(request)
+
+	requestData := []*adapters.RequestData{}
+	for impIndex := range request.Imp {
+		bidderExt, err := bidderMacro.LoadImpression(&request.Imp[impIndex])
+		if nil != err {
+			continue
+		}
+
+		//iterate each vast tags, and load vast tag
+		for vastTagIndex, tag := range bidderExt.Tags {
+			//load vasttag
+			bidderMacro.LoadVASTTag(tag)
+
+			//Setting Bidder Level Keys
+			bidderKeys := bidderMacro.GetBidderKeys()
+			macroProcessor.SetBidderKeys(bidderKeys)
+
+			uri := macroProcessor.Process(bidderMacro.GetURI())
+
+			// append custom headers if any
+			headers := bidderMacro.getAllHeaders()
+
+			requestData = append(requestData, &adapters.RequestData{
+				Params: &adapters.BidRequestParams{
+					ImpIndex:     impIndex,
+					VASTTagIndex: vastTagIndex,
+				},
+				Method:  `GET`,
+				Uri:     uri,
+				Headers: headers,
+			})
+		}
+	}
+
+	return requestData, nil
+}
+
+// MakeBids makes bids
+func (a *TagBidder) MakeBids(internalRequest *openrtb2.BidRequest, externalRequest *adapters.RequestData, response *adapters.ResponseData) (*adapters.BidderResponse, []error) {
+	//response validation can be done here independently
+	//handler, err := GetResponseHandler(a.bidderConfig.ResponseType)
+	handler, err := GetResponseHandler(VASTTagHandlerType)
+	if nil != err {
+		return nil, []error{err}
+	}
+	return handler.MakeBids(internalRequest, externalRequest, response)
+}
+
+// NewTagBidder is an constructor for TagBidder
+func NewTagBidder(bidderName openrtb_ext.BidderName, config config.Adapter) *TagBidder {
+	obj := &TagBidder{
+		bidderName:    bidderName,
+		adapterConfig: &config,
+	}
+	return obj
+}
+
+// Builder builds a new instance of the 33Across adapter for the given bidder with the given config.
+func Builder(bidderName openrtb_ext.BidderName, config config.Adapter, _ config.Server) (adapters.Bidder, error) {
+	return NewTagBidder(bidderName, config), nil
+}
diff --git a/adapters/vastbidder/tagbidder_test.go b/adapters/vastbidder/tagbidder_test.go
new file mode 100644
index 000000000..253477eed
--- /dev/null
+++ b/adapters/vastbidder/tagbidder_test.go
@@ -0,0 +1,150 @@
+package vastbidder
+
+import (
+	"net/http"
+	"testing"
+
+	"github.com/prebid/openrtb/v19/adcom1"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+)
+
+// TestMakeRequests verifies
+// 1. default and custom headers are set
+func TestMakeRequests(t *testing.T) {
+
+	type args struct {
+		customHeaders map[string]string
+		req           *openrtb2.BidRequest
+	}
+	type want struct {
+		impIDReqHeaderMap map[string]http.Header
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "multi_impression_req",
+			args: args{
+				customHeaders: map[string]string{
+					"my-custom-header": "custom-value",
+				},
+				req: &openrtb2.BidRequest{
+					Device: &openrtb2.Device{
+						IP:       "1.1.1.1",
+						UA:       "user-agent",
+						Language: "en",
+					},
+					Site: &openrtb2.Site{
+						Page: "http://test.com/",
+					},
+					Imp: []openrtb2.Imp{
+						{ // vast 2.0
+							ID: "vast_2_0_imp_req",
+							Video: &openrtb2.Video{
+								Protocols: []adcom1.MediaCreativeSubtype{
+									adcom1.CreativeVAST20,
+								},
+							},
+							Ext: []byte(`{"bidder" :{}}`),
+						},
+						{
+							ID: "vast_4_0_imp_req",
+							Video: &openrtb2.Video{ // vast 4.0
+								Protocols: []adcom1.MediaCreativeSubtype{
+									adcom1.CreativeVAST40,
+								},
+							},
+							Ext: []byte(`{"bidder" :{}}`),
+						},
+						{
+							ID: "vast_2_0_4_0_wrapper_imp_req",
+							Video: &openrtb2.Video{ // vast 2 and 4.0 wrapper
+								Protocols: []adcom1.MediaCreativeSubtype{
+									adcom1.CreativeVAST40Wrapper,
+									adcom1.CreativeVAST20,
+								},
+							},
+							Ext: []byte(`{"bidder" :{}}`),
+						},
+						{
+							ID: "other_non_vast_protocol",
+							Video: &openrtb2.Video{ // DAAST 1.0
+								Protocols: []adcom1.MediaCreativeSubtype{
+									adcom1.CreativeDAAST10,
+								},
+							},
+							Ext: []byte(`{"bidder" :{}}`),
+						},
+						{
+
+							ID: "no_protocol_field_set",
+							Video: &openrtb2.Video{ // vast 2 and 4.0 wrapper
+								Protocols: []adcom1.MediaCreativeSubtype{},
+							},
+							Ext: []byte(`{"bidder" :{}}`),
+						},
+					},
+				},
+			},
+			want: want{
+				impIDReqHeaderMap: map[string]http.Header{
+					"vast_2_0_imp_req": {
+						"X-Forwarded-For":  []string{"1.1.1.1"},
+						"User-Agent":       []string{"user-agent"},
+						"My-Custom-Header": []string{"custom-value"},
+					},
+					"vast_4_0_imp_req": {
+						"X-Device-Ip":              []string{"1.1.1.1"},
+						"X-Device-User-Agent":      []string{"user-agent"},
+						"X-Device-Referer":         []string{"http://test.com/"},
+						"X-Device-Accept-Language": []string{"en"},
+						"My-Custom-Header":         []string{"custom-value"},
+					},
+					"vast_2_0_4_0_wrapper_imp_req": {
+						"X-Device-Ip":              []string{"1.1.1.1"},
+						"X-Forwarded-For":          []string{"1.1.1.1"},
+						"X-Device-User-Agent":      []string{"user-agent"},
+						"User-Agent":               []string{"user-agent"},
+						"X-Device-Referer":         []string{"http://test.com/"},
+						"X-Device-Accept-Language": []string{"en"},
+						"My-Custom-Header":         []string{"custom-value"},
+					},
+					"other_non_vast_protocol": {
+						"My-Custom-Header": []string{"custom-value"},
+					}, // no default headers expected
+					"no_protocol_field_set": { // set all default headers
+						"X-Device-Ip":              []string{"1.1.1.1"},
+						"X-Forwarded-For":          []string{"1.1.1.1"},
+						"X-Device-User-Agent":      []string{"user-agent"},
+						"User-Agent":               []string{"user-agent"},
+						"X-Device-Referer":         []string{"http://test.com/"},
+						"X-Device-Accept-Language": []string{"en"},
+						"My-Custom-Header":         []string{"custom-value"},
+					},
+				},
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			bidderName := openrtb_ext.BidderName("myVastBidderMacro")
+			RegisterNewBidderMacro(bidderName, func() IBidderMacro {
+				return newMyVastBidderMacro(tt.args.customHeaders)
+			})
+			bidder := NewTagBidder(bidderName, config.Adapter{})
+			reqData, err := bidder.MakeRequests(tt.args.req, nil)
+			assert.Nil(t, err)
+			for _, req := range reqData {
+				impID := tt.args.req.Imp[req.Params.ImpIndex].ID
+				expectedHeaders := tt.want.impIDReqHeaderMap[impID]
+				assert.Equal(t, expectedHeaders, req.Headers, "test for - "+impID)
+			}
+		})
+	}
+}
diff --git a/adapters/vastbidder/util.go b/adapters/vastbidder/util.go
new file mode 100644
index 000000000..8ad02535e
--- /dev/null
+++ b/adapters/vastbidder/util.go
@@ -0,0 +1,70 @@
+package vastbidder
+
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"math/rand"
+	"strconv"
+
+	"github.com/prebid/prebid-server/adapters"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func ObjectArrayToString(len int, separator string, cb func(i int) string) string {
+	if 0 == len {
+		return ""
+	}
+
+	var out bytes.Buffer
+	for i := 0; i < len; i++ {
+		if out.Len() > 0 {
+			out.WriteString(separator)
+		}
+		out.WriteString(cb(i))
+	}
+	return out.String()
+}
+
+func readImpExt(impExt json.RawMessage) (*openrtb_ext.ExtImpVASTBidder, error) {
+	var bidderExt adapters.ExtImpBidder
+	if err := json.Unmarshal(impExt, &bidderExt); err != nil {
+		return nil, err
+	}
+
+	vastBidderExt := openrtb_ext.ExtImpVASTBidder{}
+	if err := json.Unmarshal(bidderExt.Bidder, &vastBidderExt); err != nil {
+		return nil, err
+	}
+	return &vastBidderExt, nil
+}
+
+func normalizeObject(prefix string, out map[string]string, obj map[string]interface{}) {
+	for k, value := range obj {
+		key := k
+		if len(prefix) > 0 {
+			key = prefix + "." + k
+		}
+
+		switch val := value.(type) {
+		case string:
+			out[key] = val
+		case []interface{}: //array
+			continue
+		case map[string]interface{}: //object
+			normalizeObject(key, out, val)
+		default: //all int, float
+			out[key] = fmt.Sprint(value)
+		}
+	}
+}
+
+func NormalizeJSON(obj map[string]interface{}) map[string]string {
+	out := map[string]string{}
+	normalizeObject("", out, obj)
+	return out
+}
+
+var GetRandomID = func() string {
+	return strconv.FormatInt(rand.Int63(), intBase)
+}
diff --git a/adapters/vastbidder/vast_tag_response_handler.go b/adapters/vastbidder/vast_tag_response_handler.go
new file mode 100644
index 000000000..38b149a91
--- /dev/null
+++ b/adapters/vastbidder/vast_tag_response_handler.go
@@ -0,0 +1,347 @@
+package vastbidder
+
+import (
+	"encoding/json"
+	"errors"
+	"net/http"
+	"regexp"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/beevik/etree"
+	"github.com/golang/glog"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/adapters"
+	"github.com/prebid/prebid-server/errortypes"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+var durationRegExp = regexp.MustCompile(`^([01]?\d|2[0-3]):([0-5]?\d):([0-5]?\d)(\.(\d{1,3}))?$`)
+
+// IVASTTagResponseHandler to parse VAST Tag
+type IVASTTagResponseHandler interface {
+	ITagResponseHandler
+	ParseExtension(version string, tag *etree.Element, bid *adapters.TypedBid) []error
+	GetStaticPrice(ext json.RawMessage) float64
+}
+
+// VASTTagResponseHandler to parse VAST Tag
+type VASTTagResponseHandler struct {
+	IVASTTagResponseHandler
+	ImpBidderExt *openrtb_ext.ExtImpVASTBidder
+	VASTTag      *openrtb_ext.ExtImpVASTBidderTag
+}
+
+// NewVASTTagResponseHandler returns new object
+func NewVASTTagResponseHandler() *VASTTagResponseHandler {
+	obj := &VASTTagResponseHandler{}
+	obj.IVASTTagResponseHandler = obj
+	return obj
+}
+
+// Validate will return bids
+func (handler *VASTTagResponseHandler) Validate(internalRequest *openrtb2.BidRequest, externalRequest *adapters.RequestData, response *adapters.ResponseData) []error {
+	if response.StatusCode != http.StatusOK {
+		return []error{errors.New(`validation failed`)}
+	}
+
+	if len(internalRequest.Imp) < externalRequest.Params.ImpIndex {
+		return []error{errors.New(`validation failed invalid impression index`)}
+	}
+
+	impExt, err := readImpExt(internalRequest.Imp[externalRequest.Params.ImpIndex].Ext)
+	if nil != err {
+		return []error{err}
+	}
+
+	if len(impExt.Tags) < externalRequest.Params.VASTTagIndex {
+		return []error{errors.New(`validation failed invalid vast tag index`)}
+	}
+
+	//Initialise Extensions
+	handler.ImpBidderExt = impExt
+	handler.VASTTag = impExt.Tags[externalRequest.Params.VASTTagIndex]
+	return nil
+}
+
+// MakeBids will return bids
+func (handler *VASTTagResponseHandler) MakeBids(internalRequest *openrtb2.BidRequest, externalRequest *adapters.RequestData, response *adapters.ResponseData) (*adapters.BidderResponse, []error) {
+	if err := handler.IVASTTagResponseHandler.Validate(internalRequest, externalRequest, response); len(err) > 0 {
+		return nil, err[:]
+	}
+
+	bidResponses, err := handler.vastTagToBidderResponse(internalRequest, externalRequest, response)
+	return bidResponses, err
+}
+
+// ParseExtension will parse VAST XML extension object
+func (handler *VASTTagResponseHandler) ParseExtension(version string, ad *etree.Element, bid *adapters.TypedBid) []error {
+	return nil
+}
+
+func (handler *VASTTagResponseHandler) vastTagToBidderResponse(internalRequest *openrtb2.BidRequest, externalRequest *adapters.RequestData, response *adapters.ResponseData) (*adapters.BidderResponse, []error) {
+	var errs []error
+
+	doc := etree.NewDocument()
+
+	//Read Document
+	if err := doc.ReadFromBytes(response.Body); err != nil {
+		errs = append(errs, err)
+		return nil, errs[:]
+	}
+
+	//Check VAST Tag
+	vast := doc.Element.FindElement(`./VAST`)
+	if vast == nil {
+		errs = append(errs, errors.New("VAST Tag Not Found"))
+		return nil, errs[:]
+	}
+
+	//Check VAST/Ad Tag
+	adElement := getAdElement(vast)
+	if nil == adElement {
+		errs = append(errs, errors.New("VAST/Ad Tag Not Found"))
+		return nil, errs[:]
+	}
+
+	typedBid := &adapters.TypedBid{
+		Bid:     &openrtb2.Bid{},
+		BidType: openrtb_ext.BidTypeVideo,
+		BidVideo: &openrtb_ext.ExtBidPrebidVideo{
+			VASTTagID: handler.VASTTag.TagID,
+		},
+	}
+
+	creatives := adElement.FindElements("Creatives/Creative")
+	if nil != creatives {
+		for _, creative := range creatives {
+			// get creative id
+			typedBid.Bid.CrID = getCreativeID(creative)
+
+			// get duration from vast creative
+			dur, err := getDuration(creative)
+			if nil != err {
+				// get duration from input bidder vast tag
+				dur = getStaticDuration(handler.VASTTag)
+			}
+			if dur > 0 {
+				typedBid.BidVideo.Duration = int(dur) // prebid expects int value
+			}
+		}
+	}
+
+	bidResponse := &adapters.BidderResponse{
+		Bids:     []*adapters.TypedBid{typedBid},
+		Currency: `USD`, //TODO: Need to check how to get currency value
+	}
+
+	//GetVersion
+	version := vast.SelectAttrValue(`version`, `2.0`)
+
+	if err := handler.IVASTTagResponseHandler.ParseExtension(version, adElement, typedBid); len(err) > 0 {
+		errs = append(errs, err...)
+		return nil, errs[:]
+	}
+
+	//if bid.price is not set in ParseExtension
+	if typedBid.Bid.Price <= 0 {
+		price, currency := getPricingDetails(version, adElement)
+		if price <= 0 {
+			price, currency = getStaticPricingDetails(handler.VASTTag)
+			if price <= 0 {
+				errs = append(errs, &errortypes.NoBidPrice{Message: "Bid Price Not Present"})
+				return nil, errs[:]
+			}
+		}
+		typedBid.Bid.Price = price
+		if len(currency) > 0 {
+			bidResponse.Currency = currency
+		}
+	}
+
+	typedBid.Bid.ADomain = getAdvertisers(version, adElement)
+
+	//if bid.id is not set in ParseExtension
+	if len(typedBid.Bid.ID) == 0 {
+		typedBid.Bid.ID = GetRandomID()
+	}
+
+	//if bid.impid is not set in ParseExtension
+	if len(typedBid.Bid.ImpID) == 0 {
+		typedBid.Bid.ImpID = internalRequest.Imp[externalRequest.Params.ImpIndex].ID
+	}
+
+	//if bid.adm is not set in ParseExtension
+	if len(typedBid.Bid.AdM) == 0 {
+		typedBid.Bid.AdM = string(response.Body)
+	}
+
+	//if bid.CrID is not set in ParseExtension
+	if len(typedBid.Bid.CrID) == 0 {
+		typedBid.Bid.CrID = "cr_" + GetRandomID()
+	}
+
+	// set vastTagId in bid.Ext
+	bidExt := openrtb_ext.ExtBid{
+		Prebid: &openrtb_ext.ExtBidPrebid{
+			Video: typedBid.BidVideo,
+			Type:  typedBid.BidType,
+		},
+	}
+
+	bidExtBytes, err := json.Marshal(bidExt)
+	if err == nil {
+		typedBid.Bid.Ext = bidExtBytes
+	}
+
+	return bidResponse, nil
+}
+
+func getAdElement(vast *etree.Element) *etree.Element {
+	if ad := vast.FindElement(`./Ad/Wrapper`); nil != ad {
+		return ad
+	}
+	if ad := vast.FindElement(`./Ad/InLine`); nil != ad {
+		return ad
+	}
+	return nil
+}
+
+func getAdvertisers(vastVer string, ad *etree.Element) []string {
+	version, err := strconv.ParseFloat(vastVer, 64)
+	if err != nil {
+		version = 2.0
+	}
+
+	advertisers := make([]string, 0)
+
+	switch int(version) {
+	case 2, 3:
+		for _, ext := range ad.FindElements(`./Extensions/Extension/`) {
+			for _, attr := range ext.Attr {
+				if attr.Key == "type" && attr.Value == "advertiser" {
+					for _, ele := range ext.ChildElements() {
+						if ele.Tag == "Advertiser" {
+							if strings.TrimSpace(ele.Text()) != "" {
+								advertisers = append(advertisers, ele.Text())
+							}
+						}
+					}
+				}
+			}
+		}
+	case 4:
+		if ad.FindElement("./Advertiser") != nil {
+			adv := strings.TrimSpace(ad.FindElement("./Advertiser").Text())
+			if adv != "" {
+				advertisers = append(advertisers, adv)
+			}
+		}
+	default:
+		glog.V(3).Infof("Handle getAdvertisers for VAST version %d", int(version))
+	}
+
+	if len(advertisers) == 0 {
+		return nil
+	}
+	return advertisers
+}
+
+func getStaticPricingDetails(vastTag *openrtb_ext.ExtImpVASTBidderTag) (float64, string) {
+	if nil == vastTag {
+		return 0.0, ""
+	}
+	return vastTag.Price, "USD"
+}
+
+func getPricingDetails(version string, ad *etree.Element) (float64, string) {
+	var currency string
+	var node *etree.Element
+
+	if version == `2.0` {
+		node = ad.FindElement(`./Extensions/Extension/Price`)
+	} else {
+		node = ad.FindElement(`./Pricing`)
+	}
+
+	if node == nil {
+		return 0.0, currency
+	}
+
+	priceValue, err := strconv.ParseFloat(node.Text(), 64)
+	if nil != err {
+		return 0.0, currency
+	}
+
+	currencyNode := node.SelectAttr(`currency`)
+	if nil != currencyNode {
+		currency = currencyNode.Value
+	}
+
+	return priceValue, currency
+}
+
+// getDuration extracts the duration of the bid from input creative of Linear type.
+// The lookup may vary from vast version provided in the input
+// returns duration in seconds or error if failed to obtained the duration.
+// If multple Linear tags are present, onlyfirst one will be used
+//
+// It will lookup for duration only in case of creative type is Linear.
+// If creative type other than Linear then this function will return error
+// For Linear Creative it will lookup for Duration attribute.Duration value will be in hh:mm:ss.mmm format as per VAST specifications
+// If Duration attribute not present this will return error
+//
+// # After extracing the duration it will convert it into seconds
+//
+// The ad server uses the <Duration> element to denote
+// the intended playback duration for the video or audio component of the ad.
+// Time value may be in the format HH:MM:SS.mmm where .mmm indicates milliseconds.
+// Providing milliseconds is optional.
+//
+// Reference
+// 1.https://iabtechlab.com/wp-content/uploads/2019/06/VAST_4.2_final_june26.pdf
+// 2.https://iabtechlab.com/wp-content/uploads/2018/11/VAST4.1-final-Nov-8-2018.pdf
+// 3.https://iabtechlab.com/wp-content/uploads/2016/05/VAST4.0_Updated_April_2016.pdf
+// 4.https://iabtechlab.com/wp-content/uploads/2016/04/VASTv3_0.pdf
+func getDuration(creative *etree.Element) (int, error) {
+	if nil == creative {
+		return 0, errors.New("Invalid Creative")
+	}
+	node := creative.FindElement("./Linear/Duration")
+	if nil == node {
+		return 0, errors.New("Invalid Duration")
+	}
+	duration := node.Text()
+	// check if milliseconds is provided
+	match := durationRegExp.FindStringSubmatch(duration)
+	if nil == match {
+		return 0, errors.New("Invalid Duration")
+	}
+	repl := "${1}h${2}m${3}s"
+	ms := match[5]
+	if "" != ms {
+		repl += "${5}ms"
+	}
+	duration = durationRegExp.ReplaceAllString(duration, repl)
+	dur, err := time.ParseDuration(duration)
+	if err != nil {
+		return 0, err
+	}
+	return int(dur.Seconds()), nil
+}
+
+func getStaticDuration(vastTag *openrtb_ext.ExtImpVASTBidderTag) int {
+	if nil == vastTag {
+		return 0
+	}
+	return vastTag.Duration
+}
+
+// getCreativeID looks for ID inside input creative tag
+func getCreativeID(creative *etree.Element) string {
+	if nil == creative {
+		return ""
+	}
+	return creative.SelectAttrValue("id", "")
+}
diff --git a/adapters/vastbidder/vast_tag_response_handler_test.go b/adapters/vastbidder/vast_tag_response_handler_test.go
new file mode 100644
index 000000000..59cbae2ea
--- /dev/null
+++ b/adapters/vastbidder/vast_tag_response_handler_test.go
@@ -0,0 +1,387 @@
+package vastbidder
+
+import (
+	"encoding/json"
+	"errors"
+	"fmt"
+	"sort"
+	"testing"
+
+	"github.com/beevik/etree"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/adapters"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestVASTTagResponseHandler_vastTagToBidderResponse(t *testing.T) {
+	type args struct {
+		internalRequest *openrtb2.BidRequest
+		externalRequest *adapters.RequestData
+		response        *adapters.ResponseData
+		vastTag         *openrtb_ext.ExtImpVASTBidderTag
+	}
+	type want struct {
+		bidderResponse *adapters.BidderResponse
+		err            []error
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: `InlinePricingNode`,
+			args: args{
+				internalRequest: &openrtb2.BidRequest{
+					ID: `request_id_1`,
+					Imp: []openrtb2.Imp{
+						{
+							ID: `imp_id_1`,
+						},
+					},
+				},
+				externalRequest: &adapters.RequestData{
+					Params: &adapters.BidRequestParams{
+						ImpIndex: 0,
+					},
+				},
+				response: &adapters.ResponseData{
+					Body: []byte(`<VAST version="2.0"> <Ad id="1"> <InLine> <Creatives> <Creative sequence="1"> <Linear> <MediaFiles> <MediaFile><![CDATA[ad.mp4]]></MediaFile> </MediaFiles> </Linear> </Creative> </Creatives> <Extensions> <Extension type="LR-Pricing"> <Price model="CPM" currency="USD"><![CDATA[0.05]]></Price> </Extension> </Extensions> </InLine> </Ad> </VAST>`),
+				},
+				vastTag: &openrtb_ext.ExtImpVASTBidderTag{
+					TagID:    "101",
+					Duration: 15,
+				},
+			},
+			want: want{
+				bidderResponse: &adapters.BidderResponse{
+					Bids: []*adapters.TypedBid{
+						{
+							Bid: &openrtb2.Bid{
+								ID:    `1234`,
+								ImpID: `imp_id_1`,
+								Price: 0.05,
+								AdM:   `<VAST version="2.0"> <Ad id="1"> <InLine> <Creatives> <Creative sequence="1"> <Linear> <MediaFiles> <MediaFile><![CDATA[ad.mp4]]></MediaFile> </MediaFiles> </Linear> </Creative> </Creatives> <Extensions> <Extension type="LR-Pricing"> <Price model="CPM" currency="USD"><![CDATA[0.05]]></Price> </Extension> </Extensions> </InLine> </Ad> </VAST>`,
+								CrID:  "cr_1234",
+								Ext:   json.RawMessage(`{"prebid":{"type":"video","video":{"duration":15,"primary_category":"","vasttagid":"101"}}}`),
+							},
+							BidType: openrtb_ext.BidTypeVideo,
+							BidVideo: &openrtb_ext.ExtBidPrebidVideo{
+								VASTTagID: "101",
+								Duration:  15,
+							},
+						},
+					},
+					Currency: `USD`,
+				},
+			},
+		},
+		// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			handler := NewVASTTagResponseHandler()
+			GetRandomID = func() string {
+				return `1234`
+			}
+			handler.VASTTag = tt.args.vastTag
+
+			bidderResponse, err := handler.vastTagToBidderResponse(tt.args.internalRequest, tt.args.externalRequest, tt.args.response)
+			assert.Equal(t, tt.want.bidderResponse, bidderResponse)
+			assert.Equal(t, tt.want.err, err)
+		})
+	}
+}
+
+// TestGetDurationInSeconds ...
+// hh:mm:ss.mmm => 3:40:43.5 => 3 hours, 40 minutes, 43 seconds and 5 milliseconds
+// => 3*60*60 + 40*60 + 43 + 5*0.001 => 10800 + 2400 + 43 + 0.005 => 13243.005
+func TestGetDurationInSeconds(t *testing.T) {
+	type args struct {
+		creativeTag string // ad element
+	}
+	type want struct {
+		duration int // seconds  (will converted from string with format as  HH:MM:SS.mmm)
+		err      error
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		// duration validation tests
+		{name: "duration 00:00:25 (= 25 seconds)", want: want{duration: 25}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>00:00:25</Duration> </Linear> </Creative>`}},
+		{name: "duration 00:00:-25 (= -25 seconds)", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>00:00:-25</Duration> </Linear> </Creative>`}},
+		{name: "duration 00:00:30.999 (= 30.990 seconds (int -> 30 seconds))", want: want{duration: 30}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>00:00:30.999</Duration> </Linear> </Creative>`}},
+		{name: "duration 00:01:08 (1 min 8 seconds = 68 seconds)", want: want{duration: 68}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>00:01:08</Duration> </Linear> </Creative>`}},
+		{name: "duration 02:13:12 (2 hrs 13 min  12 seconds) = 7992 seconds)", want: want{duration: 7992}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>02:13:12</Duration> </Linear> </Creative>`}},
+		{name: "duration 3:40:43.5 (3 hrs 40 min  43 seconds 5 ms) = 6043.005 seconds (int -> 6043 seconds))", want: want{duration: 13243}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>3:40:43.5</Duration> </Linear> </Creative>`}},
+		{name: "duration 00:00:25.0005458 (0 hrs 0 min  25 seconds 0005458 ms) - invalid max ms is 999", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>00:00:25.0005458</Duration> </Linear> </Creative>`}},
+		{name: "invalid duration 3:13:900 (3 hrs 13 min  900 seconds) = Invalid seconds )", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>3:13:900</Duration> </Linear> </Creative>`}},
+		{name: "invalid duration 3:13:34:44 (3 hrs 13 min 34 seconds :44=invalid) = ?? )", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>3:13:34:44</Duration> </Linear> </Creative>`}},
+		{name: "duration = 0:0:45.038 , with milliseconds duration (0 hrs 0 min 45 seconds and 038 millseconds) = 45.038 seconds (int -> 45 seconds) )", want: want{duration: 45}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>0:0:45.038</Duration> </Linear> </InLine> </Creative>`}},
+		{name: "duration = 0:0:48.50  = 48.050 seconds (int -> 48 seconds))", want: want{duration: 48}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>0:0:48.50</Duration> </Linear> </InLine> </Creative>`}},
+		{name: "duration = 0:0:28.59  = 28.059 seconds  (int -> 28 seconds))", want: want{duration: 28}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>0:0:28.59</Duration> </Linear> </InLine> </Creative>`}},
+		{name: "duration = 56 (ambiguity w.r.t. HH:MM:SS.mmm format)", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>56</Duration> </Linear> </Creative>`}},
+		{name: "duration = :56 (ambiguity w.r.t. HH:MM:SS.mmm format)", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>:56</Duration> </Linear> </Creative>`}},
+		{name: "duration = :56: (ambiguity w.r.t. HH:MM:SS.mmm format)", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>:56:</Duration> </Linear> </Creative>`}},
+		{name: "duration = ::56 (ambiguity w.r.t. HH:MM:SS.mmm format)", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>::56</Duration> </Linear> </Creative>`}},
+		{name: "duration = 56.445 (ambiguity w.r.t. HH:MM:SS.mmm format)", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>56.445</Duration> </Linear> </Creative>`}},
+		{name: "duration = a:b:c.d (no numbers)", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative sequence="1"> <Linear> <Duration>a:b:c.d</Duration> </Linear> </Creative>`}},
+
+		// tag validations tests
+		{name: "Linear Creative no duration", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative><Linear><Linear></Creative>`}},
+		{name: "Companion Creative no duration", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative><CompanionAds></CompanionAds></Creative>`}},
+		{name: "Non-Linear Creative no duration", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative><NonLinearAds></NonLinearAds></Creative>`}},
+		{name: "Invalid Creative tag", want: want{err: errors.New("Invalid Creative")}, args: args{creativeTag: `<Ad></Ad>`}},
+		{name: "Nil Creative tag", want: want{err: errors.New("Invalid Creative")}, args: args{creativeTag: ""}},
+
+		// multiple linear tags in creative
+		{name: "Multiple Linear Ads within Creative", want: want{duration: 25}, args: args{creativeTag: `<Creative><Linear><Duration>0:0:25<Duration></Linear><Linear><Duration>0:0:30<Duration></Linear></Creative>`}},
+		// Case sensitivity check - passing DURATION (vast is case-sensitive as per https://vastvalidator.iabtechlab.com/dash)
+		{name: "<DURATION> all caps", want: want{err: errors.New("Invalid Duration")}, args: args{creativeTag: `<Creative><Linear><DURATION>0:0:10</Duration></Linear></Creative>`}},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			doc := etree.NewDocument()
+			doc.ReadFromString(tt.args.creativeTag)
+			dur, err := getDuration(doc.FindElement("./Creative"))
+			assert.Equal(t, tt.want.duration, dur)
+			assert.Equal(t, tt.want.err, err)
+			// if error expects 0 value for duration
+			if nil != err {
+				assert.Equal(t, 0, dur)
+			}
+		})
+	}
+}
+
+func BenchmarkGetDuration(b *testing.B) {
+	doc := etree.NewDocument()
+	doc.ReadFromString(`<Creative sequence="1"> <Linear> <Duration>0:0:56.3</Duration> </Linear> </Creative>`)
+	creative := doc.FindElement("/Creative")
+	for n := 0; n < b.N; n++ {
+		getDuration(creative)
+	}
+}
+
+func TestGetCreativeId(t *testing.T) {
+	type args struct {
+		creativeTag string // ad element
+	}
+	type want struct {
+		id string
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{name: "creative tag with id", want: want{id: "233ff44"}, args: args{creativeTag: `<Creative id="233ff44"></Creative>`}},
+		{name: "creative tag without id", want: want{id: ""}, args: args{creativeTag: `<Creative></Creative>`}},
+		{name: "no creative tag", want: want{id: ""}, args: args{creativeTag: ""}},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			doc := etree.NewDocument()
+			doc.ReadFromString(tt.args.creativeTag)
+			id := getCreativeID(doc.FindElement("./Creative"))
+			assert.Equal(t, tt.want.id, id)
+		})
+	}
+}
+
+func BenchmarkGetCreativeID(b *testing.B) {
+	doc := etree.NewDocument()
+	doc.ReadFromString(`<Creative id="132324eerr">  </Creative>`)
+	creative := doc.FindElement("/Creative")
+	for n := 0; n < b.N; n++ {
+		getCreativeID(creative)
+	}
+}
+
+func TestGetAdvertisers(t *testing.T) {
+	tt := []struct {
+		name     string
+		vastStr  string
+		expected []string
+	}{
+		{
+			name: "vast_4_with_advertiser",
+			vastStr: `<VAST version="4.2" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.iab.com/VAST">
+  						<Ad id="20001" sequence="1" >
+    						<InLine>
+      							<Advertiser>www.iabtechlab.com</Advertiser>
+    						</InLine>
+  						</Ad>
+					  </VAST>`,
+			expected: []string{"www.iabtechlab.com"},
+		},
+		{
+			name: "vast_4_without_advertiser",
+			vastStr: `<VAST version="4.2" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.iab.com/VAST">
+  						<Ad id="20001" sequence="1" >
+    						<InLine>
+    						</InLine>
+  						</Ad>
+					  </VAST>`,
+			expected: []string{},
+		},
+		{
+			name: "vast_4_with_empty_advertiser",
+			vastStr: `<VAST version="4.2" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.iab.com/VAST">
+  						<Ad id="20001" sequence="1" >
+    						<InLine>
+								<Advertiser></Advertiser>
+    						</InLine>
+  						</Ad>
+					  </VAST>`,
+			expected: []string{},
+		},
+		{
+			name: "vast_2_with_single_advertiser",
+			vastStr: `<VAST version="2.0" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.iab.com/VAST">
+  						<Ad id="20001" sequence="1" >
+    						<InLine>
+								<Extensions>
+									<Extension type="advertiser">
+										<Advertiser>google.com</Advertiser>
+									</Extension>
+								</Extensions>
+    						</InLine>
+  						</Ad>
+					  </VAST>`,
+			expected: []string{"google.com"},
+		},
+		{
+			name: "vast_2_with_two_advertiser",
+			vastStr: `<VAST version="2.0" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.iab.com/VAST">
+  						<Ad id="20001" sequence="1" >
+    						<InLine>
+								<Extensions>
+									<Extension type="advertiser">
+										<Advertiser>google.com</Advertiser>
+									</Extension>
+									<Extension type="advertiser">
+										<Advertiser>facebook.com</Advertiser>
+									</Extension>
+								</Extensions>
+    						</InLine>
+  						</Ad>
+					  </VAST>`,
+			expected: []string{"google.com", "facebook.com"},
+		},
+		{
+			name: "vast_2_with_no_advertiser",
+			vastStr: `<VAST version="2.0" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.iab.com/VAST">
+  						<Ad id="20001" sequence="1" >
+    						<InLine>
+    						</InLine>
+  						</Ad>
+					  </VAST>`,
+			expected: []string{},
+		},
+		{
+			name: "vast_2_with_epmty_advertiser",
+			vastStr: `<VAST version="2.0" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.iab.com/VAST">
+  						<Ad id="20001" sequence="1" >
+    						<InLine>
+								<Extensions>
+									<Extension type="advertiser">
+										<Advertiser></Advertiser>
+									</Extension>
+								</Extensions>
+    						</InLine>
+  						</Ad>
+					  </VAST>`,
+			expected: []string{},
+		},
+		{
+			name: "vast_3_with_single_advertiser",
+			vastStr: `<VAST version="3.1" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.iab.com/VAST">
+  						<Ad id="20001" sequence="1" >
+    						<InLine>
+								<Extensions>
+									<Extension type="advertiser">
+										<Advertiser>google.com</Advertiser>
+									</Extension>
+								</Extensions>
+    						</InLine>
+  						</Ad>
+					  </VAST>`,
+			expected: []string{"google.com"},
+		},
+		{
+			name: "vast_3_with_two_advertiser",
+			vastStr: `<VAST version="3.2" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.iab.com/VAST">
+  						<Ad id="20001" sequence="1" >
+    						<InLine>
+								<Extensions>
+									<Extension type="advertiser">
+										<Advertiser>google.com</Advertiser>
+									</Extension>
+									<Extension type="advertiser">
+										<Advertiser>facebook.com</Advertiser>
+									</Extension>
+								</Extensions>
+    						</InLine>
+  						</Ad>
+					  </VAST>`,
+			expected: []string{"google.com", "facebook.com"},
+		},
+		{
+			name: "vast_3_with_no_advertiser",
+			vastStr: `<VAST version="3.0" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.iab.com/VAST">
+  						<Ad id="20001" sequence="1" >
+    						<InLine>
+    						</InLine>
+  						</Ad>
+					  </VAST>`,
+			expected: []string{},
+		},
+		{
+			name: "vast_3_with_epmty_advertiser",
+			vastStr: `<VAST version="3.1" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.iab.com/VAST">
+  						<Ad id="20001" sequence="1" >
+    						<InLine>
+								<Extensions>
+									<Extension type="advertiser">
+										<Advertiser></Advertiser>
+									</Extension>
+								</Extensions>
+    						</InLine>
+  						</Ad>
+					  </VAST>`,
+			expected: []string{},
+		},
+	}
+
+	for _, tc := range tt {
+		t.Run(tc.name, func(t *testing.T) {
+
+			doc := etree.NewDocument()
+			if err := doc.ReadFromString(tc.vastStr); err != nil {
+				t.Errorf("Failed to create etree doc from string %+v", err)
+			}
+
+			vastDoc := doc.FindElement("./VAST")
+			vastVer := vastDoc.SelectAttrValue(`version`, `2.0`)
+
+			ad := getAdElement(vastDoc)
+
+			result := getAdvertisers(vastVer, ad)
+
+			sort.Strings(result)
+			sort.Strings(tc.expected)
+
+			if !assert.Equal(t, len(tc.expected), len(result), fmt.Sprintf("Expected slice length - %+v \nResult slice length - %+v", len(tc.expected), len(result))) {
+				return
+			}
+
+			for i, expected := range tc.expected {
+				assert.Equal(t, expected, result[i], fmt.Sprintf("Element mismatch at position %d.\nExpected - %s\nActual - %s", i, expected, result[i]))
+			}
+		})
+	}
+}
diff --git a/analytics/config/config.go b/analytics/config/config.go
index 557fec361..708375de1 100644
--- a/analytics/config/config.go
+++ b/analytics/config/config.go
@@ -6,6 +6,7 @@ import (
 	"github.com/prebid/prebid-server/analytics"
 	"github.com/prebid/prebid-server/analytics/clients"
 	"github.com/prebid/prebid-server/analytics/filesystem"
+	"github.com/prebid/prebid-server/analytics/pubmatic"
 	"github.com/prebid/prebid-server/analytics/pubstack"
 	"github.com/prebid/prebid-server/config"
 )
@@ -37,6 +38,11 @@ func NewPBSAnalytics(analytics *config.Analytics) analytics.PBSAnalyticsModule {
 			glog.Errorf("Could not initialize PubstackModule: %v", err)
 		}
 	}
+
+	if analytics.PubMatic.Enabled {
+		modules = append(modules, pubmatic.NewHTTPLogger(analytics.PubMatic))
+	}
+
 	return modules
 }
 
diff --git a/analytics/config/config_ow.go b/analytics/config/config_ow.go
new file mode 100644
index 000000000..13ebb463e
--- /dev/null
+++ b/analytics/config/config_ow.go
@@ -0,0 +1,20 @@
+package config
+
+import (
+	"fmt"
+
+	"github.com/prebid/prebid-server/analytics"
+)
+
+// EnableAnalyticsModule will add the new module into the list of enabled analytics modules
+var EnableAnalyticsModule = func(module analytics.PBSAnalyticsModule, moduleList analytics.PBSAnalyticsModule) (analytics.PBSAnalyticsModule, error) {
+	if module == nil {
+		return nil, fmt.Errorf("module to be added is nil")
+	}
+	enabledModuleList, ok := moduleList.(enabledAnalytics)
+	if !ok {
+		return nil, fmt.Errorf("failed to convert moduleList interface from analytics.PBSAnalyticsModule to analytics.enabledAnalytics")
+	}
+	enabledModuleList = append(enabledModuleList, module)
+	return enabledModuleList, nil
+}
diff --git a/analytics/config/config_ow_test.go b/analytics/config/config_ow_test.go
new file mode 100644
index 000000000..a8e7d928b
--- /dev/null
+++ b/analytics/config/config_ow_test.go
@@ -0,0 +1,67 @@
+package config
+
+import (
+	"errors"
+	"testing"
+
+	"github.com/prebid/prebid-server/analytics"
+	"github.com/prebid/prebid-server/analytics/filesystem"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestEnableAnalyticsModule(t *testing.T) {
+
+	modules := enabledAnalytics{}
+	file, err := filesystem.NewFileLogger("xyz1.txt")
+	if err != nil {
+		t.Errorf("NewFileLogger returned error - %v", err.Error())
+	}
+
+	type arg struct {
+		moduleList analytics.PBSAnalyticsModule
+		module     analytics.PBSAnalyticsModule
+	}
+
+	type want struct {
+		len   int
+		error error
+	}
+
+	tests := []struct {
+		description string
+		args        arg
+		wants       want
+	}{
+		{
+			description: "add non-nil module to nil module-list",
+			args:        arg{moduleList: nil, module: file},
+			wants:       want{len: 0, error: errors.New("failed to convert moduleList interface from analytics.PBSAnalyticsModule to analytics.enabledAnalytics")},
+		},
+		{
+			description: "add nil module to non-nil module-list",
+			args:        arg{moduleList: modules, module: nil},
+			wants:       want{len: 0, error: errors.New("module to be added is nil")},
+		},
+		{
+			description: "add non-nil module to non-nil module-list",
+			args:        arg{moduleList: modules, module: file},
+			wants:       want{len: 1, error: nil},
+		},
+	}
+
+	for _, tt := range tests {
+		actual, err := EnableAnalyticsModule(tt.args.module, tt.args.moduleList)
+		assert.Equal(t, err, tt.wants.error)
+
+		if err == nil {
+			list, ok := actual.(enabledAnalytics)
+			if !ok {
+				t.Errorf("Failed to convert interface to enabledAnalytics for test case - [%v]", tt.description)
+			}
+
+			if len(list) != tt.wants.len {
+				t.Errorf("length of enabled modules mismatched, expected - [%d] , got - [%d]", tt.wants.len, len(list))
+			}
+		}
+	}
+}
diff --git a/analytics/config/config_test.go b/analytics/config/config_test.go
index 996a989e6..dc803f209 100644
--- a/analytics/config/config_test.go
+++ b/analytics/config/config_test.go
@@ -17,11 +17,12 @@ const TEST_DIR string = "testFiles"
 func TestSampleModule(t *testing.T) {
 	var count int
 	am := initAnalytics(&count)
-	am.LogAuctionObject(&analytics.AuctionObject{
+	am.LogAuctionObject(&analytics.AuctionObject{LoggableAuctionObject: analytics.LoggableAuctionObject{
 		Status:   http.StatusOK,
 		Errors:   nil,
 		Request:  &openrtb2.BidRequest{},
 		Response: &openrtb2.BidResponse{},
+	},
 	})
 	if count != 1 {
 		t.Errorf("PBSAnalyticsModule failed at LogAuctionObject")
diff --git a/analytics/core.go b/analytics/core.go
index 0d17cdeb7..b32e1540b 100644
--- a/analytics/core.go
+++ b/analytics/core.go
@@ -1,6 +1,7 @@
 package analytics
 
 import (
+	"context"
 	"time"
 
 	"github.com/prebid/openrtb/v19/openrtb2"
@@ -21,12 +22,19 @@ type PBSAnalyticsModule interface {
 	LogNotificationEventObject(*NotificationEvent)
 }
 
+// LoggableAuctionObject contains common attributes between AuctionObject, AmpObject, VideoObject
+type LoggableAuctionObject struct {
+	Context      context.Context
+	Status       int
+	Errors       []error
+	Request      *openrtb2.BidRequest
+	Response     *openrtb2.BidResponse
+	RejectedBids []RejectedBid
+}
+
 // Loggable object of a transaction at /openrtb2/auction endpoint
 type AuctionObject struct {
-	Status               int
-	Errors               []error
-	Request              *openrtb2.BidRequest
-	Response             *openrtb2.BidResponse
+	LoggableAuctionObject
 	Account              *config.Account
 	StartTime            time.Time
 	HookExecutionOutcome []hookexecution.StageOutcome
@@ -34,10 +42,7 @@ type AuctionObject struct {
 
 // Loggable object of a transaction at /openrtb2/amp endpoint
 type AmpObject struct {
-	Status               int
-	Errors               []error
-	Request              *openrtb2.BidRequest
-	AuctionResponse      *openrtb2.BidResponse
+	LoggableAuctionObject
 	AmpTargetingValues   map[string]string
 	Origin               string
 	StartTime            time.Time
@@ -46,10 +51,7 @@ type AmpObject struct {
 
 // Loggable object of a transaction at /openrtb2/video endpoint
 type VideoObject struct {
-	Status        int
-	Errors        []error
-	Request       *openrtb2.BidRequest
-	Response      *openrtb2.BidResponse
+	LoggableAuctionObject
 	VideoRequest  *openrtb_ext.BidRequestVideo
 	VideoResponse *openrtb_ext.BidResponseVideo
 	StartTime     time.Time
diff --git a/analytics/core_ow.go b/analytics/core_ow.go
new file mode 100644
index 000000000..002b84b1d
--- /dev/null
+++ b/analytics/core_ow.go
@@ -0,0 +1,14 @@
+package analytics
+
+import (
+	"github.com/prebid/openrtb/v19/openrtb3"
+	"github.com/prebid/prebid-server/exchange/entities"
+)
+
+// RejectedBid contains oRTB Bid object with
+// rejection reason and seat information
+type RejectedBid struct {
+	RejectionReason openrtb3.NonBidStatusCode
+	Bid             *entities.PbsOrtbBid
+	Seat            string
+}
diff --git a/analytics/filesystem/file_module.go b/analytics/filesystem/file_module.go
index 7c690f66a..4dccd8191 100644
--- a/analytics/filesystem/file_module.go
+++ b/analytics/filesystem/file_module.go
@@ -218,7 +218,7 @@ func jsonifyAmpObject(ao *analytics.AmpObject) string {
 			Status:               ao.Status,
 			Errors:               ao.Errors,
 			Request:              ao.Request,
-			AuctionResponse:      ao.AuctionResponse,
+			AuctionResponse:      ao.Response,
 			AmpTargetingValues:   ao.AmpTargetingValues,
 			Origin:               ao.Origin,
 			StartTime:            ao.StartTime,
diff --git a/analytics/filesystem/file_module_test.go b/analytics/filesystem/file_module_test.go
index 9843a8ab1..eb48f9b66 100644
--- a/analytics/filesystem/file_module_test.go
+++ b/analytics/filesystem/file_module_test.go
@@ -16,9 +16,11 @@ const TEST_DIR string = "testFiles"
 
 func TestAmpObject_ToJson(t *testing.T) {
 	ao := &analytics.AmpObject{
-		Status:             http.StatusOK,
-		Errors:             make([]error, 0),
-		AuctionResponse:    &openrtb2.BidResponse{},
+		LoggableAuctionObject: analytics.LoggableAuctionObject{
+			Status:   http.StatusOK,
+			Errors:   make([]error, 0),
+			Response: &openrtb2.BidResponse{},
+		},
 		AmpTargetingValues: map[string]string{},
 	}
 	if aoJson := jsonifyAmpObject(ao); strings.Contains(aoJson, "Transactional Logs Error") {
@@ -28,7 +30,9 @@ func TestAmpObject_ToJson(t *testing.T) {
 
 func TestAuctionObject_ToJson(t *testing.T) {
 	ao := &analytics.AuctionObject{
-		Status: http.StatusOK,
+		LoggableAuctionObject: analytics.LoggableAuctionObject{
+			Status: http.StatusOK,
+		},
 	}
 	if aoJson := jsonifyAuctionObject(ao); strings.Contains(aoJson, "Transactional Logs Error") {
 		t.Fatalf("AuctionObject failed to convert to json")
@@ -37,7 +41,9 @@ func TestAuctionObject_ToJson(t *testing.T) {
 
 func TestVideoObject_ToJson(t *testing.T) {
 	vo := &analytics.VideoObject{
-		Status: http.StatusOK,
+		LoggableAuctionObject: analytics.LoggableAuctionObject{
+			Status: http.StatusOK,
+		},
 	}
 	if voJson := jsonifyVideoObject(vo); strings.Contains(voJson, "Transactional Logs Error") {
 		t.Fatalf("AuctionObject failed to convert to json")
diff --git a/analytics/pubmatic/helper.go b/analytics/pubmatic/helper.go
new file mode 100644
index 000000000..272ab9c5e
--- /dev/null
+++ b/analytics/pubmatic/helper.go
@@ -0,0 +1,142 @@
+package pubmatic
+
+import (
+	"encoding/json"
+	"errors"
+	"fmt"
+	"net/http"
+	"net/url"
+	"strconv"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// Send method
+func Send(url string, headers http.Header) error {
+	mhc := NewMultiHttpContext()
+	hc, err := NewHttpCall(url, "")
+	if err != nil {
+		return err
+	}
+
+	for k, v := range headers {
+		if len(v) != 0 {
+			hc.AddHeader(k, v[0])
+		}
+	}
+
+	mhc.AddHttpCall(hc)
+	_, erc := mhc.Execute()
+	if erc != 0 {
+		return errors.New("error in sending logger pixel")
+	}
+
+	return nil
+}
+
+// PrepareLoggerURL returns the url for OW logger call
+func PrepareLoggerURL(wlog *WloggerRecord, loggerURL string, gdprEnabled int) string {
+	v := url.Values{}
+
+	jsonString, err := json.Marshal(wlog.record)
+	if err != nil {
+		return ""
+	}
+
+	v.Set(models.WLJSON, string(jsonString))
+	v.Set(models.WLPUBID, strconv.Itoa(wlog.PubID))
+	if gdprEnabled == 1 {
+		v.Set(models.WLGDPR, strconv.Itoa(gdprEnabled))
+	}
+	queryString := v.Encode()
+
+	finalLoggerURL := loggerURL + "?" + queryString
+	return finalLoggerURL
+}
+
+func (wlog *WloggerRecord) logContentObject(content *openrtb2.Content) {
+	if nil == content {
+		return
+	}
+
+	wlog.Content = &Content{
+		ID:      content.ID,
+		Episode: int(content.Episode),
+		Title:   content.Title,
+		Series:  content.Series,
+		Season:  content.Season,
+		Cat:     content.Cat,
+	}
+}
+func getSizeForPlatform(width, height int64, platform string) string {
+	s := models.GetSize(width, height)
+	if platform == models.PLATFORM_VIDEO {
+		s = s + models.VideoSizeSuffix
+	}
+	return s
+}
+
+// set partnerRecord MetaData
+func (partnerRecord *PartnerRecord) setMetaDataObject(meta *openrtb_ext.ExtBidPrebidMeta) {
+
+	if meta.NetworkID != 0 || meta.AdvertiserID != 0 || len(meta.SecondaryCategoryIDs) > 0 {
+		partnerRecord.MetaData = &MetaData{
+			NetworkID:            meta.NetworkID,
+			AdvertiserID:         meta.AdvertiserID,
+			PrimaryCategoryID:    meta.PrimaryCategoryID,
+			AgencyID:             meta.AgencyID,
+			DemandSource:         meta.DemandSource,
+			SecondaryCategoryIDs: meta.SecondaryCategoryIDs,
+		}
+	}
+	//NOTE : We Don't get following Data points in Response, whenever got from translator,
+	//they can be populated.
+	//partnerRecord.MetaData.NetworkName = meta.NetworkName
+	//partnerRecord.MetaData.AdvertiserName = meta.AdvertiserName
+	//partnerRecord.MetaData.AgencyName = meta.AgencyName
+	//partnerRecord.MetaData.BrandName = meta.BrandName
+	//partnerRecord.MetaData.BrandID = meta.BrandID
+	//partnerRecord.MetaData.DChain = meta.DChain (type is json.RawMessage)
+}
+
+// Harcode would be the optimal. We could make it configurable like _AU_@_W_x_H_:%s@%dx%d entries in pbs.yaml
+// mysql> SELECT DISTINCT key_gen_pattern FROM wrapper_mapping_template;
+// +----------------------+
+// | key_gen_pattern      |
+// +----------------------+
+// | _AU_@_W_x_H_         |
+// | _DIV_@_W_x_H_        |
+// | _W_x_H_@_W_x_H_      |
+// | _DIV_                |
+// | _AU_@_DIV_@_W_x_H_   |
+// | _AU_@_SRC_@_VASTTAG_ |
+// +----------------------+
+// 6 rows in set (0.21 sec)
+func GenerateSlotName(h, w int64, kgp, tagid, div, src string) string {
+	// func (H, W, Div), no need to validate, will always be non-nil
+	switch kgp {
+	case "_AU_": // adunitconfig
+		return tagid
+	case "_DIV_":
+		return div
+	case "_AU_@_W_x_H_":
+		return fmt.Sprintf("%s@%dx%d", tagid, w, h)
+	case "_DIV_@_W_x_H_":
+		return fmt.Sprintf("%s@%dx%d", div, w, h)
+	case "_W_x_H_@_W_x_H_":
+		return fmt.Sprintf("%dx%d@%dx%d", w, h, w, h)
+	case "_AU_@_DIV_@_W_x_H_":
+		if div == "" {
+			return fmt.Sprintf("%s@%s@s%dx%d", tagid, div, w, h)
+		}
+		return fmt.Sprintf("%s@%s@s%dx%d", tagid, div, w, h)
+	case "_AU_@_SRC_@_VASTTAG_":
+		return fmt.Sprintf("%s@%s@s_VASTTAG_", tagid, src) //TODO check where/how _VASTTAG_ is updated
+	default:
+		// TODO: check if we need to fallback to old generic flow (below)
+		// Add this cases in a map and read it from yaml file
+	}
+	return ""
+}
diff --git a/analytics/pubmatic/http_util.go b/analytics/pubmatic/http_util.go
new file mode 100644
index 000000000..e2b2b2c8b
--- /dev/null
+++ b/analytics/pubmatic/http_util.go
@@ -0,0 +1,218 @@
+package pubmatic
+
+// mhttp - Multi Http Calls
+// mhttp like multi curl provides a wrapper interface over net/http client to
+// create multiple http calls and fire them in parallel. Each http call is fired in
+// a separate go routine and waits for all responses for a given timeout;
+// All the response are captured automatically in respective individual HttpCall
+// structures for further processing
+
+import (
+	"bytes"
+	"io/ioutil"
+
+	//"log"
+	"net/http"
+	"sync"
+	"sync/atomic"
+	"time"
+)
+
+// Default Sizes
+const (
+	MAX_HTTP_CLIENTS      = 10240 //Max HTTP live clients; clients are global reused in round-robin fashion
+	MAX_HTTP_CONNECTIONS  = 1024  //For each HTTP client these many idle connections are created and resued
+	MAX_HTTP_CALLS        = 200   //Only these many multi calls are considered at a time;
+	HTTP_CONNECT_TIMEOUT  = 500   //Not used at present;
+	HTTP_RESPONSE_TIMEOUT = 2000  //Total response timeout = connect time + request write time + wait time + response read time
+)
+
+var (
+	// Global http client list; One client is used for every mutli call handle
+	clients            [MAX_HTTP_CLIENTS]*http.Client
+	maxHttpClients     int32 //No of http clients pre-created
+	maxHttpConnections int   //no of idle connections per client
+	maxHttpCalls       int   //Max allowed http calls in parallel
+	nextClientIndex    int32 //Index denotes next client index in round-robin
+)
+
+//func dialTimeout(network, addr string) (net.Conn, error) {
+//	logger.Debug("Dialling...")
+//	timeout := time.Duration(time.Duration(HTTP_CONNECT_TIMEOUT) * time.Millisecond)
+//	return net.DialTimeout(network, addr, timeout)
+//}
+
+// Init prepares the global list of http clients which are re-used in round-robin
+// it should be called only once during start of the application before making any
+// multi-http call
+//
+// maxClients		: Max Http clients to create (<=MAX_HTTP_CLIENTS)
+// maxConnections	: Max idle Connections per client (<=MAX_HTTP_CONNECTIONS)
+// maxHttpCalls 	: Max allowed http calls in parallel (<= MAX_HTTP_CALLS)
+// respTimeout	: http timeout
+func Init(maxClients int32, maxConnections, maxCalls, respTimeout int) {
+	maxHttpClients = maxClients
+	maxHttpConnections = maxConnections
+	maxHttpCalls = maxCalls
+
+	if maxHttpClients > MAX_HTTP_CLIENTS {
+		maxHttpClients = MAX_HTTP_CLIENTS
+	}
+
+	if maxHttpConnections > MAX_HTTP_CONNECTIONS {
+		maxHttpConnections = MAX_HTTP_CONNECTIONS
+	}
+
+	if maxHttpCalls > MAX_HTTP_CALLS {
+		maxHttpCalls = MAX_HTTP_CALLS
+	}
+
+	if respTimeout <= 0 || respTimeout >= HTTP_RESPONSE_TIMEOUT {
+		respTimeout = HTTP_RESPONSE_TIMEOUT
+	}
+
+	timeout := time.Duration(time.Duration(respTimeout) * time.Millisecond)
+	for i := int32(0); i < maxClients; i++ {
+		//tr := &http.Transport{MaxIdleConnsPerHost: maxConnections, Dial: dialTimeout, ResponseHeaderTimeout: timeout}
+		tr := &http.Transport{DisableKeepAlives: false, MaxIdleConnsPerHost: maxConnections}
+		clients[i] = &http.Client{Transport: tr, Timeout: timeout}
+	}
+	nextClientIndex = -1
+}
+
+// Wrapper to hold both http request and response data for a single http call
+type HttpCall struct {
+	//Request Section
+	request *http.Request
+
+	//Response Section
+	response *http.Response
+	err      error
+	respBody string
+}
+
+// create and returns a HttpCall object
+func NewHttpCall(url string, postdata string) (hc *HttpCall, err error) {
+	hc = new(HttpCall)
+	hc.response = nil
+	hc.respBody = ""
+	hc.err = nil
+	method := "POST"
+	if postdata == "" {
+		method = "GET"
+	}
+	hc.request, hc.err = http.NewRequest(method, url, bytes.NewBuffer([]byte(postdata)))
+	//hc.request.Close = true
+	return
+}
+
+// Appends an http header
+func (hc *HttpCall) AddHeader(name, value string) {
+	hc.request.Header.Add(name, value)
+}
+
+// Add http Cookie
+func (hc *HttpCall) AddCookie(name, value string) {
+	cookie := http.Cookie{Name: name, Value: value}
+	hc.request.AddCookie(&cookie)
+}
+
+// API call to get the reponse body in string format
+func (hc *HttpCall) GetResponseBody() string {
+	return hc.respBody
+}
+
+// API call to get the reponse body in string format
+func (hc *HttpCall) GetResponseHeader(hname string) string {
+	return hc.response.Header.Get(hname)
+}
+
+// Get response headers map
+func (hc *HttpCall) GetResponseHeaders() *http.Header {
+	return &hc.response.Header
+}
+
+// MultiHttpContext is required to hold the information about all http calls to run
+type MultiHttpContext struct {
+	hclist  [MAX_HTTP_CALLS]*HttpCall
+	hccount int
+	wg      sync.WaitGroup
+}
+
+// Create a multi-http-context
+func NewMultiHttpContext() *MultiHttpContext {
+	mhc := new(MultiHttpContext)
+	mhc.hccount = 0
+	return mhc
+}
+
+// Add a http call to multi-http-context
+func (mhc *MultiHttpContext) AddHttpCall(hc *HttpCall) {
+	if mhc.hccount < maxHttpCalls {
+		mhc.hclist[mhc.hccount] = hc
+		mhc.hccount += 1
+	}
+}
+
+// Start firing parallel http calls that have been added so far
+// Current go routine is blocked till it finishes with all http calls
+// vrc: valid response count
+// erc: error reponse count including timeouts
+func (mhc *MultiHttpContext) Execute() (vrc int, erc int) {
+	vrc = 0 // Mark valid response count to zero
+	erc = 0 // Mark invalid response count to zero
+	if mhc.hccount <= 0 {
+		return
+	}
+
+	mhc.wg.Add(mhc.hccount) //Set waitgroup count
+	for i := 0; i < mhc.hccount; i++ {
+		go mhc.hclist[i].submit(&mhc.wg)
+	}
+	mhc.wg.Wait() //Wait for all go routines to finish
+
+	for i := 0; i < mhc.hccount; i++ { // validate each response
+		if mhc.hclist[i].err == nil && mhc.hclist[i].respBody != "" {
+			vrc += 1
+		} else {
+			erc += 1
+		}
+	}
+	return vrc, erc
+}
+
+// Get all the http calls from multi-http-context
+func (mhc *MultiHttpContext) GetRequestsFromMultiHttpContext() [MAX_HTTP_CALLS]*HttpCall {
+	return mhc.hclist
+
+}
+
+/////////////////////////////////////////////////////////////////////////////////
+///   Internal API calls
+/////////////////////////////////////////////////////////////////////////////////
+
+// Internal api to get the next http client for use
+func getNextHttpClient() *http.Client {
+	index := atomic.AddInt32(&nextClientIndex, 1)
+	if index >= maxHttpClients {
+		index = index % maxHttpClients
+		atomic.StoreInt32(&nextClientIndex, index)
+	}
+	return clients[index]
+}
+
+// Internal API to fire individual http call
+func (hc *HttpCall) submit(wg *sync.WaitGroup) {
+	defer wg.Done()
+	client := getNextHttpClient()
+	hc.response, hc.err = client.Do(hc.request)
+	//logger.Debug("ADCALL RESPONSE :%v" , hc.response)
+	if hc.err != nil {
+		hc.respBody = ""
+		return
+	}
+	defer hc.response.Body.Close()
+	body, err := ioutil.ReadAll(hc.response.Body)
+	hc.respBody = string(body)
+	hc.err = err
+}
diff --git a/analytics/pubmatic/logger.go b/analytics/pubmatic/logger.go
new file mode 100644
index 000000000..ade3897bf
--- /dev/null
+++ b/analytics/pubmatic/logger.go
@@ -0,0 +1,374 @@
+package pubmatic
+
+import (
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"strconv"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/analytics"
+	"github.com/prebid/prebid-server/hooks/hookexecution"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func GetLogAuctionObjectAsURL(ao analytics.AuctionObject, logInfo, forRespExt bool) (string, http.Header) {
+	rCtx := GetRequestCtx(ao.HookExecutionOutcome)
+	if rCtx == nil {
+		return "", http.Header{}
+	}
+
+	wlog := WloggerRecord{
+		record: record{
+			PubID:             rCtx.PubID,
+			ProfileID:         fmt.Sprintf("%d", rCtx.ProfileID),
+			VersionID:         fmt.Sprintf("%d", rCtx.DisplayID),
+			Origin:            rCtx.Origin,
+			PageURL:           rCtx.PageURL,
+			IID:               rCtx.LoggerImpressionID,
+			Timestamp:         rCtx.StartTime,
+			ServerLogger:      1,
+			TestConfigApplied: rCtx.ABTestConfigApplied,
+			Timeout:           int(rCtx.TMax),
+		},
+	}
+
+	if ao.Request.User != nil {
+		extUser := openrtb_ext.ExtUser{}
+		_ = json.Unmarshal(ao.Request.User.Ext, &extUser)
+		wlog.ConsentString = extUser.Consent
+	}
+
+	if ao.Request.Device != nil {
+		wlog.IP = ao.Request.Device.IP
+		wlog.UserAgent = ao.Request.Device.UA
+	}
+
+	if ao.Request.Regs != nil {
+		extReg := openrtb_ext.ExtRegs{}
+		_ = json.Unmarshal(ao.Request.Regs.Ext, &extReg)
+		if extReg.GDPR != nil {
+			wlog.GDPR = *extReg.GDPR
+		}
+	}
+
+	//log device object
+	wlog.logDeviceObject(*rCtx, rCtx.UA, ao.Request, rCtx.Platform)
+
+	//log content object
+	if nil != ao.Request.Site {
+		wlog.logContentObject(ao.Request.Site.Content)
+	} else if nil != ao.Request.App {
+		wlog.logContentObject(ao.Request.App.Content)
+	}
+
+	var ipr map[string][]PartnerRecord
+
+	if logInfo {
+		ipr = getDefaultPartnerRecordsByImp(rCtx)
+	} else {
+		ipr = getPartnerRecordsByImp(ao, rCtx)
+	}
+
+	// parent bidder could in one of the above and we need them by prebid's bidderCode and not seat(could be alias)
+	slots := make([]SlotRecord, 0)
+	for _, imp := range ao.Request.Imp {
+		reward := 0
+		var incomingSlots []string
+		if impCtx, ok := rCtx.ImpBidCtx[imp.ID]; ok {
+			if impCtx.IsRewardInventory != nil {
+				reward = int(*impCtx.IsRewardInventory)
+			}
+			incomingSlots = impCtx.IncomingSlots
+		}
+
+		// to keep existing response intact
+		partnerData := make([]PartnerRecord, 0)
+		if ipr[imp.ID] != nil {
+			partnerData = ipr[imp.ID]
+		}
+
+		slots = append(slots, SlotRecord{
+			SlotName:          getSlotName(imp.ID, imp.TagID),
+			SlotSize:          incomingSlots,
+			Adunit:            imp.TagID,
+			PartnerData:       partnerData,
+			RewardedInventory: int(reward),
+			// AdPodSlot:         getAdPodSlot(imp, responseMap.AdPodBidsExt),
+		})
+	}
+
+	wlog.Slots = slots
+
+	headers := http.Header{
+		models.USER_AGENT_HEADER: []string{rCtx.UA},
+		models.IP_HEADER:         []string{rCtx.IP},
+	}
+	if rCtx.KADUSERCookie != nil {
+		headers.Add(models.KADUSERCOOKIE, rCtx.KADUSERCookie.Value)
+	}
+
+	url := ow.cfg.Endpoint
+	if logInfo || forRespExt {
+		url = ow.cfg.PublicEndpoint
+	}
+
+	return PrepareLoggerURL(&wlog, url, GetGdprEnabledFlag(rCtx.PartnerConfigMap)), headers
+}
+
+// TODO filter by name. (*stageOutcomes[8].Groups[0].InvocationResults[0].AnalyticsTags.Activities[0].Results[0].Values["request-ctx"].(data))
+func GetRequestCtx(hookExecutionOutcome []hookexecution.StageOutcome) *models.RequestCtx {
+	for _, stageOutcome := range hookExecutionOutcome {
+		for _, groups := range stageOutcome.Groups {
+			for _, invocationResult := range groups.InvocationResults {
+				for _, activity := range invocationResult.AnalyticsTags.Activities {
+					for _, result := range activity.Results {
+						if result.Values != nil {
+							if irctx, ok := result.Values["request-ctx"]; ok {
+								rctx, ok := irctx.(*models.RequestCtx)
+								if !ok {
+									return nil
+								}
+								return rctx
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	return nil
+}
+
+func getPartnerRecordsByImp(ao analytics.AuctionObject, rCtx *models.RequestCtx) map[string][]PartnerRecord {
+	// impID-partnerRecords: partner records per impression
+	ipr := make(map[string][]PartnerRecord)
+
+	// Seat-impID (based on impID as default bids do not have ID). Shall we generate unique ID's for them?
+	rejectedBids := map[string]map[string]struct{}{}
+	loggerSeat := make(map[string][]openrtb2.Bid)
+	for _, seatBids := range ao.RejectedBids {
+		if _, ok := rejectedBids[seatBids.Seat]; !ok {
+			rejectedBids[seatBids.Seat] = map[string]struct{}{}
+		}
+
+		if seatBids.Bid != nil && seatBids.Bid.Bid != nil {
+			rejectedBids[seatBids.Seat][seatBids.Bid.Bid.ImpID] = struct{}{}
+
+			loggerSeat[seatBids.Seat] = append(loggerSeat[seatBids.Seat], *seatBids.Bid.Bid)
+		}
+	}
+	for _, seatBid := range ao.Response.SeatBid {
+		for _, bid := range seatBid.Bid {
+			// Check if this is a default and RejectedBids bid. Ex. only one bid by pubmatic it was rejected by floors.
+			// Module would add a 0 bid. So, we want to skip this zero bid to avoid duplicate or incomplete data and log the correct one that was rejected.
+			// We don't have bid.ID here so using bid.ImpID
+			if bid.Price == 0 && bid.W == 0 && bid.H == 0 {
+				if _, ok := rejectedBids[seatBid.Seat]; ok {
+					if _, ok := rejectedBids[seatBid.Seat][bid.ImpID]; ok {
+						continue
+					}
+				}
+			}
+			loggerSeat[seatBid.Seat] = append(loggerSeat[seatBid.Seat], bid)
+		}
+	}
+	for seat, Bids := range rCtx.DroppedBids {
+		// include bids dropped by module. Ex. sendAllBids=false
+		loggerSeat[seat] = append(loggerSeat[seat], Bids...)
+	}
+
+	// pubmatic's KGP details per impression
+	// This is only required for groupm bids (groupm bids log pubmatic's data in ow logger)
+	type pubmaticMarketplaceMeta struct {
+		PubmaticKGP, PubmaticKGPV, PubmaticKGPSV string
+	}
+	pmMkt := make(map[string]pubmaticMarketplaceMeta)
+
+	for seat, bids := range loggerSeat {
+		if seat == string(openrtb_ext.BidderOWPrebidCTV) {
+			continue
+		}
+
+		// Response would not contain non-mapped bids, do we need this
+		if _, ok := rCtx.AdapterThrottleMap[seat]; ok {
+			continue
+		}
+
+		for _, bid := range bids {
+			impCtx, ok := rCtx.ImpBidCtx[bid.ImpID]
+			if !ok {
+				continue
+			}
+
+			// Response would not contain non-mapped bids, do we need this
+			if _, ok := impCtx.NonMapped[seat]; ok {
+				break
+			}
+
+			revShare := 0.0
+			partnerID := seat
+			var isRegex bool
+			var kgp, kgpv, kgpsv string
+
+			if bidderMeta, ok := impCtx.Bidders[seat]; ok {
+				revShare, _ = strconv.ParseFloat(rCtx.PartnerConfigMap[bidderMeta.PartnerID][models.REVSHARE], 64)
+				partnerID = bidderMeta.PrebidBidderCode
+				kgp = bidderMeta.KGP           // _AU_@_W_x_H_
+				kgpv = bidderMeta.KGPV         // ^/43743431/DMDemo[0-9]*@Div[12]@^728x90$
+				kgpsv = bidderMeta.MatchedSlot // /43743431/DMDemo1@@728x90
+				isRegex = bidderMeta.IsRegex
+			}
+
+			// 1. nobid
+			if bid.Price == 0 && bid.H == 0 && bid.W == 0 {
+				//NOTE: kgpsv = bidderMeta.MatchedSlot above. Use the same
+				if !isRegex && kgpv != "" { // unmapped pubmatic's slot
+					kgpsv = kgpv // - KGP: _AU_@_DIV_@_W_x_H_
+				} else if !isRegex {
+					kgpv = kgpsv
+				}
+			} else if !isRegex {
+				if kgpv != "" { // unmapped pubmatic's slot
+					kgpsv = kgpv // /43743431/DMDemo1234@300x250 -->
+				} else if bid.H != 0 && bid.W != 0 { // Check when bid.H and bid.W will be zero with Price !=0. Ex: MobileInApp-MultiFormat-OnlyBannerMapping_Criteo_Partner_Validaton
+					// 2. valid bid
+					// kgpv has regex, do not generate slotName again
+					// kgpsv could be unmapped or mapped slot, generate slotName again based on bid.H and bid.W
+					kgpsv = GenerateSlotName(bid.H, bid.W, kgp, impCtx.TagID, impCtx.Div, rCtx.Source)
+					kgpv = kgpsv // original /43743431/DMDemo1234@300x250 but new could be /43743431/DMDemo1234@222x111
+				}
+			}
+
+			if kgpv == "" {
+				kgpv = kgpsv
+			}
+
+			var bidExt models.BidExt
+			if bidCtx, ok := impCtx.BidCtx[bid.ID]; ok {
+				bidExt = bidCtx.BidExt
+			}
+
+			price := bid.Price
+			if ao.Response.Cur != "USD" {
+				price = bidExt.OriginalBidCPMUSD
+			}
+
+			if seat == "pubmatic" {
+				pmMkt[bid.ImpID] = pubmaticMarketplaceMeta{
+					PubmaticKGP:   kgp,
+					PubmaticKGPV:  kgpv,
+					PubmaticKGPSV: kgpsv,
+				}
+			}
+
+			pr := PartnerRecord{
+				PartnerID:  partnerID, // prebid biddercode
+				BidderCode: seat,      // pubmatic biddercode: pubmatic2
+				// AdapterCode: adapterCode, // prebid adapter that brought the bid
+				Latency1:         rCtx.BidderResponseTimeMillis[seat],
+				KGPV:             kgpv,
+				KGPSV:            kgpsv,
+				BidID:            bid.ID,
+				OrigBidID:        bid.ID,
+				DefaultBidStatus: 0,
+				ServerSide:       1,
+				// MatchedImpression: matchedImpression,
+				NetECPM: func() float64 {
+					if revShare != 0.0 {
+						return GetNetEcpm(price, revShare)
+					}
+					return price
+				}(),
+				GrossECPM:   GetGrossEcpm(price),
+				OriginalCPM: GetGrossEcpm(bidExt.OriginalBidCPM),
+				OriginalCur: bidExt.OriginalBidCur,
+				PartnerSize: getSizeForPlatform(bid.W, bid.H, rCtx.Platform),
+				DealID:      bid.DealID,
+			}
+
+			if b, ok := rCtx.WinningBids[bid.ImpID]; ok && b.ID == bid.ID {
+				pr.WinningBidStaus = 1
+			}
+
+			if len(pr.OriginalCur) == 0 {
+				pr.OriginalCPM = float64(0)
+				pr.OriginalCur = "USD"
+			}
+
+			if len(pr.DealID) != 0 {
+				pr.DealChannel = models.DEFAULT_DEALCHANNEL
+			}
+
+			if bidExt.Prebid != nil {
+				// don't want default banner for nobid in wl
+				if bidExt.Prebid.Type != "" {
+					pr.Adformat = string(bidExt.Prebid.Type)
+				}
+
+				if bidExt.Prebid.DealTierSatisfied && bidExt.Prebid.DealPriority > 0 {
+					pr.DealPriority = bidExt.Prebid.DealPriority
+				}
+
+				if bidExt.Prebid.Video != nil && bidExt.Prebid.Video.Duration > 0 {
+					pr.AdDuration = &bidExt.Prebid.Video.Duration
+				}
+
+				if bidExt.Prebid.Meta != nil {
+					pr.setMetaDataObject(bidExt.Prebid.Meta)
+				}
+
+				if bidExt.Prebid.Floors != nil {
+					pr.FloorRule = bidExt.Prebid.Floors.FloorRule
+					pr.FloorRuleValue = roundToTwoDigit(bidExt.Prebid.Floors.FloorRuleValue)
+					if bidExt.Prebid.Floors.FloorCurrency == "USD" {
+						pr.FloorValue = roundToTwoDigit(bidExt.Prebid.Floors.FloorValue)
+					} else {
+						// pr.FloorValue = roundToTwoDigit(bidExt.Prebid.Floors.FloorValueUSD)
+					}
+				}
+			}
+
+			if pr.Adformat == "" && bid.AdM != "" {
+				pr.Adformat = models.GetAdFormat(bid.AdM)
+			}
+
+			if len(bid.ADomain) != 0 {
+				if domain, err := ExtractDomain(bid.ADomain[0]); err == nil {
+					pr.ADomain = domain
+				}
+			}
+
+			ipr[bid.ImpID] = append(ipr[bid.ImpID], pr)
+		}
+	}
+
+	// overwrite marketplace bid details with that of partner adatper
+	if rCtx.MarketPlaceBidders != nil {
+		for impID, partnerRecords := range ipr {
+			for i := 0; i < len(partnerRecords); i++ {
+				if _, ok := rCtx.MarketPlaceBidders[partnerRecords[i].BidderCode]; ok {
+					partnerRecords[i].PartnerID = "pubmatic"
+					partnerRecords[i].KGPV = pmMkt[impID].PubmaticKGPV
+					partnerRecords[i].KGPSV = pmMkt[impID].PubmaticKGPSV
+				}
+			}
+			ipr[impID] = partnerRecords
+		}
+	}
+
+	return ipr
+}
+
+func getDefaultPartnerRecordsByImp(rCtx *models.RequestCtx) map[string][]PartnerRecord {
+	ipr := make(map[string][]PartnerRecord)
+	for impID := range rCtx.ImpBidCtx {
+		ipr[impID] = []PartnerRecord{{
+			ServerSide:       1,
+			DefaultBidStatus: 1,
+			PartnerSize:      "0x0",
+		}}
+	}
+	return ipr
+}
diff --git a/analytics/pubmatic/models.go b/analytics/pubmatic/models.go
new file mode 100644
index 000000000..fdf80f120
--- /dev/null
+++ b/analytics/pubmatic/models.go
@@ -0,0 +1,133 @@
+package pubmatic
+
+import (
+	"encoding/json"
+	"fmt"
+	"math"
+	"net/url"
+	"regexp"
+	"strconv"
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+const (
+	//constant for adformat
+	Banner = "banner"
+	Video  = "video"
+	Native = "native"
+
+	REVSHARE      = "rev_share"
+	BID_PRECISION = 2
+)
+
+func GetSize(width, height int64) string {
+	return fmt.Sprintf("%dx%d", width, height)
+}
+
+// CreatePartnerKey returns key with partner appended
+func CreatePartnerKey(partner, key string) string {
+	if partner == "" {
+		return key
+	}
+	return key + "_" + partner
+}
+
+// GetAdFormat gets adformat from creative(adm) of the bid
+func GetAdFormat(adm string) string {
+	adFormat := Banner
+	videoRegex, _ := regexp.Compile("<VAST\\s+")
+
+	if videoRegex.MatchString(adm) {
+		adFormat = Video
+	} else {
+		var admJSON map[string]interface{}
+		err := json.Unmarshal([]byte(strings.Replace(adm, "/\\/g", "", -1)), &admJSON)
+		if err == nil && admJSON != nil && admJSON["native"] != nil {
+			adFormat = Native
+		}
+	}
+	return adFormat
+}
+
+func GetRevenueShare(partnerConfig map[string]string) float64 {
+	var revShare float64
+
+	if val, ok := partnerConfig[REVSHARE]; ok {
+		revShare, _ = strconv.ParseFloat(val, 64)
+	}
+	return revShare
+}
+
+func GetNetEcpm(price float64, revShare float64) float64 {
+	if revShare == 0 {
+		return toFixed(price, BID_PRECISION)
+	}
+	price = price * (1 - revShare/100)
+	return toFixed(price, BID_PRECISION)
+}
+
+func GetGrossEcpm(price float64) float64 {
+	return toFixed(price, BID_PRECISION)
+}
+
+func toFixed(num float64, precision int) float64 {
+	output := math.Pow(10, float64(precision))
+	return float64(round(num*output)) / output
+}
+
+func round(num float64) int {
+	return int(num + math.Copysign(0.5, num))
+}
+
+func ExtractDomain(rawURL string) (string, error) {
+	if !strings.HasPrefix(rawURL, "http") {
+		rawURL = "http://" + rawURL
+	}
+
+	u, err := url.Parse(rawURL)
+	if err != nil {
+		return "", err
+	}
+
+	return u.Host, nil
+}
+
+func getSlotName(impID string, tagID string) string {
+	return fmt.Sprintf("%s_%s", impID, tagID)
+}
+
+func getSizesFromImp(imp openrtb2.Imp, platform string) []string {
+	//get unique sizes from banner.format and banner.w and banner.h
+	sizes := make(map[string]bool)
+	var sizeArr []string
+	// TODO: handle video
+	if imp.Banner != nil && imp.Banner.W != nil && imp.Banner.H != nil {
+		size := getSizeForPlatform(*imp.Banner.W, *imp.Banner.H, platform)
+		if _, ok := sizes[size]; !ok {
+			sizeArr = append(sizeArr, size)
+			sizes[size] = true
+		}
+	}
+
+	if imp.Banner != nil && imp.Banner.Format != nil && len(imp.Banner.Format) != 0 {
+		for _, eachFormat := range imp.Banner.Format {
+			size := GetSize(eachFormat.W, eachFormat.H)
+			if _, ok := sizes[size]; !ok {
+				sizeArr = append(sizeArr, size)
+				sizes[size] = true
+			}
+		}
+	}
+
+	if imp.Video != nil {
+		size := getSizeForPlatform(imp.Video.W, imp.Video.H, models.PLATFORM_VIDEO)
+		if _, ok := sizes[size]; !ok {
+			sizeArr = append(sizeArr, size)
+			sizes[size] = true
+		}
+	}
+	return sizeArr
+}
diff --git a/analytics/pubmatic/pubmatic.go b/analytics/pubmatic/pubmatic.go
new file mode 100644
index 000000000..a59f6ed88
--- /dev/null
+++ b/analytics/pubmatic/pubmatic.go
@@ -0,0 +1,87 @@
+package pubmatic
+
+import (
+	"runtime/debug"
+	"strconv"
+	"sync"
+
+	"github.com/golang/glog"
+	"github.com/prebid/prebid-server/analytics"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+type RequestType string
+
+const (
+	COOKIE_SYNC        RequestType = "/cookie_sync"
+	AUCTION            RequestType = "/openrtb2/auction"
+	VIDEO              RequestType = "/openrtb2/video"
+	SETUID             RequestType = "/set_uid"
+	AMP                RequestType = "/openrtb2/amp"
+	NOTIFICATION_EVENT RequestType = "/event"
+)
+
+var ow HTTPLogger
+var once sync.Once
+
+// Module that can perform transactional logging
+type HTTPLogger struct {
+	cfg config.PubMaticWL
+}
+
+// Writes AuctionObject to file
+func (ow HTTPLogger) LogAuctionObject(ao *analytics.AuctionObject) {
+	defer func() {
+		if r := recover(); r != nil {
+			glog.Error(string(debug.Stack()))
+		}
+	}()
+
+	url, headers := GetLogAuctionObjectAsURL(*ao, false, false)
+	if url != "" {
+		Send(url, headers)
+	}
+}
+
+// Writes VideoObject to file
+func (ow HTTPLogger) LogVideoObject(vo *analytics.VideoObject) {
+}
+
+// Logs SetUIDObject to file
+func (ow HTTPLogger) LogSetUIDObject(so *analytics.SetUIDObject) {
+}
+
+// Logs CookieSyncObject to file
+func (ow HTTPLogger) LogCookieSyncObject(cso *analytics.CookieSyncObject) {
+}
+
+// Logs AmpObject to file
+func (ow HTTPLogger) LogAmpObject(ao *analytics.AmpObject) {
+}
+
+// Logs NotificationEvent to file
+func (ow HTTPLogger) LogNotificationEventObject(ne *analytics.NotificationEvent) {
+}
+
+// Method to initialize the analytic module
+func NewHTTPLogger(cfg config.PubMaticWL) analytics.PBSAnalyticsModule {
+	once.Do(func() {
+		Init(cfg.MaxClients, cfg.MaxConnections, cfg.MaxCalls, cfg.RespTimeout)
+
+		ow = HTTPLogger{
+			cfg: cfg,
+		}
+	})
+
+	return ow
+}
+
+// GetGdprEnabledFlag returns gdpr flag set in the partner config
+func GetGdprEnabledFlag(partnerConfigMap map[int]map[string]string) int {
+	gdpr := 0
+	if val := partnerConfigMap[models.VersionLevelConfigID][models.GDPR_ENABLED]; val != "" {
+		gdpr, _ = strconv.Atoi(val)
+	}
+	return gdpr
+}
diff --git a/analytics/pubmatic/record.go b/analytics/pubmatic/record.go
new file mode 100644
index 000000000..e491d59ee
--- /dev/null
+++ b/analytics/pubmatic/record.go
@@ -0,0 +1,186 @@
+package pubmatic
+
+import (
+	"encoding/json"
+	"math"
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/analytics"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+// WloggerRecord structure for wrapper analytics logger object
+type WloggerRecord struct {
+	record
+	NonBidRejections map[string]analytics.RejectedBid
+}
+
+type record struct {
+	Timeout           int              `json:"to,omitempty"`
+	PubID             int              `json:"pubid,omitempty"`
+	PageURL           string           `json:"purl,omitempty"`
+	Timestamp         int64            `json:"tst,omitempty"`
+	IID               string           `json:"iid,omitempty"`
+	ProfileID         string           `json:"pid,omitempty"`
+	VersionID         string           `json:"pdvid,omitempty"`
+	IP                string           `json:"-"`
+	UserAgent         string           `json:"-"`
+	UID               string           `json:"-"`
+	GDPR              int8             `json:"gdpr,omitempty"`
+	ConsentString     string           `json:"cns,omitempty"`
+	PubmaticConsent   int              `json:"pmc,omitempty"`
+	UserID            string           `json:"uid,omitempty"`
+	PageValue         float64          `json:"pv,omitempty"` //sum of all winning bids
+	ServerLogger      int              `json:"sl,omitempty"`
+	Slots             []SlotRecord     `json:"s,omitempty"`
+	CachePutMiss      int              `json:"cm,omitempty"`
+	Origin            string           `json:"orig,omitempty"`
+	Device            Device           `json:"dvc,omitempty"`
+	AdPodPercentage   *AdPodPercentage `json:"aps,omitempty"`
+	Content           *Content         `json:"ct,omitempty"`
+	TestConfigApplied int              `json:"tgid,omitempty"`
+	//Geo             GeoRecord    `json:"geo,omitempty"`
+}
+
+// Device struct for storing device information
+type Device struct {
+	Platform models.DevicePlatform `json:"plt,omitempty"`
+	IFAType  *models.DeviceIFAType `json:"ifty,omitempty"` //OTT-416, adding device.ext.ifa_type
+}
+
+/*
+//GeoRecord structure for storing geo information
+type GeoRecord struct {
+	CountryCode string `json:"cc,omitempty"`
+}
+*/
+
+// AdPodPercentage will store adpod percentage value comes in request
+type AdPodPercentage struct {
+	CrossPodAdvertiserExclusionPercent  *int `json:"cpexap,omitempty"` //Percent Value - Across multiple impression there will be no ads from same advertiser. Note: These cross pod rule % values can not be more restrictive than per pod
+	CrossPodIABCategoryExclusionPercent *int `json:"cpexip,omitempty"` //Percent Value - Across multiple impression there will be no ads from same advertiser
+	IABCategoryExclusionWindow          *int `json:"exapw,omitempty"`  //Duration in minute between pods where exclusive IAB rule needs to be applied
+	AdvertiserExclusionWindow           *int `json:"exipw,omitempty"`  //Duration in minute between pods where exclusive advertiser rule needs to be applied
+}
+
+// Content of openrtb request object
+type Content struct {
+	ID      string   `json:"id,omitempty"`  // ID uniquely identifying the content
+	Episode int      `json:"eps,omitempty"` // Episode number (typically applies to video content).
+	Title   string   `json:"ttl,omitempty"` // Content title.
+	Series  string   `json:"srs,omitempty"` // Content series
+	Season  string   `json:"ssn,omitempty"` // Content season
+	Cat     []string `json:"cat,omitempty"` // Array of IAB content categories that describe the content producer
+}
+
+// AdPodSlot of adpod object logging
+type AdPodSlot struct {
+	MinAds                      *int `json:"mnad,omitempty"` //Default 1 if not specified
+	MaxAds                      *int `json:"mxad,omitempty"` //Default 1 if not specified
+	MinDuration                 *int `json:"amnd,omitempty"` // (adpod.adminduration * adpod.minads) should be greater than or equal to video.minduration
+	MaxDuration                 *int `json:"amxd,omitempty"` // (adpod.admaxduration * adpod.maxads) should be less than or equal to video.maxduration + video.maxextended
+	AdvertiserExclusionPercent  *int `json:"exap,omitempty"` // Percent value 0 means none of the ads can be from same advertiser 100 means can have all same advertisers
+	IABCategoryExclusionPercent *int `json:"exip,omitempty"` // Percent value 0 means all ads should be of different IAB categories.
+}
+
+// SlotRecord structure for storing slot level information
+type SlotRecord struct {
+	SlotName          string          `json:"sn,omitempty"`
+	SlotSize          []string        `json:"sz,omitempty"`
+	Adunit            string          `json:"au,omitempty"`
+	AdPodSlot         *AdPodSlot      `json:"aps,omitempty"`
+	PartnerData       []PartnerRecord `json:"ps"`
+	RewardedInventory int             `json:"rwrd,omitempty"` // Indicates if the ad slot was enabled (rwrd=1) for rewarded or disabled (rwrd=0)
+}
+
+// PartnerRecord structure for storing partner information
+type PartnerRecord struct {
+	PartnerID            string  `json:"pn"`
+	BidderCode           string  `json:"bc"`
+	KGPV                 string  `json:"kgpv"`  // In case of Regex mapping, this will contain the regex string.
+	KGPSV                string  `json:"kgpsv"` // In case of Regex mapping, this will contain the actual slot name that matched the regex.
+	PartnerSize          string  `json:"psz"`   //wxh
+	Adformat             string  `json:"af"`
+	GrossECPM            float64 `json:"eg"`
+	NetECPM              float64 `json:"en"`
+	Latency1             int     `json:"l1"` //response time
+	Latency2             int     `json:"l2"`
+	PostTimeoutBidStatus int     `json:"t"`
+	WinningBidStaus      int     `json:"wb"`
+	BidID                string  `json:"bidid"`
+	OrigBidID            string  `json:"origbidid"`
+	DealID               string  `json:"di"`
+	DealChannel          string  `json:"dc"`
+	DealPriority         int     `json:"dp,omitempty"`
+	DefaultBidStatus     int     `json:"db"`
+	ServerSide           int     `json:"ss"`
+	MatchedImpression    int     `json:"mi"`
+
+	//AdPod Specific
+	AdPodSequenceNumber *int     `json:"adsq,omitempty"`
+	AdDuration          *int     `json:"dur,omitempty"`
+	ADomain             string   `json:"adv,omitempty"`
+	Cat                 []string `json:"cat,omitempty"`
+	NoBidReason         *int     `json:"aprc,omitempty"`
+
+	OriginalCPM float64 `json:"ocpm"`
+	OriginalCur string  `json:"ocry"`
+
+	MetaData *MetaData `json:"md,omitempty"`
+
+	FloorValue     float64 `json:"fv,omitempty"`
+	FloorRule      string  `json:"fr,omitempty"`
+	FloorRuleValue float64 `json:"frv,omitempty"`
+}
+
+type MetaData struct {
+	NetworkID            int             `json:"nwid,omitempty"`
+	AdvertiserID         int             `json:"adid,omitempty"`
+	NetworkName          string          `json:"nwnm,omitempty"`
+	PrimaryCategoryID    string          `json:"pcid,omitempty"`
+	AdvertiserName       string          `json:"adnm,omitempty"`
+	AgencyID             int             `json:"agid,omitempty"`
+	AgencyName           string          `json:"agnm,omitempty"`
+	BrandID              int             `json:"brid,omitempty"`
+	BrandName            string          `json:"brnm,omitempty"`
+	DChain               json.RawMessage `json:"dc,omitempty"`
+	DemandSource         string          `json:"ds,omitempty"`
+	SecondaryCategoryIDs []string        `json:"secondaryCatIds,omitempty"`
+}
+
+// logDeviceObject will be used to log device specific parameters like platform and ifa_type
+func (wlog *WloggerRecord) logDeviceObject(rctx models.RequestCtx, uaFromHTTPReq string, ortbBidRequest *openrtb2.BidRequest, platform string) {
+	dvc := Device{
+		Platform: rctx.DevicePlatform,
+	}
+
+	if ortbBidRequest != nil && ortbBidRequest.Device != nil && ortbBidRequest.Device.Ext != nil {
+		ext := make(map[string]interface{})
+		err := json.Unmarshal(ortbBidRequest.Device.Ext, &ext)
+		if err != nil {
+			return
+
+		}
+		// if ext, ok := ortbBidRequest.Device.Ext.(map[string]interface{}); ok {
+		//use ext object for logging any other extension parameters
+
+		//log device.ext.ifa_type parameter to ifty in logger record
+		if value, ok := ext["ifa_type"].(string); ok {
+
+			//ifa_type checkking is valid parameter and log its respective id
+			ifaType := models.DeviceIFATypeID[strings.ToLower(value)]
+			dvc.IFAType = &ifaType
+		}
+		// }
+	}
+
+	//settind device object
+	wlog.Device = dvc
+}
+
+// Round value to 2 digit
+func roundToTwoDigit(value float64) float64 {
+	output := math.Pow(10, float64(2))
+	return float64(math.Round(value*output)) / output
+}
diff --git a/analytics/pubstack/helpers/json.go b/analytics/pubstack/helpers/json.go
index cde6aef25..212ae64ae 100644
--- a/analytics/pubstack/helpers/json.go
+++ b/analytics/pubstack/helpers/json.go
@@ -124,7 +124,7 @@ func JsonifyAmpObject(ao *analytics.AmpObject, scope string) ([]byte, error) {
 			Status:               ao.Status,
 			Errors:               ao.Errors,
 			Request:              ao.Request,
-			AuctionResponse:      ao.AuctionResponse,
+			AuctionResponse:      ao.Response,
 			AmpTargetingValues:   ao.AmpTargetingValues,
 			Origin:               ao.Origin,
 			StartTime:            ao.StartTime,
diff --git a/analytics/pubstack/helpers/json_test.go b/analytics/pubstack/helpers/json_test.go
index 07ead7249..1391ed49a 100644
--- a/analytics/pubstack/helpers/json_test.go
+++ b/analytics/pubstack/helpers/json_test.go
@@ -11,7 +11,9 @@ import (
 
 func TestJsonifyAuctionObject(t *testing.T) {
 	ao := &analytics.AuctionObject{
-		Status: http.StatusOK,
+		LoggableAuctionObject: analytics.LoggableAuctionObject{
+			Status: http.StatusOK,
+		},
 	}
 
 	_, err := JsonifyAuctionObject(ao, "scopeId")
@@ -20,7 +22,9 @@ func TestJsonifyAuctionObject(t *testing.T) {
 
 func TestJsonifyVideoObject(t *testing.T) {
 	vo := &analytics.VideoObject{
-		Status: http.StatusOK,
+		LoggableAuctionObject: analytics.LoggableAuctionObject{
+			Status: http.StatusOK,
+		},
 	}
 
 	_, err := JsonifyVideoObject(vo, "scopeId")
@@ -50,9 +54,11 @@ func TestJsonifySetUIDObject(t *testing.T) {
 
 func TestJsonifyAmpObject(t *testing.T) {
 	ao := &analytics.AmpObject{
-		Status:             http.StatusOK,
-		Errors:             make([]error, 0),
-		AuctionResponse:    &openrtb2.BidResponse{},
+		LoggableAuctionObject: analytics.LoggableAuctionObject{
+			Status:   http.StatusOK,
+			Errors:   make([]error, 0),
+			Response: &openrtb2.BidResponse{},
+		},
 		AmpTargetingValues: map[string]string{},
 	}
 
diff --git a/analytics/pubstack/pubstack_module_test.go b/analytics/pubstack/pubstack_module_test.go
index 675983604..9f529f2e3 100644
--- a/analytics/pubstack/pubstack_module_test.go
+++ b/analytics/pubstack/pubstack_module_test.go
@@ -55,21 +55,22 @@ func TestNewModuleSuccess(t *testing.T) {
 			description: "auction events are only published when logging an auction object with auction feature on",
 			feature:     auction,
 			logObject: func(module analytics.PBSAnalyticsModule) {
-				module.LogAuctionObject(&analytics.AuctionObject{Status: http.StatusOK})
+				module.LogAuctionObject(&analytics.AuctionObject{
+					LoggableAuctionObject: analytics.LoggableAuctionObject{Status: http.StatusOK}})
 			},
 		},
 		{
 			description: "AMP events are only published when logging an AMP object with AMP feature on",
 			feature:     amp,
 			logObject: func(module analytics.PBSAnalyticsModule) {
-				module.LogAmpObject(&analytics.AmpObject{Status: http.StatusOK})
+				module.LogAmpObject(&analytics.AmpObject{LoggableAuctionObject: analytics.LoggableAuctionObject{Status: http.StatusOK}})
 			},
 		},
 		{
 			description: "video events are only published when logging a video object with video feature on",
 			feature:     video,
 			logObject: func(module analytics.PBSAnalyticsModule) {
-				module.LogVideoObject(&analytics.VideoObject{Status: http.StatusOK})
+				module.LogVideoObject(&analytics.VideoObject{LoggableAuctionObject: analytics.LoggableAuctionObject{Status: http.StatusOK}})
 			},
 		},
 		{
diff --git a/config/account.go b/config/account.go
index 393194bc3..8405453e9 100644
--- a/config/account.go
+++ b/config/account.go
@@ -50,6 +50,17 @@ type CookieSync struct {
 	DefaultCoopSync *bool `mapstructure:"default_coop_sync" json:"default_coop_sync"`
 }
 
+type AccountFloorFetch struct {
+	Enabled     bool   `mapstructure:"enabled" json:"enabled"`
+	URL         string `mapstructure:"url" json:"url"`
+	Timeout     int    `mapstructure:"timeout_ms" json:"timeout_ms"`
+	MaxFileSize int    `mapstructure:"max_file_size_kb" json:"max_file_size_kb"`
+	MaxRules    int    `mapstructure:"max_rules" json:"max_rules"`
+	MaxAge      int    `mapstructure:"max_age_sec" json:"max_age_sec"`
+	Period      int    `mapstructure:"period_sec" json:"period_sec"`
+	AccountID   string `mapstructure:"accountID" json:"accountID"`
+}
+
 // AccountCCPA represents account-specific CCPA configuration
 type AccountCCPA struct {
 	Enabled            *bool          `mapstructure:"enabled" json:"enabled,omitempty"`
@@ -58,13 +69,14 @@ type AccountCCPA struct {
 }
 
 type AccountPriceFloors struct {
-	Enabled                bool `mapstructure:"enabled" json:"enabled"`
-	EnforceFloorsRate      int  `mapstructure:"enforce_floors_rate" json:"enforce_floors_rate"`
-	AdjustForBidAdjustment bool `mapstructure:"adjust_for_bid_adjustment" json:"adjust_for_bid_adjustment"`
-	EnforceDealFloors      bool `mapstructure:"enforce_deal_floors" json:"enforce_deal_floors"`
-	UseDynamicData         bool `mapstructure:"use_dynamic_data" json:"use_dynamic_data"`
-	MaxRule                int  `mapstructure:"max_rules" json:"max_rules"`
-	MaxSchemaDims          int  `mapstructure:"max_schema_dims" json:"max_schema_dims"`
+	Enabled                bool              `mapstructure:"enabled" json:"enabled"`
+	EnforceFloorsRate      int               `mapstructure:"enforce_floors_rate" json:"enforce_floors_rate"`
+	AdjustForBidAdjustment bool              `mapstructure:"adjust_for_bid_adjustment" json:"adjust_for_bid_adjustment"`
+	EnforceDealFloors      bool              `mapstructure:"enforce_deal_floors" json:"enforce_deal_floors"`
+	UseDynamicData         bool              `mapstructure:"use_dynamic_data" json:"use_dynamic_data"`
+	MaxRule                int               `mapstructure:"max_rules" json:"max_rules"`
+	MaxSchemaDims          int               `mapstructure:"max_schema_dims" json:"max_schema_dims"`
+	Fetch                  AccountFloorFetch `mapstructure:"fetch" json:"fetch"`
 }
 
 func (pf *AccountPriceFloors) validate(errs []error) []error {
@@ -81,6 +93,29 @@ func (pf *AccountPriceFloors) validate(errs []error) []error {
 		errs = append(errs, fmt.Errorf(`account_defaults.price_floors.max_schema_dims should be between 0 and 20`))
 	}
 
+	if pf.Fetch.Period > pf.Fetch.MaxAge {
+		errs = append(errs, fmt.Errorf(`account_defaults.price_floors.fetch.period_sec should be less than account_defaults.price_floors.fetch.max_age_sec`))
+	}
+
+	if pf.Fetch.Period < 300 {
+		errs = append(errs, fmt.Errorf(`account_defaults.price_floors.fetch.period_sec should not be less than 300 seconds`))
+	}
+
+	if !(pf.Fetch.MaxAge >= 600 && pf.Fetch.MaxAge < math.MaxInt32) {
+		errs = append(errs, fmt.Errorf(`account_defaults.price_floors.fetch.max_age_sec should not be less than 600 seconds and greater than maximum integer value`))
+	}
+
+	if !(pf.Fetch.Timeout > 10 && pf.Fetch.Timeout < 10000) {
+		errs = append(errs, fmt.Errorf(`account_defaults.price_floors.fetch.timeout_ms should be between 10 to 10,000 mili seconds`))
+	}
+
+	if !(pf.Fetch.MaxRules >= 0 && pf.Fetch.MaxRules < math.MaxInt32) {
+		errs = append(errs, fmt.Errorf(`account_defaults.price_floors.fetch.max_rules should not be less than 0 seconds and greater than maximum integer value`))
+	}
+
+	if !(pf.Fetch.MaxFileSize >= 0 && pf.Fetch.MaxFileSize < math.MaxInt32) {
+		errs = append(errs, fmt.Errorf(`account_defaults.price_floors.fetch.max_file_size_kb should not be less than 0 seconds and greater than maximum integer value`))
+	}
 	return errs
 }
 
diff --git a/config/account_test.go b/config/account_test.go
index 20c605324..e4cf33040 100644
--- a/config/account_test.go
+++ b/config/account_test.go
@@ -871,12 +871,28 @@ func TestAccountPriceFloorsValidate(t *testing.T) {
 				EnforceFloorsRate: 100,
 				MaxRule:           200,
 				MaxSchemaDims:     10,
+				Fetch: AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     11,
+					MaxFileSize: 1,
+					MaxRules:    1,
+					MaxAge:      700,
+					Period:      400,
+				},
 			},
 		},
 		{
 			description: "Invalid configuration: EnforceFloorRate:110",
 			pf: &AccountPriceFloors{
 				EnforceFloorsRate: 110,
+				Fetch: AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     11,
+					MaxFileSize: 1,
+					MaxRules:    1,
+					MaxAge:      700,
+					Period:      400,
+				},
 			},
 			want: []error{errors.New("account_defaults.price_floors.enforce_floors_rate should be between 0 and 100")},
 		},
@@ -884,6 +900,14 @@ func TestAccountPriceFloorsValidate(t *testing.T) {
 			description: "Invalid configuration: EnforceFloorRate:-10",
 			pf: &AccountPriceFloors{
 				EnforceFloorsRate: -10,
+				Fetch: AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     11,
+					MaxFileSize: 1,
+					MaxRules:    1,
+					MaxAge:      700,
+					Period:      400,
+				},
 			},
 			want: []error{errors.New("account_defaults.price_floors.enforce_floors_rate should be between 0 and 100")},
 		},
@@ -891,6 +915,14 @@ func TestAccountPriceFloorsValidate(t *testing.T) {
 			description: "Invalid configuration: MaxRule:-20",
 			pf: &AccountPriceFloors{
 				MaxRule: -20,
+				Fetch: AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     11,
+					MaxFileSize: 1,
+					MaxRules:    1,
+					MaxAge:      700,
+					Period:      400,
+				},
 			},
 			want: []error{errors.New("account_defaults.price_floors.max_rules should be between 0 and 2147483647")},
 		},
@@ -898,9 +930,107 @@ func TestAccountPriceFloorsValidate(t *testing.T) {
 			description: "Invalid configuration: MaxSchemaDims:100",
 			pf: &AccountPriceFloors{
 				MaxSchemaDims: 100,
+				Fetch: AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     11,
+					MaxFileSize: 1,
+					MaxRules:    1,
+					MaxAge:      700,
+					Period:      400,
+				},
 			},
 			want: []error{errors.New("account_defaults.price_floors.max_schema_dims should be between 0 and 20")},
 		},
+		{
+			description: "Max Age is less than Period",
+			pf: &AccountPriceFloors{
+				EnforceFloorsRate: 100,
+				Fetch: AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     500,
+					MaxFileSize: 1,
+					MaxRules:    1,
+					MaxAge:      700,
+					Period:      800,
+				},
+			},
+			want: []error{errors.New("account_defaults.price_floors.fetch.period_sec should be less than account_defaults.price_floors.fetch.max_age_sec")},
+		},
+		{
+			description: "Period is less than 300",
+			pf: &AccountPriceFloors{
+				EnforceFloorsRate: 100,
+				Fetch: AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     500,
+					MaxFileSize: 1,
+					MaxRules:    1,
+					MaxAge:      700,
+					Period:      200,
+				},
+			},
+			want: []error{errors.New("account_defaults.price_floors.fetch.period_sec should not be less than 300 seconds")},
+		},
+		{
+			description: "Invalid Max age",
+			pf: &AccountPriceFloors{
+				EnforceFloorsRate: 100,
+				Fetch: AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     500,
+					MaxFileSize: 1,
+					MaxRules:    1,
+					MaxAge:      500,
+					Period:      400,
+				},
+			},
+			want: []error{errors.New("account_defaults.price_floors.fetch.max_age_sec should not be less than 600 seconds and greater than maximum integer value")},
+		},
+		{
+			description: "Invalid Timeout",
+			pf: &AccountPriceFloors{
+				EnforceFloorsRate: 100,
+				Fetch: AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     1,
+					MaxFileSize: 1,
+					MaxRules:    1,
+					MaxAge:      700,
+					Period:      400,
+				},
+			},
+			want: []error{errors.New("account_defaults.price_floors.fetch.timeout_ms should be between 10 to 10,000 mili seconds")},
+		},
+		{
+			description: "Invalid Max rules",
+			pf: &AccountPriceFloors{
+				EnforceFloorsRate: 100,
+				Fetch: AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     11,
+					MaxFileSize: 1,
+					MaxRules:    -1,
+					MaxAge:      700,
+					Period:      400,
+				},
+			},
+			want: []error{errors.New("account_defaults.price_floors.fetch.max_rules should not be less than 0 seconds and greater than maximum integer value")},
+		},
+		{
+			description: "Invalid Max file size",
+			pf: &AccountPriceFloors{
+				EnforceFloorsRate: 100,
+				Fetch: AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     11,
+					MaxFileSize: -1,
+					MaxRules:    1,
+					MaxAge:      700,
+					Period:      400,
+				},
+			},
+			want: []error{errors.New("account_defaults.price_floors.fetch.max_file_size_kb should not be less than 0 seconds and greater than maximum integer value")},
+		},
 	}
 	for _, tt := range tests {
 		t.Run(tt.description, func(t *testing.T) {
diff --git a/config/config.go b/config/config.go
index b537d128a..e57f03b3d 100644
--- a/config/config.go
+++ b/config/config.go
@@ -105,12 +105,22 @@ type Configuration struct {
 	Hooks       Hooks       `mapstructure:"hooks"`
 	Validations Validations `mapstructure:"validations"`
 	PriceFloors PriceFloors `mapstructure:"price_floors"`
+
+	TrackerURL          string              `mapstructure:"tracker_url"`
+	VendorListScheduler VendorListScheduler `mapstructure:"vendor_list_scheduler"`
+	PriceFloorFetcher   PriceFloorFetcher   `mapstructure:"price_floor_fetcher"`
 }
 
 type PriceFloors struct {
 	Enabled bool `mapstructure:"enabled"`
 }
 
+type VendorListScheduler struct {
+	Enabled  bool   `mapstructure:"enabled"`
+	Interval string `mapstructure:"interval"`
+	Timeout  string `mapstructure:"timeout"`
+}
+
 const MIN_COOKIE_SIZE_BYTES = 500
 
 type HTTPClient struct {
@@ -118,6 +128,11 @@ type HTTPClient struct {
 	MaxIdleConns        int `mapstructure:"max_idle_connections"`
 	MaxIdleConnsPerHost int `mapstructure:"max_idle_connections_per_host"`
 	IdleConnTimeout     int `mapstructure:"idle_connection_timeout_seconds"`
+
+	TLSHandshakeTimeout   int `mapstructure:"tls_handshake_timeout"`
+	ResponseHeaderTimeout int `mapstructure:"response_header_timeout"`
+	DialTimeout           int `mapstructure:"dial_timeout"`
+	DialKeepAlive         int `mapstructure:"dial_keepalive"`
 }
 
 func (cfg *Configuration) validate(v *viper.Viper) []error {
@@ -445,8 +460,9 @@ type LMT struct {
 }
 
 type Analytics struct {
-	File     FileLogs `mapstructure:"file"`
-	Pubstack Pubstack `mapstructure:"pubstack"`
+	File     FileLogs   `mapstructure:"file"`
+	Pubstack Pubstack   `mapstructure:"pubstack"`
+	PubMatic PubMaticWL `mapstructure:"pubmatic"`
 }
 
 type CurrencyConverter struct {
@@ -462,6 +478,11 @@ func (cfg *CurrencyConverter) validate(errs []error) []error {
 	return errs
 }
 
+type PriceFloorFetcher struct {
+	Worker   int `mapstructure:"worker"`
+	Capacity int `mapstructure:"capacity"`
+}
+
 // FileLogs Corresponding config for FileLogger as a PBS Analytics Module
 type FileLogs struct {
 	Filename string `mapstructure:"filename"`
@@ -475,6 +496,17 @@ type Pubstack struct {
 	ConfRefresh string         `mapstructure:"configuration_refresh_delay"`
 }
 
+type PubMaticWL struct {
+	Enabled        bool `mapstructure:"enabled"`
+	Endpoint       string
+	PublicEndpoint string
+	MaxClients     int32
+	MaxConnections int
+	MaxCalls       int
+	RespTimeout    int
+	Client         HTTPClient `mapstructure:"http_client"`
+}
+
 type PubstackBuffer struct {
 	BufferSize string `mapstructure:"size"`
 	EventCount int    `mapstructure:"count"`
@@ -824,9 +856,7 @@ func (cfg *Configuration) GetCachedAssetURL(uuid string) string {
 // Set the default config values for the viper object we are using.
 func SetupViper(v *viper.Viper, filename string, bidderInfos BidderInfos) {
 	if filename != "" {
-		v.SetConfigName(filename)
-		v.AddConfigPath(".")
-		v.AddConfigPath("/etc/config")
+		v.SetConfigFile(filename)
 	}
 
 	// Fixes #475: Some defaults will be set just so they are accessible via environment variables
@@ -1011,9 +1041,10 @@ func SetupViper(v *viper.Viper, filename string, bidderInfos BidderInfos) {
 	v.SetDefault("blacklisted_apps", []string{""})
 	v.SetDefault("blacklisted_accts", []string{""})
 	v.SetDefault("account_required", false)
+
 	v.SetDefault("account_defaults.disabled", false)
 	v.SetDefault("account_defaults.debug_allow", true)
-	v.SetDefault("account_defaults.price_floors.enabled", false)
+	v.SetDefault("account_defaults.price_floors.enabled", true)
 	v.SetDefault("account_defaults.price_floors.enforce_floors_rate", 100)
 	v.SetDefault("account_defaults.price_floors.adjust_for_bid_adjustment", true)
 	v.SetDefault("account_defaults.price_floors.enforce_deal_floors", false)
@@ -1021,6 +1052,12 @@ func SetupViper(v *viper.Viper, filename string, bidderInfos BidderInfos) {
 	v.SetDefault("account_defaults.price_floors.max_rules", 100)
 	v.SetDefault("account_defaults.price_floors.max_schema_dims", 3)
 	v.SetDefault("account_defaults.events_enabled", false)
+	v.SetDefault("account_defaults.price_floors.fetch.enabled", false)
+	v.SetDefault("account_defaults.price_floors.fetch.timeout_ms", 3000)
+	v.SetDefault("account_defaults.price_floors.fetch.max_file_size_kb", 100)
+	v.SetDefault("account_defaults.price_floors.fetch.max_rules", 1000)
+	v.SetDefault("account_defaults.price_floors.fetch.max_age_sec", 86400)
+	v.SetDefault("account_defaults.price_floors.fetch.period_sec", 3600)
 
 	v.SetDefault("certificates_file", "")
 	v.SetDefault("auto_gen_source_tid", true)
@@ -1126,6 +1163,9 @@ func SetupViper(v *viper.Viper, filename string, bidderInfos BidderInfos) {
 	for bidderName := range bidderInfos {
 		setBidderDefaults(v, strings.ToLower(bidderName))
 	}
+	//Defaults for Price floor fetcher
+	v.SetDefault("price_floor_fetcher.worker", 20)
+	v.SetDefault("price_floor_fetcher.capacity", 20000)
 }
 
 func migrateConfig(v *viper.Viper) {
diff --git a/config/config_test.go b/config/config_test.go
index 64f4f8a06..cc1d5ecc1 100644
--- a/config/config_test.go
+++ b/config/config_test.go
@@ -179,7 +179,7 @@ func TestDefaults(t *testing.T) {
 	//Assert the price floor default values
 	cmpBools(t, "price_floors.enabled", false, cfg.PriceFloors.Enabled)
 
-	cmpBools(t, "account_defaults.price_floors.enabled", false, cfg.AccountDefaults.PriceFloors.Enabled)
+	cmpBools(t, "account_defaults.price_floors.enabled", true, cfg.AccountDefaults.PriceFloors.Enabled)
 	cmpInts(t, "account_defaults.price_floors.enforce_floors_rate", 100, cfg.AccountDefaults.PriceFloors.EnforceFloorsRate)
 	cmpBools(t, "account_defaults.price_floors.adjust_for_bid_adjustment", true, cfg.AccountDefaults.PriceFloors.AdjustForBidAdjustment)
 	cmpBools(t, "account_defaults.price_floors.enforce_deal_floors", false, cfg.AccountDefaults.PriceFloors.EnforceDealFloors)
@@ -188,6 +188,14 @@ func TestDefaults(t *testing.T) {
 	cmpInts(t, "account_defaults.price_floors.max_schema_dims", 3, cfg.AccountDefaults.PriceFloors.MaxSchemaDims)
 	cmpBools(t, "account_defaults.events_enabled", *cfg.AccountDefaults.EventsEnabled, false)
 	cmpNils(t, "account_defaults.events.enabled", cfg.AccountDefaults.Events.Enabled)
+	cmpBools(t, "account_defaults.price_floors.fetch.enabled", false, cfg.AccountDefaults.PriceFloors.Fetch.Enabled)
+	cmpInts(t, "account_defaults.price_floors.fetch.timeout_ms", 3000, cfg.AccountDefaults.PriceFloors.Fetch.Timeout)
+	cmpInts(t, "account_defaults.price_floors.fetch.max_file_size_kb", 100, cfg.AccountDefaults.PriceFloors.Fetch.MaxFileSize)
+	cmpInts(t, "account_defaults.price_floors.fetch.max_rules", 1000, cfg.AccountDefaults.PriceFloors.Fetch.MaxRules)
+	cmpInts(t, "account_defaults.price_floors.fetch.max_age_sec", 86400, cfg.AccountDefaults.PriceFloors.Fetch.MaxAge)
+	cmpInts(t, "account_defaults.price_floors.fetch.period_sec", 3600, cfg.AccountDefaults.PriceFloors.Fetch.Period)
+	cmpInts(t, "price_floor_fetcher.worker", 20, cfg.PriceFloorFetcher.Worker)
+	cmpInts(t, "price_floor_fetcher.capacity", 20000, cfg.PriceFloorFetcher.Capacity)
 
 	cmpBools(t, "hooks.enabled", false, cfg.Hooks.Enabled)
 	cmpStrings(t, "validations.banner_creative_max_size", "skip", cfg.Validations.BannerCreativeMaxSize)
@@ -466,6 +474,16 @@ account_defaults:
         use_dynamic_data: true
         max_rules: 120
         max_schema_dims: 5
+        fetch:
+            enabled: true
+            timeout_ms: 1000
+            max_file_size_kb: 100
+            max_rules: 1000
+            max_age_sec: 36000
+            period_sec: 7200
+price_floor_fetcher:
+  worker: 10
+  capacity: 20
 tmax_adjustments:
   enabled: true
   bidder_response_duration_min_ms: 700
@@ -571,6 +589,14 @@ func TestFullConfig(t *testing.T) {
 	cmpInts(t, "account_defaults.price_floors.max_schema_dims", 5, cfg.AccountDefaults.PriceFloors.MaxSchemaDims)
 	cmpBools(t, "account_defaults.events_enabled", *cfg.AccountDefaults.EventsEnabled, true)
 	cmpNils(t, "account_defaults.events.enabled", cfg.AccountDefaults.Events.Enabled)
+	cmpBools(t, "account_defaults.price_floors.fetch.enabled", true, cfg.AccountDefaults.PriceFloors.Fetch.Enabled)
+	cmpInts(t, "account_defaults.price_floors.fetch.timeout_ms", 1000, cfg.AccountDefaults.PriceFloors.Fetch.Timeout)
+	cmpInts(t, "account_defaults.price_floors.fetch.max_file_size_kb", 100, cfg.AccountDefaults.PriceFloors.Fetch.MaxFileSize)
+	cmpInts(t, "account_defaults.price_floors.fetch.max_rules", 1000, cfg.AccountDefaults.PriceFloors.Fetch.MaxRules)
+	cmpInts(t, "account_defaults.price_floors.fetch.max_age_sec", 36000, cfg.AccountDefaults.PriceFloors.Fetch.MaxAge)
+	cmpInts(t, "account_defaults.price_floors.fetch.period_sec", 7200, cfg.AccountDefaults.PriceFloors.Fetch.Period)
+	cmpInts(t, "price_floor_fetcher.worker", 10, cfg.PriceFloorFetcher.Worker)
+	cmpInts(t, "price_floor_fetcher.capacity", 20, cfg.PriceFloorFetcher.Capacity)
 
 	//Assert the NonStandardPublishers was correctly unmarshalled
 	assert.Equal(t, []string{"pub1", "pub2"}, cfg.GDPR.NonStandardPublishers, "gdpr.non_standard_publishers")
@@ -781,6 +807,15 @@ func TestValidateConfig(t *testing.T) {
 			Files:         FileFetcherConfig{Enabled: true},
 			InMemoryCache: InMemoryCache{Type: "none"},
 		},
+		AccountDefaults: Account{
+			PriceFloors: AccountPriceFloors{
+				Fetch: AccountFloorFetch{
+					Period:  400,
+					Timeout: 20,
+					MaxAge:  700,
+				},
+			},
+		},
 	}
 
 	v := viper.New()
diff --git a/docs/developers/automated-tests.md b/docs/developers/automated-tests.md
index 6814fba38..9e435aaf5 100644
--- a/docs/developers/automated-tests.md
+++ b/docs/developers/automated-tests.md
@@ -15,7 +15,7 @@ For more info on how to write tests in Go, see [the Go docs](https://golang.org/
 ## Adapter Tests
 
 If your adapter makes HTTP calls using standard JSON, you should use the
-[RunJSONBidderTest](https://github.com/prebid/prebid-server/blob/master/adapters/adapterstest/test_json.go#L50) function.
+[RunJSONBidderTest](https://github.com/PubMatic-OpenWrap/prebid-server/blob/master/adapters/adapterstest/test_json.go#L50) function.
 
 This will be much more thorough, convenient, maintainable, and reusable than writing standard Go tests
 for your adapter.
diff --git a/docs/developers/code-reviews.md b/docs/developers/code-reviews.md
index d8ee820cd..59455d3b8 100644
--- a/docs/developers/code-reviews.md
+++ b/docs/developers/code-reviews.md
@@ -1,9 +1,9 @@
 # Code Reviews
 
 ## Standards
-Anyone is free to review and comment on any [open pull requests](https://github.com/prebid/prebid-server/pulls).
+Anyone is free to review and comment on any [open pull requests](https://github.com/PubMatic-OpenWrap/prebid-server/pulls).
 
-All pull requests must be reviewed and approved by at least one [core member](https://github.com/orgs/prebid/teams/core/members) before merge.
+All pull requests must be reviewed and approved by at least one [core member](https://github.com/orgs/PubMatic-OpenWrap/teams/core/members) before merge.
 
 Very small pull requests may be merged with just one review if they:
 
@@ -38,7 +38,7 @@ Some examples include:
 - Can we improve the user's experience in any way?
 - Have the relevant [docs](..) been added or updated? If not, add the `needs docs` label.
 - Do you believe that the code works by looking at the unit tests? If not, suggest more tests until you do!
-- Is the motivation behind these changes clear? If not, there must be [an issue](https://github.com/prebid/prebid-server/issues) explaining it. Are there better ways to achieve those goals?
+- Is the motivation behind these changes clear? If not, there must be [an issue](https://github.com/PubMatic-OpenWrap/prebid-server/issues) explaining it. Are there better ways to achieve those goals?
 - Does the code use any global, mutable state? [Inject dependencies](https://en.wikipedia.org/wiki/Dependency_injection) instead!
 - Can the code be organized into smaller, more modular pieces?
 - Is there dead code which can be deleted? Or TODO comments which should be resolved?
diff --git a/docs/developers/contributing.md b/docs/developers/contributing.md
index 2a6a574ed..cc2daaecd 100644
--- a/docs/developers/contributing.md
+++ b/docs/developers/contributing.md
@@ -2,7 +2,7 @@
 
 ## Create an issue
 
-[Create an issue](https://github.com/prebid/prebid-server/issues/new) describing the motivation for your changes.
+[Create an issue](https://github.com/PubMatic-OpenWrap/prebid-server/issues/new) describing the motivation for your changes.
 Are you fixing a bug? Improving documentation? Optimizing some slow code?
 
 Pull Requests without associated Issues may still be accepted, if the motivation is obvious.
@@ -38,7 +38,7 @@ those updates must be submitted in the same Pull Request as the code changes.
 ## Open a Pull Request
 
 When you're ready, [submit a Pull Request](https://help.github.com/articles/creating-a-pull-request/)
-against the `master` branch of [our GitHub repository](https://github.com/prebid/prebid-server/compare).
+against the `master` branch of [our GitHub repository](https://github.com/PubMatic-OpenWrap/prebid-server/compare).
 
 Pull Requests will be vetted through GitHub Actions.
 To reproduce these same tests locally, do:
@@ -49,5 +49,5 @@ To reproduce these same tests locally, do:
 
 If the tests pass locally, but fail on your PR, [update your fork](https://help.github.com/articles/syncing-a-fork/) with the latest code from `master`.
 
-**Note**: We also have some [known intermittent failures](https://github.com/prebid/prebid-server/issues/103).
+**Note**: We also have some [known intermittent failures](https://github.com/PubMatic-OpenWrap/prebid-server/issues/103).
           If the tests still fail after pulling `master`, don't worry about it. We'll re-run them when we review your PR.
diff --git a/endpoints/cookie_sync.go b/endpoints/cookie_sync.go
index 8b9309629..a5dd4d830 100644
--- a/endpoints/cookie_sync.go
+++ b/endpoints/cookie_sync.go
@@ -32,6 +32,7 @@ var (
 	errCookieSyncBody                              = errors.New("Failed to read request body")
 	errCookieSyncGDPRConsentMissing                = errors.New("gdpr_consent is required if gdpr=1")
 	errCookieSyncGDPRConsentMissingSignalAmbiguous = errors.New("gdpr_consent is required. gdpr is not specified and is assumed to be 1 by the server. set gdpr=0 to exempt this request")
+	errCookieSyncGDPRMandatoryByHost               = errors.New("gdpr_consent is required. gdpr exemption disabled by host")
 	errCookieSyncInvalidBiddersType                = errors.New("invalid bidders type. must either be a string '*' or a string array of bidders")
 	errCookieSyncAccountBlocked                    = errors.New("account is disabled, please reach out to the prebid server host")
 	errCookieSyncAccountConfigMalformed            = errors.New("account config is malformed and could not be read")
@@ -134,6 +135,11 @@ func (c *cookieSyncEndpoint) parseRequest(r *http.Request) (usersync.Request, pr
 		return usersync.Request{}, privacy.Policies{}, err
 	}
 
+	//OpenWrap: do not allow publishers to bypass GDPR
+	if c.privacyConfig.gdprConfig.DefaultValue == "1" && gdprSignal == gdpr.SignalNo {
+		return usersync.Request{}, privacy.Policies{}, errCookieSyncGDPRMandatoryByHost
+	}
+
 	if request.GDPRConsent == "" {
 		if gdprSignal == gdpr.SignalYes {
 			return usersync.Request{}, privacy.Policies{}, errCookieSyncGDPRConsentMissing
@@ -352,10 +358,16 @@ func (c *cookieSyncEndpoint) handleResponse(w http.ResponseWriter, tf usersync.S
 	}
 
 	for _, syncerChoice := range s {
-		syncTypes := tf.ForBidder(syncerChoice.Bidder)
+		//added hack to support to old wrapper versions having indexExchange as partner
+		//TODO: Remove when a stable version is released
+		bidderName := syncerChoice.Bidder
+		if bidderName == "indexExchange" {
+			bidderName = "ix"
+		}
+		syncTypes := tf.ForBidder(bidderName)
 		sync, err := syncerChoice.Syncer.GetSync(syncTypes, p)
 		if err != nil {
-			glog.Errorf("Failed to get usersync info for %s: %v", syncerChoice.Bidder, err)
+			glog.Errorf("Failed to get usersync info for %s: %v", bidderName, err)
 			continue
 		}
 
@@ -397,6 +409,9 @@ func mapBidderStatusToAnalytics(from []cookieSyncResponseBidder) []*analytics.Co
 	return to
 }
 
+type CookieSyncReq cookieSyncRequest
+type CookieSyncResp cookieSyncResponse
+
 type cookieSyncRequest struct {
 	Bidders         []string                         `json:"bidders"`
 	GDPR            *int                             `json:"gdpr"`
diff --git a/endpoints/cookie_sync_test.go b/endpoints/cookie_sync_test.go
index 3947d1f06..495129ee5 100644
--- a/endpoints/cookie_sync_test.go
+++ b/endpoints/cookie_sync_test.go
@@ -689,6 +689,13 @@ func TestCookieSyncParseRequest(t *testing.T) {
 			givenCCPAEnabled: true,
 			expectedError:    "gdpr_consent is required. gdpr is not specified and is assumed to be 1 by the server. set gdpr=0 to exempt this request",
 		},
+		{
+			description:      "Explicit GDPR Signal 0 - Default Value 1",
+			givenBody:        strings.NewReader(`{"gdpr": 0}`),
+			givenGDPRConfig:  config.GDPR{Enabled: true, DefaultValue: "1"},
+			givenCCPAEnabled: true,
+			expectedError:    "gdpr_consent is required. gdpr exemption disabled by host",
+		},
 		{
 			description:      "HTTP Read Error",
 			givenBody:        iotest.ErrReader(errors.New("anyError")),
diff --git a/endpoints/events/vtrack_ow.go b/endpoints/events/vtrack_ow.go
new file mode 100644
index 000000000..3e2a7b8a8
--- /dev/null
+++ b/endpoints/events/vtrack_ow.go
@@ -0,0 +1,284 @@
+package events
+
+import (
+	"encoding/json"
+	"errors"
+	"fmt"
+	"net/url"
+	"strings"
+
+	"github.com/beevik/etree"
+	"github.com/golang/glog"
+	"github.com/prebid/openrtb/v19/adcom1"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// standard VAST macros
+// https://interactiveadvertisingbureau.github.io/vast/vast4macros/vast4-macros-latest.html#macro-spec-adcount
+const (
+	VASTAdTypeMacro    = "[ADTYPE]"
+	VASTAppBundleMacro = "[APPBUNDLE]"
+	VASTDomainMacro    = "[DOMAIN]"
+	VASTPageURLMacro   = "[PAGEURL]"
+
+	// PBS specific macros
+	PBSEventIDMacro = "[EVENT_ID]" // macro for injecting PBS defined  video event tracker id
+	//[PBS-ACCOUNT] represents publisher id / account id
+	PBSAccountMacro = "[PBS-ACCOUNT]"
+	// [PBS-BIDDER] represents bidder name
+	PBSBidderMacro = "[PBS-BIDDER]"
+	// [PBS-ORIG_BIDID] represents original bid id.
+	PBSOrigBidIDMacro = "[PBS-ORIG_BIDID]"
+	// [PBS-BIDID] represents bid id. If auction.generate-bid-id config is on, then resolve with response.seatbid.bid.ext.prebid.bidid. Else replace with response.seatbid.bid.id
+	PBSBidIDMacro = "[PBS-BIDID]"
+	// [ADERVERTISER_NAME] represents advertiser name
+	PBSAdvertiserNameMacro = "[ADVERTISER_NAME]"
+	// Pass imp.tagId using this macro
+	PBSAdUnitIDMacro = "[AD_UNIT]"
+	//PBSBidderCodeMacro represents an alias id or core bidder id.
+	PBSBidderCodeMacro = "[BIDDER_CODE]"
+)
+
+var trackingEvents = []string{"start", "firstQuartile", "midpoint", "thirdQuartile", "complete"}
+
+// PubMatic specific event IDs
+// This will go in event-config once PreBid modular design is in place
+var eventIDMap = map[string]string{
+	"start":         "2",
+	"firstQuartile": "4",
+	"midpoint":      "3",
+	"thirdQuartile": "5",
+	"complete":      "6",
+}
+
+// InjectVideoEventTrackers injects the video tracking events
+// Returns VAST xml contains as first argument. Second argument indicates whether the trackers are injected and last argument indicates if there is any error in injecting the trackers
+func InjectVideoEventTrackers(trackerURL, vastXML string, bid *openrtb2.Bid, prebidGenBidId, requestingBidder, bidderCoreName, accountID string, timestamp int64, bidRequest *openrtb2.BidRequest) ([]byte, bool, error) {
+	// parse VAST
+	doc := etree.NewDocument()
+	err := doc.ReadFromString(vastXML)
+	if nil != err {
+		err = fmt.Errorf("Error parsing VAST XML. '%v'", err.Error())
+		glog.Errorf(err.Error())
+		return []byte(vastXML), false, err // false indicates events trackers are not injected
+	}
+
+	//Maintaining BidRequest Impression Map (Copied from exchange.go#applyCategoryMapping)
+	//TODO: It should be optimized by forming once and reusing
+	impMap := make(map[string]*openrtb2.Imp)
+	for i := range bidRequest.Imp {
+		impMap[bidRequest.Imp[i].ID] = &bidRequest.Imp[i]
+	}
+
+	eventURLMap := GetVideoEventTracking(trackerURL, bid, prebidGenBidId, requestingBidder, bidderCoreName, accountID, timestamp, bidRequest, doc, impMap)
+	trackersInjected := false
+	// return if if no tracking URL
+	if len(eventURLMap) == 0 {
+		return []byte(vastXML), false, errors.New("Event URLs are not found")
+	}
+
+	creatives := FindCreatives(doc)
+
+	if adm := strings.TrimSpace(bid.AdM); adm == "" || strings.HasPrefix(adm, "http") {
+		// determine which creative type to be created based on linearity
+		if imp, ok := impMap[bid.ImpID]; ok && nil != imp.Video {
+			// create creative object
+			creatives = doc.FindElements("VAST/Ad/Wrapper/Creatives")
+			// var creative *etree.Element
+			// if len(creatives) > 0 {
+			// 	creative = creatives[0] // consider only first creative
+			// } else {
+			creative := doc.CreateElement("Creative")
+			creatives[0].AddChild(creative)
+
+			// }
+
+			switch imp.Video.Linearity {
+			case adcom1.LinearityLinear:
+				creative.AddChild(doc.CreateElement("Linear"))
+			case adcom1.LinearityNonLinear:
+				creative.AddChild(doc.CreateElement("NonLinearAds"))
+			default: // create both type of creatives
+				creative.AddChild(doc.CreateElement("Linear"))
+				creative.AddChild(doc.CreateElement("NonLinearAds"))
+			}
+			creatives = creative.ChildElements() // point to actual cratives
+		}
+	}
+	for _, creative := range creatives {
+		trackingEvents := creative.SelectElement("TrackingEvents")
+		if nil == trackingEvents {
+			trackingEvents = creative.CreateElement("TrackingEvents")
+			creative.AddChild(trackingEvents)
+		}
+		// Inject
+		for event, url := range eventURLMap {
+			trackingEle := trackingEvents.CreateElement("Tracking")
+			trackingEle.CreateAttr("event", event)
+			trackingEle.SetText(fmt.Sprintf("%s", url))
+			trackersInjected = true
+		}
+	}
+
+	out := []byte(vastXML)
+	var wErr error
+	if trackersInjected {
+		out, wErr = doc.WriteToBytes()
+		trackersInjected = trackersInjected && nil == wErr
+		if nil != wErr {
+			glog.Errorf("%v", wErr.Error())
+		}
+	}
+	return out, trackersInjected, wErr
+}
+
+// GetVideoEventTracking returns map containing key as event name value as associaed video event tracking URL
+// By default PBS will expect [EVENT_ID] macro in trackerURL to inject event information
+// [EVENT_ID] will be injected with one of the following values
+//
+//	firstQuartile, midpoint, thirdQuartile, complete
+//
+// If your company can not use [EVENT_ID] and has its own macro. provide config.TrackerMacros implementation
+// and ensure that your macro is part of trackerURL configuration
+func GetVideoEventTracking(trackerURL string, bid *openrtb2.Bid, prebidGenBidId, requestingBidder string, bidderCoreName string, accountId string, timestamp int64, req *openrtb2.BidRequest, doc *etree.Document, impMap map[string]*openrtb2.Imp) map[string]string {
+	eventURLMap := make(map[string]string)
+	if "" == strings.TrimSpace(trackerURL) {
+		return eventURLMap
+	}
+
+	// lookup custom macros
+	var customMacroMap map[string]string
+	if nil != req.Ext {
+		reqExt := new(openrtb_ext.ExtRequest)
+		err := json.Unmarshal(req.Ext, &reqExt)
+		if err == nil {
+			customMacroMap = reqExt.Prebid.Macros
+		} else {
+			glog.Warningf("Error in unmarshling req.Ext.Prebid.Vast: [%s]", err.Error())
+		}
+	}
+
+	for _, event := range trackingEvents {
+		eventURL := trackerURL
+		// lookup in custom macros
+		if nil != customMacroMap {
+			for customMacro, value := range customMacroMap {
+				eventURL = replaceMacro(eventURL, customMacro, value)
+			}
+		}
+		// replace standard macros
+		eventURL = replaceMacro(eventURL, VASTAdTypeMacro, string(openrtb_ext.BidTypeVideo))
+		if nil != req && nil != req.App {
+			// eventURL = replaceMacro(eventURL, VASTAppBundleMacro, req.App.Bundle)
+			eventURL = replaceMacro(eventURL, VASTDomainMacro, req.App.Bundle)
+			if nil != req.App.Publisher {
+				eventURL = replaceMacro(eventURL, PBSAccountMacro, req.App.Publisher.ID)
+			}
+		}
+		if nil != req && nil != req.Site {
+			eventURL = replaceMacro(eventURL, VASTDomainMacro, getDomain(req.Site))
+			eventURL = replaceMacro(eventURL, VASTPageURLMacro, req.Site.Page)
+			if nil != req.Site.Publisher {
+				eventURL = replaceMacro(eventURL, PBSAccountMacro, req.Site.Publisher.ID)
+			}
+		}
+
+		domain := ""
+		if len(bid.ADomain) > 0 {
+			var err error
+			//eventURL = replaceMacro(eventURL, PBSAdvertiserNameMacro, strings.Join(bid.ADomain, ","))
+			domain, err = extractDomain(bid.ADomain[0])
+			if err != nil {
+				glog.Warningf("Unable to extract domain from '%s'. [%s]", bid.ADomain[0], err.Error())
+			}
+		}
+
+		eventURL = replaceMacro(eventURL, PBSAdvertiserNameMacro, domain)
+
+		eventURL = replaceMacro(eventURL, PBSBidderMacro, bidderCoreName)
+		eventURL = replaceMacro(eventURL, PBSBidderCodeMacro, requestingBidder)
+
+		/* Use generated bidId if present, else use bid.ID */
+		if len(prebidGenBidId) > 0 && prebidGenBidId != bid.ID {
+			eventURL = replaceMacro(eventURL, PBSBidIDMacro, prebidGenBidId)
+		} else {
+			eventURL = replaceMacro(eventURL, PBSBidIDMacro, bid.ID)
+		}
+		eventURL = replaceMacro(eventURL, PBSOrigBidIDMacro, bid.ID)
+
+		// replace [EVENT_ID] macro with PBS defined event ID
+		eventURL = replaceMacro(eventURL, PBSEventIDMacro, eventIDMap[event])
+
+		if imp, ok := impMap[bid.ImpID]; ok {
+			eventURL = replaceMacro(eventURL, PBSAdUnitIDMacro, imp.TagID)
+		} else {
+			glog.Warningf("Setting empty value for %s macro, as failed to determine imp.TagID for bid.ImpID: %s", PBSAdUnitIDMacro, bid.ImpID)
+			eventURL = replaceMacro(eventURL, PBSAdUnitIDMacro, "")
+		}
+
+		eventURLMap[event] = eventURL
+	}
+	return eventURLMap
+}
+
+func replaceMacro(trackerURL, macro, value string) string {
+	macro = strings.TrimSpace(macro)
+	trimmedValue := strings.TrimSpace(value)
+
+	if strings.HasPrefix(macro, "[") && strings.HasSuffix(macro, "]") && len(trimmedValue) > 0 {
+		trackerURL = strings.ReplaceAll(trackerURL, macro, url.QueryEscape(value))
+	} else if strings.HasPrefix(macro, "[") && strings.HasSuffix(macro, "]") && len(trimmedValue) == 0 {
+		trackerURL = strings.ReplaceAll(trackerURL, macro, url.QueryEscape(""))
+	} else {
+		glog.Warningf("Invalid macro '%v'. Either empty or missing prefix '[' or suffix ']", macro)
+	}
+	return trackerURL
+}
+
+// FindCreatives finds Linear, NonLinearAds fro InLine and Wrapper Type of creatives
+// from input doc - VAST Document
+// NOTE: This function is temporarily seperated to reuse in ctv_auction.go. Because, in case of ctv
+// we generate bid.id
+func FindCreatives(doc *etree.Document) []*etree.Element {
+	// Find Creatives of Linear and NonLinear Type
+	// Injecting Tracking Events for Companion is not supported here
+	creatives := doc.FindElements("VAST/Ad/InLine/Creatives/Creative/Linear")
+	creatives = append(creatives, doc.FindElements("VAST/Ad/Wrapper/Creatives/Creative/Linear")...)
+	creatives = append(creatives, doc.FindElements("VAST/Ad/InLine/Creatives/Creative/NonLinearAds")...)
+	creatives = append(creatives, doc.FindElements("VAST/Ad/Wrapper/Creatives/Creative/NonLinearAds")...)
+	return creatives
+}
+
+func extractDomain(rawURL string) (string, error) {
+	if !strings.HasPrefix(rawURL, "http") {
+		rawURL = "http://" + rawURL
+	}
+	// decode rawURL
+	rawURL, err := url.QueryUnescape(rawURL)
+	if nil != err {
+		return "", err
+	}
+	url, err := url.Parse(rawURL)
+	if nil != err {
+		return "", err
+	}
+	// remove www if present
+	return strings.TrimPrefix(url.Hostname(), "www."), nil
+}
+
+func getDomain(site *openrtb2.Site) string {
+	if site.Domain != "" {
+		return site.Domain
+	}
+
+	hostname := ""
+
+	if site.Page != "" {
+		pageURL, err := url.Parse(site.Page)
+		if err == nil && pageURL != nil {
+			hostname = pageURL.Host
+		}
+	}
+	return hostname
+}
diff --git a/endpoints/events/vtrack_ow_test.go b/endpoints/events/vtrack_ow_test.go
new file mode 100644
index 000000000..33177e66e
--- /dev/null
+++ b/endpoints/events/vtrack_ow_test.go
@@ -0,0 +1,636 @@
+package events
+
+import (
+	"fmt"
+	"net/url"
+	"testing"
+
+	"github.com/beevik/etree"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestInjectVideoEventTrackers(t *testing.T) {
+	type args struct {
+		externalURL string
+		genbidID    string
+		bid         *openrtb2.Bid
+		req         *openrtb2.BidRequest
+	}
+	type want struct {
+		eventURLs map[string][]string
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "linear_creative",
+			args: args{
+				externalURL: "http://company.tracker.com?eventId=[EVENT_ID]&appbundle=[DOMAIN]",
+				bid: &openrtb2.Bid{
+					AdM: `<VAST version="3.0"><Ad><InLine><Creatives><Creative>
+					                              <Linear>                      
+					                                      <TrackingEvents>
+					                                              <Tracking event="firstQuartile"><![CDATA[http://example.com/tracking/firstQuartile?k1=v1&k2=v2]]></Tracking>
+					                                              <Tracking event="midpoint">http://example.com/tracking/midpoint</Tracking>
+					                                              <Tracking event="thirdQuartile">http://example.com/tracking/thirdQuartile</Tracking>
+																  <Tracking event="complete">http://example.com/tracking/complete</Tracking>
+																  <Tracking event="start">http://partner.tracking.url</Tracking>
+					                                      </TrackingEvents>
+					                              </Linear>
+					                     </Creative></Creatives></InLine></Ad></VAST>`,
+				},
+				req: &openrtb2.BidRequest{App: &openrtb2.App{Bundle: "abc"}},
+			},
+			want: want{
+				eventURLs: map[string][]string{
+					// "firstQuartile": {"http://example.com/tracking/firstQuartile?k1=v1&k2=v2", "http://company.tracker.com?eventId=1004&appbundle=abc"},
+					// "midpoint":      {"http://example.com/tracking/midpoint", "http://company.tracker.com?eventId=1003&appbundle=abc"},
+					// "thirdQuartile": {"http://example.com/tracking/thirdQuartile", "http://company.tracker.com?eventId=1005&appbundle=abc"},
+					// "complete":      {"http://example.com/tracking/complete", "http://company.tracker.com?eventId=1006&appbundle=abc"},
+					"firstQuartile": {"http://example.com/tracking/firstQuartile?k1=v1&k2=v2", "http://company.tracker.com?eventId=4&appbundle=abc"},
+					"midpoint":      {"http://example.com/tracking/midpoint", "http://company.tracker.com?eventId=3&appbundle=abc"},
+					"thirdQuartile": {"http://example.com/tracking/thirdQuartile", "http://company.tracker.com?eventId=5&appbundle=abc"},
+					"complete":      {"http://example.com/tracking/complete", "http://company.tracker.com?eventId=6&appbundle=abc"},
+					"start":         {"http://company.tracker.com?eventId=2&appbundle=abc", "http://partner.tracking.url"},
+				},
+			},
+		},
+		{
+			name: "non_linear_creative",
+			args: args{
+				externalURL: "http://company.tracker.com?eventId=[EVENT_ID]&appbundle=[DOMAIN]",
+				bid: &openrtb2.Bid{ // Adm contains to TrackingEvents tag
+					AdM: `<VAST version="3.0"><Ad><InLine><Creatives><Creative>
+				<NonLinearAds>
+					<TrackingEvents>
+					<Tracking event="firstQuartile">http://something.com</Tracking>
+					</TrackingEvents>
+				</NonLinearAds>
+			</Creative></Creatives></InLine></Ad></VAST>`,
+				},
+				req: &openrtb2.BidRequest{App: &openrtb2.App{Bundle: "abc"}},
+			},
+			want: want{
+				eventURLs: map[string][]string{
+					// "firstQuartile": {"http://something.com", "http://company.tracker.com?eventId=1004&appbundle=abc"},
+					// "midpoint":      {"http://company.tracker.com?eventId=1003&appbundle=abc"},
+					// "thirdQuartile": {"http://company.tracker.com?eventId=1005&appbundle=abc"},
+					// "complete":      {"http://company.tracker.com?eventId=1006&appbundle=abc"},
+					"firstQuartile": {"http://something.com", "http://company.tracker.com?eventId=4&appbundle=abc"},
+					"midpoint":      {"http://company.tracker.com?eventId=3&appbundle=abc"},
+					"thirdQuartile": {"http://company.tracker.com?eventId=5&appbundle=abc"},
+					"complete":      {"http://company.tracker.com?eventId=6&appbundle=abc"},
+					"start":         {"http://company.tracker.com?eventId=2&appbundle=abc"},
+				},
+			},
+		}, {
+			name: "no_traker_url_configured", // expect no injection
+			args: args{
+				externalURL: "",
+				bid: &openrtb2.Bid{ // Adm contains to TrackingEvents tag
+					AdM: `<VAST version="3.0"><Ad><InLine><Creatives><Creative>
+				<Linear>                      
+				</Linear>
+			</Creative></Creatives></InLine></Ad></VAST>`,
+				},
+				req: &openrtb2.BidRequest{App: &openrtb2.App{Bundle: "abc"}},
+			},
+			want: want{
+				eventURLs: map[string][]string{},
+			},
+		},
+		{
+			name: "wrapper_vast_xml_from_partner", // expect we are injecting trackers inside wrapper
+			args: args{
+				externalURL: "http://company.tracker.com?eventId=[EVENT_ID]&appbundle=[DOMAIN]",
+				bid: &openrtb2.Bid{ // Adm contains to TrackingEvents tag
+					AdM: `<VAST version="4.2" xmlns="http://www.iab.com/VAST">
+					<Ad id="20011" sequence="1" >
+					  <Wrapper followAdditionalWrappers="0" allowMultipleAds="1" fallbackOnNoAd="0">
+						<AdSystem version="4.0">iabtechlab</AdSystem>
+					  <VASTAdTagURI>http://somevasturl</VASTAdTagURI>
+						<Impression id="Impression-ID"><![CDATA[https://example.com/track/impression]]></Impression>
+						<Creatives>
+						  <Creative id="5480" sequence="1" adId="2447226">
+							 <Linear></Linear>
+						 </Creative>
+				  </Creatives></Wrapper></Ad></VAST>`,
+				},
+				req: &openrtb2.BidRequest{App: &openrtb2.App{Bundle: "abc"}},
+			},
+			want: want{
+				eventURLs: map[string][]string{
+					// "firstQuartile": {"http://company.tracker.com?eventId=firstQuartile&appbundle=abc"},
+					// "midpoint":      {"http://company.tracker.com?eventId=midpoint&appbundle=abc"},
+					// "thirdQuartile": {"http://company.tracker.com?eventId=thirdQuartile&appbundle=abc"},
+					// "complete":      {"http://company.tracker.com?eventId=complete&appbundle=abc"},
+					"firstQuartile": {"http://company.tracker.com?eventId=4&appbundle=abc"},
+					"midpoint":      {"http://company.tracker.com?eventId=3&appbundle=abc"},
+					"thirdQuartile": {"http://company.tracker.com?eventId=5&appbundle=abc"},
+					"complete":      {"http://company.tracker.com?eventId=6&appbundle=abc"},
+					"start":         {"http://company.tracker.com?eventId=2&appbundle=abc"},
+				},
+			},
+		},
+		// {
+		// 	name: "vast_tag_uri_response_from_partner",
+		// 	args: args{
+		// 		externalURL: "http://company.tracker.com?eventId=[EVENT_ID]&appbundle=[DOMAIN]",
+		// 		bid: &openrtb2.Bid{ // Adm contains to TrackingEvents tag
+		// 			AdM: `<![CDATA[http://hostedvasttag.url&k=v]]>`,
+		// 		},
+		// 		req: &openrtb2.BidRequest{App: &openrtb2.App{Bundle: "abc"}},
+		// 	},
+		// 	want: want{
+		// 		eventURLs: map[string][]string{
+		// 			"firstQuartile": {"http://company.tracker.com?eventId=firstQuartile&appbundle=abc"},
+		// 			"midpoint":      {"http://company.tracker.com?eventId=midpoint&appbundle=abc"},
+		// 			"thirdQuartile": {"http://company.tracker.com?eventId=thirdQuartile&appbundle=abc"},
+		// 			"complete":      {"http://company.tracker.com?eventId=complete&appbundle=abc"},
+		// 		},
+		// 	},
+		// },
+		// {
+		// 	name: "adm_empty",
+		// 	args: args{
+		// 		externalURL: "http://company.tracker.com?eventId=[EVENT_ID]&appbundle=[DOMAIN]",
+		// 		bid: &openrtb2.Bid{ // Adm contains to TrackingEvents tag
+		// 			AdM:  "",
+		// 			NURL: "nurl_contents",
+		// 		},
+		// 		req: &openrtb2.BidRequest{App: &openrtb2.App{Bundle: "abc"}},
+		// 	},
+		// 	want: want{
+		// 		eventURLs: map[string][]string{
+		// 			"firstQuartile": {"http://company.tracker.com?eventId=firstQuartile&appbundle=abc"},
+		// 			"midpoint":      {"http://company.tracker.com?eventId=midpoint&appbundle=abc"},
+		// 			"thirdQuartile": {"http://company.tracker.com?eventId=thirdQuartile&appbundle=abc"},
+		// 			"complete":      {"http://company.tracker.com?eventId=complete&appbundle=abc"},
+		// 		},
+		// 	},
+		// },
+	}
+	for _, tc := range tests {
+		t.Run(tc.name, func(t *testing.T) {
+			vast := ""
+			if nil != tc.args.bid {
+				vast = tc.args.bid.AdM // original vast
+			}
+			// bind this bid id with imp object
+			tc.args.req.Imp = []openrtb2.Imp{{ID: "123", Video: &openrtb2.Video{}}}
+			tc.args.bid.ImpID = tc.args.req.Imp[0].ID
+			accountID := ""
+			timestamp := int64(0)
+			requestingBidder := "test_bidder"
+			bidderCoreName := "test_core_bidder"
+			injectedVast, injected, ierr := InjectVideoEventTrackers(tc.args.externalURL, vast, tc.args.bid, tc.args.genbidID, requestingBidder, bidderCoreName, accountID, timestamp, tc.args.req)
+
+			if !injected {
+				// expect no change in input vast if tracking events are not injected
+				assert.Equal(t, vast, string(injectedVast))
+				assert.NotNil(t, ierr)
+			} else {
+				assert.Nil(t, ierr)
+			}
+			actualVastDoc := etree.NewDocument()
+
+			err := actualVastDoc.ReadFromBytes(injectedVast)
+			if nil != err {
+				assert.Fail(t, err.Error())
+			}
+
+			// fmt.Println(string(injectedVast))
+			actualTrackingEvents := actualVastDoc.FindElements("VAST/Ad/InLine/Creatives/Creative/Linear/TrackingEvents/Tracking")
+			actualTrackingEvents = append(actualTrackingEvents, actualVastDoc.FindElements("VAST/Ad/InLine/Creatives/Creative/NonLinearAds/TrackingEvents/Tracking")...)
+			actualTrackingEvents = append(actualTrackingEvents, actualVastDoc.FindElements("VAST/Ad/Wrapper/Creatives/Creative/Linear/TrackingEvents/Tracking")...)
+			actualTrackingEvents = append(actualTrackingEvents, actualVastDoc.FindElements("VAST/Ad/Wrapper/Creatives/Creative/NonLinearAds/TrackingEvents/Tracking")...)
+
+			totalURLCount := 0
+			for event, URLs := range tc.want.eventURLs {
+
+				for _, expectedURL := range URLs {
+					present := false
+					for _, te := range actualTrackingEvents {
+						if te.SelectAttr("event").Value == event && te.Text() == expectedURL {
+							present = true
+							totalURLCount++
+							break // expected URL present. check for next expected URL
+						}
+					}
+					if !present {
+						assert.Fail(t, "Expected tracker URL '"+expectedURL+"' is not present")
+					}
+				}
+			}
+			// ensure all total of events are injected
+			assert.Equal(t, totalURLCount, len(actualTrackingEvents), fmt.Sprintf("Expected '%v' event trackers. But found '%v'", len(tc.want.eventURLs), len(actualTrackingEvents)))
+
+		})
+	}
+}
+
+func TestGetVideoEventTracking(t *testing.T) {
+	type args struct {
+		trackerURL       string
+		bid              *openrtb2.Bid
+		requestingBidder string
+		gen_bidid        string
+		bidderCoreName   string
+		accountId        string
+		timestamp        int64
+		req              *openrtb2.BidRequest
+		doc              *etree.Document
+	}
+	type want struct {
+		trackerURLMap map[string]string
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "valid_scenario",
+			args: args{
+				trackerURL: "http://company.tracker.com?eventId=[EVENT_ID]&appbundle=[DOMAIN]",
+				bid:        &openrtb2.Bid{
+					// AdM: vastXMLWith2Creatives,
+				},
+				req: &openrtb2.BidRequest{
+					App: &openrtb2.App{
+						Bundle: "someappbundle",
+					},
+					Imp: []openrtb2.Imp{},
+				},
+			},
+			want: want{
+				trackerURLMap: map[string]string{
+					// "firstQuartile": "http://company.tracker.com?eventId=firstQuartile&appbundle=someappbundle",
+					// "midpoint":      "http://company.tracker.com?eventId=midpoint&appbundle=someappbundle",
+					// "thirdQuartile": "http://company.tracker.com?eventId=thirdQuartile&appbundle=someappbundle",
+					// "complete":      "http://company.tracker.com?eventId=complete&appbundle=someappbundle"},
+					"firstQuartile": "http://company.tracker.com?eventId=4&appbundle=someappbundle",
+					"midpoint":      "http://company.tracker.com?eventId=3&appbundle=someappbundle",
+					"thirdQuartile": "http://company.tracker.com?eventId=5&appbundle=someappbundle",
+					"start":         "http://company.tracker.com?eventId=2&appbundle=someappbundle",
+					"complete":      "http://company.tracker.com?eventId=6&appbundle=someappbundle"},
+			},
+		},
+		{
+			name: "no_macro_value", // expect no replacement
+			args: args{
+				trackerURL: "http://company.tracker.com?eventId=[EVENT_ID]&appbundle=[DOMAIN]",
+				bid:        &openrtb2.Bid{},
+				req: &openrtb2.BidRequest{
+					App: &openrtb2.App{}, // no app bundle value
+					Imp: []openrtb2.Imp{},
+				},
+			},
+			want: want{
+				trackerURLMap: map[string]string{
+					// "firstQuartile": "http://company.tracker.com?eventId=firstQuartile&appbundle=[DOMAIN]",
+					// "midpoint":      "http://company.tracker.com?eventId=midpoint&appbundle=[DOMAIN]",
+					// "thirdQuartile": "http://company.tracker.com?eventId=thirdQuartile&appbundle=[DOMAIN]",
+					// "complete":      "http://company.tracker.com?eventId=complete&appbundle=[DOMAIN]"},
+					"firstQuartile": "http://company.tracker.com?eventId=4&appbundle=",
+					"midpoint":      "http://company.tracker.com?eventId=3&appbundle=",
+					"thirdQuartile": "http://company.tracker.com?eventId=5&appbundle=",
+					"start":         "http://company.tracker.com?eventId=2&appbundle=",
+					"complete":      "http://company.tracker.com?eventId=6&appbundle="},
+			},
+		},
+		{
+			name: "prefer_company_value_for_standard_macro",
+			args: args{
+				trackerURL: "http://company.tracker.com?eventId=[EVENT_ID]&appbundle=[DOMAIN]",
+				req: &openrtb2.BidRequest{
+					App: &openrtb2.App{
+						Bundle: "myapp", // do not expect this value
+					},
+					Imp: []openrtb2.Imp{},
+					Ext: []byte(`{"prebid":{
+								"macros": {
+									"[DOMAIN]": "my_custom_value"
+								}
+						}}`),
+				},
+			},
+			want: want{
+				trackerURLMap: map[string]string{
+					// "firstQuartile": "http://company.tracker.com?eventId=firstQuartile&appbundle=my_custom_value",
+					// "midpoint":      "http://company.tracker.com?eventId=midpoint&appbundle=my_custom_value",
+					// "thirdQuartile": "http://company.tracker.com?eventId=thirdQuartile&appbundle=my_custom_value",
+					// "complete":      "http://company.tracker.com?eventId=complete&appbundle=my_custom_value"},
+					"firstQuartile": "http://company.tracker.com?eventId=4&appbundle=my_custom_value",
+					"midpoint":      "http://company.tracker.com?eventId=3&appbundle=my_custom_value",
+					"thirdQuartile": "http://company.tracker.com?eventId=5&appbundle=my_custom_value",
+					"start":         "http://company.tracker.com?eventId=2&appbundle=my_custom_value",
+					"complete":      "http://company.tracker.com?eventId=6&appbundle=my_custom_value"},
+			},
+		}, {
+			name: "multireplace_macro",
+			args: args{
+				trackerURL: "http://company.tracker.com?eventId=[EVENT_ID]&appbundle=[DOMAIN]&parameter2=[DOMAIN]",
+				req: &openrtb2.BidRequest{
+					App: &openrtb2.App{
+						Bundle: "myapp123",
+					},
+					Imp: []openrtb2.Imp{},
+				},
+			},
+			want: want{
+				trackerURLMap: map[string]string{
+					// "firstQuartile": "http://company.tracker.com?eventId=firstQuartile&appbundle=myapp123&parameter2=myapp123",
+					// "midpoint":      "http://company.tracker.com?eventId=midpoint&appbundle=myapp123&parameter2=myapp123",
+					// "thirdQuartile": "http://company.tracker.com?eventId=thirdQuartile&appbundle=myapp123&parameter2=myapp123",
+					// "complete":      "http://company.tracker.com?eventId=complete&appbundle=myapp123&parameter2=myapp123"},
+					"firstQuartile": "http://company.tracker.com?eventId=4&appbundle=myapp123&parameter2=myapp123",
+					"midpoint":      "http://company.tracker.com?eventId=3&appbundle=myapp123&parameter2=myapp123",
+					"thirdQuartile": "http://company.tracker.com?eventId=5&appbundle=myapp123&parameter2=myapp123",
+					"start":         "http://company.tracker.com?eventId=2&appbundle=myapp123&parameter2=myapp123",
+					"complete":      "http://company.tracker.com?eventId=6&appbundle=myapp123&parameter2=myapp123"},
+			},
+		},
+		{
+			name: "custom_macro_without_prefix_and_suffix",
+			args: args{
+				trackerURL: "http://company.tracker.com?eventId=[EVENT_ID]&param1=[CUSTOM_MACRO]",
+				req: &openrtb2.BidRequest{
+					Ext: []byte(`{"prebid":{
+							"macros": {
+								"CUSTOM_MACRO": "my_custom_value"
+							}
+					}}`),
+					Imp: []openrtb2.Imp{},
+				},
+			},
+			want: want{
+				trackerURLMap: map[string]string{
+					// "firstQuartile": "http://company.tracker.com?eventId=firstQuartile&param1=[CUSTOM_MACRO]",
+					// "midpoint":      "http://company.tracker.com?eventId=midpoint&param1=[CUSTOM_MACRO]",
+					// "thirdQuartile": "http://company.tracker.com?eventId=thirdQuartile&param1=[CUSTOM_MACRO]",
+					// "complete":      "http://company.tracker.com?eventId=complete&param1=[CUSTOM_MACRO]"},
+					"firstQuartile": "http://company.tracker.com?eventId=4&param1=[CUSTOM_MACRO]",
+					"midpoint":      "http://company.tracker.com?eventId=3&param1=[CUSTOM_MACRO]",
+					"thirdQuartile": "http://company.tracker.com?eventId=5&param1=[CUSTOM_MACRO]",
+					"start":         "http://company.tracker.com?eventId=2&param1=[CUSTOM_MACRO]",
+					"complete":      "http://company.tracker.com?eventId=6&param1=[CUSTOM_MACRO]"},
+			},
+		},
+		{
+			name: "empty_macro",
+			args: args{
+				trackerURL: "http://company.tracker.com?eventId=[EVENT_ID]&param1=[CUSTOM_MACRO]",
+				req: &openrtb2.BidRequest{
+					Ext: []byte(`{"prebid":{
+							"macros": {
+								"": "my_custom_value"
+							}
+					}}`),
+					Imp: []openrtb2.Imp{},
+				},
+			},
+			want: want{
+				trackerURLMap: map[string]string{
+					// "firstQuartile": "http://company.tracker.com?eventId=firstQuartile&param1=[CUSTOM_MACRO]",
+					// "midpoint":      "http://company.tracker.com?eventId=midpoint&param1=[CUSTOM_MACRO]",
+					// "thirdQuartile": "http://company.tracker.com?eventId=thirdQuartile&param1=[CUSTOM_MACRO]",
+					// "complete":      "http://company.tracker.com?eventId=complete&param1=[CUSTOM_MACRO]"},
+					"firstQuartile": "http://company.tracker.com?eventId=4&param1=[CUSTOM_MACRO]",
+					"midpoint":      "http://company.tracker.com?eventId=3&param1=[CUSTOM_MACRO]",
+					"thirdQuartile": "http://company.tracker.com?eventId=5&param1=[CUSTOM_MACRO]",
+					"start":         "http://company.tracker.com?eventId=2&param1=[CUSTOM_MACRO]",
+					"complete":      "http://company.tracker.com?eventId=6&param1=[CUSTOM_MACRO]"},
+			},
+		},
+		{
+			name: "macro_is_case_sensitive",
+			args: args{
+				trackerURL: "http://company.tracker.com?eventId=[EVENT_ID]&param1=[CUSTOM_MACRO]",
+				req: &openrtb2.BidRequest{
+					Ext: []byte(`{"prebid":{
+							"macros": {
+								"": "my_custom_value"
+							}
+					}}`),
+					Imp: []openrtb2.Imp{},
+				},
+			},
+			want: want{
+				trackerURLMap: map[string]string{
+					// "firstQuartile": "http://company.tracker.com?eventId=firstQuartile&param1=[CUSTOM_MACRO]",
+					// "midpoint":      "http://company.tracker.com?eventId=midpoint&param1=[CUSTOM_MACRO]",
+					// "thirdQuartile": "http://company.tracker.com?eventId=thirdQuartile&param1=[CUSTOM_MACRO]",
+					// "complete":      "http://company.tracker.com?eventId=complete&param1=[CUSTOM_MACRO]"},
+					"firstQuartile": "http://company.tracker.com?eventId=4&param1=[CUSTOM_MACRO]",
+					"midpoint":      "http://company.tracker.com?eventId=3&param1=[CUSTOM_MACRO]",
+					"thirdQuartile": "http://company.tracker.com?eventId=5&param1=[CUSTOM_MACRO]",
+					"start":         "http://company.tracker.com?eventId=2&param1=[CUSTOM_MACRO]",
+					"complete":      "http://company.tracker.com?eventId=6&param1=[CUSTOM_MACRO]"},
+			},
+		},
+		{
+			name: "empty_tracker_url",
+			args: args{trackerURL: "    ", req: &openrtb2.BidRequest{Imp: []openrtb2.Imp{}}},
+			want: want{trackerURLMap: make(map[string]string)},
+		},
+		{
+			name: "site_domain_tracker_url",
+			args: args{trackerURL: "https://company.tracker.com?operId=8&e=[EVENT_ID]&p=[PBS-ACCOUNT]&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=[PBS-BIDDER]&advertiser_id=[ADVERTISER_NAME]&sURL=[DOMAIN]&pfi=[PLATFORM]&af=[ADTYPE]&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=[AD_UNIT]&bidid=[PBS-BIDID]",
+				req: &openrtb2.BidRequest{Site: &openrtb2.Site{Name: "test", Domain: "www.test.com", Publisher: &openrtb2.Publisher{ID: "5890"}}, Imp: []openrtb2.Imp{}}},
+			want: want{
+				map[string]string{
+					"complete":      "https://company.tracker.com?operId=8&e=6&p=5890&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=&advertiser_id=&sURL=www.test.com&pfi=[PLATFORM]&af=video&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=&bidid=",
+					"firstQuartile": "https://company.tracker.com?operId=8&e=4&p=5890&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=&advertiser_id=&sURL=www.test.com&pfi=[PLATFORM]&af=video&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=&bidid=",
+					"midpoint":      "https://company.tracker.com?operId=8&e=3&p=5890&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=&advertiser_id=&sURL=www.test.com&pfi=[PLATFORM]&af=video&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=&bidid=",
+					"start":         "https://company.tracker.com?operId=8&e=2&p=5890&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=&advertiser_id=&sURL=www.test.com&pfi=[PLATFORM]&af=video&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=&bidid=",
+					"thirdQuartile": "https://company.tracker.com?operId=8&e=5&p=5890&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=&advertiser_id=&sURL=www.test.com&pfi=[PLATFORM]&af=video&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=&bidid=",
+				},
+			},
+		},
+		{
+			name: "site_page_tracker_url",
+			args: args{trackerURL: "https://company.tracker.com?operId=8&e=[EVENT_ID]&p=[PBS-ACCOUNT]&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=[PBS-BIDDER]&advertiser_id=[ADVERTISER_NAME]&sURL=[DOMAIN]&pfi=[PLATFORM]&af=[ADTYPE]&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=[AD_UNIT]&bidid=[PBS-BIDID]",
+				req: &openrtb2.BidRequest{Site: &openrtb2.Site{Name: "test", Page: "https://www.test.com/", Publisher: &openrtb2.Publisher{ID: "5890"}}, Imp: []openrtb2.Imp{}}},
+			want: want{
+				map[string]string{
+					"complete":      "https://company.tracker.com?operId=8&e=6&p=5890&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=&advertiser_id=&sURL=www.test.com&pfi=[PLATFORM]&af=video&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=&bidid=",
+					"firstQuartile": "https://company.tracker.com?operId=8&e=4&p=5890&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=&advertiser_id=&sURL=www.test.com&pfi=[PLATFORM]&af=video&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=&bidid=",
+					"midpoint":      "https://company.tracker.com?operId=8&e=3&p=5890&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=&advertiser_id=&sURL=www.test.com&pfi=[PLATFORM]&af=video&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=&bidid=",
+					"start":         "https://company.tracker.com?operId=8&e=2&p=5890&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=&advertiser_id=&sURL=www.test.com&pfi=[PLATFORM]&af=video&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=&bidid=",
+					"thirdQuartile": "https://company.tracker.com?operId=8&e=5&p=5890&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=&advertiser_id=&sURL=www.test.com&pfi=[PLATFORM]&af=video&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=&bidid=",
+				},
+			},
+		},
+		{
+			name: "all_macros with generated_bidId", // expect encoding for WRAPPER_IMPRESSION_ID macro
+			args: args{
+				trackerURL: "https://company.tracker.com?operId=8&e=[EVENT_ID]&p=[PBS-ACCOUNT]&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=[PBS-BIDDER]&advertiser_id=[ADVERTISER_NAME]&sURL=[DOMAIN]&pfi=[PLATFORM]&af=[ADTYPE]&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=[AD_UNIT]&bidid=[PBS-BIDID]&origbidid=[PBS-ORIG_BIDID]&bc=[BIDDER_CODE]",
+				req: &openrtb2.BidRequest{
+					App: &openrtb2.App{Bundle: "com.someapp.com", Publisher: &openrtb2.Publisher{ID: "5890"}},
+					Ext: []byte(`{
+						"prebid": {
+								"macros": {
+									"[PROFILE_ID]": "100",
+									"[PROFILE_VERSION]": "2",
+									"[UNIX_TIMESTAMP]": "1234567890",
+									"[PLATFORM]": "7",
+									"[WRAPPER_IMPRESSION_ID]": "abc~!@#$%^&&*()_+{}|:\"<>?[]\\;',./"
+								}
+						}
+					}`),
+					Imp: []openrtb2.Imp{
+						{TagID: "/testadunit/1", ID: "imp_1"},
+					},
+				},
+				bid:              &openrtb2.Bid{ADomain: []string{"http://a.com/32?k=v", "b.com"}, ImpID: "imp_1", ID: "test_bid_id"},
+				gen_bidid:        "random_bid_id",
+				requestingBidder: "test_bidder:234",
+				bidderCoreName:   "test_core_bidder:234",
+			},
+			want: want{
+				trackerURLMap: map[string]string{
+					"firstQuartile": "https://company.tracker.com?operId=8&e=4&p=5890&pid=100&v=2&ts=1234567890&pn=test_core_bidder%3A234&advertiser_id=a.com&sURL=com.someapp.com&pfi=7&af=video&iid=abc~%21%40%23%24%25%5E%26%26%2A%28%29_%2B%7B%7D%7C%3A%22%3C%3E%3F%5B%5D%5C%3B%27%2C.%2F&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=%2Ftestadunit%2F1&bidid=random_bid_id&origbidid=test_bid_id&bc=test_bidder%3A234",
+					"midpoint":      "https://company.tracker.com?operId=8&e=3&p=5890&pid=100&v=2&ts=1234567890&pn=test_core_bidder%3A234&advertiser_id=a.com&sURL=com.someapp.com&pfi=7&af=video&iid=abc~%21%40%23%24%25%5E%26%26%2A%28%29_%2B%7B%7D%7C%3A%22%3C%3E%3F%5B%5D%5C%3B%27%2C.%2F&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=%2Ftestadunit%2F1&bidid=random_bid_id&origbidid=test_bid_id&bc=test_bidder%3A234",
+					"thirdQuartile": "https://company.tracker.com?operId=8&e=5&p=5890&pid=100&v=2&ts=1234567890&pn=test_core_bidder%3A234&advertiser_id=a.com&sURL=com.someapp.com&pfi=7&af=video&iid=abc~%21%40%23%24%25%5E%26%26%2A%28%29_%2B%7B%7D%7C%3A%22%3C%3E%3F%5B%5D%5C%3B%27%2C.%2F&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=%2Ftestadunit%2F1&bidid=random_bid_id&origbidid=test_bid_id&bc=test_bidder%3A234",
+					"complete":      "https://company.tracker.com?operId=8&e=6&p=5890&pid=100&v=2&ts=1234567890&pn=test_core_bidder%3A234&advertiser_id=a.com&sURL=com.someapp.com&pfi=7&af=video&iid=abc~%21%40%23%24%25%5E%26%26%2A%28%29_%2B%7B%7D%7C%3A%22%3C%3E%3F%5B%5D%5C%3B%27%2C.%2F&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=%2Ftestadunit%2F1&bidid=random_bid_id&origbidid=test_bid_id&bc=test_bidder%3A234",
+					"start":         "https://company.tracker.com?operId=8&e=2&p=5890&pid=100&v=2&ts=1234567890&pn=test_core_bidder%3A234&advertiser_id=a.com&sURL=com.someapp.com&pfi=7&af=video&iid=abc~%21%40%23%24%25%5E%26%26%2A%28%29_%2B%7B%7D%7C%3A%22%3C%3E%3F%5B%5D%5C%3B%27%2C.%2F&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=%2Ftestadunit%2F1&bidid=random_bid_id&origbidid=test_bid_id&bc=test_bidder%3A234"},
+			},
+		},
+		{
+			name: "all_macros with empty generated_bidId", // expect encoding for WRAPPER_IMPRESSION_ID macro
+			args: args{
+				trackerURL: "https://company.tracker.com?operId=8&e=[EVENT_ID]&p=[PBS-ACCOUNT]&pid=[PROFILE_ID]&v=[PROFILE_VERSION]&ts=[UNIX_TIMESTAMP]&pn=[PBS-BIDDER]&advertiser_id=[ADVERTISER_NAME]&sURL=[DOMAIN]&pfi=[PLATFORM]&af=[ADTYPE]&iid=[WRAPPER_IMPRESSION_ID]&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=[AD_UNIT]&bidid=[PBS-BIDID]&origbidid=[PBS-ORIG_BIDID]&bc=[BIDDER_CODE]",
+				req: &openrtb2.BidRequest{
+					App: &openrtb2.App{Bundle: "com.someapp.com", Publisher: &openrtb2.Publisher{ID: "5890"}},
+					Ext: []byte(`{
+						"prebid": {
+								"macros": {
+									"[PROFILE_ID]": "100",
+									"[PROFILE_VERSION]": "2",
+									"[UNIX_TIMESTAMP]": "1234567890",
+									"[PLATFORM]": "7",
+									"[WRAPPER_IMPRESSION_ID]": "abc~!@#$%^&&*()_+{}|:\"<>?[]\\;',./"
+								}
+						}
+					}`),
+					Imp: []openrtb2.Imp{
+						{TagID: "/testadunit/1", ID: "imp_1"},
+					},
+				},
+				bid:              &openrtb2.Bid{ADomain: []string{"http://a.com/32?k=v", "b.com"}, ImpID: "imp_1", ID: "test_bid_id"},
+				gen_bidid:        "",
+				requestingBidder: "test_bidder:234",
+				bidderCoreName:   "test_core_bidder:234",
+			},
+			want: want{
+				trackerURLMap: map[string]string{
+					"firstQuartile": "https://company.tracker.com?operId=8&e=4&p=5890&pid=100&v=2&ts=1234567890&pn=test_core_bidder%3A234&advertiser_id=a.com&sURL=com.someapp.com&pfi=7&af=video&iid=abc~%21%40%23%24%25%5E%26%26%2A%28%29_%2B%7B%7D%7C%3A%22%3C%3E%3F%5B%5D%5C%3B%27%2C.%2F&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=%2Ftestadunit%2F1&bidid=test_bid_id&origbidid=test_bid_id&bc=test_bidder%3A234",
+					"midpoint":      "https://company.tracker.com?operId=8&e=3&p=5890&pid=100&v=2&ts=1234567890&pn=test_core_bidder%3A234&advertiser_id=a.com&sURL=com.someapp.com&pfi=7&af=video&iid=abc~%21%40%23%24%25%5E%26%26%2A%28%29_%2B%7B%7D%7C%3A%22%3C%3E%3F%5B%5D%5C%3B%27%2C.%2F&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=%2Ftestadunit%2F1&bidid=test_bid_id&origbidid=test_bid_id&bc=test_bidder%3A234",
+					"thirdQuartile": "https://company.tracker.com?operId=8&e=5&p=5890&pid=100&v=2&ts=1234567890&pn=test_core_bidder%3A234&advertiser_id=a.com&sURL=com.someapp.com&pfi=7&af=video&iid=abc~%21%40%23%24%25%5E%26%26%2A%28%29_%2B%7B%7D%7C%3A%22%3C%3E%3F%5B%5D%5C%3B%27%2C.%2F&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=%2Ftestadunit%2F1&bidid=test_bid_id&origbidid=test_bid_id&bc=test_bidder%3A234",
+					"complete":      "https://company.tracker.com?operId=8&e=6&p=5890&pid=100&v=2&ts=1234567890&pn=test_core_bidder%3A234&advertiser_id=a.com&sURL=com.someapp.com&pfi=7&af=video&iid=abc~%21%40%23%24%25%5E%26%26%2A%28%29_%2B%7B%7D%7C%3A%22%3C%3E%3F%5B%5D%5C%3B%27%2C.%2F&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=%2Ftestadunit%2F1&bidid=test_bid_id&origbidid=test_bid_id&bc=test_bidder%3A234",
+					"start":         "https://company.tracker.com?operId=8&e=2&p=5890&pid=100&v=2&ts=1234567890&pn=test_core_bidder%3A234&advertiser_id=a.com&sURL=com.someapp.com&pfi=7&af=video&iid=abc~%21%40%23%24%25%5E%26%26%2A%28%29_%2B%7B%7D%7C%3A%22%3C%3E%3F%5B%5D%5C%3B%27%2C.%2F&pseq=[PODSEQUENCE]&adcnt=[ADCOUNT]&cb=[CACHEBUSTING]&au=%2Ftestadunit%2F1&bidid=test_bid_id&origbidid=test_bid_id&bc=test_bidder%3A234"},
+			},
+		},
+	}
+	for _, tc := range tests {
+		t.Run(tc.name, func(t *testing.T) {
+
+			if nil == tc.args.bid {
+				tc.args.bid = &openrtb2.Bid{}
+			}
+
+			impMap := map[string]*openrtb2.Imp{}
+
+			for _, imp := range tc.args.req.Imp {
+				impMap[imp.ID] = &imp
+			}
+
+			eventURLMap := GetVideoEventTracking(tc.args.trackerURL, tc.args.bid, tc.args.gen_bidid, tc.args.requestingBidder, tc.args.bidderCoreName, tc.args.accountId, tc.args.timestamp, tc.args.req, tc.args.doc, impMap)
+
+			for event, eurl := range tc.want.trackerURLMap {
+
+				u, _ := url.Parse(eurl)
+				expectedValues, _ := url.ParseQuery(u.RawQuery)
+				u, _ = url.Parse(eventURLMap[event])
+				actualValues, _ := url.ParseQuery(u.RawQuery)
+				for k, ev := range expectedValues {
+					av := actualValues[k]
+					for i := 0; i < len(ev); i++ {
+						assert.Equal(t, ev[i], av[i], fmt.Sprintf("Expected '%v' for '%v'. but found %v", ev[i], k, av[i]))
+					}
+				}
+
+				// error out if extra query params
+				if len(expectedValues) != len(actualValues) {
+					assert.Equal(t, expectedValues, actualValues, fmt.Sprintf("Expected '%v' query params but found '%v'", len(expectedValues), len(actualValues)))
+					break
+				}
+			}
+
+			// check if new quartile pixels are covered inside test
+			assert.Equal(t, tc.want.trackerURLMap, eventURLMap)
+		})
+	}
+}
+
+func TestReplaceMacro(t *testing.T) {
+	type args struct {
+		trackerURL string
+		macro      string
+		value      string
+	}
+	type want struct {
+		trackerURL string
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{name: "empty_tracker_url", args: args{trackerURL: "", macro: "[TEST]", value: "testme"}, want: want{trackerURL: ""}},
+		{name: "tracker_url_with_macro", args: args{trackerURL: "http://something.com?test=[TEST]", macro: "[TEST]", value: "testme"}, want: want{trackerURL: "http://something.com?test=testme"}},
+		{name: "tracker_url_with_invalid_macro", args: args{trackerURL: "http://something.com?test=TEST]", macro: "[TEST]", value: "testme"}, want: want{trackerURL: "http://something.com?test=TEST]"}},
+		{name: "tracker_url_with_repeating_macro", args: args{trackerURL: "http://something.com?test=[TEST]&test1=[TEST]", macro: "[TEST]", value: "testme"}, want: want{trackerURL: "http://something.com?test=testme&test1=testme"}},
+		{name: "empty_macro", args: args{trackerURL: "http://something.com?test=[TEST]", macro: "", value: "testme"}, want: want{trackerURL: "http://something.com?test=[TEST]"}},
+		{name: "macro_without_[", args: args{trackerURL: "http://something.com?test=[TEST]", macro: "TEST]", value: "testme"}, want: want{trackerURL: "http://something.com?test=[TEST]"}},
+		{name: "macro_without_]", args: args{trackerURL: "http://something.com?test=[TEST]", macro: "[TEST", value: "testme"}, want: want{trackerURL: "http://something.com?test=[TEST]"}},
+		{name: "empty_value", args: args{trackerURL: "http://something.com?test=[TEST]", macro: "[TEST]", value: ""}, want: want{trackerURL: "http://something.com?test="}},
+		{name: "nested_macro_value", args: args{trackerURL: "http://something.com?test=[TEST]", macro: "[TEST]", value: "[TEST][TEST]"}, want: want{trackerURL: "http://something.com?test=%5BTEST%5D%5BTEST%5D"}},
+		{name: "url_as_macro_value", args: args{trackerURL: "http://something.com?test=[TEST]", macro: "[TEST]", value: "http://iamurl.com"}, want: want{trackerURL: "http://something.com?test=http%3A%2F%2Fiamurl.com"}},
+		{name: "macro_with_spaces", args: args{trackerURL: "http://something.com?test=[TEST]", macro: "  [TEST]  ", value: "http://iamurl.com"}, want: want{trackerURL: "http://something.com?test=http%3A%2F%2Fiamurl.com"}},
+	}
+	for _, tc := range tests {
+		t.Run(tc.name, func(t *testing.T) {
+			trackerURL := replaceMacro(tc.args.trackerURL, tc.args.macro, tc.args.value)
+			assert.Equal(t, tc.want.trackerURL, trackerURL)
+		})
+	}
+
+}
+func TestExtractDomain(t *testing.T) {
+	testCases := []struct {
+		description    string
+		url            string
+		expectedDomain string
+		expectedErr    error
+	}{
+		{description: "a.com", url: "a.com", expectedDomain: "a.com", expectedErr: nil},
+		{description: "a.com/123", url: "a.com/123", expectedDomain: "a.com", expectedErr: nil},
+		{description: "http://a.com/123", url: "http://a.com/123", expectedDomain: "a.com", expectedErr: nil},
+		{description: "https://a.com/123", url: "https://a.com/123", expectedDomain: "a.com", expectedErr: nil},
+		{description: "c.b.a.com", url: "c.b.a.com", expectedDomain: "c.b.a.com", expectedErr: nil},
+		{description: "url_encoded_http://c.b.a.com", url: "http%3A%2F%2Fc.b.a.com", expectedDomain: "c.b.a.com", expectedErr: nil},
+		{description: "url_encoded_with_www_http://c.b.a.com", url: "http%3A%2F%2Fwww.c.b.a.com", expectedDomain: "c.b.a.com", expectedErr: nil},
+	}
+	for _, test := range testCases {
+		t.Run(test.description, func(t *testing.T) {
+			domain, err := extractDomain(test.url)
+			assert.Equal(t, test.expectedDomain, domain)
+			assert.Equal(t, test.expectedErr, err)
+		})
+	}
+}
diff --git a/endpoints/events/vtrack_test.go b/endpoints/events/vtrack_test.go
index 2c40c9b41..ebf32dc0b 100644
--- a/endpoints/events/vtrack_test.go
+++ b/endpoints/events/vtrack_test.go
@@ -692,7 +692,6 @@ func getVTrackRequestData(wi bool, wic bool) (db []byte, e error) {
 
 	return data.Bytes(), e
 }
-
 func TestGetIntegrationType(t *testing.T) {
 	testCases := []struct {
 		description             string
diff --git a/endpoints/openrtb2/amp_auction.go b/endpoints/openrtb2/amp_auction.go
index 36248a882..48ee84adf 100644
--- a/endpoints/openrtb2/amp_auction.go
+++ b/endpoints/openrtb2/amp_auction.go
@@ -115,13 +115,16 @@ func (deps *endpointDeps) AmpAuction(w http.ResponseWriter, r *http.Request, _ h
 	hookExecutor := hookexecution.NewHookExecutor(deps.hookExecutionPlanBuilder, hookexecution.EndpointAmp, deps.metricsEngine)
 
 	ao := analytics.AmpObject{
-		Status:    http.StatusOK,
-		Errors:    make([]error, 0),
+		LoggableAuctionObject: analytics.LoggableAuctionObject{
+			Context:      r.Context(),
+			Status:       http.StatusOK,
+			Errors:       make([]error, 0),
+			RejectedBids: []analytics.RejectedBid{},
+		},
 		StartTime: start,
 	}
 
 	// Set this as an AMP request in Metrics.
-
 	labels := metrics.Labels{
 		Source:        metrics.DemandWeb,
 		RType:         metrics.ReqTypeAMP,
@@ -172,7 +175,7 @@ func (deps *endpointDeps) AmpAuction(w http.ResponseWriter, r *http.Request, _ h
 
 	ao.Request = reqWrapper.BidRequest
 
-	ctx := context.Background()
+	ctx := r.Context()
 	var cancel context.CancelFunc
 	if reqWrapper.TMax > 0 {
 		ctx, cancel = context.WithDeadline(ctx, start.Add(time.Duration(reqWrapper.TMax)*time.Millisecond))
@@ -237,12 +240,13 @@ func (deps *endpointDeps) AmpAuction(w http.ResponseWriter, r *http.Request, _ h
 		BidderImpReplaceImpID:      bidderImpReplaceImp,
 		PubID:                      labels.PubID,
 		HookExecutor:               hookExecutor,
+		LoggableObject:             &ao.LoggableAuctionObject,
 		QueryParams:                r.URL.Query(),
 		TCF2Config:                 tcf2Config,
 	}
 
 	response, err := deps.ex.HoldAuction(ctx, auctionRequest, nil)
-	ao.AuctionResponse = response
+	ao.Response = response
 	rejectErr, isRejectErr := hookexecution.CastRejectErr(err)
 	if err != nil && !isRejectErr {
 		w.WriteHeader(http.StatusInternalServerError)
@@ -286,7 +290,7 @@ func rejectAmpRequest(
 	errs []error,
 ) (metrics.Labels, analytics.AmpObject) {
 	response := &openrtb2.BidResponse{NBR: openrtb3.NoBidReason(rejectErr.NBR).Ptr()}
-	ao.AuctionResponse = response
+	ao.Response = response
 	ao.Errors = append(ao.Errors, rejectErr)
 
 	return sendAmpResponse(w, hookExecutor, response, reqWrapper, account, labels, ao, errs)
diff --git a/endpoints/openrtb2/amp_auction_test.go b/endpoints/openrtb2/amp_auction_test.go
index 8eb80672f..fe00d23fd 100644
--- a/endpoints/openrtb2/amp_auction_test.go
+++ b/endpoints/openrtb2/amp_auction_test.go
@@ -1665,8 +1665,10 @@ func TestBuildAmpObject(t *testing.T) {
 			inTagId:         "test",
 			inStoredRequest: nil,
 			expectedAmpObject: &analytics.AmpObject{
-				Status: http.StatusOK,
-				Errors: []error{fmt.Errorf("unexpected end of JSON input")},
+				LoggableAuctionObject: analytics.LoggableAuctionObject{
+					Status: http.StatusOK,
+					Errors: []error{fmt.Errorf("unexpected end of JSON input")},
+				},
 			},
 		},
 		{
@@ -1674,8 +1676,10 @@ func TestBuildAmpObject(t *testing.T) {
 			inTagId:         "test",
 			inStoredRequest: json.RawMessage(`{"id":"some-request-id","site":{"page":"prebid.org"},"imp":[],"tmax":500}`),
 			expectedAmpObject: &analytics.AmpObject{
-				Status: http.StatusOK,
-				Errors: []error{fmt.Errorf("data for tag_id='test' does not define the required imp array")},
+				LoggableAuctionObject: analytics.LoggableAuctionObject{
+					Status: http.StatusOK,
+					Errors: []error{fmt.Errorf("data for tag_id='test' does not define the required imp array")},
+				},
 			},
 		},
 		{
@@ -1683,8 +1687,10 @@ func TestBuildAmpObject(t *testing.T) {
 			inTagId:         "unknown",
 			inStoredRequest: json.RawMessage(`{"id":"some-request-id","site":{"page":"prebid.org"},"imp":[{"id":"some-impression-id","banner":{"format":[{"w":300,"h":250}]},"ext":{"prebid":{"bidder":{"appnexus":{"placementId":12883451}}}}}],"tmax":500}`),
 			expectedAmpObject: &analytics.AmpObject{
-				Status: http.StatusOK,
-				Errors: []error{fmt.Errorf("unexpected end of JSON input")},
+				LoggableAuctionObject: analytics.LoggableAuctionObject{
+					Status: http.StatusOK,
+					Errors: []error{fmt.Errorf("unexpected end of JSON input")},
+				},
 			},
 		},
 		{
@@ -1692,46 +1698,49 @@ func TestBuildAmpObject(t *testing.T) {
 			inTagId:         "test",
 			inStoredRequest: json.RawMessage(`{"id":"some-request-id","site":{"page":"prebid.org"},"imp":[{"id":"some-impression-id","banner":{"format":[{"w":300,"h":250}]},"ext":{"prebid":{"bidder":{"appnexus":{"placementId":12883451}}}}}],"tmax":500}`),
 			expectedAmpObject: &analytics.AmpObject{
-				Status: http.StatusOK,
-				Errors: nil,
-				Request: &openrtb2.BidRequest{
-					ID: "some-request-id",
-					Device: &openrtb2.Device{
-						IP: "192.0.2.1",
-					},
-					Site: &openrtb2.Site{
-						Page: "prebid.org",
-						Ext:  json.RawMessage(`{"amp":1}`),
-					},
-					Imp: []openrtb2.Imp{
-						{
-							ID: "some-impression-id",
-							Banner: &openrtb2.Banner{
-								Format: []openrtb2.Format{
-									{
-										W: 300,
-										H: 250,
+				LoggableAuctionObject: analytics.LoggableAuctionObject{
+					Status: http.StatusOK,
+					Errors: nil,
+					Request: &openrtb2.BidRequest{
+						ID: "some-request-id",
+						Device: &openrtb2.Device{
+							IP: "192.0.2.1",
+						},
+						Site: &openrtb2.Site{
+							Page: "prebid.org",
+							Ext:  json.RawMessage(`{"amp":1}`),
+						},
+						Imp: []openrtb2.Imp{
+							{
+								ID: "some-impression-id",
+								Banner: &openrtb2.Banner{
+									Format: []openrtb2.Format{
+										{
+											W: 300,
+											H: 250,
+										},
 									},
 								},
+								Secure: func(val int8) *int8 { return &val }(1), //(*int8)(1),
+								Ext:    json.RawMessage(`{"prebid":{"bidder":{"appnexus":{"placementId":12883451}}}}`),
 							},
-							Secure: func(val int8) *int8 { return &val }(1), //(*int8)(1),
-							Ext:    json.RawMessage(`{"prebid":{"bidder":{"appnexus":{"placementId":12883451}}}}`),
 						},
+						AT:   1,
+						TMax: 500,
+						Ext:  json.RawMessage(`{"prebid":{"cache":{"bids":{}},"channel":{"name":"amp","version":""},"targeting":{"pricegranularity":{"precision":2,"ranges":[{"min":0,"max":20,"increment":0.1}]},"includewinners":true,"includebidderkeys":true}}}`),
 					},
-					AT:   1,
-					TMax: 500,
-					Ext:  json.RawMessage(`{"prebid":{"cache":{"bids":{}},"channel":{"name":"amp","version":""},"targeting":{"pricegranularity":{"precision":2,"ranges":[{"min":0,"max":20,"increment":0.1}]},"includewinners":true,"includebidderkeys":true}}}`),
-				},
-				AuctionResponse: &openrtb2.BidResponse{
-					SeatBid: []openrtb2.SeatBid{{
-						Bid: []openrtb2.Bid{{
-							AdM: "<script></script>",
-							Ext: json.RawMessage(`{ "prebid": {"targeting": { "hb_pb": "1.20", "hb_appnexus_pb": "1.20", "hb_cache_id": "some_id"}}}`),
+					Response: &openrtb2.BidResponse{
+						SeatBid: []openrtb2.SeatBid{{
+							Bid: []openrtb2.Bid{{
+								AdM: "<script></script>",
+								Ext: json.RawMessage(`{ "prebid": {"targeting": { "hb_pb": "1.20", "hb_appnexus_pb": "1.20", "hb_cache_id": "some_id"}}}`),
+							}},
+							Seat: "",
 						}},
-						Seat: "",
-					}},
-					Ext: json.RawMessage(`{ "errors": {"openx":[ { "code": 1, "message": "The request exceeded the timeout allocated" } ] } }`),
+						Ext: json.RawMessage(`{ "errors": {"openx":[ { "code": 1, "message": "The request exceeded the timeout allocated" } ] } }`),
+					},
 				},
+
 				AmpTargetingValues: map[string]string{
 					"hb_appnexus_pb": "1.20",
 					"hb_cache_id":    "some_id",
@@ -1746,45 +1755,47 @@ func TestBuildAmpObject(t *testing.T) {
 			inStoredRequest: json.RawMessage(`{"id":"some-request-id","site":{"page":"prebid.org"},"imp":[{"id":"some-impression-id","banner":{"format":[{"w":300,"h":250}]},"ext":{"prebid":{"bidder":{"appnexus":{"placementId":12883451}}}}}],"tmax":500}`),
 			exchange:        &mockAmpExchange{requestExt: json.RawMessage(`{ "prebid": {"targeting": { "test_key": "test_value", "hb_appnexus_pb": "9999" } }, "errors": {"openx":[ { "code": 1, "message": "The request exceeded the timeout allocated" } ] } }`)},
 			expectedAmpObject: &analytics.AmpObject{
-				Status: http.StatusOK,
-				Errors: nil,
-				Request: &openrtb2.BidRequest{
-					ID: "some-request-id",
-					Device: &openrtb2.Device{
-						IP: "192.0.2.1",
-					},
-					Site: &openrtb2.Site{
-						Page: "prebid.org",
-						Ext:  json.RawMessage(`{"amp":1}`),
-					},
-					Imp: []openrtb2.Imp{
-						{
-							ID: "some-impression-id",
-							Banner: &openrtb2.Banner{
-								Format: []openrtb2.Format{
-									{
-										W: 300,
-										H: 250,
+				LoggableAuctionObject: analytics.LoggableAuctionObject{
+					Status: http.StatusOK,
+					Errors: nil,
+					Request: &openrtb2.BidRequest{
+						ID: "some-request-id",
+						Device: &openrtb2.Device{
+							IP: "192.0.2.1",
+						},
+						Site: &openrtb2.Site{
+							Page: "prebid.org",
+							Ext:  json.RawMessage(`{"amp":1}`),
+						},
+						Imp: []openrtb2.Imp{
+							{
+								ID: "some-impression-id",
+								Banner: &openrtb2.Banner{
+									Format: []openrtb2.Format{
+										{
+											W: 300,
+											H: 250,
+										},
 									},
 								},
+								Secure: func(val int8) *int8 { return &val }(1), //(*int8)(1),
+								Ext:    json.RawMessage(`{"prebid":{"bidder":{"appnexus":{"placementId":12883451}}}}`),
 							},
-							Secure: func(val int8) *int8 { return &val }(1), //(*int8)(1),
-							Ext:    json.RawMessage(`{"prebid":{"bidder":{"appnexus":{"placementId":12883451}}}}`),
 						},
+						AT:   1,
+						TMax: 500,
+						Ext:  json.RawMessage(`{"prebid":{"cache":{"bids":{}},"channel":{"name":"amp","version":""},"targeting":{"pricegranularity":{"precision":2,"ranges":[{"min":0,"max":20,"increment":0.1}]},"includewinners":true,"includebidderkeys":true}}}`),
 					},
-					AT:   1,
-					TMax: 500,
-					Ext:  json.RawMessage(`{"prebid":{"cache":{"bids":{}},"channel":{"name":"amp","version":""},"targeting":{"pricegranularity":{"precision":2,"ranges":[{"min":0,"max":20,"increment":0.1}]},"includewinners":true,"includebidderkeys":true}}}`),
-				},
-				AuctionResponse: &openrtb2.BidResponse{
-					SeatBid: []openrtb2.SeatBid{{
-						Bid: []openrtb2.Bid{{
-							AdM: "<script></script>",
-							Ext: json.RawMessage(`{ "prebid": {"targeting": { "hb_pb": "1.20", "hb_appnexus_pb": "1.20", "hb_cache_id": "some_id"}}}`),
+					Response: &openrtb2.BidResponse{
+						SeatBid: []openrtb2.SeatBid{{
+							Bid: []openrtb2.Bid{{
+								AdM: "<script></script>",
+								Ext: json.RawMessage(`{ "prebid": {"targeting": { "hb_pb": "1.20", "hb_appnexus_pb": "1.20", "hb_cache_id": "some_id"}}}`),
+							}},
+							Seat: "",
 						}},
-						Seat: "",
-					}},
-					Ext: json.RawMessage(`{ "prebid": {"targeting": { "test_key": "test_value", "hb_appnexus_pb": "9999" } }, "errors": {"openx":[ { "code": 1, "message": "The request exceeded the timeout allocated" } ] } }`),
+						Ext: json.RawMessage(`{ "prebid": {"targeting": { "test_key": "test_value", "hb_appnexus_pb": "9999" } }, "errors": {"openx":[ { "code": 1, "message": "The request exceeded the timeout allocated" } ] } }`),
+					},
 				},
 				AmpTargetingValues: map[string]string{
 					"hb_appnexus_pb": "1.20", // Bid level has higher priority than global
@@ -1814,7 +1825,7 @@ func TestBuildAmpObject(t *testing.T) {
 		assert.Equalf(t, test.expectedAmpObject.Status, actualAmpObject.Status, "Amp Object Status field doesn't match expected: %s\n", test.description)
 		assert.Lenf(t, actualAmpObject.Errors, len(test.expectedAmpObject.Errors), "Amp Object Errors array doesn't match expected: %s\n", test.description)
 		assert.Equalf(t, test.expectedAmpObject.Request, actualAmpObject.Request, "Amp Object BidRequest doesn't match expected: %s\n", test.description)
-		assert.Equalf(t, test.expectedAmpObject.AuctionResponse, actualAmpObject.AuctionResponse, "Amp Object BidResponse doesn't match expected: %s\n", test.description)
+		assert.Equalf(t, test.expectedAmpObject.Response, actualAmpObject.Response, "Amp Object BidResponse doesn't match expected: %s\n", test.description)
 		assert.Equalf(t, test.expectedAmpObject.AmpTargetingValues, actualAmpObject.AmpTargetingValues, "Amp Object AmpTargetingValues doesn't match expected: %s\n", test.description)
 		assert.Equalf(t, test.expectedAmpObject.Origin, actualAmpObject.Origin, "Amp Object Origin field doesn't match expected: %s\n", test.description)
 	}
@@ -1920,7 +1931,7 @@ func TestAmpAuctionResponseHeaders(t *testing.T) {
 			expectedHeaders: func(h http.Header) {
 				h.Set("AMP-Access-Control-Allow-Source-Origin", "foo")
 				h.Set("Access-Control-Expose-Headers", "AMP-Access-Control-Allow-Source-Origin")
-				h.Set("X-Prebid", "pbs-go/unknown")
+				h.Set("X-Prebid", "owpbs-go/unknown")
 				h.Set("Content-Type", "text/plain; charset=utf-8")
 			},
 		},
@@ -1931,7 +1942,7 @@ func TestAmpAuctionResponseHeaders(t *testing.T) {
 			expectedHeaders: func(h http.Header) {
 				h.Set("AMP-Access-Control-Allow-Source-Origin", "foo")
 				h.Set("Access-Control-Expose-Headers", "AMP-Access-Control-Allow-Source-Origin")
-				h.Set("X-Prebid", "pbs-go/unknown")
+				h.Set("X-Prebid", "owpbs-go/unknown")
 			},
 		},
 	}
@@ -2108,30 +2119,30 @@ func TestValidAmpResponseWhenRequestRejected(t *testing.T) {
 		{
 			description: "Assert correct AmpResponse when request rejected at entrypoint stage",
 			file:        "sample-requests/hooks/amp_entrypoint_reject.json",
-			planBuilder: mockPlanBuilder{entrypointPlan: makePlan[hookstage.Entrypoint](mockRejectionHook{nbr})},
+			planBuilder: mockPlanBuilder{entrypointPlan: makePlan[hookstage.Entrypoint](mockRejectionHook{nbr, nil})},
 		},
 		{
 			// raw_auction stage not executed for AMP endpoint, so we expect full response
 			description: "Assert correct AmpResponse when request rejected at raw_auction stage",
 			file:        "sample-requests/amp/valid-supplementary/aliased-buyeruids.json",
-			planBuilder: mockPlanBuilder{rawAuctionPlan: makePlan[hookstage.RawAuctionRequest](mockRejectionHook{nbr})},
+			planBuilder: mockPlanBuilder{rawAuctionPlan: makePlan[hookstage.RawAuctionRequest](mockRejectionHook{nbr, nil})},
 		},
 		{
 			description: "Assert correct AmpResponse when request rejected at processed_auction stage",
 			file:        "sample-requests/hooks/amp_processed_auction_request_reject.json",
-			planBuilder: mockPlanBuilder{processedAuctionPlan: makePlan[hookstage.ProcessedAuctionRequest](mockRejectionHook{nbr})},
+			planBuilder: mockPlanBuilder{processedAuctionPlan: makePlan[hookstage.ProcessedAuctionRequest](mockRejectionHook{nbr, nil})},
 		},
 		{
 			// bidder_request stage rejects only bidder, so we expect bidder rejection warning added
 			description: "Assert correct AmpResponse when request rejected at bidder-request stage",
 			file:        "sample-requests/hooks/amp_bidder_reject.json",
-			planBuilder: mockPlanBuilder{bidderRequestPlan: makePlan[hookstage.BidderRequest](mockRejectionHook{nbr})},
+			planBuilder: mockPlanBuilder{bidderRequestPlan: makePlan[hookstage.BidderRequest](mockRejectionHook{nbr, nil})},
 		},
 		{
 			// raw_bidder_response stage rejects only bidder, so we expect bidder rejection warning added
 			description: "Assert correct AmpResponse when request rejected at raw_bidder_response stage",
 			file:        "sample-requests/hooks/amp_bidder_response_reject.json",
-			planBuilder: mockPlanBuilder{rawBidderResponsePlan: makePlan[hookstage.RawBidderResponse](mockRejectionHook{nbr})},
+			planBuilder: mockPlanBuilder{rawBidderResponsePlan: makePlan[hookstage.RawBidderResponse](mockRejectionHook{nbr, nil})},
 		},
 		{
 			// no debug information should be added for raw_auction stage because it's not executed for amp endpoint
diff --git a/endpoints/openrtb2/auction.go b/endpoints/openrtb2/auction.go
index 623537114..da9696962 100644
--- a/endpoints/openrtb2/auction.go
+++ b/endpoints/openrtb2/auction.go
@@ -26,6 +26,7 @@ import (
 	"github.com/prebid/openrtb/v19/openrtb3"
 	"github.com/prebid/prebid-server/adapters"
 	"github.com/prebid/prebid-server/bidadjustment"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/util"
 	"github.com/prebid/prebid-server/hooks"
 	"github.com/prebid/prebid-server/ortb"
 	"golang.org/x/net/publicsuffix"
@@ -58,6 +59,14 @@ import (
 const storedRequestTimeoutMillis = 50
 const ampChannel = "amp"
 const appChannel = "app"
+const (
+	VastUnwrapperEnableKey = "enableVastUnwrapper"
+)
+
+func GetContextValueForField(ctx context.Context, field string) string {
+	vastEnableUnwrapper, _ := ctx.Value(field).(string)
+	return vastEnableUnwrapper
+}
 
 var (
 	dntKey      string = http.CanonicalHeaderKey("DNT")
@@ -145,6 +154,8 @@ type endpointDeps struct {
 }
 
 func (deps *endpointDeps) Auction(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
+	deps.metricsEngine.RecordHttpCounter()
+
 	// Prebid Server interprets request.tmax to be the maximum amount of time that a caller is willing
 	// to wait for bids. However, tmax may be defined in the Stored Request data.
 	//
@@ -156,11 +167,18 @@ func (deps *endpointDeps) Auction(w http.ResponseWriter, r *http.Request, _ http
 	hookExecutor := hookexecution.NewHookExecutor(deps.hookExecutionPlanBuilder, hookexecution.EndpointAuction, deps.metricsEngine)
 
 	ao := analytics.AuctionObject{
-		Status:    http.StatusOK,
-		Errors:    make([]error, 0),
+		LoggableAuctionObject: analytics.LoggableAuctionObject{
+			Context:      r.Context(),
+			Status:       http.StatusOK,
+			Errors:       make([]error, 0),
+			RejectedBids: []analytics.RejectedBid{},
+		},
 		StartTime: start,
 	}
 
+	vastUnwrapperEnable := GetContextValueForField(r.Context(), VastUnwrapperEnableKey)
+	util.JLogf("VastUnwrapperEnable", vastUnwrapperEnable)
+
 	labels := metrics.Labels{
 		Source:        metrics.DemandUnknown,
 		RType:         metrics.ReqTypeORTB2Web,
@@ -170,6 +188,7 @@ func (deps *endpointDeps) Auction(w http.ResponseWriter, r *http.Request, _ http
 	}
 	defer func() {
 		deps.metricsEngine.RecordRequest(labels)
+		recordRejectedBids(labels.PubID, ao.LoggableAuctionObject.RejectedBids, deps.metricsEngine)
 		deps.metricsEngine.RecordRequestTime(labels, time.Since(start))
 		deps.analytics.LogAuctionObject(&ao)
 	}()
@@ -189,7 +208,7 @@ func (deps *endpointDeps) Auction(w http.ResponseWriter, r *http.Request, _ http
 
 	tcf2Config := gdpr.NewTCF2Config(deps.cfg.GDPR.TCF2, account.GDPR)
 
-	ctx := context.Background()
+	ctx := r.Context()
 
 	timeout := deps.cfg.AuctionTimeouts.LimitAuctionTimeout(time.Duration(req.TMax) * time.Millisecond)
 	if timeout > 0 {
@@ -234,8 +253,10 @@ func (deps *endpointDeps) Auction(w http.ResponseWriter, r *http.Request, _ http
 		PubID:                      labels.PubID,
 		HookExecutor:               hookExecutor,
 		TCF2Config:                 tcf2Config,
+		LoggableObject:             &ao.LoggableAuctionObject,
 	}
 	response, err := deps.ex.HoldAuction(ctx, auctionRequest, nil)
+	exchange.UpdateRejectedBidExt(auctionRequest.LoggableObject)
 	ao.Request = req.BidRequest
 	ao.Response = response
 	ao.Account = account
@@ -277,6 +298,11 @@ func rejectAuctionRequest(
 		response.ID = request.ID
 	}
 
+	// TODO merge this with success case
+	stageOutcomes := hookExecutor.GetOutcomes()
+	ao.HookExecutionOutcome = stageOutcomes
+	UpdateResponseExtOW(response, ao)
+
 	ao.Response = response
 	ao.Errors = append(ao.Errors, rejectErr)
 
@@ -297,6 +323,7 @@ func sendAuctionResponse(
 	if response != nil {
 		stageOutcomes := hookExecutor.GetOutcomes()
 		ao.HookExecutionOutcome = stageOutcomes
+		UpdateResponseExtOW(response, ao)
 
 		ext, warns, err := hookexecution.EnrichExtBidResponse(response.Ext, stageOutcomes, request, account)
 		if err != nil {
@@ -379,7 +406,6 @@ func (deps *endpointDeps) parseRequest(httpRequest *http.Request, labels *metric
 	if len(errs) > 0 {
 		return nil, nil, nil, nil, nil, nil, errs
 	}
-
 	storedBidRequestId, hasStoredBidRequest, storedRequests, storedImps, errs := deps.getStoredRequests(ctx, requestJson, impInfo)
 	if len(errs) > 0 {
 		return
@@ -443,6 +469,12 @@ func (deps *endpointDeps) parseRequest(httpRequest *http.Request, labels *metric
 		return
 	}
 
+	rejectErr = hookExecutor.ExecuteBeforeRequestValidationStage(req.BidRequest)
+	if rejectErr != nil {
+		errs = append(errs, rejectErr)
+		return
+	}
+
 	if err := mergeBidderParams(req); err != nil {
 		errs = []error{err}
 		return
@@ -861,7 +893,7 @@ func validateAndFillSourceTID(req *openrtb_ext.RequestWrapper, generateRequestID
 				return errors.New("imp.ext.tid missing in the imp and error creating a random UID")
 			}
 			ie.SetTid(rawUUID.String())
-			impWrapper.RebuildImp()
+			impWrapper.RebuildImpressionExt()
 		}
 	}
 
@@ -1436,7 +1468,11 @@ func (deps *endpointDeps) validateImpExt(imp *openrtb_ext.ImpWrapper, aliases ma
 
 		if coreBidderNormalized, isValid := deps.bidderMap[coreBidder]; isValid {
 			if err := deps.paramsValidator.Validate(coreBidderNormalized, ext); err != nil {
-				return []error{fmt.Errorf("request.imp[%d].ext.prebid.bidder.%s failed validation.\n%v", impIndex, bidder, err)}
+				msg := fmt.Sprintf("request.imp[%d].ext.prebid.bidder.%s failed validation.\n%v", impIndex, bidder, err)
+
+				delete(prebid.Bidder, bidder)
+				glog.Errorf("BidderSchemaValidationError: %s", msg)
+				errL = append(errL, &errortypes.BidderFailedSchemaValidation{Message: msg})
 			}
 		} else {
 			if msg, isDisabled := deps.disabledBidders[bidder]; isDisabled {
diff --git a/endpoints/openrtb2/auction_benchmark_test.go b/endpoints/openrtb2/auction_benchmark_test.go
index 2866a31e3..6aa3741d0 100644
--- a/endpoints/openrtb2/auction_benchmark_test.go
+++ b/endpoints/openrtb2/auction_benchmark_test.go
@@ -10,6 +10,8 @@ import (
 	"testing"
 	"time"
 
+	"github.com/prebid/prebid-server/floors"
+
 	analyticsConf "github.com/prebid/prebid-server/analytics/config"
 	"github.com/prebid/prebid-server/config"
 	"github.com/prebid/prebid-server/currency"
@@ -93,6 +95,7 @@ func BenchmarkOpenrtbEndpoint(b *testing.B) {
 		currency.NewRateConverter(&http.Client{}, "", time.Duration(0)),
 		empty_fetcher.EmptyFetcher{},
 		&adscert.NilSigner{},
+		&floors.PriceFloorFetcher{},
 	)
 
 	endpoint, _ := NewEndpoint(
diff --git a/endpoints/openrtb2/auction_ow.go b/endpoints/openrtb2/auction_ow.go
new file mode 100644
index 000000000..8b0553658
--- /dev/null
+++ b/endpoints/openrtb2/auction_ow.go
@@ -0,0 +1,139 @@
+package openrtb2
+
+import (
+	"encoding/json"
+	"runtime/debug"
+	"strconv"
+
+	"github.com/golang/glog"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/openrtb/v19/openrtb3"
+	"github.com/prebid/prebid-server/analytics"
+	"github.com/prebid/prebid-server/analytics/pubmatic"
+	"github.com/prebid/prebid-server/metrics"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// recordRejectedBids records the rejected bids and respective rejection reason code
+func recordRejectedBids(pubID string, rejBids []analytics.RejectedBid, metricEngine metrics.MetricsEngine) {
+
+	var found bool
+	var codeLabel string
+	reasonCodeMap := make(map[openrtb3.NonBidStatusCode]string)
+
+	for _, bid := range rejBids {
+		if codeLabel, found = reasonCodeMap[bid.RejectionReason]; !found {
+			codeLabel = strconv.FormatInt(int64(bid.RejectionReason), 10)
+			reasonCodeMap[bid.RejectionReason] = codeLabel
+		}
+		metricEngine.RecordRejectedBids(pubID, bid.Seat, codeLabel)
+	}
+}
+
+func UpdateResponseExtOW(bidResponse *openrtb2.BidResponse, ao analytics.AuctionObject) {
+	defer func() {
+		if r := recover(); r != nil {
+			response, err := json.Marshal(bidResponse)
+			if err != nil {
+				glog.Error("response:" + string(response) + ". err: " + err.Error() + ". stacktrace:" + string(debug.Stack()))
+				return
+			}
+			glog.Error("response:" + string(response) + ". stacktrace:" + string(debug.Stack()))
+		}
+	}()
+
+	if bidResponse == nil {
+		return
+	}
+
+	extBidResponse := openrtb_ext.ExtBidResponse{}
+	if len(bidResponse.Ext) != 0 {
+		if err := json.Unmarshal(bidResponse.Ext, &extBidResponse); err != nil {
+			return
+		}
+	}
+
+	rCtx := pubmatic.GetRequestCtx(ao.HookExecutionOutcome)
+	if rCtx == nil {
+		return
+	}
+
+	if rCtx.LogInfoFlag == 1 {
+		extBidResponse.OwLogInfo.Logger, _ = pubmatic.GetLogAuctionObjectAsURL(ao, true, true)
+	}
+
+	// TODO: uncomment after seatnonbid PR is merged https://github.com/prebid/prebid-server/pull/2505
+	// if seatNonBids := updateSeatNoBid(rCtx, ao); len(seatNonBids) != 0 {
+	// 	if extBidResponse.Prebid == nil {
+	// 		extBidResponse.Prebid = &openrtb_ext.ExtResponsePrebid{}
+	// 	}
+	// 	extBidResponse.Prebid.SeatNonBid = seatNonBids
+	// }
+
+	if rCtx.Debug {
+		extBidResponse.OwLogger, _ = pubmatic.GetLogAuctionObjectAsURL(ao, false, true)
+	}
+
+	bidResponse.Ext, _ = json.Marshal(extBidResponse)
+}
+
+// TODO: uncomment after seatnonbid PR is merged https://github.com/prebid/prebid-server/pull/2505
+// TODO: Move this to module once it gets []analytics.RejectedBid as param (submit it in vanilla)
+// func updateSeatNoBid(rCtx *models.RequestCtx, ao analytics.AuctionObject) []openrtb_ext.SeatNonBid {
+// 	seatNonBids := make([]openrtb_ext.SeatNonBid, 0, len(ao.RejectedBids))
+
+// 	seatNoBids := make(map[string][]analytics.RejectedBid)
+// 	for _, rejectedBid := range ao.RejectedBids {
+// 		seatNoBids[rejectedBid.Seat] = append(seatNoBids[rejectedBid.Seat], rejectedBid)
+// 	}
+
+// 	for seat, rejectedBids := range seatNoBids {
+// 		extSeatNoBid := openrtb_ext.SeatNonBid{
+// 			Seat:    seat,
+// 			NonBids: make([]openrtb_ext.NonBid, 0, len(rejectedBids)),
+// 		}
+
+// 		for _, rejectedBid := range rejectedBids {
+// 			bid := *rejectedBid.Bid.Bid
+// 			addClientConfig(rCtx, seat, &bid)
+// 			extSeatNoBid.NonBids = append(extSeatNoBid.NonBids, openrtb_ext.NonBid{
+// 				ImpId:      rejectedBid.Bid.Bid.ImpID,
+// 				StatusCode: rejectedBid.RejectionReason,
+// 				Ext: openrtb_ext.NonBidExt{
+// 					Prebid: openrtb_ext.ExtResponseNonBidPrebid{
+// 						Bid: openrtb_ext.Bid{
+// 							Bid: bid,
+// 						},
+// 					},
+// 				},
+// 			})
+// 		}
+
+// 		seatNonBids = append(seatNonBids, extSeatNoBid)
+// 	}
+
+// 	return seatNonBids
+// }
+
+// func addClientConfig(rCtx *models.RequestCtx, seat string, bid *openrtb2.Bid) {
+// 	if seatNoBidBySeat, ok := rCtx.NoSeatBids[bid.ImpID]; ok {
+// 		if seatNoBids, ok := seatNoBidBySeat[seat]; ok {
+// 			for _, seatNoBid := range seatNoBids {
+// 				bidExt := models.BidExt{}
+// 				if err := json.Unmarshal(seatNoBid.Ext, &bidExt); err != nil {
+// 					continue
+// 				}
+
+// 				inBidExt := models.BidExt{}
+// 				if err := json.Unmarshal(bid.Ext, &inBidExt); err != nil {
+// 					continue
+// 				}
+
+// 				inBidExt.Banner = bidExt.Banner
+// 				inBidExt.Video = bidExt.Video
+
+// 				bid.Ext, _ = json.Marshal(inBidExt)
+// 			}
+// 		}
+// 	}
+// }
diff --git a/endpoints/openrtb2/auction_ow_test.go b/endpoints/openrtb2/auction_ow_test.go
new file mode 100644
index 000000000..68e88c7cf
--- /dev/null
+++ b/endpoints/openrtb2/auction_ow_test.go
@@ -0,0 +1,173 @@
+package openrtb2
+
+import (
+	"encoding/json"
+	"fmt"
+
+	"testing"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/openrtb/v19/openrtb3"
+	"github.com/prebid/prebid-server/analytics"
+	analyticsConf "github.com/prebid/prebid-server/analytics/config"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/errortypes"
+	"github.com/prebid/prebid-server/hooks"
+	"github.com/prebid/prebid-server/metrics"
+	metricsConfig "github.com/prebid/prebid-server/metrics/config"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/prebid/prebid-server/stored_requests/backends/empty_fetcher"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/mock"
+)
+
+func TestValidateImpExtOW(t *testing.T) {
+	paramValidator, err := openrtb_ext.NewBidderParamsValidator("../../static/bidder-params")
+	if err != nil {
+		panic(err.Error())
+	}
+
+	type testCase struct {
+		description    string
+		impExt         json.RawMessage
+		expectedImpExt string
+		expectedErrs   []error
+	}
+	testGroups := []struct {
+		description string
+		testCases   []testCase
+	}{
+		{
+			"Invalid bidder params tests",
+			[]testCase{
+				{
+					description:    "Impression dropped for bidder with invalid bidder params",
+					impExt:         json.RawMessage(`{"appnexus":{"placement_id":5.44}}`),
+					expectedImpExt: `{"appnexus":{"placement_id":5.44}}`,
+					expectedErrs: []error{&errortypes.BidderFailedSchemaValidation{Message: "request.imp[0].ext.prebid.bidder.appnexus failed validation.\nplacement_id: Invalid type. Expected: [integer,string], given: number"},
+						fmt.Errorf("request.imp[%d].ext.prebid.bidder must contain at least one bidder", 0)},
+				},
+				{
+					description:    "Valid Bidder params + Invalid bidder params",
+					impExt:         json.RawMessage(`{"appnexus":{"placement_id":5.44},"pubmatic":{"publisherId":"156209"}}`),
+					expectedImpExt: `{"appnexus":{"placement_id":5.44},"pubmatic":{"publisherId":"156209"}}`,
+					expectedErrs:   []error{&errortypes.BidderFailedSchemaValidation{Message: "request.imp[0].ext.prebid.bidder.appnexus failed validation.\nplacement_id: Invalid type. Expected: [integer,string], given: number"}},
+				},
+				{
+					description:    "Valid Bidder + Disabled Bidder + Invalid bidder params",
+					impExt:         json.RawMessage(`{"pubmatic":{"publisherId":156209},"appnexus":{"placement_id":555},"disabledbidder":{"foo":"bar"}}`),
+					expectedImpExt: `{"pubmatic":{"publisherId":156209},"appnexus":{"placement_id":555},"disabledbidder":{"foo":"bar"}}`,
+					expectedErrs: []error{&errortypes.BidderTemporarilyDisabled{Message: "The bidder 'disabledbidder' has been disabled."},
+						&errortypes.BidderFailedSchemaValidation{Message: "request.imp[0].ext.prebid.bidder.pubmatic failed validation.\npublisherId: Invalid type. Expected: string, given: integer"}},
+				},
+				{
+					description:    "Valid Bidder + Disabled Bidder + Invalid bidder params",
+					impExt:         json.RawMessage(`{"pubmatic":{"publisherId":156209},"disabledbidder":{"foo":"bar"}}`),
+					expectedImpExt: `{"pubmatic":{"publisherId":156209},"disabledbidder":{"foo":"bar"}}`,
+					expectedErrs: []error{&errortypes.BidderFailedSchemaValidation{Message: "request.imp[0].ext.prebid.bidder.pubmatic failed validation.\npublisherId: Invalid type. Expected: string, given: integer"},
+						&errortypes.BidderTemporarilyDisabled{Message: "The bidder 'disabledbidder' has been disabled."},
+						fmt.Errorf("request.imp[%d].ext.prebid.bidder must contain at least one bidder", 0)},
+				},
+			},
+		},
+	}
+
+	deps := &endpointDeps{
+		fakeUUIDGenerator{},
+		&nobidExchange{},
+		paramValidator,
+		&mockStoredReqFetcher{},
+		empty_fetcher.EmptyFetcher{},
+		empty_fetcher.EmptyFetcher{},
+		&config.Configuration{MaxRequestSize: int64(8096)},
+		&metricsConfig.NilMetricsEngine{},
+		analyticsConf.NewPBSAnalytics(&config.Analytics{}),
+		map[string]string{"disabledbidder": "The bidder 'disabledbidder' has been disabled."},
+		false,
+		[]byte{},
+		openrtb_ext.BuildBidderMap(),
+		nil,
+		nil,
+		hardcodedResponseIPValidator{response: true},
+		empty_fetcher.EmptyFetcher{},
+		hooks.EmptyPlanBuilder{},
+	}
+
+	for _, group := range testGroups {
+		for _, test := range group.testCases {
+			impWrapper := &openrtb_ext.ImpWrapper{Imp: &openrtb2.Imp{Ext: test.impExt}}
+
+			errs := deps.validateImpExt(impWrapper, nil, 0, false, nil)
+
+			if len(test.expectedImpExt) > 0 {
+				assert.JSONEq(t, test.expectedImpExt, string(impWrapper.Ext), "imp.ext JSON does not match expected. Test: %s. %s\n", group.description, test.description)
+			} else {
+				assert.Empty(t, impWrapper.Ext, "imp.ext expected to be empty but was: %s. Test: %s. %s\n", string(impWrapper.Ext), group.description, test.description)
+			}
+			assert.ElementsMatch(t, test.expectedErrs, errs, "errs slice does not match expected. Test: %s. %s\n", group.description, test.description)
+		}
+	}
+}
+
+func TestRecordRejectedBids(t *testing.T) {
+
+	type args struct {
+		pubid   string
+		rejBids []analytics.RejectedBid
+	}
+
+	type want struct {
+		expectedCalls int
+	}
+
+	tests := []struct {
+		description string
+		args        args
+		want        want
+	}{
+		{
+			description: "empty rejected bids",
+			args: args{
+				rejBids: []analytics.RejectedBid{},
+			},
+			want: want{
+				expectedCalls: 0,
+			},
+		},
+		{
+			description: "rejected bids",
+			args: args{
+				pubid: "1010",
+				rejBids: []analytics.RejectedBid{
+					{
+						Seat:            "pubmatic",
+						RejectionReason: openrtb3.LossBidAdvertiserExclusions,
+					},
+					{
+						Seat:            "pubmatic",
+						RejectionReason: openrtb3.LossBidBelowDealFloor,
+					},
+					{
+						Seat:            "pubmatic",
+						RejectionReason: openrtb3.LossBidAdvertiserExclusions,
+					},
+					{
+						Seat:            "appnexus",
+						RejectionReason: openrtb3.LossBidBelowDealFloor,
+					},
+				},
+			},
+			want: want{
+				expectedCalls: 4,
+			},
+		},
+	}
+
+	for _, test := range tests {
+		me := &metrics.MetricsEngineMock{}
+		me.On("RecordRejectedBids", mock.Anything, mock.Anything, mock.Anything).Return()
+
+		recordRejectedBids(test.args.pubid, test.args.rejBids, me)
+		me.AssertNumberOfCalls(t, "RecordRejectedBids", test.want.expectedCalls)
+	}
+}
diff --git a/endpoints/openrtb2/auction_test.go b/endpoints/openrtb2/auction_test.go
index 544a46d0e..77f550f3b 100644
--- a/endpoints/openrtb2/auction_test.go
+++ b/endpoints/openrtb2/auction_test.go
@@ -208,7 +208,7 @@ func runEndToEndTest(t *testing.T, auctionEndpointHandler httprouter.Handle, tes
 		if assert.NoError(t, err, "Could not unmarshal expected bidResponse taken from test file.\n Test file: %s\n Error:%s\n", testFile, err) {
 			err = json.Unmarshal([]byte(actualJsonBidResponse), &actualBidResponse)
 			if assert.NoError(t, err, "Could not unmarshal actual bidResponse from auction.\n Test file: %s\n Error:%s\n", testFile, err) {
-				assertBidResponseEqual(t, testFile, expectedBidResponse, actualBidResponse)
+				assertBidResponseEqual(t, test, testFile, expectedBidResponse, actualBidResponse)
 			}
 		}
 	}
@@ -249,7 +249,7 @@ func compareWarnings(t *testing.T, expectedBidResponseExt, actualBidResponseExt
 // Once unmarshalled, bidResponse objects can't simply be compared with an `assert.Equalf()` call
 // because tests fail if the elements inside the `bidResponse.SeatBid` and `bidResponse.SeatBid.Bid`
 // arrays, if any, are not listed in the exact same order in the actual version and in the expected version.
-func assertBidResponseEqual(t *testing.T, testFile string, expectedBidResponse openrtb2.BidResponse, actualBidResponse openrtb2.BidResponse) {
+func assertBidResponseEqual(t *testing.T, test testCase, testFile string, expectedBidResponse openrtb2.BidResponse, actualBidResponse openrtb2.BidResponse) {
 
 	//Assert non-array BidResponse fields
 	assert.Equalf(t, expectedBidResponse.ID, actualBidResponse.ID, "BidResponse.ID doesn't match expected. Test: %s\n", testFile)
@@ -303,7 +303,7 @@ func assertBidResponseEqual(t *testing.T, testFile string, expectedBidResponse o
 			assert.Equalf(t, expectedBid.ImpID, actualBidMap[bidID].ImpID, "BidResponse.SeatBid[%s].Bid[%s].ImpID doesn't match expected. Test: %s\n", bidderName, bidID, testFile)
 			assert.Equalf(t, expectedBid.Price, actualBidMap[bidID].Price, "BidResponse.SeatBid[%s].Bid[%s].Price doesn't match expected. Test: %s\n", bidderName, bidID, testFile)
 
-			if len(expectedBid.Ext) > 0 {
+			if test.Config.AssertBidExt && len(expectedBid.Ext) > 0 {
 				assert.JSONEq(t, string(expectedBid.Ext), string(actualBidMap[bidID].Ext), "Incorrect bid extension")
 			}
 		}
@@ -388,7 +388,7 @@ func TestBidRequestAssert(t *testing.T) {
 	}
 
 	for _, test := range testSuites {
-		assertBidResponseEqual(t, test.description, test.expectedBidResponse, test.actualBidResponse)
+		assertBidResponseEqual(t, testCase{Config: &testConfigValues{}}, test.description, test.expectedBidResponse, test.actualBidResponse)
 	}
 }
 
@@ -2602,14 +2602,14 @@ func TestValidateImpExt(t *testing.T) {
 
 			errs := deps.validateImpExt(impWrapper, nil, 0, false, nil)
 
-			assert.NoError(t, impWrapper.RebuildImp(), test.description+":rebuild_imp")
+			assert.NoError(t, impWrapper.RebuildImpressionExt(), test.description+":rebuild_imp")
 
 			if len(test.expectedImpExt) > 0 {
 				assert.JSONEq(t, test.expectedImpExt, string(imp.Ext), "imp.ext JSON does not match expected. Test: %s. %s\n", group.description, test.description)
 			} else {
 				assert.Empty(t, imp.Ext, "imp.ext expected to be empty but was: %s. Test: %s. %s\n", string(imp.Ext), group.description, test.description)
 			}
-			assert.Equal(t, test.expectedErrs, errs, "errs slice does not match expected. Test: %s. %s\n", group.description, test.description)
+			assert.ElementsMatch(t, test.expectedErrs, errs, "errs slice does not match expected. Test: %s. %s\n", group.description, test.description)
 		}
 	}
 }
@@ -4140,7 +4140,7 @@ func TestAuctionResponseHeaders(t *testing.T) {
 			requestBody:    validRequest(t, "site.json"),
 			expectedStatus: 200,
 			expectedHeaders: func(h http.Header) {
-				h.Set("X-Prebid", "pbs-go/unknown")
+				h.Set("X-Prebid", "owpbs-go/unknown")
 				h.Set("Content-Type", "application/json")
 			},
 		},
@@ -4149,7 +4149,7 @@ func TestAuctionResponseHeaders(t *testing.T) {
 			requestBody:    "{}",
 			expectedStatus: 400,
 			expectedHeaders: func(h http.Header) {
-				h.Set("X-Prebid", "pbs-go/unknown")
+				h.Set("X-Prebid", "owpbs-go/unknown")
 			},
 		},
 	}
@@ -5084,28 +5084,33 @@ func TestValidResponseAfterExecutingStages(t *testing.T) {
 		{
 			description: "Assert correct BidResponse when request rejected at entrypoint stage",
 			file:        "sample-requests/hooks/auction_entrypoint_reject.json",
-			planBuilder: mockPlanBuilder{entrypointPlan: makePlan[hookstage.Entrypoint](mockRejectionHook{nbr})},
+			planBuilder: mockPlanBuilder{entrypointPlan: makePlan[hookstage.Entrypoint](mockRejectionHook{nbr, nil})},
 		},
 		{
 			description: "Assert correct BidResponse when request rejected at raw-auction stage",
 			file:        "sample-requests/hooks/auction_raw_auction_request_reject.json",
-			planBuilder: mockPlanBuilder{rawAuctionPlan: makePlan[hookstage.RawAuctionRequest](mockRejectionHook{nbr})},
+			planBuilder: mockPlanBuilder{rawAuctionPlan: makePlan[hookstage.RawAuctionRequest](mockRejectionHook{nbr, nil})},
 		},
 		{
 			description: "Assert correct BidResponse when request rejected at processed-auction stage",
 			file:        "sample-requests/hooks/auction_processed_auction_request_reject.json",
-			planBuilder: mockPlanBuilder{processedAuctionPlan: makePlan[hookstage.ProcessedAuctionRequest](mockRejectionHook{nbr})},
+			planBuilder: mockPlanBuilder{processedAuctionPlan: makePlan[hookstage.ProcessedAuctionRequest](mockRejectionHook{nbr, nil})},
 		},
 		{
 			// bidder-request stage doesn't reject whole request, so we do not expect NBR code in response
 			description: "Assert correct BidResponse when request rejected at bidder-request stage",
 			file:        "sample-requests/hooks/auction_bidder_reject.json",
-			planBuilder: mockPlanBuilder{bidderRequestPlan: makePlan[hookstage.BidderRequest](mockRejectionHook{nbr})},
+			planBuilder: mockPlanBuilder{bidderRequestPlan: makePlan[hookstage.BidderRequest](mockRejectionHook{nbr, nil})},
 		},
 		{
 			description: "Assert correct BidResponse when request rejected at raw-bidder-response stage",
 			file:        "sample-requests/hooks/auction_bidder_response_reject.json",
-			planBuilder: mockPlanBuilder{rawBidderResponsePlan: makePlan[hookstage.RawBidderResponse](mockRejectionHook{nbr})},
+			planBuilder: mockPlanBuilder{rawBidderResponsePlan: makePlan[hookstage.RawBidderResponse](mockRejectionHook{nbr, nil})},
+		},
+		{
+			description: "Assert correct BidResponse when request rejected with error from hook",
+			file:        "sample-requests/hooks/auction_reject_with_error.json",
+			planBuilder: mockPlanBuilder{entrypointPlan: makePlan[hookstage.Entrypoint](mockRejectionHook{nbr, errors.New("dummy")})},
 		},
 		{
 			description: "Assert correct BidResponse with debug information from modules added to ext.prebid.modules",
@@ -5145,7 +5150,7 @@ func TestValidResponseAfterExecutingStages(t *testing.T) {
 				assert.NoError(t, json.Unmarshal(actualResp.Ext, &actualExt), "Unable to unmarshal actual ExtBidResponse.")
 			}
 
-			assertBidResponseEqual(t, tc.file, expectedResp, actualResp)
+			assertBidResponseEqual(t, test, tc.file, expectedResp, actualResp)
 			assert.Equal(t, expectedResp.NBR, actualResp.NBR, "Invalid NBR.")
 			assert.Equal(t, expectedExt.Warnings, actualExt.Warnings, "Wrong bidResponse.ext.warnings.")
 
diff --git a/endpoints/openrtb2/ctv/combination/adslot_combination_generator.go b/endpoints/openrtb2/ctv/combination/adslot_combination_generator.go
new file mode 100644
index 000000000..2e58b3497
--- /dev/null
+++ b/endpoints/openrtb2/ctv/combination/adslot_combination_generator.go
@@ -0,0 +1,587 @@
+package combination
+
+import (
+	"math/big"
+
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// generator holds all the combinations based
+// on Video Ad Pod request and Bid Response Max duration
+type generator struct {
+	podMinDuration      uint64            // Pod Minimum duration value present in origin Video Ad Pod Request
+	podMaxDuration      uint64            // Pod Maximum duration value present in origin Video Ad Pod Request
+	minAds              uint64            // Minimum Ads value present in origin Video Ad Pod Request
+	maxAds              uint64            // Maximum Ads value present in origin Video Ad Pod Request
+	slotDurations       []uint64          // input slot durations for which
+	slotDurationAdMap   map[uint64]uint64 // map of key = duration, value = no of creatives with given duration
+	noOfSlots           int               // Number of slots to be consider (from left to right)
+	combinationCountMap map[uint64]uint64 //key - number of ads, ranging from 1 to maxads given in request config value - containing no of combinations with repeatation each key can have (without validations)
+	stats               stats             // metrics information
+	combinations        [][]uint64        // May contains some/all combinations at given point of time
+	state               snapshot          // state configurations in case of lazy loading
+	order               int               // Indicates generation order e.g. maxads to min ads
+}
+
+// stats holds the metrics information for given point of time
+// such as current combination count, valid combination count, repeatation count
+// out of range combination
+type stats struct {
+	currentCombinationCount   int    // current combination count generated out of totalExpectedCombinations
+	validCombinationCount     int    //
+	repeatationsCount         int    // no of combinations not considered because containing some/all durations for which only single ad is present
+	outOfRangeCount           int    // no of combinations out of range because not satisfied pod min and max range
+	totalExpectedCombinations uint64 // indicates total number for possible combinations without validations but subtracts repeatations for duration with single ad
+}
+
+// snashot retains the state of iteration
+// it is used in determing when next valid combination is requested
+// using Next() method
+type snapshot struct {
+	start              uint64   // indicates which duration to be used to form combination
+	index              int64    // indicates from which index in combination array we should fill duration given by start
+	r                  uint64   // holds the current combination length ranging from minads to maxads
+	lastCombination    []uint64 // holds the last combination iterated
+	stateUpdated       bool     // flag indicating whether underneath search method updated the c.state values
+	valueUpdated       bool     // indicates whether search method determined and updated next combination
+	combinationCounter uint64   // holds the index of duration to be filled when 1 cycle of combination ends
+	resetFlags         bool     // indicates whether the required flags to reset or not
+}
+
+// Init ...initializes with following
+// 1. Determines the number of combinations to be generated
+// 2. Intializes the c.state values required for c.Next() and iteratoor
+// generationOrder indicates how combinations should be generated.
+func (c *generator) Init(podMinDuration, podMaxDuration uint64, config *openrtb_ext.VideoAdPod, durationAdsMap [][2]uint64, generationOrder int) {
+
+	c.podMinDuration = podMinDuration
+	c.podMaxDuration = podMaxDuration
+	c.minAds = uint64(*config.MinAds)
+	c.maxAds = uint64(*config.MaxAds)
+
+	// map of key = duration value = number of ads(must be non zero positive number)
+	c.slotDurationAdMap = make(map[uint64]uint64, len(c.slotDurations))
+
+	// iterate and extract duration and number of ads belonging to the duration
+	// split logic - :: separated
+
+	cnt := 0
+	c.slotDurations = make([]uint64, len(durationAdsMap))
+	for _, durationNoOfAds := range durationAdsMap {
+
+		c.slotDurations[cnt] = durationNoOfAds[0]
+		// save duration  and no of ads info
+		c.slotDurationAdMap[durationNoOfAds[0]] = durationNoOfAds[1]
+		cnt++
+	}
+
+	c.noOfSlots = len(c.slotDurations)
+	c.stats.currentCombinationCount = 0
+	c.stats.validCombinationCount = 0
+	c.state = snapshot{}
+
+	c.combinationCountMap = make(map[uint64]uint64, c.maxAds)
+	// compute no of possible combinations (without validations)
+	// using configurationss
+	c.stats.totalExpectedCombinations = compute(c, c.maxAds, true)
+	subtractUnwantedRepeatations(c)
+	// c.combinations = make([][]uint64, c.totalExpectedCombinations)
+	// util.Logf("Allow Repeatation = %v", c.allowRepetitationsForEligibleDurations)
+	// util.Logf("Total possible combinations (without validations) = %v ", c.totalExpectedCombinations)
+
+	/// new states
+	c.state.start = uint64(0)
+	c.state.index = 0
+	c.state.r = c.minAds
+	c.order = generationOrder
+	if c.order == MaxToMin {
+		c.state.r = c.maxAds
+	}
+	c.state.resetFlags = true
+}
+
+// Next - Get next ad slot combination
+// returns empty array if next combination is not present
+func (c *generator) Next() []uint64 {
+	var comb []uint64
+	if len(c.slotDurations) <= 0 {
+		return comb
+	}
+	if c.state.resetFlags {
+		reset(c)
+		c.state.resetFlags = false
+	}
+	for {
+		comb = c.lazyNext()
+		if len(comb) == 0 || isValidCombination(c, comb) {
+			break
+		}
+	}
+	return comb
+}
+
+func isValidCombination(c *generator, combination []uint64) bool {
+	// check if repeatations are allowed
+	repeationMap := make(map[uint64]uint64, len(c.slotDurations))
+	totalAdDuration := uint64(0)
+	for _, duration := range combination {
+		repeationMap[uint64(duration)]++
+		// check current combination contains repeating durations such that
+		// count(duration) > count(no of ads aunction engine received for the duration)
+		currentRepeationCnt := repeationMap[duration]
+		noOfAdsPresent := c.slotDurationAdMap[duration]
+		if currentRepeationCnt > noOfAdsPresent {
+			//util.Logf("count = %v :: Discarding combination '%v' as only '%v' ad is present for duration %v", c.stats.currentCombinationCount, combination, noOfAdsPresent, duration)
+			c.stats.repeatationsCount++
+			return false
+		}
+
+		// check if sum of durations is withing pod min and max duration
+		totalAdDuration += duration
+	}
+
+	if !(totalAdDuration >= c.podMinDuration && totalAdDuration <= c.podMaxDuration) {
+		// totalAdDuration is not within range of Pod min and max duration
+		//util.Logf("count = %v :: Discarding combination '%v' as either total Ad duration (%v) < %v (Pod min duration) or > %v (Pod Max duration)", c.stats.currentCombinationCount, combination, totalAdDuration, c.podMinDuration, c.podMaxDuration)
+		c.stats.outOfRangeCount++
+		return false
+	}
+	c.stats.validCombinationCount++
+	return true
+}
+
+// compute - number of combinations that can be generated based on
+// 1. minads
+// 2. maxads
+// 3. Ordering of durations not matters. i.e. 4,5,6 will not be considered again as 5,4,6 or 6,5,4
+// 4. Repeatations are allowed only for those durations where multiple ads are present
+// Sum ups number of combinations for each noOfAds (r) based on above criteria and returns the total
+// It operates recursively
+// c - algorithm config, noOfAds (r) - maxads requested (if recursion=true otherwise any valid value), recursion - whether to do recursion or not. if false then only single combination
+// for given noOfAds will be computed
+func compute(c *generator, noOfAds uint64, recursion bool) uint64 {
+
+	// can not limit till  c.minAds
+	// because we want to construct
+	// c.combinationCountMap required by subtractUnwantedRepeatations
+	if noOfAds <= 0 || len(c.slotDurations) <= 0 {
+		return 0
+	}
+	var noOfCombinations *big.Int
+	// Formula
+	//		(r + n - 1)!
+	//      ------------
+	//       r! (n - 1)!
+	n := uint64(len(c.slotDurations))
+	r := uint64(noOfAds)
+	d1 := fact(uint64(r))
+	d2 := fact(n - 1)
+	d3 := d1.Mul(&d1, &d2)
+	nmrt := fact(r + n - 1)
+
+	noOfCombinations = nmrt.Div(&nmrt, d3)
+	// store pure combination with repeatation in combinationCountMap
+	c.combinationCountMap[r] = noOfCombinations.Uint64()
+	//util.Logf("%v", noOfCombinations)
+	if recursion {
+
+		// add only if it  is  withing limit of c.minads
+		nextLevelCombinations := compute(c, noOfAds-1, recursion)
+		if noOfAds-1 >= c.minAds {
+			sumOfCombinations := noOfCombinations.Add(noOfCombinations, big.NewInt(int64(nextLevelCombinations)))
+			return sumOfCombinations.Uint64()
+		}
+
+	}
+	return noOfCombinations.Uint64()
+}
+
+// fact computes factorial of given number.
+// It is used by compute function
+func fact(no uint64) big.Int {
+	if no == 0 {
+		return *big.NewInt(int64(1))
+	}
+	var bigNo big.Int
+	bigNo.SetUint64(no)
+
+	fact := fact(no - 1)
+	mult := bigNo.Mul(&bigNo, &fact)
+
+	return *mult
+}
+
+// searchAll - searches all valid combinations
+// valid combinations are those which satisifies following
+// 1. sum of duration is within range of pod min and max values
+// 2. Each duration within combination honours number of ads value given in the request
+// 3. Number of durations in combination are within range of min and max ads
+func (c *generator) searchAll() [][]uint64 {
+	reset(c)
+	start := uint64(0)
+	index := uint64(0)
+
+	if c.order == MinToMax {
+		for r := c.minAds; r <= c.maxAds; r++ {
+			data := make([]uint64, r)
+			c.search(data, start, index, r, false, 0)
+		}
+	}
+	if c.order == MaxToMin {
+		for r := c.maxAds; r >= c.minAds; r-- {
+			data := make([]uint64, r)
+			c.search(data, start, index, r, false, 0)
+		}
+	}
+	// util.Logf("Total combinations generated = %v", c.currentCombinationCount)
+	// util.Logf("Total combinations expected = %v", c.totalExpectedCombinations)
+	// result := make([][]uint64, c.totalExpectedCombinations)
+	result := make([][]uint64, c.stats.validCombinationCount)
+	copy(result, c.combinations)
+	c.stats.currentCombinationCount = 0
+	return result
+}
+
+// reset the internal counters
+func reset(c *generator) {
+	c.stats.currentCombinationCount = 0
+	c.stats.validCombinationCount = 0
+	c.stats.repeatationsCount = 0
+	c.stats.outOfRangeCount = 0
+}
+
+// lazyNext performs stateful iteration. Instead of returning all valid combinations
+// in one gp, it will return each combination on demand basis.
+// valid combinations are those which satisifies following
+// 1. sum of duration is within range of pod min and max values
+// 2. Each duration within combination honours number of ads value given in the request
+// 3. Number of durations in combination are within range of min and max ads
+func (c *generator) lazyNext() []uint64 {
+	start := c.state.start
+	index := c.state.index
+	r := c.state.r
+	// reset last combination
+	// by deleting previous values
+	if c.state.lastCombination == nil {
+		c.combinations = make([][]uint64, 0)
+	}
+	data := &c.state.lastCombination
+	if *data == nil || uint64(len(*data)) != r {
+		*data = make([]uint64, r)
+	}
+	c.state.stateUpdated = false
+	c.state.valueUpdated = false
+	var result []uint64
+	if (c.order == MinToMax && r <= c.maxAds) || (c.order == MaxToMin && r >= c.minAds) {
+		// for ;  r <= c.maxAds; r++ {
+		c.search(*data, start, uint64(index), r, true, 0)
+		c.state.stateUpdated = false // reset
+		c.state.valueUpdated = false
+		result = make([]uint64, len(*data))
+		copy(result, *data)
+	}
+	return result
+}
+
+// search generates the combinations based on min and max number of ads
+func (c *generator) search(data []uint64, start, index, r uint64, lazyLoad bool, reursionCount int) []uint64 {
+
+	end := uint64(len(c.slotDurations) - 1)
+
+	// Current combination is ready to be printed, print it
+	if index == r {
+		data1 := make([]uint64, len(data))
+		for j := uint64(0); j < r; j++ {
+			data1[j] = data[j]
+		}
+		appendComb := true
+		if !lazyLoad {
+			appendComb = isValidCombination(c, data1)
+		}
+		if appendComb {
+			c.combinations = append(c.combinations, data1)
+			c.stats.currentCombinationCount++
+		}
+		//util.Logf("%v", data1)
+		c.state.valueUpdated = true
+		return data1
+
+	}
+
+	for i := start; i <= end && end+1+c.maxAds >= r-index; i++ {
+		if shouldUpdateAndReturn(c, start, index, r, lazyLoad, reursionCount, i, end) {
+			return data
+		}
+		data[index] = c.slotDurations[i]
+		currentDuration := i
+		c.search(data, currentDuration, index+1, r, lazyLoad, reursionCount+1)
+	}
+
+	if lazyLoad && !c.state.stateUpdated {
+		c.state.combinationCounter++
+		index = uint64(c.state.index) - 1
+		updateState(c, lazyLoad, r, reursionCount, end, c.state.combinationCounter, index, c.slotDurations[end])
+	}
+	return data
+}
+
+// getNextElement assuming arr contains unique values
+// other wise next elemt will be returned when first matching value of val found
+// returns nextValue and its index
+func getNextElement(arr []uint64, val uint64) (uint64, uint64) {
+	for i, e := range arr {
+		if e == val && i+1 < len(arr) {
+			return uint64(i) + 1, arr[i+1]
+		}
+	}
+	// assuming durations will never be 0
+	return 0, 0
+}
+
+// updateState - is used in case of lazy loading
+// It maintains the state of iterator by updating the required flags
+func updateState(c *generator, lazyLoad bool, r uint64, reursionCount int, end uint64, i uint64, index uint64, valueAtEnd uint64) {
+
+	if lazyLoad {
+		c.state.start = i
+		// set c.state.index = 0 when
+		// lastCombination contains, number X len(input) - 1 times starting from last index
+		// where X = last number present in the input
+		occurance := getOccurance(c, valueAtEnd)
+		//c.state.index = int64(c.state.combinationCounter)
+		// c.state.index = int64(index)
+		c.state.index = int64(index)
+		if occurance == r {
+			c.state.index = 0
+		}
+
+		// set c.state.combinationCounter
+		//	c.state.combinationCounter++
+		if c.state.combinationCounter >= r || c.state.combinationCounter >= uint64(len(c.slotDurations)) {
+			// LOGIC : to determine next value
+			// 1. get the value P at 0th index present in lastCombination
+			// 2. get the index of P
+			// 3. determine the next index i.e. index(p) + 1 = q
+			// 4. if q == r then set to 0
+			diff := (uint64(len(c.state.lastCombination)) - occurance)
+			if diff > 0 {
+				eleIndex := diff - 1
+				c.state.combinationCounter, _ = getNextElement(c.slotDurations, c.state.lastCombination[eleIndex])
+				if c.state.combinationCounter == r {
+					//			c.state.combinationCounter = 0
+				}
+				c.state.start = c.state.combinationCounter
+			} else {
+				// end of r
+			}
+		}
+		// set r
+		// increament value of r if occurance == r
+		if occurance == r {
+			c.state.start = 0
+			c.state.index = 0
+			c.state.combinationCounter = 0
+			if c.order == MinToMax {
+				c.state.r++
+			}
+			if c.order == MaxToMin {
+				c.state.r--
+			}
+		}
+		c.state.stateUpdated = true
+	}
+}
+
+// shouldUpdateAndReturn checks if states should be updated in case of lazy loading
+// If required it updates the state
+func shouldUpdateAndReturn(c *generator, start, index, r uint64, lazyLoad bool, reursionCount int, i, end uint64) bool {
+	if lazyLoad && c.state.valueUpdated {
+		if uint64(reursionCount) <= r && !c.state.stateUpdated {
+			updateState(c, lazyLoad, r, reursionCount, end, i, index, c.slotDurations[end])
+		}
+		return true
+	}
+	return false
+}
+
+// getOccurance checks how many time given number is occured in c.state.lastCombination
+func getOccurance(c *generator, valToCheck uint64) uint64 {
+	occurance := uint64(0)
+	for i := len(c.state.lastCombination) - 1; i >= 0; i-- {
+		if c.state.lastCombination[i] == valToCheck {
+			occurance++
+		}
+	}
+	return occurance
+}
+
+// subtractUnwantedRepeatations ensures subtracting repeating combination counts
+// from combinations count computed by compute fuction for each r = min and max ads range
+func subtractUnwantedRepeatations(c *generator) {
+
+	series := getRepeatitionBreakUp(c)
+
+	// subtract repeatations from noOfCombinations
+	// if not allowed for specific duration
+	totalUnwantedRepeatitions := uint64(0)
+
+	for _, noOfAds := range c.slotDurationAdMap {
+
+		// repeatation is not allowed for given duration
+		// get how many repeation can have for the duration
+		// at given level r = no of ads
+
+		// Logic - to find repeatation for given duration at level r
+		// 1. if r = 1 - repeatition = 0 for any duration
+		// 2. if r = 2 - repeatition = 1 for any duration
+		// 3. if r >= 3 - repeatition = noOfCombinations(r) - noOfCombinations(r-2)
+		// 4. Using tetrahedral series determine the exact repeations w.r.t. noofads
+		//    For Example, if noAds = 6  1 4 10 20 ...
+		//	   1 => 1 repeatation for given number X in combination of 6
+		//     4 => 4 repeatations for given number X  in combination of 5
+		//    10 => 10 repeatations for given number X in combination of 4 (i.e. combination containing  ..,X,X,X....)
+		/*
+			4 5 8 7
+																	4	5	8	7
+			n = 4    r = 1      repeat = 4     no-repeat = 4        0	0	0	0
+			n = 4    r = 2      repeat = 10    no-repeat = 6        1	1	1	1
+			n = 4    r = 3      repeat = 20    no-repeat = 4		4	4	4	4
+																1+3   1+3  1+3 1+3
+			n = 4    r = 4      repeat = 35    no-repeat = 1		10	10	10	10
+																1+3+6 1+3+6 1+3+6
+
+																	4	5	8	7	18
+			n = 5    r = 1      repeat = 5     no-repeat = 5        0	0	0	0	0
+			n = 5    r = 2      repeat = 15    no-repeat = 10       1	1	1	1	1
+			n = 5    r = 3      repeat = 35    no-repeat = 10		5	5	5	5	5
+																1+4
+			n = 5    r = 4      repeat = 70    no-repeat = 5		15	15	15	15	15
+																1+4+10
+			n = 5    r = 5      repeat = 126   no-repeat = 1		35	35	35	35	35
+																1+4+10+20
+			n = 5    r = 6      repeat = 210   no-repeat = xxx		70
+																1+4+10+20+35
+
+
+																	14	4
+			n = 2    r = 1      repeat = 2            				0	0
+			n = 2    r = 2      repeat = 3        					1	1
+
+																	15
+			n = 1    r = 1      repeat = 1            				0
+			n = 1    r = 2      repeat = 1        					1
+			n = 1    r = 3      repeat = 1            				1
+			n = 1    r = 4      repeat = 1        					1
+			n = 1    r = 5      repeat = 1	        				1
+
+
+			if r = 1 => r1rpt = 0
+			if r = 2 => r2rpt = 1
+
+			if r >= 3
+
+			r3rpt = comb(r3 - 2)
+			r4rpt = comb(r4 - 2)
+		*/
+
+		for r := c.minAds; r <= c.maxAds; r++ {
+			if r == 1 {
+				// duration will no be repeated when noOfAds = 1
+				continue // 0 to be subtracted
+			}
+			// if r == 2 {
+			// 	// each duration will be repeated only once when noOfAds = 2
+			// 	totalUnwantedRepeatitions++
+			// 	// get total no of repeatations for combination of no > noOfAds
+			// 	continue
+			// }
+
+			// r >= 3
+
+			// find out how many repeatations are allowed for given duration
+			// if allowedRepeatitions = 3, it means there are r = 3 ads for given duration
+			// hence, we can allow duration repeated ranging from r= 1 to r= 3
+			// i.e. durations can not be repeated beyong r = 3
+			// so we should discard the repeations beyond r = 3 i.e. from r = 4 to r = maxads
+			maxAllowedRepeatitions := noOfAds
+
+			if maxAllowedRepeatitions > c.maxAds {
+				// maximum we can given upto c.maxads
+				maxAllowedRepeatitions = c.maxAds
+			}
+
+			// if maxAllowedRepeatitions = 2 then
+			// repeatations > 2 should not be considered
+			// compute not allowed repeatitions
+			for i := maxAllowedRepeatitions + 1; i <= c.maxAds; i++ {
+				totalUnwantedRepeatitions += series[i]
+			}
+
+		}
+
+	}
+	// subtract all repeatations across all minads and maxads combinations count
+	c.stats.totalExpectedCombinations -= totalUnwantedRepeatitions
+}
+
+// getRepeatitionBreakUp
+func getRepeatitionBreakUp(c *generator) map[uint64]uint64 {
+	series := make(map[uint64]uint64, c.maxAds) // not using index 0
+	ads := c.maxAds
+	series[ads] = 1
+	seriesSum := uint64(1)
+	// always generate from r = 3 where r is no of ads
+	ads--
+	for r := uint64(3); r <= c.maxAds; r++ {
+		// get repeations
+		repeatations := c.combinationCountMap[r-2]
+		// get next series item
+		nextItem := repeatations - seriesSum
+		if repeatations == seriesSum {
+			nextItem = repeatations
+		}
+		series[ads] = nextItem
+		seriesSum += nextItem
+		ads--
+	}
+
+	return series
+}
+
+// getInvalidCombinatioCount returns no of invalid combination due to one of the following reason
+// 1. Contains repeatition of durations, which has only one ad with it
+// 2. Sum of duration (combinationo) is out of Pod Min or Pod Max duration
+func (c *generator) getInvalidCombinatioCount() int {
+	return c.stats.repeatationsCount + c.stats.outOfRangeCount
+}
+
+// GetCurrentCombinationCount returns current combination count
+// irrespective of whether it is valid combination
+func (c *generator) GetCurrentCombinationCount() int {
+	return c.stats.currentCombinationCount
+}
+
+// GetExpectedCombinationCount returns total number for possible combinations without validations
+// but subtracts repeatations for duration with single ad
+func (c *generator) GetExpectedCombinationCount() uint64 {
+	return c.stats.totalExpectedCombinations
+}
+
+// GetOutOfRangeCombinationsCount returns number of combinations currently rejected because of
+// not satisfying Pod Minimum and Maximum duration
+func (c *generator) GetOutOfRangeCombinationsCount() int {
+	return c.stats.outOfRangeCount
+}
+
+// GetRepeatedDurationCombinationCount returns number of combinations currently rejected because of containing
+// one or more repeatations of duration values, for which partners returned only single ad
+func (c *generator) GetRepeatedDurationCombinationCount() int {
+	return c.stats.repeatationsCount
+}
+
+// GetValidCombinationCount returns the number of valid combinations
+//  1. Within range of Pod min and max duration
+//  2. Repeatations are inline with input no of ads
+func (c *generator) GetValidCombinationCount() int {
+	return c.stats.validCombinationCount
+}
diff --git a/endpoints/openrtb2/ctv/combination/adslot_combination_generator_test.go b/endpoints/openrtb2/ctv/combination/adslot_combination_generator_test.go
new file mode 100644
index 000000000..781a85de1
--- /dev/null
+++ b/endpoints/openrtb2/ctv/combination/adslot_combination_generator_test.go
@@ -0,0 +1,240 @@
+package combination
+
+import (
+	"encoding/json"
+	"fmt"
+	"os"
+	"testing"
+
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/util"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+)
+
+var testBidResponseMaxDurations = []struct {
+	scenario string
+	// index 0 = Max Duration of Ad present in Bid Response
+	// index 1 = Number of Ads for given Max Duration (Index 0)
+	responseMaxDurations [][2]uint64
+	podMinDuration       int // Pod Minimum duration value present in origin Video Ad Pod Request
+	podMaxDuration       int // Pod Maximum duration value present in origin Video Ad Pod Request
+	minAds               int // Minimum Ads value present in origin Video Ad Pod Request
+	maxAds               int // Maximum Ads value present in origin Video Ad Pod Request
+}{
+	{
+		scenario:             "TC1-Single_Value",
+		responseMaxDurations: [][2]uint64{{14, 1}, {4, 3}},
+		podMinDuration:       10, podMaxDuration: 14, minAds: 1, maxAds: 2,
+	}, {
+		scenario:             "TC2-Multi_Value",
+		responseMaxDurations: [][2]uint64{{1, 2}, {2, 2}, {3, 2}, {4, 2}, {5, 2}},
+		podMinDuration:       10, podMaxDuration: 14, minAds: 1, maxAds: 2,
+	}, {
+		scenario:             "TC3-max_ads = input_bid_durations",
+		responseMaxDurations: [][2]uint64{{4, 2}, {5, 2}, {8, 2}, {7, 2}},
+		podMinDuration:       10, podMaxDuration: 50, minAds: 2, maxAds: 5,
+	}, {
+		scenario:             "TC4-max_ads < input_bid_durations (test 1)",
+		responseMaxDurations: [][2]uint64{{4, 2}, {5, 2}, {8, 2}, {7, 2}},
+		podMinDuration:       10, podMaxDuration: 17, minAds: 3, maxAds: 3,
+	}, {
+		scenario:             "TC5-max_ads  (1) < input_bid_durations (test 1)",
+		responseMaxDurations: [][2]uint64{{4, 2}, {5, 2}, {8, 2}, {7, 2}},
+		podMinDuration:       10, podMaxDuration: 14, minAds: 3, maxAds: 1,
+	}, {
+		scenario:             "TC6-max_ads < input_bid_durations (test 2)",
+		responseMaxDurations: [][2]uint64{{4, 2}, {5, 2}, {8, 2}, {7, 2}},
+		podMinDuration:       10, podMaxDuration: 14, minAds: 3, maxAds: 2,
+	}, {
+		scenario:             "TC7-max_ads > input_bid_durations (test 1)",
+		responseMaxDurations: [][2]uint64{{4, 2}, {5, 1}, {8, 2}, {7, 2}},
+		podMinDuration:       10, podMaxDuration: 50, minAds: 4, maxAds: 4,
+	},
+	// {
+
+	// 	// 4 - c1, c2,    :  5 - c3 : 6 - c4, c5,  8 : c7
+	// 	scenario:             "TC8-max_ads (20 ads) > input_bid_durations (test 2)",
+	// 	responseMaxDurations: []uint64{4, 5, 8, 7},
+	// 	podMinDuration:       10, podMaxDuration: 14, minAds: 3, maxAds: 20,
+	// 	combinations: [][]int64{{14}}},
+	{
+
+		// 4 - c1, c2,    :  5 - c3 : 6 - c4, c5,  8 : c7
+		scenario:             "TC6-max_ads (20 ads) > input_bid_durations-repeatation_not_allowed",
+		responseMaxDurations: [][2]uint64{{4, 2}, {5, 2}, {8, 2}, {7, 2}},
+		podMinDuration:       10, podMaxDuration: 14, minAds: 3, maxAds: 2,
+	},
+	// {
+
+	// 	// 4 - c1, c2,    :  5 - c3 : 6 - c4, c5,  8 : c7
+	// 	scenario:             "TC8-max_ads (20 ads) > input_bid_durations (no repitations)",
+	// 	responseMaxDurations: []uint64{4, 5, 8, 7},
+	// 	podMinDuration:       10, podMaxDuration: 14, minAds: 3, maxAds: 20,
+	// 	combinations:                           [][]int64{{14}},
+	// 	allowRepetitationsForEligibleDurations: "true", // no repeitations
+	// },
+
+	// {
+
+	// 	// 4 - c1, c2,    :  5 - c3 : 6 - c4, c5,  8 : c7
+	// 	scenario:             "TC9-max_ads = input_bid_durations = 4",
+	// 	responseMaxDurations: []uint64{4, 4, 4, 4},
+	// 	podMinDuration:       10, podMaxDuration: 14, minAds: 3, maxAds: 4,
+	// 	combinations: [][]int64{{14}}, allowRepetitationsForEligibleDurations: "true"},
+	{
+		scenario:             "TC10-max_ads 0",
+		responseMaxDurations: [][2]uint64{{4, 2}, {4, 2}, {4, 2}, {4, 2}},
+		podMinDuration:       10, podMaxDuration: 14, minAds: 3, maxAds: 0,
+	}, {
+		scenario:             "TC11-max_ads =5-input-empty",
+		responseMaxDurations: [][2]uint64{},
+		podMinDuration:       10, podMaxDuration: 14, minAds: 3, maxAds: 0,
+	}, {
+		scenario:             "TC12-max_ads =5-input-empty-no-repeatation",
+		responseMaxDurations: [][2]uint64{{25, 2}, {30, 2}, {76, 2}, {10, 2}, {88, 2}},
+		podMinDuration:       10, podMaxDuration: 229, minAds: 1, maxAds: 4,
+	}, {
+		scenario:             "TC13-max_ads = input = 10-without-repeatation",
+		responseMaxDurations: [][2]uint64{{25, 2}, {30, 2}, {76, 2}, {10, 2}, {88, 2}, {34, 2}, {37, 2}, {67, 2}, {89, 2}, {45, 2}},
+		podMinDuration:       10, podMaxDuration: 14, minAds: 3, maxAds: 10,
+	}, {
+		scenario:             "TC14-single duration: single ad",
+		responseMaxDurations: [][2]uint64{{15, 1}},
+		podMinDuration:       10, podMaxDuration: 15, minAds: 1, maxAds: 5,
+	}, {
+		scenario:             "TC15-exact-pod-duration",
+		responseMaxDurations: [][2]uint64{{25, 2}, {30, 2}, {76, 2}, {10, 2}, {88, 2}},
+		podMinDuration:       200, podMaxDuration: 200, minAds: 8, maxAds: 10,
+	}, {
+		scenario:             "TC16-50ads",
+		responseMaxDurations: [][2]uint64{{25, 2}, {30, 2}, {76, 2}, {10, 2}, {88, 2}},
+		podMinDuration:       200, podMaxDuration: 200, minAds: 10, maxAds: 10, /*50*/
+	},
+}
+
+func BenchmarkPodDurationCombinationGenerator(b *testing.B) {
+	for _, test := range testBidResponseMaxDurations {
+		b.Run(test.scenario, func(b *testing.B) {
+			c := new(generator)
+			config := new(openrtb_ext.VideoAdPod)
+			config.MinAds = &test.minAds
+			config.MaxAds = &test.maxAds
+			config.MinDuration = &test.podMinDuration
+			config.MaxDuration = &test.podMaxDuration
+
+			for n := 0; n < b.N; n++ {
+				for true {
+					comb := c.Next()
+					if nil == comb || len(comb) == 0 {
+						break
+					}
+				}
+			}
+		})
+	}
+}
+
+// TestMaxToMinCombinationGenerator tests the genreration of
+// combinations from min to max combinations
+//
+//	e.g.
+//	1
+//	1 2
+//	1 2 3
+//	1 2 3 4
+func TestMinToMaxCombinationGenerator(t *testing.T) {
+	for _, test := range testBidResponseMaxDurations {
+		// if test.scenario != "TC1-Single_Value" {
+		// 	continue
+		// }
+		// eOut := readExpectedOutput()
+		// fmt.Println(eOut)
+		t.Run(test.scenario, func(t *testing.T) {
+			c := new(generator)
+			config := new(openrtb_ext.VideoAdPod)
+			config.MinAds = &test.minAds
+			config.MaxAds = &test.maxAds
+			c.Init(uint64(test.podMinDuration), uint64(test.podMaxDuration), config, test.responseMaxDurations, MinToMax)
+			validator(t, c)
+		})
+	}
+}
+
+// TestMaxToMinCombinationGenerator tests the genreration of
+// combinations from max to min combinations
+//
+//	e.g.
+//	1 2 3 4
+//	1 2 3
+//	1 2
+//	1
+func TestMaxToMinCombinationGenerator(t *testing.T) {
+	for _, test := range testBidResponseMaxDurations {
+		t.Run(test.scenario, func(t *testing.T) {
+			c := new(generator)
+			config := new(openrtb_ext.VideoAdPod)
+			config.MinAds = &test.minAds
+			config.MaxAds = &test.maxAds
+			c.Init(uint64(test.podMinDuration), uint64(test.podMaxDuration), config, test.responseMaxDurations, MaxToMin)
+			validator(t, c)
+		})
+	}
+}
+
+func validator(t *testing.T, c *generator) {
+	expectedOutput := c.searchAll()
+	// determine expected size of expected output
+	// subtract invalid combinations size
+	actualOutput := make([][]uint64, len(expectedOutput))
+
+	cnt := 0
+	for true {
+		comb := c.Next()
+		if comb == nil || len(comb) == 0 {
+			break
+		}
+		//ctv.Logf("%v", comb)
+		//fmt.Print("count = ", c.currentCombinationCount, " :: ", comb, "\n")
+		fmt.Println("e = ", (expectedOutput)[cnt], "\t : a = ", comb)
+		val := make([]uint64, len(comb))
+		copy(val, comb)
+		actualOutput[cnt] = val
+		cnt++
+	}
+
+	if expectedOutput != nil {
+		// compare results
+		for i := uint64(0); i < uint64(len(expectedOutput)); i++ {
+			if expectedOutput[i] == nil {
+				continue
+			}
+			for j := uint64(0); j < uint64(len(expectedOutput[i])); j++ {
+				if expectedOutput[i][j] == actualOutput[i][j] {
+				} else {
+
+					assert.Fail(t, "expectedOutput[", i, "][", j, "] != actualOutput[", i, "][", j, "] ", expectedOutput[i][j], " !=", actualOutput[i][j])
+
+				}
+			}
+
+		}
+	}
+
+	assert.Equal(t, expectedOutput, actualOutput)
+	assert.ElementsMatch(t, expectedOutput, actualOutput)
+
+	util.Logf("Total combinations generated = %v", c.stats.currentCombinationCount)
+	util.Logf("Total valid combinations  = %v", c.stats.validCombinationCount)
+	util.Logf("Total repeated combinations  = %v", c.stats.repeatationsCount)
+	util.Logf("Total outofrange combinations  = %v", c.stats.outOfRangeCount)
+	util.Logf("Total combinations expected = %v", c.stats.totalExpectedCombinations)
+}
+
+func readExpectedOutput() map[string][][]int {
+	file, _ := os.Open("test_input/TC_1,json")
+	var bytes []byte
+	file.Read(bytes)
+	eOut := make(map[string][][]int, 0)
+	json.Unmarshal(bytes, eOut)
+	return eOut
+}
diff --git a/endpoints/openrtb2/ctv/combination/combination.go b/endpoints/openrtb2/ctv/combination/combination.go
new file mode 100644
index 000000000..f14a0157e
--- /dev/null
+++ b/endpoints/openrtb2/ctv/combination/combination.go
@@ -0,0 +1,71 @@
+// Package combination generates possible ad pod response
+// based on bid response durations. It ensures that generated
+// combination is satifying ad pod request configurations like
+// Min Pod Duation, Maximum Pod Duration, Minimum number of ads, Maximum number of Ads.
+// It also considers number of bids received for given duration
+// For Example, if for 60 second duration we have 2 bids then
+// then it will ensure combination contains at most 2 repeatations of 60 sec; not more than that
+package combination
+
+import (
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/types"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// ICombination ...
+type ICombination interface {
+	Get() []int
+}
+
+// Combination ...
+type Combination struct {
+	ICombination
+	data      []int
+	generator generator
+	config    *openrtb_ext.VideoAdPod
+	order     int // order of combination generator
+}
+
+// NewCombination ... Generates on demand valid combinations
+// Valid combinations are those who satisifies
+//  1. Pod Min Max duration
+//  2. minAds <= size(combination) <= maxads
+//  3. If  Combination contains repeatition for given duration then
+//     repeatitions are <= no of ads received for the duration
+//
+// Use Get method to start getting valid combinations
+func NewCombination(buckets types.BidsBuckets, podMinDuration, podMaxDuration uint64, config *openrtb_ext.VideoAdPod) *Combination {
+	generator := new(generator)
+	durationBidsCnts := make([][2]uint64, 0)
+	for duration, bids := range buckets {
+		durationBidsCnts = append(durationBidsCnts, [2]uint64{uint64(duration), uint64(len(bids))})
+	}
+	generator.Init(podMinDuration, podMaxDuration, config, durationBidsCnts, MaxToMin)
+	return &Combination{
+		generator: *generator,
+		config:    config,
+	}
+}
+
+// Get next valid combination
+// Retuns empty slice if all combinations are generated
+func (c *Combination) Get() []int {
+	nextComb := c.generator.Next()
+	nextCombInt := make([]int, len(nextComb))
+	cnt := 0
+	for _, duration := range nextComb {
+		nextCombInt[cnt] = int(duration)
+		cnt++
+	}
+	return nextCombInt
+}
+
+const (
+	// MinToMax tells combination generator to generate combinations
+	// starting from Min Ads to Max Ads
+	MinToMax = iota
+
+	// MaxToMin tells combination generator to generate combinations
+	// starting from Max Ads to Min Ads
+	MaxToMin
+)
diff --git a/endpoints/openrtb2/ctv/combination/combination_test.go b/endpoints/openrtb2/ctv/combination/combination_test.go
new file mode 100644
index 000000000..14f32eddc
--- /dev/null
+++ b/endpoints/openrtb2/ctv/combination/combination_test.go
@@ -0,0 +1,38 @@
+package combination
+
+import (
+	"testing"
+
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/types"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestCombination(t *testing.T) {
+	buckets := make(types.BidsBuckets)
+
+	dBids := make([]*types.Bid, 0)
+	for i := 1; i <= 3; i++ {
+		bid := new(types.Bid)
+		bid.Duration = 10 * i
+		dBids = append(dBids, bid)
+		buckets[bid.Duration] = dBids
+	}
+
+	config := new(openrtb_ext.VideoAdPod)
+	config.MinAds = new(int)
+	*config.MinAds = 2
+	config.MaxAds = new(int)
+	*config.MaxAds = 4
+
+	c := NewCombination(buckets, 30, 70, config)
+
+	for true {
+		comb := c.generator.Next()
+		if nil == comb || len(comb) == 0 {
+			assert.True(t, nil == comb || len(comb) == 0)
+			break
+		}
+	}
+
+}
diff --git a/endpoints/openrtb2/ctv/combination/test_input/TC_1.json b/endpoints/openrtb2/ctv/combination/test_input/TC_1.json
new file mode 100644
index 000000000..498204657
--- /dev/null
+++ b/endpoints/openrtb2/ctv/combination/test_input/TC_1.json
@@ -0,0 +1,4 @@
+{
+    "1" : [[14], [4]],
+    "2" : [[14,14],[14,4],[4,4]]
+}
\ No newline at end of file
diff --git a/endpoints/openrtb2/ctv/constant/constant.go b/endpoints/openrtb2/ctv/constant/constant.go
new file mode 100644
index 000000000..1ea776c12
--- /dev/null
+++ b/endpoints/openrtb2/ctv/constant/constant.go
@@ -0,0 +1,53 @@
+package constant
+
+const (
+	CTVImpressionIDSeparator = `_`
+	CTVImpressionIDFormat    = `%v` + CTVImpressionIDSeparator + `%v`
+	CTVUniqueBidIDFormat     = `%v-%v`
+	HTTPPrefix               = `http`
+
+	//VAST Constants
+	VASTDefaultVersion    = 2.0
+	VASTMaxVersion        = 4.0
+	VASTDefaultVersionStr = `2.0`
+	VASTDefaultTag        = `<VAST version="` + VASTDefaultVersionStr + `"/>`
+	VASTElement           = `VAST`
+	VASTAdElement         = `Ad`
+	VASTWrapperElement    = `Wrapper`
+	VASTAdTagURIElement   = `VASTAdTagURI`
+	VASTVersionAttribute  = `version`
+	VASTSequenceAttribute = `sequence`
+
+	CTVAdpod  = `adpod`
+	CTVOffset = `offset`
+)
+
+var (
+	VASTVersionsStr = []string{"0", "1.0", "2.0", "3.0", "4.0"}
+)
+
+// BidStatus contains bids filtering reason
+type BidStatus = int64
+
+const (
+	//StatusOK ...
+	StatusOK BidStatus = 0
+	//StatusWinningBid ...
+	StatusWinningBid BidStatus = 1
+	//StatusCategoryExclusion ...
+	StatusCategoryExclusion BidStatus = 2
+	//StatusDomainExclusion ...
+	StatusDomainExclusion BidStatus = 3
+	//StatusDurationMismatch ...
+	StatusDurationMismatch BidStatus = 4
+)
+
+// MonitorKey provides the unique key for moniroting the algorithms
+type MonitorKey string
+
+const (
+	// CombinationGeneratorV1 ...
+	CombinationGeneratorV1 MonitorKey = "comp_exclusion_v1"
+	// CompetitiveExclusionV1 ...
+	CompetitiveExclusionV1 MonitorKey = "comp_exclusion_v1"
+)
diff --git a/endpoints/openrtb2/ctv/impressions/by_duration_range_test.go b/endpoints/openrtb2/ctv/impressions/by_duration_range_test.go
new file mode 100644
index 000000000..0bc0b2ff1
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/by_duration_range_test.go
@@ -0,0 +1,177 @@
+package impressions
+
+import (
+	"testing"
+
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestGetImpressionsByDurationRanges(t *testing.T) {
+	type args struct {
+		policy        openrtb_ext.OWVideoAdDurationMatchingPolicy
+		durations     []int
+		maxAds        int
+		adMinDuration int
+		adMaxDuration int
+	}
+	type want struct {
+		imps [][2]int64
+	}
+
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			// do not generate impressions
+			name: "no_adpod_context",
+			args: args{},
+			want: want{
+				imps: [][2]int64{},
+			},
+		},
+		{
+			// do not generate impressions
+			name: "nil_durations",
+			args: args{
+				durations: nil,
+			},
+			want: want{
+				imps: make([][2]int64, 0),
+			},
+		},
+		{
+			// do not generate impressions
+			name: "empty_durations",
+			args: args{
+				durations: make([]int, 0),
+			},
+			want: want{
+				imps: make([][2]int64, 0),
+			},
+		},
+		{
+			name: "zero_valid_durations_under_boundary",
+			args: args{
+				policy:        openrtb_ext.OWExactVideoAdDurationMatching,
+				durations:     []int{5, 10, 15},
+				maxAds:        5,
+				adMinDuration: 2,
+				adMaxDuration: 2,
+			},
+			want: want{
+				imps: [][2]int64{},
+			},
+		},
+		{
+			name: "zero_valid_durations_out_of_bound",
+			args: args{
+				policy:        openrtb_ext.OWExactVideoAdDurationMatching,
+				durations:     []int{5, 10, 15},
+				maxAds:        5,
+				adMinDuration: 20,
+				adMaxDuration: 20,
+			},
+			want: want{
+				imps: [][2]int64{},
+			},
+		},
+		{
+			name: "valid_durations_less_than_maxAds",
+			args: args{
+				policy:        openrtb_ext.OWExactVideoAdDurationMatching,
+				durations:     []int{5, 10, 15, 20, 25},
+				maxAds:        5,
+				adMinDuration: 10,
+				adMaxDuration: 20,
+			},
+			want: want{
+				imps: [][2]int64{
+					{10, 10},
+					{15, 15},
+					{20, 20},
+					//got repeated because of current video duration impressions are less than maxads
+					{10, 10},
+					{15, 15},
+				},
+			},
+		},
+		{
+			name: "valid_durations_greater_than_maxAds",
+			args: args{
+				policy:        openrtb_ext.OWExactVideoAdDurationMatching,
+				durations:     []int{5, 10, 15, 20, 25},
+				maxAds:        2,
+				adMinDuration: 10,
+				adMaxDuration: 20,
+			},
+			want: want{
+				imps: [][2]int64{
+					{10, 10},
+					{15, 15},
+					{20, 20},
+				},
+			},
+		},
+		{
+			name: "roundup_policy_valid_durations",
+			args: args{
+				policy:        openrtb_ext.OWRoundupVideoAdDurationMatching,
+				durations:     []int{5, 10, 15, 20, 25},
+				maxAds:        5,
+				adMinDuration: 10,
+				adMaxDuration: 20,
+			},
+			want: want{
+				imps: [][2]int64{
+					{10, 10},
+					{10, 15},
+					{10, 20},
+					{10, 10},
+					{10, 15},
+				},
+			},
+		},
+		{
+			name: "roundup_policy_zero_valid_durations",
+			args: args{
+				policy:        openrtb_ext.OWRoundupVideoAdDurationMatching,
+				durations:     []int{5, 10, 15, 20, 25},
+				maxAds:        5,
+				adMinDuration: 30,
+				adMaxDuration: 30,
+			},
+			want: want{
+				imps: [][2]int64{},
+			},
+		},
+		{
+			name: "roundup_policy_valid_max_ads_more_than_max_ads",
+			args: args{
+				policy:        openrtb_ext.OWRoundupVideoAdDurationMatching,
+				durations:     []int{5, 10, 15, 20, 25},
+				maxAds:        2,
+				adMinDuration: 10,
+				adMaxDuration: 20,
+			},
+			want: want{
+				imps: [][2]int64{
+					{10, 10},
+					{10, 15},
+					{10, 20},
+				},
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			args := tt.args
+			gen := newByDurationRanges(args.policy, args.durations, args.maxAds, args.adMinDuration, args.adMaxDuration)
+			imps := gen.Get()
+			assert.Equal(t, tt.want.imps, imps)
+		})
+	}
+}
diff --git a/endpoints/openrtb2/ctv/impressions/by_duration_ranges.go b/endpoints/openrtb2/ctv/impressions/by_duration_ranges.go
new file mode 100644
index 000000000..6aa129b5e
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/by_duration_ranges.go
@@ -0,0 +1,91 @@
+package impressions
+
+import (
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/util"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// byDurRangeConfig struct will be used for creating impressions object based on list of duration ranges
+type byDurRangeConfig struct {
+	IImpressions                                              //IImpressions interface
+	policy        openrtb_ext.OWVideoAdDurationMatchingPolicy //duration matching algorithm round/exact
+	durations     []int                                       //durations list of durations in seconds used for creating impressions object
+	maxAds        int                                         //maxAds is number of max impressions can be created
+	adMinDuration int                                         //adpod slot mininum duration
+	adMaxDuration int                                         //adpod slot maximum duration
+}
+
+// newByDurationRanges will create new object ob byDurRangeConfig for creating impressions for adpod request
+func newByDurationRanges(policy openrtb_ext.OWVideoAdDurationMatchingPolicy, durations []int,
+	maxAds, adMinDuration, adMaxDuration int) byDurRangeConfig {
+
+	return byDurRangeConfig{
+		policy:        policy,
+		durations:     durations,
+		maxAds:        maxAds,
+		adMinDuration: adMinDuration,
+		adMaxDuration: adMaxDuration,
+	}
+}
+
+// Get function returns lists of min,max duration ranges ganerated based on durations
+// it will return valid durations, duration must be within podMinDuration and podMaxDuration range
+// if len(durations) < maxAds then clone valid durations from starting till we reach maxAds length
+func (c *byDurRangeConfig) Get() [][2]int64 {
+	if len(c.durations) == 0 {
+		util.Logf("durations is nil. [%v] algorithm returning not generated impressions", c.Algorithm())
+		return make([][2]int64, 0)
+	}
+
+	isRoundupDurationMatchingPolicy := (openrtb_ext.OWRoundupVideoAdDurationMatching == c.policy)
+	var minDuration = -1
+	var validDurations []int
+
+	for _, dur := range c.durations {
+		// validate durations (adminduration <= lineitemduration <= admaxduration) (adpod adslot min and max duration)
+		if !(c.adMinDuration <= dur && dur <= c.adMaxDuration) {
+			continue // invalid duration
+		}
+
+		// finding minimum duration for roundup policy, this may include valid or invalid duration
+		if isRoundupDurationMatchingPolicy && (minDuration == -1 || minDuration >= dur) {
+			minDuration = dur
+		}
+
+		validDurations = append(validDurations, dur)
+	}
+
+	imps := make([][2]int64, 0)
+	for _, dur := range validDurations {
+		/*
+			minimum value is depends on duration matching policy
+			openrtb_ext.OWAdPodRoundupDurationMatching (round): minduration would be min(duration)
+			openrtb_ext.OWAdPodExactDurationMatching (exact) or empty: minduration would be same as maxduration
+		*/
+		if isRoundupDurationMatchingPolicy {
+			imps = append(imps, [2]int64{int64(minDuration), int64(dur)})
+		} else {
+			imps = append(imps, [2]int64{int64(dur), int64(dur)})
+		}
+	}
+
+	//calculate max ads
+	maxAds := c.maxAds
+	if len(validDurations) > maxAds {
+		maxAds = len(validDurations)
+	}
+
+	//adding extra impressions incase of total impressions generated are less than pod max ads.
+	if len(imps) > 0 {
+		for i := 0; len(imps) < maxAds; i++ {
+			imps = append(imps, [2]int64{imps[i][0], imps[i][1]})
+		}
+	}
+
+	return imps
+}
+
+// Algorithm returns MinMaxAlgorithm
+func (c *byDurRangeConfig) Algorithm() Algorithm {
+	return ByDurationRanges
+}
diff --git a/endpoints/openrtb2/ctv/impressions/helper.go b/endpoints/openrtb2/ctv/impressions/helper.go
new file mode 100644
index 000000000..0cfc0a76f
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/helper.go
@@ -0,0 +1,140 @@
+package impressions
+
+import (
+	"math"
+
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/util"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// newConfig initializes the generator instance
+func newConfig(podMinDuration, podMaxDuration int64, vPod openrtb_ext.VideoAdPod) generator {
+	config := generator{}
+	config.totalSlotTime = new(int64)
+	// configure requested pod
+	config.requested = pod{
+		podMinDuration:  podMinDuration,
+		podMaxDuration:  podMaxDuration,
+		slotMinDuration: int64(*vPod.MinDuration),
+		slotMaxDuration: int64(*vPod.MaxDuration),
+		minAds:          int64(*vPod.MinAds),
+		maxAds:          int64(*vPod.MaxAds),
+	}
+
+	// configure internal object (FOR INTERNAL USE ONLY)
+	// this  is used for internal computation and may contains modified values of
+	// slotMinDuration and slotMaxDuration in multiples of multipleOf factor
+	// This function will by deault intialize this pod with same values
+	// as of requestedPod
+	// There is another function newConfigWithMultipleOf, which computes and assigns
+	// values to this object
+	config.internal = internal{
+		slotMinDuration: config.requested.slotMinDuration,
+		slotMaxDuration: config.requested.slotMaxDuration,
+	}
+	return config
+}
+
+// newConfigWithMultipleOf initializes the generator instance
+// it internally calls newConfig to obtain the generator instance
+// then it computes closed to factor basedon 'multipleOf' parameter value
+// and accordingly determines the Pod Min/Max and Slot Min/Max values for internal
+// computation only.
+func newConfigWithMultipleOf(podMinDuration, podMaxDuration int64, vPod openrtb_ext.VideoAdPod, multipleOf int64) generator {
+	config := newConfig(podMinDuration, podMaxDuration, vPod)
+
+	// try to compute slot level min and max duration values in multiple of
+	// given number. If computed values are overlapping then prefer requested
+	if config.requested.slotMinDuration == config.requested.slotMaxDuration {
+		/*TestCase 30*/
+		util.Logf("requested.SlotMinDuration = requested.SlotMaxDuration = %v\n", config.requested.slotMinDuration)
+		config.internal.slotMinDuration = config.requested.slotMinDuration
+		config.internal.slotMaxDuration = config.requested.slotMaxDuration
+	} else {
+		config.internal.slotMinDuration = getClosestFactorForMinDuration(int64(config.requested.slotMinDuration), multipleOf)
+		config.internal.slotMaxDuration = getClosestFactorForMaxDuration(int64(config.requested.slotMaxDuration), multipleOf)
+		config.internal.slotDurationComputed = true
+		if config.internal.slotMinDuration > config.internal.slotMaxDuration {
+			// computed slot min duration > computed slot max duration
+			// avoid overlap and prefer requested values
+			config.internal.slotMinDuration = config.requested.slotMinDuration
+			config.internal.slotMaxDuration = config.requested.slotMaxDuration
+			// update marker indicated slot duation values are not computed
+			// this required by algorithm in computeTimeForEachAdSlot function
+			config.internal.slotDurationComputed = false
+		}
+	}
+	return config
+}
+
+// Returns true if num is multipleof second argument. False otherwise
+func isMultipleOf(num, multipleOf int64) bool {
+	return math.Mod(float64(num), float64(multipleOf)) == 0
+}
+
+// Returns closest factor for num, with  respect  input multipleOf
+//
+//	Example: Closest Factor of 9, in multiples of 5 is '10'
+func getClosestFactor(num, multipleOf int64) int64 {
+	return int64(math.Round(float64(num)/float64(multipleOf)) * float64(multipleOf))
+}
+
+// Returns closestfactor of MinDuration, with  respect to multipleOf
+// If computed factor < MinDuration then it will ensure and return
+// close factor >=  MinDuration
+func getClosestFactorForMinDuration(MinDuration int64, multipleOf int64) int64 {
+	closedMinDuration := getClosestFactor(MinDuration, multipleOf)
+
+	if closedMinDuration == 0 {
+		return multipleOf
+	}
+
+	if closedMinDuration < MinDuration {
+		return closedMinDuration + multipleOf
+	}
+
+	return closedMinDuration
+}
+
+// Returns closestfactor of maxduration, with  respect to multipleOf
+// If computed factor > maxduration then it will ensure and return
+// close factor <=  maxduration
+func getClosestFactorForMaxDuration(maxduration, multipleOf int64) int64 {
+	closedMaxDuration := getClosestFactor(maxduration, multipleOf)
+	if closedMaxDuration == maxduration {
+		return maxduration
+	}
+
+	// set closest maxduration closed to masduration
+	for i := closedMaxDuration; i <= maxduration; {
+		if closedMaxDuration < maxduration {
+			closedMaxDuration = i + multipleOf
+			i = closedMaxDuration
+		}
+	}
+
+	if closedMaxDuration > maxduration {
+		duration := closedMaxDuration - multipleOf
+		if duration == 0 {
+			// return input value as is instead of zero to avoid NPE
+			return maxduration
+		}
+		return duration
+	}
+
+	return closedMaxDuration
+}
+
+// Returns Maximum number out off 2 input numbers
+func max(num1, num2 int64) int64 {
+
+	if num1 > num2 {
+		return num1
+	}
+
+	if num2 > num1 {
+		return num2
+	}
+	// both must be equal here
+	return num1
+}
diff --git a/endpoints/openrtb2/ctv/impressions/impression_generator.go b/endpoints/openrtb2/ctv/impressions/impression_generator.go
new file mode 100644
index 000000000..7c828ab65
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/impression_generator.go
@@ -0,0 +1,352 @@
+package impressions
+
+import (
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/util"
+)
+
+// generator contains Pod Minimum Duration, Pod Maximum Duration, Slot Minimum Duration and Slot Maximum Duration
+// It holds additional attributes required by this algorithm for  internal computation.
+//
+//	It contains Slots attribute. This  attribute holds the output of this algorithm
+type generator struct {
+	IImpressions
+	Slots             [][2]int64 // Holds Minimum and Maximum duration (in seconds) for each Ad Slot. Length indicates total number of Ad Slots/ Impressions for given Ad Pod
+	totalSlotTime     *int64     // Total Sum of all Ad Slot durations (in seconds)
+	freeTime          int64      // Remaining Time (in seconds) not allocated. It is compared with RequestedPodMaxDuration
+	slotsWithZeroTime *int64     // Indicates number of slots with zero time (starting from 1).
+	// requested holds all the requested information received
+	requested pod
+	// internal holds the slot duration values closed to original value and multiples of X.
+	// It helps in plotting impressions with duration values in multiples of given number
+	internal internal
+}
+
+// pod for internal computation
+// should not be used outside
+type pod struct {
+	minAds          int64
+	maxAds          int64
+	slotMinDuration int64
+	slotMaxDuration int64
+	podMinDuration  int64
+	podMaxDuration  int64
+}
+
+// internal (FOR INTERNAL USE ONLY) holds the computed values slot min and max duration
+// in multiples of given number. It also holds slotDurationComputed flag
+// if slotDurationComputed = false, it means values computed were overlapping
+type internal struct {
+	slotMinDuration      int64
+	slotMaxDuration      int64
+	slotDurationComputed bool
+}
+
+// Get returns the number of Ad Slots/Impression  that input Ad Pod can have.
+// It returns List 2D array containing following
+//  1. Dimension 1 - Represents the minimum duration of an impression
+//  2. Dimension 2 - Represents the maximum duration of an impression
+func (config *generator) Get() [][2]int64 {
+	util.Logf("Pod Config with Internal Computation (using multiples of %v) = %+v\n", multipleOf, config)
+	totalAds := computeTotalAds(*config)
+	timeForEachSlot := computeTimeForEachAdSlot(*config, totalAds)
+
+	config.Slots = make([][2]int64, totalAds)
+	config.slotsWithZeroTime = new(int64)
+	*config.slotsWithZeroTime = totalAds
+	util.Logf("Plotted Ad Slots / Impressions of size = %v\n", len(config.Slots))
+	// iterate over total time till it is < cfg.RequestedPodMaxDuration
+	time := int64(0)
+	util.Logf("Started allocating durations to each Ad Slot / Impression\n")
+	fillZeroSlotsOnPriority := true
+	noOfZeroSlotsFilledByLastRun := int64(0)
+	*config.totalSlotTime = 0
+	for time < config.requested.podMaxDuration {
+		adjustedTime, slotsFull := config.addTime(timeForEachSlot, fillZeroSlotsOnPriority)
+		time += adjustedTime
+		timeForEachSlot = computeTimeLeastValue(config.requested.podMaxDuration-time, config.requested.slotMaxDuration-timeForEachSlot)
+		if slotsFull {
+			util.Logf("All slots are full of their capacity. validating slots\n")
+			break
+		}
+
+		// instruct for filling zero capacity slots on priority if
+		// 1. shouldAdjustSlotWithZeroDuration returns true
+		// 2. there are slots with 0 duration
+		// 3. there is at least ont slot with zero duration filled by last iteration
+		fillZeroSlotsOnPriority = false
+		noOfZeroSlotsFilledByLastRun = *config.slotsWithZeroTime - noOfZeroSlotsFilledByLastRun
+		if config.shouldAdjustSlotWithZeroDuration() && *config.slotsWithZeroTime > 0 && noOfZeroSlotsFilledByLastRun > 0 {
+			fillZeroSlotsOnPriority = true
+		}
+	}
+	util.Logf("Completed allocating durations to each Ad Slot / Impression\n")
+
+	// validate slots
+	config.validateSlots()
+
+	// log free time if present to stats server
+	// also check algoritm computed the no. of ads
+	if config.requested.podMaxDuration-time > 0 && len(config.Slots) > 0 {
+		config.freeTime = config.requested.podMaxDuration - time
+		util.Logf("TO STATS SERVER : Free Time not allocated %v sec", config.freeTime)
+	}
+
+	util.Logf("\nTotal Impressions = %v, Total Allocated Time = %v sec (out of %v sec, Max Pod Duration)\n%v", len(config.Slots), *config.totalSlotTime, config.requested.podMaxDuration, config.Slots)
+	return config.Slots
+}
+
+// Returns total number of Ad Slots/ impressions that the Ad Pod can have
+func computeTotalAds(cfg generator) int64 {
+	if cfg.internal.slotMaxDuration <= 0 || cfg.internal.slotMinDuration <= 0 {
+		util.Logf("Either cfg.slotMaxDuration or cfg.slotMinDuration or both are <= 0. Hence, totalAds = 0")
+		return 0
+	}
+	minAds := cfg.requested.podMaxDuration / cfg.internal.slotMaxDuration
+	maxAds := cfg.requested.podMaxDuration / cfg.internal.slotMinDuration
+
+	util.Logf("Computed minAds = %v , maxAds = %v\n", minAds, maxAds)
+
+	totalAds := max(minAds, maxAds)
+	util.Logf("Computed max(minAds, maxAds) = totalAds = %v\n", totalAds)
+
+	if totalAds < cfg.requested.minAds {
+		totalAds = cfg.requested.minAds
+		util.Logf("Computed totalAds < requested  minAds (%v). Hence, setting totalAds =  minAds = %v\n", cfg.requested.minAds, totalAds)
+	}
+	if totalAds > cfg.requested.maxAds {
+		totalAds = cfg.requested.maxAds
+		util.Logf("Computed totalAds > requested  maxAds (%v). Hence, setting totalAds =  maxAds = %v\n", cfg.requested.maxAds, totalAds)
+	}
+	util.Logf("Computed Final totalAds = %v  [%v <= %v <= %v]\n", totalAds, cfg.requested.minAds, totalAds, cfg.requested.maxAds)
+	return totalAds
+}
+
+// Returns duration in seconds that can be allocated to each Ad Slot
+// Accepts cfg containing algorithm configurations and totalAds containing Total number of
+// Ad Slots / Impressions that the Ad Pod can have.
+func computeTimeForEachAdSlot(cfg generator, totalAds int64) int64 {
+	// Compute time for each ad
+	if totalAds <= 0 {
+		util.Logf("totalAds = 0, Hence timeForEachSlot = 0")
+		return 0
+	}
+	timeForEachSlot := cfg.requested.podMaxDuration / totalAds
+
+	util.Logf("Computed timeForEachSlot = %v (podMaxDuration/totalAds) (%v/%v)\n", timeForEachSlot, cfg.requested.podMaxDuration, totalAds)
+
+	if timeForEachSlot < cfg.internal.slotMinDuration {
+		timeForEachSlot = cfg.internal.slotMinDuration
+		util.Logf("Computed timeForEachSlot < requested  slotMinDuration (%v). Hence, setting timeForEachSlot =  slotMinDuration = %v\n", cfg.internal.slotMinDuration, timeForEachSlot)
+	}
+
+	if timeForEachSlot > cfg.internal.slotMaxDuration {
+		timeForEachSlot = cfg.internal.slotMaxDuration
+		util.Logf("Computed timeForEachSlot > requested  slotMaxDuration (%v). Hence, setting timeForEachSlot =  slotMaxDuration = %v\n", cfg.internal.slotMaxDuration, timeForEachSlot)
+	}
+
+	// Case - Exact slot duration is given. No scope for finding multiples
+	// of given number. Prefer to return computed timeForEachSlot
+	// In such case timeForEachSlot no necessarily to be multiples of given number
+	if cfg.requested.slotMinDuration == cfg.requested.slotMaxDuration {
+		util.Logf("requested.slotMinDuration = requested.slotMaxDuration = %v. Hence, not computing multiples of %v value.", cfg.requested.slotMaxDuration, multipleOf)
+		return timeForEachSlot
+	}
+
+	// Case II - timeForEachSlot*totalAds > podmaxduration
+	// In such case prefer to return cfg.podMaxDuration / totalAds
+	// In such case timeForEachSlot no necessarily to be multiples of given number
+	if (timeForEachSlot * totalAds) > cfg.requested.podMaxDuration {
+		util.Logf("timeForEachSlot*totalAds (%v) > cfg.requested.podMaxDuration (%v) ", timeForEachSlot*totalAds, cfg.requested.podMaxDuration)
+		util.Logf("Hence, not computing multiples of %v value.", multipleOf)
+		// need that division again
+		return cfg.requested.podMaxDuration / totalAds
+	}
+
+	// ensure timeForEachSlot is multipleof given number
+	if cfg.internal.slotDurationComputed && !isMultipleOf(timeForEachSlot, multipleOf) {
+		// get close to value of multiple
+		// here we muse get either cfg.SlotMinDuration or cfg.SlotMaxDuration
+		// these values are already pre-computed in multiples of given number
+		timeForEachSlot = getClosestFactor(timeForEachSlot, multipleOf)
+		util.Logf("Computed closet factor %v, in multiples of %v for timeForEachSlot\n", timeForEachSlot, multipleOf)
+	}
+	util.Logf("Computed Final timeForEachSlot = %v  [%v <= %v <= %v]\n", timeForEachSlot, cfg.requested.slotMinDuration, timeForEachSlot, cfg.requested.slotMaxDuration)
+	return timeForEachSlot
+}
+
+// Checks if multipleOf can be used as least time value
+// this will ensure eack slot to maximize its time if possible
+// if multipleOf can not be used as least value then default input value is returned as is
+// accepts time containing, which least value to be computed.
+// leastTimeRequiredByEachSlot - indicates the mimimum time that any slot can accept (UOE-5268)
+// Returns the least value based on multiple of X
+func computeTimeLeastValue(time int64, leastTimeRequiredByEachSlot int64) int64 {
+	// time if Testcase#6
+	// 1. multiple of x - get smallest factor N of multiple of x for time
+	// 2. not multiple of x - try to obtain smallet no N multipe of x
+	// ensure N <= timeForEachSlot
+	leastFactor := multipleOf
+	if leastFactor < time {
+		time = leastFactor
+	}
+
+	// case:  check if slots are looking for time < leastFactor
+	// UOE-5268
+	if leastTimeRequiredByEachSlot > 0 && leastTimeRequiredByEachSlot < time {
+		time = leastTimeRequiredByEachSlot
+	}
+
+	return time
+}
+
+// Validate the algorithm computations
+//  1. Verifies if 2D slice containing Min duration and Max duration values are non-zero
+//  2. Idenfies the Ad Slots / Impressions with either Min Duration or Max Duration or both
+//     having zero value and removes it from 2D slice
+//  3. Ensures  Minimum Pod duration <= TotalSlotTime <= Maximum Pod Duration
+//
+// if  any validation fails it removes all the alloated slots and  makes is of size 0
+// and sets the freeTime value as RequestedPodMaxDuration
+func (config *generator) validateSlots() {
+
+	// default return value if validation fails
+	emptySlots := make([][2]int64, 0)
+	if len(config.Slots) == 0 {
+		return
+	}
+
+	returnEmptySlots := false
+
+	// check slot with 0 values
+	// remove them from config.Slots
+	emptySlotCount := 0
+	for index, slot := range config.Slots {
+		if slot[0] == 0 || slot[1] == 0 {
+			util.Logf("WARNING:Slot[%v][%v] is having 0 duration\n", index, slot)
+			emptySlotCount++
+			continue
+		}
+
+		// check slot boundaries
+		if slot[1] < config.requested.slotMinDuration || slot[1] > config.requested.slotMaxDuration {
+			util.Logf("ERROR: Slot%v Duration %v sec is out of either requested.slotMinDuration (%v) or requested.slotMaxDuration (%v)\n", index, slot[1], config.requested.slotMinDuration, config.requested.slotMaxDuration)
+			returnEmptySlots = true
+			break
+		}
+	}
+
+	// remove empty slot
+	if emptySlotCount > 0 {
+		optimizedSlots := make([][2]int64, len(config.Slots)-emptySlotCount)
+		for index, slot := range config.Slots {
+			if slot[0] == 0 || slot[1] == 0 {
+			} else {
+				optimizedSlots[index][0] = slot[0]
+				optimizedSlots[index][1] = slot[1]
+			}
+		}
+		config.Slots = optimizedSlots
+		util.Logf("Removed %v empty slots\n", emptySlotCount)
+	}
+
+	if int64(len(config.Slots)) < config.requested.minAds || int64(len(config.Slots)) > config.requested.maxAds {
+		util.Logf("ERROR: slotSize %v is either less than Min Ads (%v) or greater than Max Ads (%v)\n", len(config.Slots), config.requested.minAds, config.requested.maxAds)
+		returnEmptySlots = true
+	}
+
+	// ensure if min pod duration = max pod duration
+	// config.TotalSlotTime = pod duration
+	if config.requested.podMinDuration == config.requested.podMaxDuration && *config.totalSlotTime != config.requested.podMaxDuration {
+		util.Logf("ERROR: Total Slot Duration %v sec is not matching with Total Pod Duration %v sec\n", *config.totalSlotTime, config.requested.podMaxDuration)
+		returnEmptySlots = true
+	}
+
+	// ensure slot duration lies between requested min pod duration and  requested max pod duration
+	// Testcase #15
+	if *config.totalSlotTime < config.requested.podMinDuration || *config.totalSlotTime > config.requested.podMaxDuration {
+		util.Logf("ERROR: Total Slot Duration %v sec is either less than Requested Pod Min Duration (%v sec) or greater than Requested  Pod Max Duration (%v sec)\n", *config.totalSlotTime, config.requested.podMinDuration, config.requested.podMaxDuration)
+		returnEmptySlots = true
+	}
+
+	if returnEmptySlots {
+		config.Slots = emptySlots
+		config.freeTime = config.requested.podMaxDuration
+	}
+}
+
+// Adds time to possible slots and returns total added time
+//
+// Checks following for each Ad Slot
+//  1. Can Ad Slot adjust the input time
+//  2. If addition of new time to any slot not exeeding Total Pod Max Duration
+//
+// Performs the following operations
+//  1. Populates Minimum duration slot[][0] - Either Slot Minimum Duration or Actual Slot Time computed
+//  2. Populates Maximum duration slot[][1] - Always actual Slot Time computed
+//  3. Counts the number of Ad Slots / Impressons full with  duration  capacity. If all Ad Slots / Impressions
+//     are full of capacity it returns true as second return argument, indicating all slots are full with capacity
+//  4. Keeps track of TotalSlotDuration when each new time is added to the Ad Slot
+//  5. Keeps track of difference between computed PodMaxDuration and RequestedPodMaxDuration (TestCase #16) and used in step #2 above
+//
+// Returns argument 1 indicating total time adusted, argument 2 whether all slots are full of duration capacity
+func (config generator) addTime(timeForEachSlot int64, fillZeroSlotsOnPriority bool) (int64, bool) {
+	time := int64(0)
+
+	// iterate over each ad
+	slotCountFullWithCapacity := 0
+	for ad := int64(0); ad < int64(len(config.Slots)); ad++ {
+
+		slot := &config.Slots[ad]
+		// check
+		// 1. time(slot(0)) <= config.SlotMaxDuration
+		// 2. if adding new time  to slot0 not exeeding config.SlotMaxDuration
+		// 3. if sum(slot time) +  timeForEachSlot  <= config.RequestedPodMaxDuration
+		canAdjustTime := (slot[1]+timeForEachSlot) <= config.requested.slotMaxDuration && (slot[1]+timeForEachSlot) >= config.requested.slotMinDuration
+		totalSlotTimeWithNewTimeLessThanRequestedPodMaxDuration := *config.totalSlotTime+timeForEachSlot <= config.requested.podMaxDuration
+
+		// if fillZeroSlotsOnPriority= true ensure current slot value =  0
+		allowCurrentSlot := !fillZeroSlotsOnPriority || (fillZeroSlotsOnPriority && slot[1] == 0)
+		if slot[1] <= config.internal.slotMaxDuration && canAdjustTime && totalSlotTimeWithNewTimeLessThanRequestedPodMaxDuration && allowCurrentSlot {
+			slot[0] += timeForEachSlot
+
+			// if we are adjusting the free time which will match up with config.RequestedPodMaxDuration
+			// then set config.SlotMinDuration as min value for this slot
+			// TestCase #16
+			//if timeForEachSlot == maxPodDurationMatchUpTime {
+			if timeForEachSlot < multipleOf {
+				// override existing value of slot[0] here
+				slot[0] = config.requested.slotMinDuration
+			}
+
+			// check if this slot duration was zero
+			if slot[1] == 0 {
+				// decrememt config.slotsWithZeroTime as we added some time for this slot
+				*config.slotsWithZeroTime--
+			}
+
+			slot[1] += timeForEachSlot
+			*config.totalSlotTime += timeForEachSlot
+			time += timeForEachSlot
+			util.Logf("Slot %v = Added %v sec (New Time = %v)\n", ad, timeForEachSlot, slot[1])
+		}
+		// check slot capabity
+		// !canAdjustTime - TestCase18
+		// UOE-5268 - Check with Requested Slot Max Duration
+		if slot[1] == config.requested.slotMaxDuration || !canAdjustTime {
+			// slot is full
+			slotCountFullWithCapacity++
+		}
+	}
+	util.Logf("adjustedTime = %v\n ", time)
+	return time, slotCountFullWithCapacity == len(config.Slots)
+}
+
+// shouldAdjustSlotWithZeroDuration - returns if slot with zero durations should be filled
+// Currently it will return true in following condition
+// cfg.minAds = cfg.maxads (i.e. Exact number of ads are required)
+func (config generator) shouldAdjustSlotWithZeroDuration() bool {
+	if config.requested.minAds == config.requested.maxAds {
+		return true
+	}
+	return false
+}
diff --git a/endpoints/openrtb2/ctv/impressions/impressions.go b/endpoints/openrtb2/ctv/impressions/impressions.go
new file mode 100644
index 000000000..5260968dc
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/impressions.go
@@ -0,0 +1,116 @@
+// Package impressions provides various algorithms to get the number of impressions
+// along with minimum and maximum duration of each impression.
+// It uses Ad pod request for it
+package impressions
+
+import (
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/util"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// Algorithm indicates type of algorithms supported
+// Currently it supports
+//  1. MaximizeForDuration
+//  2. MinMaxAlgorithm
+type Algorithm int
+
+const (
+	// MaximizeForDuration algorithm tends towards Ad Pod Maximum Duration, Ad Slot Maximum Duration
+	// and Maximum number of Ads. Accordingly it computes the number of impressions
+	MaximizeForDuration Algorithm = iota
+	// MinMaxAlgorithm algorithm ensures all possible impression breaks are plotted by considering
+	// minimum as well as maxmimum durations and ads received in the ad pod request.
+	// It computes number of impressions with following steps
+	//  1. Passes input configuration as it is (Equivalent of MaximizeForDuration algorithm)
+	//	2. Ad Pod Duration = Ad Pod Max Duration, Number of Ads = max ads
+	//	3. Ad Pod Duration = Ad Pod Max Duration, Number of Ads = min ads
+	//	4. Ad Pod Duration = Ad Pod Min Duration, Number of Ads = max ads
+	//	5. Ad Pod Duration = Ad Pod Min Duration, Number of Ads = min ads
+	MinMaxAlgorithm
+	// ByDurationRanges algorithm plots the impression objects based on expected video duration
+	// ranges reveived in the input prebid-request. Based on duration matching policy
+	// it will generate the impression objects. in case 'exact' duration matching impression
+	// min duration = max duration. In case 'round up' this algorithm will not be executed.Instead
+	ByDurationRanges
+)
+
+// MonitorKey provides the unique key for moniroting the impressions algorithm
+var MonitorKey = map[Algorithm]string{
+	MaximizeForDuration: `a1_max`,
+	MinMaxAlgorithm:     `a2_min_max`,
+	ByDurationRanges:    `a3_duration`,
+}
+
+// Value use to compute Ad Slot Durations and Pod Durations for internal computation
+// Right now this value is set to 5, based on passed data observations
+// Observed that typically video impression contains contains minimum and maximum duration in multiples of  5
+var multipleOf = int64(5)
+
+// IImpressions ...
+type IImpressions interface {
+	Get() [][2]int64
+	Algorithm() Algorithm // returns algorithm used for computing number of impressions
+}
+
+// NewImpressions generate object of impression generator
+// based on input algorithm type
+// if invalid algorithm type is passed, it returns default algorithm which will compute
+// impressions based on minimum ad slot duration
+func NewImpressions(podMinDuration, podMaxDuration int64, reqAdPod *openrtb_ext.ExtRequestAdPod, vPod *openrtb_ext.VideoAdPod, algorithm Algorithm) IImpressions {
+	switch algorithm {
+	case MaximizeForDuration:
+		util.Logf("Selected ImpGen Algorithm - 'MaximizeForDuration'")
+		g := newMaximizeForDuration(podMinDuration, podMaxDuration, *vPod)
+		return &g
+
+	case MinMaxAlgorithm:
+		util.Logf("Selected ImpGen Algorithm - 'MinMaxAlgorithm'")
+		g := newMinMaxAlgorithm(podMinDuration, podMaxDuration, *vPod)
+		return &g
+
+	case ByDurationRanges:
+		util.Logf("Selected ImpGen Algorithm - 'ByDurationRanges'")
+
+		g := newByDurationRanges(reqAdPod.VideoAdDurationMatching, reqAdPod.VideoAdDuration,
+			int(*vPod.MaxAds),
+			*vPod.MinDuration, *vPod.MaxDuration)
+
+		return &g
+	}
+
+	// return default algorithm with slot durations set to minimum slot duration
+	util.Logf("Selected 'DefaultAlgorithm'")
+	defaultGenerator := newConfig(podMinDuration, podMinDuration, openrtb_ext.VideoAdPod{
+		MinAds:      vPod.MinAds,
+		MaxAds:      vPod.MaxAds,
+		MinDuration: vPod.MinDuration,
+		MaxDuration: vPod.MinDuration, // sending slot minduration as max duration
+	})
+	return &defaultGenerator
+}
+
+// SelectAlgorithm is factory function which will return valid Algorithm based on adpod parameters
+// Return Value:
+//   - MinMaxAlgorithm (default)
+//   - ByDurationRanges: if reqAdPod extension has VideoAdDuration and VideoAdDurationMatchingPolicy is "exact" algorithm
+func SelectAlgorithm(reqAdPod *openrtb_ext.ExtRequestAdPod) Algorithm {
+	if nil != reqAdPod {
+		if len(reqAdPod.VideoAdDuration) > 0 &&
+			(openrtb_ext.OWExactVideoAdDurationMatching == reqAdPod.VideoAdDurationMatching || openrtb_ext.OWRoundupVideoAdDurationMatching == reqAdPod.VideoAdDurationMatching) {
+			return ByDurationRanges
+		}
+	}
+	return MinMaxAlgorithm
+}
+
+// Duration indicates the position
+// where the required min or max duration value can be found
+// within given impression object
+type Duration int
+
+const (
+	// MinDuration represents index value where we can get minimum duration of given impression object
+	MinDuration Duration = iota
+	// MaxDuration represents index value where we can get maximum duration of given impression object
+	MaxDuration
+)
diff --git a/endpoints/openrtb2/ctv/impressions/impressions_test.go b/endpoints/openrtb2/ctv/impressions/impressions_test.go
new file mode 100644
index 000000000..32dc04326
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/impressions_test.go
@@ -0,0 +1,147 @@
+// Package impressions provides various algorithms to get the number of impressions
+// along with minimum and maximum duration of each impression.
+// It uses Ad pod request for it
+package impressions
+
+import (
+	"testing"
+
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestSelectAlgorithm(t *testing.T) {
+	type args struct {
+		reqAdPod *openrtb_ext.ExtRequestAdPod
+	}
+	tests := []struct {
+		name string
+		args args
+		want Algorithm
+	}{
+		{
+			name: "default",
+			args: args{},
+			want: MinMaxAlgorithm,
+		},
+		{
+			name: "missing_videoAdDuration",
+			args: args{reqAdPod: &openrtb_ext.ExtRequestAdPod{}},
+			want: MinMaxAlgorithm,
+		},
+		{
+			name: "roundup_matching_algo",
+			args: args{reqAdPod: &openrtb_ext.ExtRequestAdPod{
+				VideoAdDuration:         []int{15, 20},
+				VideoAdDurationMatching: openrtb_ext.OWRoundupVideoAdDurationMatching,
+			}},
+			want: ByDurationRanges,
+		},
+		{
+			name: "exact_matching_algo",
+			args: args{reqAdPod: &openrtb_ext.ExtRequestAdPod{
+				VideoAdDuration:         []int{15, 20},
+				VideoAdDurationMatching: openrtb_ext.OWExactVideoAdDurationMatching,
+			}},
+			want: ByDurationRanges,
+		},
+		// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got := SelectAlgorithm(tt.args.reqAdPod)
+			assert.Equal(t, tt.want, got)
+		})
+	}
+}
+
+func TestNewImpressions(t *testing.T) {
+	intPtr := func(v int) *int { return &v }
+
+	type args struct {
+		podMinDuration int64
+		podMaxDuration int64
+		reqAdPod       *openrtb_ext.ExtRequestAdPod
+		vPod           *openrtb_ext.VideoAdPod
+		algorithm      Algorithm
+	}
+	tests := []struct {
+		name string
+		args args
+		want Algorithm
+	}{
+		{
+			name: "Default-MaximizeForDuration",
+			args: args{
+				podMinDuration: 15,
+				podMaxDuration: 90,
+				reqAdPod:       &openrtb_ext.ExtRequestAdPod{},
+				vPod: &openrtb_ext.VideoAdPod{
+					MinAds:      intPtr(1),
+					MaxAds:      intPtr(2),
+					MinDuration: intPtr(5),
+					MaxDuration: intPtr(10),
+				},
+				algorithm: Algorithm(-1),
+			},
+			want: MaximizeForDuration,
+		},
+		{
+			name: "MaximizeForDuration",
+			args: args{
+				podMinDuration: 15,
+				podMaxDuration: 90,
+				reqAdPod:       &openrtb_ext.ExtRequestAdPod{},
+				vPod: &openrtb_ext.VideoAdPod{
+					MinAds:      intPtr(1),
+					MaxAds:      intPtr(2),
+					MinDuration: intPtr(5),
+					MaxDuration: intPtr(10),
+				},
+				algorithm: MaximizeForDuration,
+			},
+			want: MaximizeForDuration,
+		},
+		{
+			name: "MinMaxAlgorithm",
+			args: args{
+				podMinDuration: 15,
+				podMaxDuration: 90,
+				reqAdPod:       &openrtb_ext.ExtRequestAdPod{},
+				vPod: &openrtb_ext.VideoAdPod{
+					MinAds:      intPtr(1),
+					MaxAds:      intPtr(2),
+					MinDuration: intPtr(5),
+					MaxDuration: intPtr(10),
+				},
+				algorithm: MinMaxAlgorithm,
+			},
+			want: MinMaxAlgorithm,
+		},
+		{
+			name: "ByDurationRanges",
+			args: args{
+				podMinDuration: 15,
+				podMaxDuration: 90,
+				reqAdPod: &openrtb_ext.ExtRequestAdPod{
+					VideoAdDuration: []int{10, 15},
+				},
+				vPod: &openrtb_ext.VideoAdPod{
+					MinAds:      intPtr(1),
+					MaxAds:      intPtr(2),
+					MinDuration: intPtr(5),
+					MaxDuration: intPtr(10),
+				},
+				algorithm: ByDurationRanges,
+			},
+			want: ByDurationRanges,
+		},
+		// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got := NewImpressions(tt.args.podMinDuration, tt.args.podMaxDuration, tt.args.reqAdPod, tt.args.vPod, tt.args.algorithm)
+			assert.Equal(t, tt.want, got.Algorithm())
+		})
+	}
+}
diff --git a/endpoints/openrtb2/ctv/impressions/maximize_for_duration.go b/endpoints/openrtb2/ctv/impressions/maximize_for_duration.go
new file mode 100644
index 000000000..b51116744
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/maximize_for_duration.go
@@ -0,0 +1,25 @@
+package impressions
+
+import (
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/util"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// newMaximizeForDuration Constucts the generator object from openrtb_ext.VideoAdPod
+// It computes durations for Ad Slot and Ad Pod in multiple of X
+func newMaximizeForDuration(podMinDuration, podMaxDuration int64, vPod openrtb_ext.VideoAdPod) generator {
+	config := newConfigWithMultipleOf(podMinDuration, podMaxDuration, vPod, multipleOf)
+
+	util.Logf("Computed podMinDuration = %v in multiples of %v (requestedPodMinDuration = %v)\n", config.requested.podMinDuration, multipleOf, config.requested.podMinDuration)
+	util.Logf("Computed podMaxDuration = %v in multiples of %v (requestedPodMaxDuration = %v)\n", config.requested.podMaxDuration, multipleOf, config.requested.podMaxDuration)
+	util.Logf("Computed slotMinDuration = %v in multiples of %v (requestedSlotMinDuration = %v)\n", config.internal.slotMinDuration, multipleOf, config.requested.slotMinDuration)
+	util.Logf("Computed slotMaxDuration = %v in multiples of %v (requestedSlotMaxDuration = %v)\n", config.internal.slotMaxDuration, multipleOf, *vPod.MaxDuration)
+	util.Logf("Requested minAds = %v\n", config.requested.minAds)
+	util.Logf("Requested maxAds = %v\n", config.requested.maxAds)
+	return config
+}
+
+// Algorithm returns MaximizeForDuration
+func (config generator) Algorithm() Algorithm {
+	return MaximizeForDuration
+}
diff --git a/endpoints/openrtb2/ctv/impressions/maximize_for_duration_test.go b/endpoints/openrtb2/ctv/impressions/maximize_for_duration_test.go
new file mode 100644
index 000000000..c252573cf
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/maximize_for_duration_test.go
@@ -0,0 +1,465 @@
+package impressions
+
+import (
+	"testing"
+
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/impressions/testdata"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+)
+
+type TestAdPod struct {
+	vPod           openrtb_ext.VideoAdPod
+	podMinDuration int64
+	podMaxDuration int64
+}
+
+type expected struct {
+	impressionCount int
+	// Time remaining after ad breaking is done
+	// if no ad breaking i.e. 0 then freeTime = pod.maxduration
+	freeTime        int64
+	adSlotTimeInSec []int64
+
+	// close bounds
+	closedMinDuration     int64 // pod
+	closedMaxDuration     int64 // pod
+	closedSlotMinDuration int64 // ad slot
+	closedSlotMaxDuration int64 // ad slot
+}
+
+var impressionsTests = []struct {
+	scenario string   // Testcase scenario
+	out      expected // Testcase execpted output
+}{
+	{scenario: "TC2", out: expected{
+		impressionCount:       6,
+		freeTime:              0.0,
+		closedMinDuration:     5,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 15,
+		closedSlotMaxDuration: 15,
+	}},
+	{scenario: "TC3", out: expected{
+		impressionCount: 4,
+		freeTime:        30.0, closedMinDuration: 5,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 15,
+		closedSlotMaxDuration: 15,
+	}},
+	{scenario: "TC4", out: expected{
+		impressionCount: 1,
+		freeTime:        0.0, closedMinDuration: 5,
+		closedMaxDuration:     15,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 15,
+	}},
+	{scenario: "TC5", out: expected{
+		impressionCount: 2,
+		freeTime:        0.0, closedMinDuration: 5,
+		closedMaxDuration:     15,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 15,
+	}},
+	{scenario: "TC6", out: expected{
+		impressionCount: 8,
+		freeTime:        0.0, closedMinDuration: 5,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 15,
+	}},
+	{scenario: "TC7", out: expected{
+		impressionCount: 1,
+		freeTime:        15.0, closedMinDuration: 15,
+		closedMaxDuration:     30,
+		closedSlotMinDuration: 10,
+		closedSlotMaxDuration: 15,
+	}},
+	{scenario: "TC8", out: expected{
+		impressionCount: 3,
+		freeTime:        0.0, closedMinDuration: 35,
+		closedMaxDuration:     35,
+		closedSlotMinDuration: 10,
+		closedSlotMaxDuration: 35,
+	}},
+	{scenario: "TC9", out: expected{
+		impressionCount: 0,
+		freeTime:        35, closedMinDuration: 35,
+		closedMaxDuration:     35,
+		closedSlotMinDuration: 10,
+		closedSlotMaxDuration: 35,
+	}},
+	{scenario: "TC10", out: expected{
+		impressionCount: 6,
+		freeTime:        0.0, closedMinDuration: 35,
+		closedMaxDuration:     65,
+		closedSlotMinDuration: 10,
+		closedSlotMaxDuration: 35,
+	}},
+	{scenario: "TC11", out: expected{
+		impressionCount: 0, //7,
+		freeTime:        0, closedMinDuration: 35,
+		closedMaxDuration:     65,
+		closedSlotMinDuration: 10,
+		closedSlotMaxDuration: 35,
+	}},
+	{scenario: "TC12", out: expected{
+		impressionCount: 10,
+		freeTime:        0.0, closedMinDuration: 100,
+		closedMaxDuration:     100,
+		closedSlotMinDuration: 10,
+		closedSlotMaxDuration: 35,
+	}},
+	{scenario: "TC13", out: expected{
+		impressionCount: 0,
+		freeTime:        60, closedMinDuration: 60,
+		closedMaxDuration:     60,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 5,
+	}},
+	{scenario: "TC14", out: expected{
+		impressionCount: 6,
+		freeTime:        6, closedMinDuration: 30,
+		closedMaxDuration:     60,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 5,
+	}},
+	{scenario: "TC15", out: expected{
+		impressionCount: 5,
+		freeTime:        15, closedMinDuration: 30,
+		closedMaxDuration:     60,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 5,
+	}},
+	{scenario: "TC16", out: expected{
+		impressionCount: 13,
+		freeTime:        0, closedMinDuration: 126,
+		closedMaxDuration:     126,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 10,
+	}},
+	{scenario: "TC17", out: expected{
+		impressionCount: 13,
+		freeTime:        0, closedMinDuration: 130,
+		closedMaxDuration:     125,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 10,
+	}},
+	{scenario: "TC18", out: expected{
+		impressionCount: 0,
+		freeTime:        125, closedMinDuration: 125,
+		closedMaxDuration:     125,
+		closedSlotMinDuration: 4,
+		closedSlotMaxDuration: 4,
+	}},
+	{scenario: "TC19", out: expected{
+		impressionCount: 0,
+		freeTime:        90, closedMinDuration: 90,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 7, // overlapping case. Hence as is
+		closedSlotMaxDuration: 9,
+	}},
+	{scenario: "TC20", out: expected{
+		impressionCount: 9,
+		freeTime:        0, closedMinDuration: 90,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 10,
+	}},
+	{scenario: "TC21", out: expected{
+		impressionCount: 9,
+		freeTime:        89, closedMinDuration: 5,
+		closedMaxDuration:     170,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 5,
+	}},
+	{scenario: "TC23", out: expected{
+		impressionCount: 12,
+		freeTime:        0, closedMinDuration: 120,
+		closedMaxDuration:     120,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 15,
+	}},
+	{scenario: "TC24", out: expected{
+		impressionCount: 2,
+		freeTime:        0, closedMinDuration: 134,
+		closedMaxDuration:     134,
+		closedSlotMinDuration: 60,
+		closedSlotMaxDuration: 90,
+	}},
+	{scenario: "TC25", out: expected{
+		impressionCount: 2,
+		freeTime:        0,
+
+		closedMinDuration:     88,
+		closedMaxDuration:     88,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 80,
+	}},
+	{scenario: "TC26", out: expected{
+		impressionCount: 2,
+		freeTime:        0,
+
+		closedMinDuration:     90,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 45,
+		closedSlotMaxDuration: 45,
+	}},
+	{scenario: "TC27", out: expected{
+		impressionCount: 3,
+		freeTime:        0,
+
+		closedMinDuration:     5,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 45,
+	}},
+	{scenario: "TC28", out: expected{
+		impressionCount: 6,
+		freeTime:        0,
+
+		closedMinDuration:     5,
+		closedMaxDuration:     180,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 90,
+	}},
+	{scenario: "TC29", out: expected{
+		impressionCount: 3,
+		freeTime:        0, closedMinDuration: 5,
+		closedMaxDuration:     65,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 35,
+	}},
+	{scenario: "TC30", out: expected{
+		impressionCount: 3,
+		freeTime:        123, closedMinDuration: 123,
+		closedMaxDuration:     123,
+		closedSlotMinDuration: 34,
+		closedSlotMaxDuration: 34,
+	}},
+	{scenario: "TC31", out: expected{
+		impressionCount: 3,
+		freeTime:        123, closedMinDuration: 123,
+		closedMaxDuration:     123,
+		closedSlotMinDuration: 31,
+		closedSlotMaxDuration: 31,
+	}}, {scenario: "TC32", out: expected{
+		impressionCount: 0,
+		freeTime:        134, closedMinDuration: 134,
+		closedMaxDuration:     134,
+		closedSlotMinDuration: 63,
+		closedSlotMaxDuration: 63,
+	}},
+	{scenario: "TC33", out: expected{
+		impressionCount: 4,
+		freeTime:        0, closedMinDuration: 147,
+		closedMaxDuration:     147,
+		closedSlotMinDuration: 30,
+		closedSlotMaxDuration: 60,
+	}},
+	{scenario: "TC34", out: expected{
+		impressionCount: 3,
+		freeTime:        12, closedMinDuration: 90,
+		closedMaxDuration:     100,
+		closedSlotMinDuration: 30,
+		closedSlotMaxDuration: 30,
+	}}, {scenario: "TC35", out: expected{
+		impressionCount: 0,
+		freeTime:        102, closedMinDuration: 90,
+		closedMaxDuration:     100,
+		closedSlotMinDuration: 30,
+		closedSlotMaxDuration: 40,
+	}}, {scenario: "TC36", out: expected{
+		impressionCount: 2,
+		freeTime:        0, closedMinDuration: 90,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 45,
+		closedSlotMaxDuration: 45,
+	}}, {scenario: "TC37", out: expected{
+		impressionCount: 2,
+		freeTime:        0, closedMinDuration: 10,
+		closedMaxDuration:     45,
+		closedSlotMinDuration: 20,
+		closedSlotMaxDuration: 45,
+	}}, {scenario: "TC38", out: expected{
+		impressionCount: 0,
+		freeTime:        0, closedMinDuration: 90,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 20,
+		closedSlotMaxDuration: 45,
+	}}, {scenario: "TC39", out: expected{
+		impressionCount: 4,
+		freeTime:        0, closedMinDuration: 60,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 20,
+		closedSlotMaxDuration: 45,
+	}}, {scenario: "TC40", out: expected{
+		impressionCount: 10,
+		freeTime:        0, closedMinDuration: 95,
+		closedMaxDuration:     95,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 45,
+	}}, {scenario: "TC41", out: expected{
+		impressionCount: 0,
+		freeTime:        123, closedMinDuration: 95,
+		closedMaxDuration:     120,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 45,
+	}}, {scenario: "TC42", out: expected{
+		impressionCount: 1,
+		freeTime:        0, closedMinDuration: 1,
+		closedMaxDuration:     1,
+		closedSlotMinDuration: 1,
+		closedSlotMaxDuration: 1,
+	}}, {scenario: "TC43", out: expected{
+		impressionCount: 0,
+		freeTime:        2, closedMinDuration: 2,
+		closedMaxDuration:     2,
+		closedSlotMinDuration: 2,
+		closedSlotMaxDuration: 2,
+	}}, {scenario: "TC44", out: expected{
+		impressionCount: 0,
+		freeTime:        0, closedMinDuration: 0,
+		closedMaxDuration:     0,
+		closedSlotMinDuration: 0,
+		closedSlotMaxDuration: 0,
+	}}, {scenario: "TC45", out: expected{
+		impressionCount: 0,
+		freeTime:        0, closedMinDuration: 5,
+		closedMaxDuration:     -5,
+		closedSlotMinDuration: -3, // overlapping hence will as is
+		closedSlotMaxDuration: -4,
+	}}, {scenario: "TC46", out: expected{
+		impressionCount: 0,
+		freeTime:        0, closedMinDuration: -1,
+		closedMaxDuration:     -1,
+		closedSlotMinDuration: -1,
+		closedSlotMaxDuration: -1,
+	}}, {scenario: "TC47", out: expected{
+		impressionCount: 1,
+		freeTime:        0, closedMinDuration: 6,
+		closedMaxDuration:     6,
+		closedSlotMinDuration: 6,
+		closedSlotMaxDuration: 6,
+	}}, {scenario: "TC48", out: expected{
+		impressionCount: 2,
+		freeTime:        0, closedMinDuration: 12,
+		closedMaxDuration:     12,
+		closedSlotMinDuration: 6,
+		closedSlotMaxDuration: 6,
+	}}, {scenario: "TC49", out: expected{
+		impressionCount: 0,
+		freeTime:        12, closedMinDuration: 12,
+		closedMaxDuration:     12,
+		closedSlotMinDuration: 7,
+		closedSlotMaxDuration: 7,
+	}}, {scenario: "TC50", out: expected{
+		impressionCount: 0,
+		freeTime:        0, closedMinDuration: 1,
+		closedMaxDuration:     1,
+		closedSlotMinDuration: 1,
+		closedSlotMaxDuration: 1,
+	}}, {scenario: "TC51", out: expected{
+		impressionCount: 3,
+		freeTime:        4, closedMinDuration: 35,
+		closedMaxDuration:     40,
+		closedSlotMinDuration: 11,
+		closedSlotMaxDuration: 13,
+	}},
+	{scenario: "TC52", out: expected{
+		impressionCount: 3,
+		freeTime:        0, closedMinDuration: 70,
+		closedMaxDuration:     70,
+		closedSlotMinDuration: 15,
+		closedSlotMaxDuration: 15,
+	}}, {scenario: "TC53", out: expected{
+		impressionCount: 3,
+		freeTime:        0, closedMinDuration: 126,
+		closedMaxDuration:     126,
+		closedSlotMinDuration: 5,
+		closedSlotMaxDuration: 20,
+	}}, {scenario: "TC55", out: expected{
+		impressionCount: 6,
+		freeTime:        2, closedMinDuration: 1,
+		closedMaxDuration:     74,
+		closedSlotMinDuration: 12,
+		closedSlotMaxDuration: 12,
+	}}, {scenario: "TC56", out: expected{
+		impressionCount: 1,
+		freeTime:        0, closedMinDuration: 126,
+		closedMaxDuration:     126,
+		closedSlotMinDuration: 126,
+		closedSlotMaxDuration: 126,
+	}}, {scenario: "TC57", out: expected{
+		impressionCount: 1,
+		freeTime:        0, closedMinDuration: 126,
+		closedMaxDuration:     126,
+		closedSlotMinDuration: 126,
+		closedSlotMaxDuration: 126,
+	}}, {scenario: "TC58", out: expected{
+		impressionCount: 4,
+		freeTime:        0, closedMinDuration: 30,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 15,
+		closedSlotMaxDuration: 45,
+	}},
+	{scenario: "TC59", out: expected{
+		impressionCount: 1,
+		freeTime:        45, closedMinDuration: 30,
+		closedMaxDuration:     90,
+		closedSlotMinDuration: 15,
+		closedSlotMaxDuration: 45,
+	}},
+}
+
+func TestGetImpressionsA1(t *testing.T) {
+	for _, impTest := range impressionsTests {
+		t.Run(impTest.scenario, func(t *testing.T) {
+			in := testdata.Input[impTest.scenario]
+			p := newTestPod(int64(in[0]), int64(in[1]), in[2], in[3], in[4], in[5])
+
+			cfg := newMaximizeForDuration(p.podMinDuration, p.podMaxDuration, p.vPod)
+			imps := cfg.Get()
+			expected := impTest.out
+			expectedImpressionBreak := testdata.Scenario[impTest.scenario].MaximizeForDuration
+			// assert.Equal(t, expected.impressionCount, len(pod.Slots), "expected impression count = %v . But Found %v", expectedImpressionCount, len(pod.Slots))
+			assert.Equal(t, expected.freeTime, cfg.freeTime, "expected Free Time = %v . But Found %v", expected.freeTime, cfg.freeTime)
+			// assert.Equal(t, expected.closedMinDuration, cfg.requested.podMinDuration, "expected closedMinDuration= %v . But Found %v", expected.closedMinDuration, cfg.requested.podMinDuration)
+			// assert.Equal(t, expected.closedMaxDuration, cfg.requested.podMaxDuration, "expected closedMinDuration= %v . But Found %v", expected.closedMaxDuration, cfg.requested.podMaxDuration)
+			assert.Equal(t, expected.closedSlotMinDuration, cfg.internal.slotMinDuration, "expected closedSlotMinDuration= %v . But Found %v", expected.closedSlotMinDuration, cfg.internal.slotMinDuration)
+			assert.Equal(t, expected.closedSlotMaxDuration, cfg.internal.slotMaxDuration, "expected closedSlotMinDuration= %v . But Found %v", expected.closedSlotMaxDuration, cfg.internal.slotMaxDuration)
+			assert.Equal(t, expectedImpressionBreak, imps, "2darray mismatch")
+			assert.Equal(t, MaximizeForDuration, cfg.Algorithm())
+		})
+	}
+}
+
+/* Benchmarking Tests */
+func BenchmarkGetImpressions(b *testing.B) {
+	for _, impTest := range impressionsTests {
+		b.Run(impTest.scenario, func(b *testing.B) {
+			in := testdata.Input[impTest.scenario]
+			p := newTestPod(int64(in[0]), int64(in[1]), in[2], in[3], in[4], in[5])
+			for n := 0; n < b.N; n++ {
+				cfg := newMaximizeForDuration(p.podMinDuration, p.podMaxDuration, p.vPod)
+				cfg.Get()
+			}
+		})
+	}
+}
+
+func newTestPod(podMinDuration, podMaxDuration int64, slotMinDuration, slotMaxDuration, minAds, maxAds int) *TestAdPod {
+	testPod := TestAdPod{}
+
+	pod := openrtb_ext.VideoAdPod{}
+
+	pod.MinDuration = &slotMinDuration
+	pod.MaxDuration = &slotMaxDuration
+	pod.MinAds = &minAds
+	pod.MaxAds = &maxAds
+
+	testPod.vPod = pod
+	testPod.podMinDuration = podMinDuration
+	testPod.podMaxDuration = podMaxDuration
+	return &testPod
+}
diff --git a/endpoints/openrtb2/ctv/impressions/min_max_algorithm.go b/endpoints/openrtb2/ctv/impressions/min_max_algorithm.go
new file mode 100644
index 000000000..3cfd1bde2
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/min_max_algorithm.go
@@ -0,0 +1,191 @@
+package impressions
+
+import (
+	"fmt"
+	"math"
+	"strconv"
+	"strings"
+	"sync"
+
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/util"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// keyDelim used as separator in forming key of maxExpectedDurationMap
+var keyDelim = ","
+
+type config struct {
+	IImpressions
+	generator []generator
+	// maxExpectedDurationMap contains key = min , max duration, value = 0 -no of impressions, 1
+	// this map avoids the unwanted repeatations of impressions generated
+	//   Example,
+	//   Step 1 : {{2, 17}, {15, 15}, {15, 15}, {10, 10}, {10, 10}, {10, 10}}
+	//   Step 2 : {{2, 17}, {15, 15}, {15, 15}, {10, 10}, {10, 10}, {10, 10}}
+	//   Step 3 : {{25, 25}, {25, 25}, {2, 22}, {5, 5}}
+	//   Step 4 : {{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}}
+	//   Step 5 : {{15, 15}, {15, 15}, {15, 15}, {15, 15}}
+	//   Optimized Output : {{2, 17}, {15, 15},{15, 15},{15, 15},{15, 15},{10, 10},{10, 10},{10, 10},{10, 10},{10, 10},{10, 10},{25, 25}, {25, 25},{2, 22}, {5, 5}}
+	//   This map will contains : {2, 17} = 1, {15, 15} = 4, {10, 10} = 6, {25, 25} = 2, {2, 22} = 1, {5, 5} =1
+	maxExpectedDurationMap map[string][2]int
+	requested              pod
+}
+
+// newMinMaxAlgorithm constructs instance of MinMaxAlgorithm
+// It computes durations for Ad Slot and Ad Pod in multiple of X
+// it also considers minimum configurations present in the request
+func newMinMaxAlgorithm(podMinDuration, podMaxDuration int64, p openrtb_ext.VideoAdPod) config {
+	generator := make([]generator, 0)
+	// step 1 - same as Algorithm1
+	generator = append(generator, initGenerator(podMinDuration, podMaxDuration, p, *p.MinAds, *p.MaxAds))
+	// step 2 - pod duration = pod max, no of ads = max ads
+	generator = append(generator, initGenerator(podMaxDuration, podMaxDuration, p, *p.MaxAds, *p.MaxAds))
+	// step 3 - pod duration = pod max, no of ads = min ads
+	generator = append(generator, initGenerator(podMaxDuration, podMaxDuration, p, *p.MinAds, *p.MinAds))
+	// step 4 - pod duration = pod min, no of ads = max  ads
+	generator = append(generator, initGenerator(podMinDuration, podMinDuration, p, *p.MaxAds, *p.MaxAds))
+	// step 5 - pod duration = pod min, no of ads = min  ads
+	generator = append(generator, initGenerator(podMinDuration, podMinDuration, p, *p.MinAds, *p.MinAds))
+
+	return config{generator: generator, requested: generator[0].requested}
+}
+
+func initGenerator(podMinDuration, podMaxDuration int64, p openrtb_ext.VideoAdPod, minAds, maxAds int) generator {
+	config := newConfigWithMultipleOf(podMinDuration, podMaxDuration, newVideoAdPod(p, minAds, maxAds), multipleOf)
+	return config
+}
+
+func newVideoAdPod(p openrtb_ext.VideoAdPod, minAds, maxAds int) openrtb_ext.VideoAdPod {
+	return openrtb_ext.VideoAdPod{MinDuration: p.MinDuration,
+		MaxDuration: p.MaxDuration,
+		MinAds:      &minAds,
+		MaxAds:      &maxAds}
+}
+
+// Get ...
+func (c *config) Get() [][2]int64 {
+	imps := make([][2]int64, 0)
+	wg := new(sync.WaitGroup) // ensures each step generating impressions is finished
+	impsChan := make(chan [][2]int64, len(c.generator))
+	for i := 0; i < len(c.generator); i++ {
+		wg.Add(1)
+		go get(c.generator[i], impsChan, wg)
+	}
+
+	// ensure impressions channel is closed
+	// when all go routines are executed
+	func() {
+		defer close(impsChan)
+		wg.Wait()
+	}()
+
+	c.maxExpectedDurationMap = make(map[string][2]int, 0)
+	util.Logf("Step wise breakup ")
+	for impressions := range impsChan {
+		for index, impression := range impressions {
+			impKey := getKey(impression)
+			setMaximumRepeatations(c, impKey, index+1 == len(impressions))
+		}
+		util.Logf("%v", impressions)
+	}
+
+	// for impressions array
+	indexOffset := 0
+	for impKey := range c.maxExpectedDurationMap {
+		totalRepeations := c.getRepeations(impKey)
+		for repeation := 1; repeation <= totalRepeations; repeation++ {
+			imps = append(imps, getImpression(impKey))
+		}
+		// if exact pod duration is provided then do not compute
+		// min duration. Instead expect min duration same as max duration
+		// It must be set by underneath algorithm
+		if c.requested.podMinDuration != c.requested.podMaxDuration {
+			computeMinDuration(*c, imps[:], indexOffset, indexOffset+totalRepeations)
+		}
+		indexOffset += totalRepeations
+	}
+	return imps
+}
+
+// getImpression constructs the impression object with min and max duration
+// from input impression key
+func getImpression(key string) [2]int64 {
+	decodedKey := strings.Split(key, keyDelim)
+	minDuration, _ := strconv.Atoi(decodedKey[MinDuration])
+	maxDuration, _ := strconv.Atoi(decodedKey[MaxDuration])
+	return [2]int64{int64(minDuration), int64(maxDuration)}
+}
+
+// setMaximumRepeatations avoids unwanted repeatations of impression object. Using following logic
+// maxExpectedDurationMap value contains 2 types of storage
+//  1. value[0] - represents current counter where final repeataions are stored
+//  2. value[1] - local storage used by each impression object to add more repeatations if required
+//
+// impKey - key used to obtained already added repeatations for given impression
+// updateCurrentCounter - if true and if current local storage value  > repeatations then repeations will be
+// updated as current counter
+func setMaximumRepeatations(c *config, impKey string, updateCurrentCounter bool) {
+	// update maxCounter of each impression
+	value := c.maxExpectedDurationMap[impKey]
+	value[1]++ // increment max counter (contains no of repeatations for given iteration)
+	c.maxExpectedDurationMap[impKey] = value
+	// if val(maxCounter)  > actual store then consider temporary value as actual value
+	if updateCurrentCounter {
+		for k := range c.maxExpectedDurationMap {
+			val := c.maxExpectedDurationMap[k]
+			if val[1] > val[0] {
+				val[0] = val[1]
+			}
+			// clear maxCounter
+			val[1] = 0
+			c.maxExpectedDurationMap[k] = val // reassign
+		}
+	}
+
+}
+
+// getKey returns the key used for refering values of maxExpectedDurationMap
+// key is computed based on input impression object having min and max durations
+func getKey(impression [2]int64) string {
+	return fmt.Sprintf("%v%v%v", impression[MinDuration], keyDelim, impression[MaxDuration])
+}
+
+// getRepeations returns number of repeatations at that time that this algorithm will
+// return w.r.t. input impressionKey
+func (c config) getRepeations(impressionKey string) int {
+	return c.maxExpectedDurationMap[impressionKey][0]
+}
+
+// get is internal function that actually computes the number of impressions
+// based on configrations present in c
+func get(c generator, ch chan [][2]int64, wg *sync.WaitGroup) {
+	defer wg.Done()
+	imps := c.Get()
+	util.Logf("A2 Impressions = %v\n", imps)
+	ch <- imps
+}
+
+// Algorithm returns MinMaxAlgorithm
+func (c config) Algorithm() Algorithm {
+	return MinMaxAlgorithm
+}
+
+func computeMinDuration(c config, impressions [][2]int64, start int, end int) {
+	r := c.requested
+	// 5/2 => q = 2 , r = 1 =>  2.5 => 3
+	minDuration := int64(math.Round(float64(r.podMinDuration) / float64(r.minAds)))
+	for i := start; i < end; i++ {
+		impression := &impressions[i]
+		// ensure imp duration boundaries
+		// if boundaries are not honoured keep min duration which is computed as is
+		if minDuration >= r.slotMinDuration && minDuration <= impression[MaxDuration] {
+			// override previous value
+			impression[MinDuration] = minDuration
+		} else {
+			// boundaries are not matching keep min value as is
+			util.Logf("False : minDuration (%v) >= r.slotMinDuration (%v)  &&  minDuration (%v)  <= impression[MaxDuration] (%v)", minDuration, r.slotMinDuration, minDuration, impression[MaxDuration])
+			util.Logf("Hence, setting request level slot minduration (%v) ", r.slotMinDuration)
+			impression[MinDuration] = r.slotMinDuration
+		}
+	}
+}
diff --git a/endpoints/openrtb2/ctv/impressions/min_max_algorithm_test.go b/endpoints/openrtb2/ctv/impressions/min_max_algorithm_test.go
new file mode 100644
index 000000000..a1af10162
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/min_max_algorithm_test.go
@@ -0,0 +1,601 @@
+package impressions
+
+import (
+	"sort"
+	"testing"
+
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/impressions/testdata"
+	"github.com/stretchr/testify/assert"
+)
+
+type expectedOutputA2 struct {
+	step1 [][2]int64 // input passed as is
+	step2 [][2]int64 // pod duration = pod max duration, no of ads = maxads
+	step3 [][2]int64 // pod duration = pod max duration, no of ads = minads
+	step4 [][2]int64 // pod duration = pod min duration, no of ads = maxads
+	step5 [][2]int64 // pod duration = pod min duration, no of ads = minads
+}
+
+var impressionsTestsA2 = []struct {
+	scenario string // Testcase scenario
+	//in       []int            // Testcase input
+	out expectedOutputA2 // Testcase execpted output
+}{
+	{scenario: "TC2", out: expectedOutputA2{
+		step1: [][2]int64{{15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}},
+		step2: [][2]int64{{11, 13}, {11, 11}, {11, 11}, {11, 11}, {11, 11}, {11, 11}, {11, 11}, {11, 11}},
+		step3: [][2]int64{}, // 90 90 15 15 2 2
+		step4: [][2]int64{}, // 1,1, 15,15, 8 8
+		step5: [][2]int64{}, // 1,1, 15,15, 2 2
+	}},
+	{scenario: "TC3", out: expectedOutputA2{
+		step1: [][2]int64{{15, 15}, {15, 15}, {15, 15}, {15, 15}},
+		step2: [][2]int64{}, // 90 90 15 15 4 4
+		step3: [][2]int64{}, // 90 90 15 15 2 2
+		step4: [][2]int64{}, // 1 1 15 15 4 4
+		step5: [][2]int64{}, // 1 1 15 15 2 2
+	}},
+	{scenario: "TC4", out: expectedOutputA2{
+		step1: [][2]int64{{15, 15}},
+		step2: [][2]int64{{15, 15}}, // 15 15 5 15 1 1
+		step3: [][2]int64{{15, 15}}, // 15 15 5 15 1 1
+		step4: [][2]int64{{1, 1}},   //  1  1 5 15 1 1
+		step5: [][2]int64{{1, 1}},   //  1  1 5 15 1 1
+	}},
+	{scenario: "TC5", out: expectedOutputA2{
+		step1: [][2]int64{{10, 10}, {5, 5}},
+		step2: [][2]int64{{10, 10}, {5, 5}}, // 15, 15, 5, 15, 2, 2
+		step3: [][2]int64{{15, 15}},         // 15, 15, 5, 15, 1, 1
+		step4: [][2]int64{},                 //  1,  1, 5, 15, 2, 2
+		step5: [][2]int64{{1, 1}},           //  1,  1, 5, 15, 1, 1
+	}},
+	{scenario: "TC6", out: expectedOutputA2{
+		// 5, 90, 5, 15, 1, 8
+		step1: [][2]int64{{15, 15}, {15, 15}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		// 90, 90, 5, 15, 8, 8
+		step2: [][2]int64{{15, 15}, {15, 15}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		// 90, 90, 5, 15, 1, 1
+		step3: [][2]int64{},
+		// 1, 1, 5, 15, 8, 8
+		step4: [][2]int64{},
+		// 1, 1, 5, 15, 1, 1
+		step5: [][2]int64{{1, 1}},
+	}},
+	{scenario: "TC7", out: expectedOutputA2{
+		// 15, 30, 10, 15, 1, 1
+		step1: [][2]int64{{15, 15}},
+		// 30, 30, 10, 15, 1, 1
+		step2: [][2]int64{},
+		// 30, 30, 10, 15, 1, 1
+		step3: [][2]int64{},
+		// 15, 15, 10, 15, 1, 1
+		step4: [][2]int64{{15, 15}},
+		// 15, 15, 10, 15, 1, 1
+		step5: [][2]int64{{15, 15}},
+	}},
+	{scenario: "TC8", out: expectedOutputA2{
+		// 35, 35, 10, 35, 3, 40
+		step1: [][2]int64{{15, 15}, {10, 10}, {10, 10}},
+		// 35, 35, 10, 35, 40, 40
+		step2: [][2]int64{},
+		// 35, 35, 10, 35, 3, 3
+		step3: [][2]int64{{15, 15}, {10, 10}, {10, 10}},
+		// 35, 35, 10, 35, 40, 40
+		step4: [][2]int64{},
+		// 35, 35, 10, 35, 3, 3
+		step5: [][2]int64{{15, 15}, {10, 10}, {10, 10}},
+	}},
+	{scenario: "TC9", out: expectedOutputA2{
+		// 35, 35, 10, 35, 6, 40
+		step1: [][2]int64{},
+		// 35, 35, 10, 35, 40, 40
+		step2: [][2]int64{},
+		// 35, 35, 10, 35, 6, 6
+		step3: [][2]int64{},
+		// 35, 35, 10, 35, 40, 40
+		step4: [][2]int64{},
+		// 35, 35, 10, 35, 6, 6
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC10", out: expectedOutputA2{
+		// 35, 65, 10, 35, 6, 40
+		step1: [][2]int64{{15, 15}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		// 65, 65, 10, 35, 40, 40
+		step2: [][2]int64{},
+		// 65, 65, 10, 35, 6, 6
+		step3: [][2]int64{{15, 15}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		// 35, 35, 10, 35, 40, 40
+		step4: [][2]int64{},
+		// 35, 35, 10, 35, 6, 6
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC11", out: expectedOutputA2{
+		// 35, 65, 10, 35, 7, 40
+		step1: [][2]int64{{9, 11}, {9, 9}, {9, 9}, {9, 9}, {9, 9}, {9, 9}, {9, 9}},
+		// 65, 65, 10, 35, 40, 40
+		step2: [][2]int64{},
+		// 65, 65, 10, 35, 7, 7
+		step3: [][2]int64{{9, 11}, {9, 9}, {9, 9}, {9, 9}, {9, 9}, {9, 9}, {9, 9}},
+		// 35, 35, 10, 35, 40, 40
+		step4: [][2]int64{},
+		// 35, 35, 10, 35, 7, 7
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC12", out: expectedOutputA2{
+		step1: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		step2: [][2]int64{},
+		step3: [][2]int64{{20, 20}, {20, 20}, {15, 15}, {15, 15}, {15, 15}, {15, 15}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{20, 20}, {20, 20}, {15, 15}, {15, 15}, {15, 15}, {15, 15}},
+	}},
+	{scenario: "TC13", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC14", out: expectedOutputA2{
+		step1: [][2]int64{{5, 9}, {5, 9}, {5, 9}, {5, 9}, {5, 9}, {5, 9}},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{{5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC15", out: expectedOutputA2{
+		step1: [][2]int64{{5, 9}, {5, 9}, {5, 9}, {5, 9}, {5, 9}},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{{5, 9}, {5, 6}, {5, 5}, {5, 5}, {5, 5}},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC27", out: expectedOutputA2{
+		step1: [][2]int64{{30, 30}, {30, 30}, {30, 30}},
+		step2: [][2]int64{{30, 30}, {30, 30}, {30, 30}},
+		step3: [][2]int64{{45, 45}, {45, 45}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{2, 3}, {2, 2}},
+	}},
+	{scenario: "TC16", out: expectedOutputA2{
+		step1: [][2]int64{{1, 12}, {1, 12}, {1, 12}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		step2: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {1, 6}},
+		step3: [][2]int64{},
+		step4: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {1, 6}},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC17", out: expectedOutputA2{
+		step1: [][2]int64{{1, 12}, {1, 12}, {1, 12}, {1, 12}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		step2: [][2]int64{{1, 11}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {6, 7}},
+		step3: [][2]int64{},
+		step4: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {6, 7}},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC18", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC19", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC20", out: expectedOutputA2{
+		step1: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC21", out: expectedOutputA2{
+		step1: [][2]int64{{3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC23", out: expectedOutputA2{
+		step1: [][2]int64{{4, 14}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{{4, 13}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC24", out: expectedOutputA2{
+		step1: [][2]int64{{60, 69}, {65, 65}},
+		step2: [][2]int64{},
+		step3: [][2]int64{{60, 69}, {65, 65}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{60, 69}, {65, 65}},
+	}},
+	{scenario: "TC25", out: expectedOutputA2{
+		step1: [][2]int64{{1, 68}, {20, 20}},
+		step2: [][2]int64{{1, 68}, {20, 20}},
+		step3: [][2]int64{{1, 68}, {20, 20}},
+		step4: [][2]int64{{1, 68}, {20, 20}},
+		step5: [][2]int64{{1, 68}, {20, 20}},
+	}},
+	{scenario: "TC26", out: expectedOutputA2{
+		step1: [][2]int64{{45, 45}, {45, 45}},
+		step2: [][2]int64{},
+		step3: [][2]int64{{45, 45}, {45, 45}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{45, 45}, {45, 45}},
+	}},
+	{scenario: "TC27", out: expectedOutputA2{
+		step1: [][2]int64{{30, 30}, {30, 30}, {30, 30}},
+		step2: [][2]int64{{30, 30}, {30, 30}, {30, 30}},
+		step3: [][2]int64{{45, 45}, {45, 45}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{2, 3}, {2, 2}},
+	}},
+	{scenario: "TC28", out: expectedOutputA2{
+		step1: [][2]int64{{30, 30}, {30, 30}, {30, 30}, {30, 30}, {30, 30}, {30, 30}},
+		step2: [][2]int64{{30, 30}, {30, 30}, {30, 30}, {30, 30}, {30, 30}, {30, 30}},
+		step3: [][2]int64{{90, 90}, {90, 90}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{2, 3}, {2, 2}},
+	}},
+	{scenario: "TC29", out: expectedOutputA2{
+		step1: [][2]int64{{25, 25}, {20, 20}, {20, 20}},
+		step2: [][2]int64{{25, 25}, {20, 20}, {20, 20}},
+		step3: [][2]int64{{35, 35}, {30, 30}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{2, 3}, {2, 2}},
+	}},
+	{scenario: "TC30", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC31", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC32", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC33", out: expectedOutputA2{
+		step1: [][2]int64{{30, 42}, {35, 35}, {35, 35}, {35, 35}},
+		step2: [][2]int64{},
+		step3: [][2]int64{{30, 42}, {35, 35}, {35, 35}, {35, 35}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{30, 42}, {35, 35}, {35, 35}, {35, 35}},
+	}},
+	{scenario: "TC34", out: expectedOutputA2{
+		step1: [][2]int64{{30, 30}, {30, 30}, {30, 30}},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC35", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC36", out: expectedOutputA2{
+		step1: [][2]int64{{45, 45}, {45, 45}},
+		step2: [][2]int64{},
+		step3: [][2]int64{{45, 45}, {45, 45}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{45, 45}, {45, 45}},
+	}},
+	{scenario: "TC37", out: expectedOutputA2{
+		step1: [][2]int64{{25, 25}, {20, 20}},
+		step2: [][2]int64{},
+		step3: [][2]int64{{25, 25}, {20, 20}},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC38", out: expectedOutputA2{
+		step1: [][2]int64{{25, 25}, {25, 25}, {20, 20}, {20, 20}},
+		step2: [][2]int64{},
+		step3: [][2]int64{{45, 45}, {45, 45}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{45, 45}, {45, 45}},
+	}},
+	{scenario: "TC39", out: expectedOutputA2{
+		step1: [][2]int64{{25, 25}, {25, 25}, {20, 20}, {20, 20}},
+		step2: [][2]int64{},
+		step3: [][2]int64{{45, 45}, {45, 45}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{30, 30}, {30, 30}},
+	}},
+	{scenario: "TC40", out: expectedOutputA2{
+		step1: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {5, 5}},
+		step2: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {5, 5}},
+		step3: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {5, 5}},
+		step4: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {5, 5}},
+		step5: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {5, 5}},
+	}},
+	{scenario: "TC41", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}},
+		step5: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}},
+	}},
+	{scenario: "TC42", out: expectedOutputA2{
+		step1: [][2]int64{{1, 1}},
+		step2: [][2]int64{{1, 1}},
+		step3: [][2]int64{{1, 1}},
+		step4: [][2]int64{{1, 1}},
+		step5: [][2]int64{{1, 1}},
+	}},
+	{scenario: "TC43", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC44", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC45", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC46", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC47", out: expectedOutputA2{
+		step1: [][2]int64{{6, 6}},
+		step2: [][2]int64{{6, 6}},
+		step3: [][2]int64{{6, 6}},
+		step4: [][2]int64{{6, 6}},
+		step5: [][2]int64{{6, 6}},
+	}},
+	{scenario: "TC48", out: expectedOutputA2{
+		step1: [][2]int64{{6, 6}, {6, 6}},
+		step2: [][2]int64{{6, 6}, {6, 6}},
+		step3: [][2]int64{},
+		step4: [][2]int64{{6, 6}, {6, 6}},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC49", out: expectedOutputA2{
+		step1: [][2]int64{},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC50", out: expectedOutputA2{
+		step1: [][2]int64{{1, 1}},
+		step2: [][2]int64{{1, 1}},
+		step3: [][2]int64{{1, 1}},
+		step4: [][2]int64{{1, 1}},
+		step5: [][2]int64{{1, 1}},
+	}},
+	{scenario: "TC51", out: expectedOutputA2{
+		step1: [][2]int64{{13, 13}, {13, 13}, {13, 13}},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC52", out: expectedOutputA2{
+		step1: [][2]int64{{12, 18}, {12, 18}, {12, 18}, {12, 18}},
+		step2: [][2]int64{{12, 18}, {12, 18}, {12, 18}, {12, 18}},
+		step3: [][2]int64{},
+		step4: [][2]int64{{12, 18}, {12, 18}, {12, 17}, {15, 15}},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC53", out: expectedOutputA2{
+		step1: [][2]int64{{20, 20}, {20, 20}, {20, 20}, {20, 20}, {20, 20}, {20, 20}, {1, 6}},
+		step2: [][2]int64{{20, 20}, {20, 20}, {20, 20}, {20, 20}, {20, 20}, {20, 20}, {1, 6}},
+		step3: [][2]int64{},
+		step4: [][2]int64{{20, 20}, {20, 20}, {20, 20}, {20, 20}, {20, 20}, {20, 20}, {1, 6}},
+		step5: [][2]int64{},
+	}},
+	// {1, 74, 12, 12, 1, 6}
+	{scenario: "TC55", out: expectedOutputA2{
+		step1: [][2]int64{{12, 12}, {12, 12}, {12, 12}, {12, 12}, {12, 12}, {12, 12}},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{},
+		step5: [][2]int64{},
+	}},
+	{scenario: "TC56", out: expectedOutputA2{
+		step1: [][2]int64{{126, 126}},
+		step2: [][2]int64{{126, 126}},
+		step3: [][2]int64{{126, 126}},
+		step4: [][2]int64{{126, 126}},
+		step5: [][2]int64{{126, 126}},
+	}},
+	{scenario: "TC57", out: expectedOutputA2{
+		step1: [][2]int64{{126, 126}},
+		step2: [][2]int64{},
+		step3: [][2]int64{{126, 126}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{126, 126}},
+	}},
+	{scenario: "TC58", out: expectedOutputA2{
+		step1: [][2]int64{{25, 25}, {25, 25}, {20, 20}, {20, 20}},
+		step2: [][2]int64{{25, 25}, {25, 25}, {20, 20}, {20, 20}},
+		step3: [][2]int64{{45, 45}, {45, 45}},
+		step4: [][2]int64{},
+		step5: [][2]int64{{15, 15}, {15, 15}},
+	}},
+	{scenario: "TC59", out: expectedOutputA2{
+		step1: [][2]int64{{45, 45}},
+		step2: [][2]int64{},
+		step3: [][2]int64{},
+		step4: [][2]int64{{30, 30}},
+		step5: [][2]int64{{30, 30}},
+	}},
+	// {scenario: "TC1" , out: expectedOutputA2{
+	// 	step1: [][2]int64{},
+	// 	step2: [][2]int64{},
+	// 	step3: [][2]int64{},
+	// 	step4: [][2]int64{},
+	// 	step5: [][2]int64{},
+	// }},
+	// Testcases with realistic scenarios
+
+	// {scenario: "TC_3_to_4_Ads_Of_5_to_10_Sec" /*in: []int{15, 40, 5, 10, 3, 4},*/, out: expectedOutputA2{
+	// 	// 15, 40, 5, 10, 3, 4
+	// 	step1: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}},
+	// 	// 40, 40, 5, 10, 4, 4
+	// 	step2: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}},
+	// 	// 40, 40, 5, 10, 3, 3
+	// 	step3: [][2]int64{},
+	// 	// 15, 15, 5, 10, 4, 4
+	// 	step4: [][2]int64{},
+	// 	// 15, 15, 5, 10, 3, 3
+	// 	step5: [][2]int64{{5, 5}, {5, 5}, {5, 5}},
+	// }},
+	// {scenario: "TC_4_to_6_Ads_Of_2_to_25_Sec" /*in: []int{60, 77, 2, 25, 4, 6}, */, out: expectedOutputA2{
+	// 	// 60, 77, 2, 25, 4, 6
+	// 	step1: [][2]int64{{2, 17}, {15, 15}, {15, 15}, {10, 10}, {10, 10}, {10, 10}},
+	// 	// 77, 77, 5, 25, 6, 6
+	// 	step2: [][2]int64{{2, 17}, {15, 15}, {15, 15}, {10, 10}, {10, 10}, {10, 10}},
+	// 	// 77, 77, 5, 25, 4, 4
+	// 	step3: [][2]int64{{25, 25}, {25, 25}, {2, 22}, {5, 5}},
+	// 	// 60, 60, 5, 25, 6, 6
+	// 	step4: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+	// 	// 60, 60, 5, 25, 4, 4
+	// 	step5: [][2]int64{{15, 15}, {15, 15}, {15, 15}, {15, 15}},
+	// }},
+
+	// {scenario: "TC_2_to_6_ads_of_15_to_45_sec" /*in: []int{60, 90, 15, 45, 2, 6},*/, out: expectedOutputA2{
+	// 	// 60, 90, 15, 45, 2, 6
+	// 	step1: [][2]int64{{15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}},
+	// 	// 90, 90, 15, 45, 6, 6
+	// 	step2: [][2]int64{{15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}},
+	// 	// 90, 90, 15, 45, 2, 2
+	// 	step3: [][2]int64{{45, 45}, {45, 45}},
+	// 	// 60, 60, 15, 45, 6, 6
+	// 	step4: [][2]int64{},
+	// 	// 60, 60, 15, 45, 2, 2
+	// 	step5: [][2]int64{{30, 30}, {30, 30}},
+	// }},
+
+}
+
+func TestGetImpressionsA2(t *testing.T) {
+	for _, impTest := range impressionsTestsA2 {
+		t.Run(impTest.scenario, func(t *testing.T) {
+			in := testdata.Input[impTest.scenario]
+			p := newTestPod(int64(in[0]), int64(in[1]), in[2], in[3], in[4], in[5])
+			a2 := newMinMaxAlgorithm(p.podMinDuration, p.podMaxDuration, p.vPod)
+			expectedMergedOutput := make([][2]int64, 0)
+			// explictly looping in order to check result of individual generator
+			for step, gen := range a2.generator {
+				switch step {
+				case 0: // algo1 equaivalent
+					assert.Equal(t, impTest.out.step1, gen.Get())
+					expectedMergedOutput = appendOptimized(expectedMergedOutput, impTest.out.step1)
+					break
+				case 1: // pod duration = pod max duration, no of ads = maxads
+					assert.Equal(t, impTest.out.step2, gen.Get())
+					expectedMergedOutput = appendOptimized(expectedMergedOutput, impTest.out.step2)
+					break
+				case 2: // pod duration = pod max duration, no of ads = minads
+					assert.Equal(t, impTest.out.step3, gen.Get())
+					expectedMergedOutput = appendOptimized(expectedMergedOutput, impTest.out.step3)
+					break
+				case 3: // pod duration = pod min duration, no of ads = maxads
+					assert.Equal(t, impTest.out.step4, gen.Get())
+					expectedMergedOutput = appendOptimized(expectedMergedOutput, impTest.out.step4)
+					break
+				case 4: // pod duration = pod min duration, no of ads = minads
+					assert.Equal(t, impTest.out.step5, gen.Get())
+					expectedMergedOutput = appendOptimized(expectedMergedOutput, impTest.out.step5)
+					break
+				}
+
+			}
+			// also verify merged output
+			expectedMergedOutput = testdata.Scenario[impTest.scenario].MinMaxAlgorithm
+			out := sortOutput(a2.Get())
+			//fmt.Println(out)
+			assert.Equal(t, sortOutput(expectedMergedOutput), out)
+		})
+	}
+}
+
+func BenchmarkGetImpressionsA2(b *testing.B) {
+	for _, impTest := range impressionsTestsA2 {
+		for i := 0; i < b.N; i++ {
+			in := testdata.Input[impTest.scenario]
+			p := newTestPod(int64(in[0]), int64(in[1]), in[2], in[3], in[4], in[5])
+			a2 := newMinMaxAlgorithm(p.podMinDuration, p.podMaxDuration, p.vPod)
+			a2.Get()
+		}
+	}
+}
+
+func sortOutput(imps [][2]int64) [][2]int64 {
+	sort.Slice(imps, func(i, j int) bool {
+		return imps[i][1] < imps[j][1]
+	})
+	return imps
+}
+
+func appendOptimized(slice [][2]int64, elems [][2]int64) [][2]int64 {
+	m := make(map[string]int, 0)
+	keys := make([]string, 0)
+	for _, sel := range slice {
+		k := getKey(sel)
+		m[k]++
+		keys = append(keys, k)
+	}
+	elemsmap := make(map[string]int, 0)
+	for _, ele := range elems {
+		elemsmap[getKey(ele)]++
+	}
+
+	for k := range elemsmap {
+		if elemsmap[k] > m[k] {
+			m[k] = elemsmap[k]
+		}
+
+		keyPresent := false
+		for _, kl := range keys {
+			if kl == k {
+				keyPresent = true
+				break
+			}
+		}
+
+		if !keyPresent {
+			keys = append(keys, k)
+		}
+	}
+
+	optimized := make([][2]int64, 0)
+	for k, v := range m {
+		for i := 1; i <= v; i++ {
+			optimized = append(optimized, getImpression(k))
+		}
+	}
+	return optimized
+}
diff --git a/endpoints/openrtb2/ctv/impressions/testdata/input.go b/endpoints/openrtb2/ctv/impressions/testdata/input.go
new file mode 100644
index 000000000..3ee64544b
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/testdata/input.go
@@ -0,0 +1,61 @@
+package testdata
+
+// Input Test Input
+var Input = map[string][]int{
+	"TC2":  {1, 90, 11, 15, 2, 8},
+	"TC3":  {1, 90, 11, 15, 2, 4},
+	"TC4":  {1, 15, 1, 15, 1, 1},
+	"TC5":  {1, 15, 1, 15, 1, 2},
+	"TC6":  {1, 90, 1, 15, 1, 8},
+	"TC7":  {15, 30, 8, 15, 1, 1},
+	"TC8":  {35, 35, 10, 35, 3, 40},
+	"TC9":  {35, 35, 10, 35, 6, 40},
+	"TC10": {35, 65, 10, 35, 6, 40},
+	"TC11": {35, 65, 9, 35, 7, 40},
+	"TC12": {100, 100, 10, 35, 6, 40},
+	"TC13": {60, 60, 5, 9, 1, 6},
+	"TC14": {30, 60, 5, 9, 1, 6},
+	"TC15": {30, 60, 5, 9, 1, 5},
+	"TC16": {126, 126, 1, 12, 7, 13}, /* Exact Pod Duration */
+	"TC17": {127, 128, 1, 12, 7, 13},
+	"TC18": {125, 125, 4, 4, 1, 1},
+	"TC19": {90, 90, 7, 9, 3, 5},
+	"TC20": {90, 90, 5, 10, 1, 11},
+	"TC21": {2, 170, 3, 9, 4, 9},
+	"TC23": {118, 124, 4, 17, 6, 15},
+	"TC24": {134, 134, 60, 90, 2, 3},
+	"TC25": {88, 88, 1, 80, 2, 2},
+	"TC26": {90, 90, 45, 45, 2, 3},
+	"TC27": {5, 90, 2, 45, 2, 3},
+	"TC28": {5, 180, 2, 90, 2, 6},
+	"TC29": {5, 65, 2, 35, 2, 3},
+	"TC30": {123, 123, 34, 34, 3, 3},
+	"TC31": {123, 123, 31, 31, 3, 3},
+	"TC32": {134, 134, 63, 63, 2, 3},
+	"TC33": {147, 147, 30, 60, 4, 6},
+	"TC34": {88, 102, 30, 30, 3, 3},
+	"TC35": {88, 102, 30, 42, 3, 3},
+	"TC36": {90, 90, 45, 45, 2, 5},
+	"TC37": {10, 45, 20, 45, 2, 5},
+	"TC38": {90, 90, 20, 45, 2, 5},
+	"TC39": {60, 90, 20, 45, 2, 5},
+	"TC40": {95, 95, 5, 45, 10, 10},
+	"TC41": {95, 123, 5, 45, 13, 13},
+	"TC42": {1, 1, 1, 1, 1, 1},
+	"TC43": {2, 2, 2, 2, 2, 2},
+	"TC44": {0, 0, 0, 0, 0, 0},
+	"TC45": {-1, -2, -3, -4, -5, -6},
+	"TC46": {-1, -1, -1, -1, -1, -1},
+	"TC47": {6, 6, 6, 6, 1, 1},
+	"TC48": {12, 12, 6, 6, 1, 2},
+	"TC49": {12, 12, 7, 7, 1, 2},
+	"TC50": {1, 1, 1, 1, 1, 1},
+	"TC51": {31, 43, 11, 13, 2, 3},
+	"TC52": {68, 72, 12, 18, 2, 4},
+	"TC53": {126, 126, 1, 20, 1, 7},
+	"TC55": {1, 74, 12, 12, 1, 6},
+	"TC56": {126, 126, 126, 126, 1, 1},
+	"TC57": {126, 126, 126, 126, 1, 3},
+	"TC58": {30, 90, 15, 45, 2, 4},
+	"TC59": {30, 90, 15, 45, 1, 1},
+}
diff --git a/endpoints/openrtb2/ctv/impressions/testdata/output.go b/endpoints/openrtb2/ctv/impressions/testdata/output.go
new file mode 100644
index 000000000..d7e854fc5
--- /dev/null
+++ b/endpoints/openrtb2/ctv/impressions/testdata/output.go
@@ -0,0 +1,236 @@
+package testdata
+
+type eout struct {
+	MaximizeForDuration [][2]int64
+	MinMaxAlgorithm     [][2]int64
+}
+
+// Scenario returns expected impression breaks for given algorithm and for given
+// test scenario
+var Scenario = map[string]eout{
+
+	"TC2": {
+		MaximizeForDuration: [][2]int64{{15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}, {15, 15}},
+		MinMaxAlgorithm:     [][2]int64{{11, 13}, {11, 11}, {11, 11}, {11, 11}, {11, 11}, {11, 11}, {11, 11}, {11, 11}, {11, 15}, {11, 15}, {11, 15}, {11, 15}, {11, 15}, {11, 15}}},
+
+	"TC3": {
+		MaximizeForDuration: [][2]int64{{15, 15}, {15, 15}, {15, 15}, {15, 15}},
+		MinMaxAlgorithm:     [][2]int64{{11, 15}, {11, 15}, {11, 15}, {11, 15}},
+	},
+	"TC4": {
+		MaximizeForDuration: [][2]int64{{15, 15}},
+		MinMaxAlgorithm:     [][2]int64{{1, 15}, {1, 1}},
+	},
+	"TC5": {
+		MaximizeForDuration: [][2]int64{{10, 10}, {5, 5}},
+		MinMaxAlgorithm:     [][2]int64{{1, 1}, {1, 5}, {1, 15}, {1, 10}},
+	},
+	"TC6": {
+		MaximizeForDuration: [][2]int64{{15, 15}, {15, 15}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		MinMaxAlgorithm:     [][2]int64{{1, 15}, {1, 15}, {1, 10}, {1, 10}, {1, 10}, {1, 10}, {1, 10}, {1, 10}, {1, 1}},
+	},
+	"TC7": {
+		MaximizeForDuration: [][2]int64{{15, 15}},
+		MinMaxAlgorithm:     [][2]int64{{15, 15}},
+	},
+	"TC8": {
+		MaximizeForDuration: [][2]int64{{15, 15}, {10, 10}, {10, 10}},
+		MinMaxAlgorithm:     [][2]int64{{10, 10}, {10, 10}, {15, 15}},
+	},
+	"TC9": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC10": {
+		MaximizeForDuration: [][2]int64{{15, 15}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		MinMaxAlgorithm:     [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 15}},
+	},
+	"TC11": {
+		MaximizeForDuration: [][2]int64{{9, 11}, {9, 9}, {9, 9}, {9, 9}, {9, 9}, {9, 9}, {9, 9}},
+		MinMaxAlgorithm:     [][2]int64{{9, 11}, {9, 9}, {9, 9}, {9, 9}, {9, 9}, {9, 9}, {9, 9}},
+	},
+	"TC12": {
+		MaximizeForDuration: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		MinMaxAlgorithm:     [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {20, 20}, {20, 20}, {15, 15}, {15, 15}, {15, 15}, {15, 15}},
+	},
+	"TC13": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC14": {
+		MaximizeForDuration: [][2]int64{{5, 9}, {5, 9}, {5, 9}, {5, 9}, {5, 9}, {5, 9}},
+		MinMaxAlgorithm:     [][2]int64{{5, 9}, {5, 9}, {5, 9}, {5, 9}, {5, 9}, {5, 9}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}},
+	},
+	"TC15": {
+		MaximizeForDuration: [][2]int64{{5, 9}, {5, 9}, {5, 9}, {5, 9}, {5, 9}},
+		MinMaxAlgorithm:     [][2]int64{{5, 9}, {5, 9}, {5, 9}, {5, 9}, {5, 9}, {5, 6}, {5, 5}, {5, 5}, {5, 5}},
+	},
+	"TC16": {
+		MaximizeForDuration: [][2]int64{{1, 12}, {1, 12}, {1, 12}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		MinMaxAlgorithm:     [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {1, 6}, {1, 12}, {1, 12}, {1, 12}},
+	},
+	"TC17": {
+		MaximizeForDuration: [][2]int64{{1, 12}, {1, 12}, {1, 12}, {1, 12}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		MinMaxAlgorithm:     [][2]int64{{1, 11}, {1, 7}, {1, 12}, {1, 12}, {1, 12}, {1, 12}, {1, 10}, {1, 10}, {1, 10}, {1, 10}, {1, 10}, {1, 10}, {1, 10}, {1, 10}, {1, 10}, {1, 10}, {1, 10}, {1, 10}},
+	},
+	"TC18": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC19": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC20": {
+		MaximizeForDuration: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		MinMaxAlgorithm:     [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+	},
+	"TC21": {
+		MaximizeForDuration: [][2]int64{{3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}},
+		MinMaxAlgorithm:     [][2]int64{{3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}, {3, 9}},
+	},
+	"TC23": {
+		MaximizeForDuration: [][2]int64{{4, 14}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}},
+		MinMaxAlgorithm:     [][2]int64{{4, 13}, {4, 5}, {4, 5}, {4, 5}, {4, 5}, {4, 5}, {4, 5}, {4, 5}, {4, 14}, {4, 10}, {4, 10}, {4, 10}, {4, 10}, {4, 10}, {4, 10}, {4, 10}, {4, 10}, {4, 10}, {4, 10}, {4, 10}},
+	},
+	"TC24": {
+		MaximizeForDuration: [][2]int64{{60, 69}, {65, 65}},
+		MinMaxAlgorithm:     [][2]int64{{60, 69}, {65, 65}},
+	},
+	"TC25": {
+		MaximizeForDuration: [][2]int64{{1, 68}, {20, 20}},
+		MinMaxAlgorithm:     [][2]int64{{1, 68}, {20, 20}},
+	},
+	"TC26": {
+		MaximizeForDuration: [][2]int64{{45, 45}, {45, 45}},
+		MinMaxAlgorithm:     [][2]int64{{45, 45}, {45, 45}},
+	},
+	"TC27": {
+		MaximizeForDuration: [][2]int64{{30, 30}, {30, 30}, {30, 30}},
+		MinMaxAlgorithm:     [][2]int64{{3, 3}, {2, 2}, {3, 30}, {3, 30}, {3, 30}, {3, 45}, {3, 45}},
+	},
+	"TC28": {
+		MaximizeForDuration: [][2]int64{{30, 30}, {30, 30}, {30, 30}, {30, 30}, {30, 30}, {30, 30}},
+		MinMaxAlgorithm:     [][2]int64{{3, 90}, {3, 90}, {3, 3}, {2, 2}, {3, 30}, {3, 30}, {3, 30}, {3, 30}, {3, 30}, {3, 30}},
+	},
+	"TC29": {
+		MaximizeForDuration: [][2]int64{{25, 25}, {20, 20}, {20, 20}},
+		MinMaxAlgorithm:     [][2]int64{{3, 25}, {3, 20}, {3, 20}, {3, 3}, {2, 2}, {3, 35}, {3, 30}},
+	},
+	"TC30": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC31": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC32": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC33": {
+		MaximizeForDuration: [][2]int64{{30, 42}, {35, 35}, {35, 35}, {35, 35}},
+		MinMaxAlgorithm:     [][2]int64{{30, 42}, {35, 35}, {35, 35}, {35, 35}},
+	},
+	"TC34": {
+		MaximizeForDuration: [][2]int64{{30, 30}, {30, 30}, {30, 30}},
+		MinMaxAlgorithm:     [][2]int64{{30, 30}, {30, 30}, {30, 30}},
+	},
+	"TC35": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC36": {
+		MaximizeForDuration: [][2]int64{{45, 45}, {45, 45}},
+		MinMaxAlgorithm:     [][2]int64{{45, 45}, {45, 45}},
+	},
+	"TC37": {
+		MaximizeForDuration: [][2]int64{{25, 25}, {20, 20}},
+		MinMaxAlgorithm:     [][2]int64{{20, 20}, {20, 25}},
+	},
+	"TC38": {
+		MaximizeForDuration: [][2]int64{{25, 25}, {25, 25}, {20, 20}, {20, 20}},
+		MinMaxAlgorithm:     [][2]int64{{25, 25}, {25, 25}, {20, 20}, {20, 20}, {45, 45}, {45, 45}},
+	},
+	"TC39": {
+		MaximizeForDuration: [][2]int64{{25, 25}, {25, 25}, {20, 20}, {20, 20}},
+		MinMaxAlgorithm:     [][2]int64{{30, 45}, {30, 45}, {30, 30}, {30, 30}, {20, 25}, {20, 25}, {20, 20}, {20, 20}},
+	},
+	"TC40": {
+		MaximizeForDuration: [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {5, 5}},
+		MinMaxAlgorithm:     [][2]int64{{10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {10, 10}, {5, 5}},
+	},
+	"TC41": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{{7, 10}, {7, 10}, {7, 10}, {7, 10}, {7, 10}, {7, 10}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}, {5, 5}},
+	},
+	"TC42": {
+		MaximizeForDuration: [][2]int64{{1, 1}},
+		MinMaxAlgorithm:     [][2]int64{{1, 1}},
+	},
+	"TC43": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC44": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC45": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC46": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC47": {
+		MaximizeForDuration: [][2]int64{{6, 6}},
+		MinMaxAlgorithm:     [][2]int64{{6, 6}},
+	},
+	"TC48": {
+		MaximizeForDuration: [][2]int64{{6, 6}, {6, 6}},
+		MinMaxAlgorithm:     [][2]int64{{6, 6}, {6, 6}},
+	},
+	"TC49": {
+		MaximizeForDuration: [][2]int64{},
+		MinMaxAlgorithm:     [][2]int64{},
+	},
+	"TC50": {
+		MaximizeForDuration: [][2]int64{{1, 1}},
+		MinMaxAlgorithm:     [][2]int64{{1, 1}},
+	},
+	"TC51": {
+		MaximizeForDuration: [][2]int64{{13, 13}, {13, 13}, {13, 13}},
+		MinMaxAlgorithm:     [][2]int64{{11, 13}, {11, 13}, {11, 13}},
+	},
+	"TC52": {
+		MaximizeForDuration: [][2]int64{{12, 18}, {12, 18}, {12, 18}, {12, 18}},
+		MinMaxAlgorithm:     [][2]int64{{12, 17}, {12, 15}, {12, 18}, {12, 18}, {12, 18}, {12, 18}},
+	},
+	"TC53": {
+		MaximizeForDuration: [][2]int64{{20, 20}, {20, 20}, {20, 20}, {20, 20}, {20, 20}, {20, 20}, {1, 6}},
+		MinMaxAlgorithm:     [][2]int64{{1, 6}, {20, 20}, {20, 20}, {20, 20}, {20, 20}, {20, 20}, {20, 20}},
+	},
+	"TC55": {
+		MaximizeForDuration: [][2]int64{{12, 12}, {12, 12}, {12, 12}, {12, 12}, {12, 12}, {12, 12}},
+		MinMaxAlgorithm:     [][2]int64{{12, 12}, {12, 12}, {12, 12}, {12, 12}, {12, 12}, {12, 12}},
+	},
+	"TC56": {
+		MaximizeForDuration: [][2]int64{{126, 126}},
+		MinMaxAlgorithm:     [][2]int64{{126, 126}},
+	},
+	"TC57": {
+		MaximizeForDuration: [][2]int64{{126, 126}},
+		MinMaxAlgorithm:     [][2]int64{{126, 126}},
+	},
+	"TC58": {
+		MaximizeForDuration: [][2]int64{{25, 25}, {25, 25}, {20, 20}, {20, 20}},
+		MinMaxAlgorithm:     [][2]int64{{15, 15}, {15, 15}, {15, 20}, {15, 20}, {15, 25}, {15, 25}, {15, 45}, {15, 45}},
+	},
+	"TC59": {
+		MaximizeForDuration: [][2]int64{{45, 45}},
+		MinMaxAlgorithm:     [][2]int64{{30, 30}, {30, 45}},
+	},
+}
diff --git a/endpoints/openrtb2/ctv/response/adpod_generator copy.go.bak b/endpoints/openrtb2/ctv/response/adpod_generator copy.go.bak
new file mode 100644
index 000000000..df5b7e36b
--- /dev/null
+++ b/endpoints/openrtb2/ctv/response/adpod_generator copy.go.bak	
@@ -0,0 +1,276 @@
+package ctv
+
+import (
+	"context"
+	"time"
+
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+/********************* AdPodGenerator Functions *********************/
+
+//IAdPodGenerator interface for generating AdPod from Ads
+type IAdPodGenerator interface {
+	GetAdPodBids() *AdPodBid
+}
+type filteredBids struct {
+	bid        *Bid
+	reasonCode FilterReasonCode
+}
+type highestCombination struct {
+	bids          []*Bid
+	price         float64
+	categoryScore map[string]int
+	domainScore   map[string]int
+	filteredBids  []filteredBids
+}
+
+//AdPodGenerator AdPodGenerator
+type AdPodGenerator struct {
+	IAdPodGenerator
+	buckets BidsBuckets
+	comb    ICombination
+	adpod   *openrtb_ext.VideoAdPod
+}
+
+//NewAdPodGenerator will generate adpod based on configuration
+func NewAdPodGenerator(buckets BidsBuckets, comb ICombination, adpod *openrtb_ext.VideoAdPod) *AdPodGenerator {
+	return &AdPodGenerator{
+		buckets: buckets,
+		comb:    comb,
+		adpod:   adpod,
+	}
+}
+
+//GetAdPodBids will return Adpod based on configurations
+func (o *AdPodGenerator) GetAdPodBids() *AdPodBid {
+
+	isTimedOutORReceivedAllResponses := false
+	responseCount := 0
+	totalRequest := 0
+	maxRequests := 5
+	responseCh := make(chan *highestCombination, maxRequests)
+	var results []*highestCombination
+
+	timeout := 50 * time.Millisecond
+	ctx, cancel := context.WithTimeout(context.Background(), timeout)
+	defer cancel()
+
+	for totalRequest < maxRequests {
+		durations := o.comb.Get()
+		if len(durations) == 0 {
+			break
+		}
+
+		totalRequest++
+		go o.getUniqueBids(responseCh, durations)
+	}
+
+	for !isTimedOutORReceivedAllResponses {
+		select {
+		case <-ctx.Done():
+			isTimedOutORReceivedAllResponses = true
+		case hbc := <-responseCh:
+			responseCount++
+			if nil != hbc {
+				results = append(results, hbc)
+			}
+			if responseCount == totalRequest {
+				isTimedOutORReceivedAllResponses = true
+			}
+		}
+	}
+
+	go cleanupResponseChannel(responseCh, totalRequest-responseCount)
+
+	if 0 == len(results) {
+		return nil
+	}
+
+	//Get Max Response
+	var maxResult *highestCombination
+	for _, result := range results {
+		if nil == maxResult || maxResult.price < result.price {
+			maxResult = result
+		}
+
+		for _, rc := range result.filteredBids {
+			if CTVRCDidNotGetChance == rc.bid.FilterReasonCode {
+				rc.bid.FilterReasonCode = rc.reasonCode
+			}
+		}
+	}
+
+	adpodBid := &AdPodBid{
+		Bids:    maxResult.bids[:],
+		Price:   maxResult.price,
+		ADomain: make([]string, 0),
+		Cat:     make([]string, 0),
+	}
+
+	//Get Unique Domains
+	for domain := range maxResult.domainScore {
+		adpodBid.ADomain = append(adpodBid.ADomain, domain)
+	}
+
+	//Get Unique Categories
+	for cat := range maxResult.categoryScore {
+		adpodBid.Cat = append(adpodBid.Cat, cat)
+	}
+
+	return adpodBid
+}
+
+func cleanupResponseChannel(responseCh <-chan *highestCombination, responseCount int) {
+	for responseCount > 0 {
+		<-responseCh
+		responseCount--
+	}
+}
+
+func (o *AdPodGenerator) getUniqueBids(responseCh chan<- *highestCombination, durationSequence []int) {
+	data := [][]*Bid{}
+	combinations := []int{}
+
+	uniqueDuration := 0
+	for index, duration := range durationSequence {
+		if 0 != index && durationSequence[index-1] == duration {
+			combinations[uniqueDuration-1]++
+			continue
+		}
+		data = append(data, o.buckets[duration][:])
+		combinations = append(combinations, 1)
+		uniqueDuration++
+	}
+	hbc := findUniqueCombinations(data[:], combinations[:], *o.adpod.IABCategoryExclusionPercent, *o.adpod.AdvertiserExclusionPercent)
+	responseCh <- hbc
+}
+
+func findUniqueCombinations(data [][]*Bid, combination []int, maxCategoryScore, maxDomainScore int) *highestCombination {
+	// number of arrays
+	n := len(combination)
+	totalBids := 0
+	//  to keep track of next element in each of the n arrays
+	// indices is initialized
+	indices := make([][]int, len(combination))
+	for i := 0; i < len(combination); i++ {
+		indices[i] = make([]int, combination[i])
+		for j := 0; j < combination[i]; j++ {
+			indices[i][j] = j
+			totalBids++
+		}
+	}
+
+	hc := &highestCombination{}
+	var ehc *highestCombination
+	var rc FilterReasonCode
+	inext, jnext := n-1, 0
+	var filterBids []filteredBids
+
+	// maintain highest price combination
+	for true {
+
+		ehc, inext, jnext, rc = evaluate(data[:], indices[:], totalBids, maxCategoryScore, maxDomainScore)
+		if nil != ehc {
+			if nil == hc || hc.price < ehc.price {
+				hc = ehc
+			} else {
+				// if you see current combination price lower than the highest one then break the loop
+				break
+			}
+		} else {
+			//Filtered Bid
+			filterBids = append(filterBids, filteredBids{bid: data[inext][indices[inext][jnext]], reasonCode: rc})
+		}
+
+		if -1 == inext {
+			inext, jnext = n-1, 0
+		}
+
+		// find the rightmost array that has more
+		// elements left after the current element
+		// in that array
+		inext, jnext := n-1, 0
+
+		for inext >= 0 {
+			jnext = len(indices[inext]) - 1
+			for jnext >= 0 && (indices[inext][jnext]+1 > (len(data[inext]) - len(indices[inext]) + jnext)) {
+				jnext--
+			}
+			if jnext >= 0 {
+				break
+			}
+			inext--
+		}
+
+		// no such array is found so no more combinations left
+		if inext < 0 {
+			break
+		}
+
+		// if found move to next element in that array
+		indices[inext][jnext]++
+
+		// for all arrays to the right of this
+		// array current index again points to
+		// first element
+		jnext++
+		for i := inext; i < len(combination); i++ {
+			for j := jnext; j < combination[i]; j++ {
+				if i == inext {
+					indices[i][j] = indices[i][j-1] + 1
+				} else {
+					indices[i][j] = j
+				}
+			}
+			jnext = 0
+		}
+	}
+
+	//setting filteredBids
+	if nil != hc {
+		hc.filteredBids = filterBids[:]
+	}
+	return hc
+}
+
+func evaluate(bids [][]*Bid, indices [][]int, totalBids int, maxCategoryScore, maxDomainScore int) (*highestCombination, int, int, FilterReasonCode) {
+
+	hbc := &highestCombination{
+		bids:          make([]*Bid, totalBids),
+		price:         0,
+		categoryScore: make(map[string]int),
+		domainScore:   make(map[string]int),
+	}
+	pos := 0
+
+	for inext := range indices {
+		for jnext := range indices[inext] {
+			bid := bids[inext][indices[inext][jnext]]
+
+			hbc.bids[pos] = bid
+			pos++
+
+			//Price
+			hbc.price = hbc.price + bid.Price
+
+			//Categories
+			for _, cat := range bid.Cat {
+				hbc.categoryScore[cat]++
+				if (hbc.categoryScore[cat] * 100 / totalBids) > maxCategoryScore {
+					return nil, inext, jnext, CTVRCCategoryExclusion
+				}
+			}
+
+			//Domain
+			for _, domain := range bid.ADomain {
+				hbc.domainScore[domain]++
+				if (hbc.domainScore[domain] * 100 / totalBids) > maxDomainScore {
+					return nil, inext, jnext, CTVRCDomainExclusion
+				}
+			}
+		}
+	}
+
+	return hbc, -1, -1, CTVRCWinningBid
+}
diff --git a/endpoints/openrtb2/ctv/response/adpod_generator.go b/endpoints/openrtb2/ctv/response/adpod_generator.go
new file mode 100644
index 000000000..cd8447c22
--- /dev/null
+++ b/endpoints/openrtb2/ctv/response/adpod_generator.go
@@ -0,0 +1,386 @@
+package response
+
+import (
+	"fmt"
+	"sync"
+	"time"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/combination"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/constant"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/types"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/util"
+	"github.com/prebid/prebid-server/metrics"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+/********************* AdPodGenerator Functions *********************/
+
+// IAdPodGenerator interface for generating AdPod from Ads
+type IAdPodGenerator interface {
+	GetAdPodBids() *types.AdPodBid
+}
+type filteredBid struct {
+	bid    *types.Bid
+	status constant.BidStatus
+}
+type highestCombination struct {
+	bids              []*types.Bid
+	bidIDs            []string
+	durations         []int
+	price             float64
+	categoryScore     map[string]int
+	domainScore       map[string]int
+	filteredBids      map[string]*filteredBid
+	timeTakenCompExcl time.Duration // time taken by comp excl
+	timeTakenCombGen  time.Duration // time taken by combination generator
+	nDealBids         int
+}
+
+// AdPodGenerator AdPodGenerator
+type AdPodGenerator struct {
+	IAdPodGenerator
+	request  *openrtb2.BidRequest
+	impIndex int
+	buckets  types.BidsBuckets
+	comb     combination.ICombination
+	adpod    *openrtb_ext.VideoAdPod
+	met      metrics.MetricsEngine
+}
+
+// NewAdPodGenerator will generate adpod based on configuration
+func NewAdPodGenerator(request *openrtb2.BidRequest, impIndex int, buckets types.BidsBuckets, comb combination.ICombination, adpod *openrtb_ext.VideoAdPod, met metrics.MetricsEngine) *AdPodGenerator {
+	return &AdPodGenerator{
+		request:  request,
+		impIndex: impIndex,
+		buckets:  buckets,
+		comb:     comb,
+		adpod:    adpod,
+		met:      met,
+	}
+}
+
+// GetAdPodBids will return Adpod based on configurations
+func (o *AdPodGenerator) GetAdPodBids() *types.AdPodBid {
+	defer util.TimeTrack(time.Now(), fmt.Sprintf("Tid:%v ImpId:%v adpodgenerator", o.request.ID, o.request.Imp[o.impIndex].ID))
+
+	results := o.getAdPodBids(10 * time.Millisecond)
+	adpodBid := o.getMaxAdPodBid(results)
+
+	return adpodBid
+}
+
+func (o *AdPodGenerator) cleanup(wg *sync.WaitGroup, responseCh chan *highestCombination) {
+	defer func() {
+		close(responseCh)
+		for extra := range responseCh {
+			if nil != extra {
+				util.Logf("Tid:%v ImpId:%v Delayed Response Durations:%v Bids:%v", o.request.ID, o.request.Imp[o.impIndex].ID, extra.durations, extra.bidIDs)
+			}
+		}
+	}()
+	wg.Wait()
+}
+
+func (o *AdPodGenerator) getAdPodBids(timeout time.Duration) []*highestCombination {
+	start := time.Now()
+	defer util.TimeTrack(start, fmt.Sprintf("Tid:%v ImpId:%v getAdPodBids", o.request.ID, o.request.Imp[o.impIndex].ID))
+
+	maxRoutines := 3
+	isTimedOutORReceivedAllResponses := false
+	results := []*highestCombination{}
+	responseCh := make(chan *highestCombination, maxRoutines)
+	wg := new(sync.WaitGroup) // ensures each step generating impressions is finished
+	lock := sync.Mutex{}
+	ticker := time.NewTicker(timeout)
+
+	combinationCount := 0
+	for i := 0; i < maxRoutines; i++ {
+		wg.Add(1)
+		go func() {
+			for !isTimedOutORReceivedAllResponses {
+				combGenStartTime := time.Now()
+				lock.Lock()
+				durations := o.comb.Get()
+				lock.Unlock()
+				combGenElapsedTime := time.Since(combGenStartTime)
+
+				if len(durations) == 0 {
+					break
+				}
+				hbc := o.getUniqueBids(durations)
+				hbc.timeTakenCombGen = combGenElapsedTime
+				responseCh <- hbc
+				util.Logf("Tid:%v GetUniqueBids Durations:%v Price:%v DealBids:%v Time:%v Bids:%v", o.request.ID, hbc.durations[:], hbc.price, hbc.nDealBids, hbc.timeTakenCompExcl, hbc.bidIDs[:])
+			}
+			wg.Done()
+		}()
+	}
+
+	// ensure impressions channel is closed
+	// when all go routines are executed
+	go o.cleanup(wg, responseCh)
+
+	totalTimeByCombGen := int64(0)
+	totalTimeByCompExcl := int64(0)
+	for !isTimedOutORReceivedAllResponses {
+		select {
+		case hbc, ok := <-responseCh:
+
+			if false == ok {
+				isTimedOutORReceivedAllResponses = true
+				break
+			}
+			if nil != hbc {
+				combinationCount++
+				totalTimeByCombGen += int64(hbc.timeTakenCombGen)
+				totalTimeByCompExcl += int64(hbc.timeTakenCompExcl)
+				results = append(results, hbc)
+			}
+		case <-ticker.C:
+			isTimedOutORReceivedAllResponses = true
+			util.Logf("Tid:%v ImpId:%v GetAdPodBids Timeout Reached %v", o.request.ID, o.request.Imp[o.impIndex].ID, timeout)
+		}
+	}
+
+	defer ticker.Stop()
+
+	labels := metrics.PodLabels{
+		AlgorithmName:    string(constant.CombinationGeneratorV1),
+		NoOfCombinations: new(int),
+	}
+	*labels.NoOfCombinations = combinationCount
+	o.met.RecordPodCombGenTime(labels, time.Duration(totalTimeByCombGen))
+
+	compExclLabels := metrics.PodLabels{
+		AlgorithmName:    string(constant.CompetitiveExclusionV1),
+		NoOfResponseBids: new(int),
+	}
+	*compExclLabels.NoOfResponseBids = 0
+	for _, ads := range o.buckets {
+		*compExclLabels.NoOfResponseBids += len(ads)
+	}
+	o.met.RecordPodCompititveExclusionTime(compExclLabels, time.Duration(totalTimeByCompExcl))
+
+	return results[:]
+}
+
+func (o *AdPodGenerator) getMaxAdPodBid(results []*highestCombination) *types.AdPodBid {
+	if 0 == len(results) {
+		util.Logf("Tid:%v ImpId:%v NoBid", o.request.ID, o.request.Imp[o.impIndex].ID)
+		return nil
+	}
+
+	//Get Max Response
+	var maxResult *highestCombination
+	for _, result := range results {
+		for _, rc := range result.filteredBids {
+			if constant.StatusOK == rc.bid.Status {
+				rc.bid.Status = rc.status
+			}
+		}
+		if len(result.bidIDs) == 0 {
+			continue
+		}
+
+		if nil == maxResult ||
+			(maxResult.nDealBids < result.nDealBids) ||
+			(maxResult.nDealBids == result.nDealBids && maxResult.price < result.price) {
+			maxResult = result
+		}
+	}
+
+	if nil == maxResult {
+		util.Logf("Tid:%v ImpId:%v All Combination Filtered in Ad Exclusion", o.request.ID, o.request.Imp[o.impIndex].ID)
+		return nil
+	}
+
+	adpodBid := &types.AdPodBid{
+		Bids:    maxResult.bids[:],
+		Price:   maxResult.price,
+		ADomain: make([]string, 0),
+		Cat:     make([]string, 0),
+	}
+
+	//Get Unique Domains
+	for domain := range maxResult.domainScore {
+		adpodBid.ADomain = append(adpodBid.ADomain, domain)
+	}
+
+	//Get Unique Categories
+	for cat := range maxResult.categoryScore {
+		adpodBid.Cat = append(adpodBid.Cat, cat)
+	}
+
+	util.Logf("Tid:%v ImpId:%v Selected Durations:%v Price:%v Bids:%v", o.request.ID, o.request.Imp[o.impIndex].ID, maxResult.durations[:], maxResult.price, maxResult.bidIDs[:])
+
+	return adpodBid
+}
+
+func (o *AdPodGenerator) getUniqueBids(durationSequence []int) *highestCombination {
+	startTime := time.Now()
+	data := [][]*types.Bid{}
+	combinations := []int{}
+
+	defer util.TimeTrack(startTime, fmt.Sprintf("Tid:%v ImpId:%v getUniqueBids:%v", o.request.ID, o.request.Imp[o.impIndex].ID, durationSequence))
+
+	uniqueDuration := 0
+	for index, duration := range durationSequence {
+		if 0 != index && durationSequence[index-1] == duration {
+			combinations[uniqueDuration-1]++
+			continue
+		}
+		data = append(data, o.buckets[duration][:])
+		combinations = append(combinations, 1)
+		uniqueDuration++
+	}
+	hbc := findUniqueCombinations(data[:], combinations[:], *o.adpod.IABCategoryExclusionPercent, *o.adpod.AdvertiserExclusionPercent)
+	hbc.durations = durationSequence[:]
+	hbc.timeTakenCompExcl = time.Since(startTime)
+
+	return hbc
+}
+
+func findUniqueCombinations(data [][]*types.Bid, combination []int, maxCategoryScore, maxDomainScore int) *highestCombination {
+	// number of arrays
+	n := len(combination)
+	totalBids := 0
+	//  to keep track of next element in each of the n arrays
+	// indices is initialized
+	indices := make([][]int, len(combination))
+	for i := 0; i < len(combination); i++ {
+		indices[i] = make([]int, combination[i])
+		for j := 0; j < combination[i]; j++ {
+			indices[i][j] = j
+			totalBids++
+		}
+	}
+
+	hc := &highestCombination{}
+	var ehc *highestCombination
+	var rc constant.BidStatus
+	inext, jnext := n-1, 0
+	filterBids := map[string]*filteredBid{}
+
+	// maintain highest price combination
+	for true {
+
+		ehc, inext, jnext, rc = evaluate(data[:], indices[:], totalBids, maxCategoryScore, maxDomainScore)
+		if nil != ehc {
+			if nil == hc || (hc.nDealBids == ehc.nDealBids && hc.price < ehc.price) || (hc.nDealBids < ehc.nDealBids) {
+				hc = ehc
+			} else {
+				// if you see current combination price lower than the highest one then break the loop
+				break
+			}
+		} else {
+			//Filtered Bid
+			for i := 0; i <= inext; i++ {
+				for j := 0; j < combination[i] && !(i == inext && j > jnext); j++ {
+					bid := data[i][indices[i][j]]
+					if _, ok := filterBids[bid.ID]; !ok {
+						filterBids[bid.ID] = &filteredBid{bid: bid, status: rc}
+					}
+				}
+			}
+		}
+
+		if -1 == inext {
+			inext, jnext = n-1, 0
+		}
+
+		// find the rightmost array that has more
+		// elements left after the current element
+		// in that array
+		inext, jnext := n-1, 0
+
+		for inext >= 0 {
+			jnext = len(indices[inext]) - 1
+			for jnext >= 0 && (indices[inext][jnext]+1 > (len(data[inext]) - len(indices[inext]) + jnext)) {
+				jnext--
+			}
+			if jnext >= 0 {
+				break
+			}
+			inext--
+		}
+
+		// no such array is found so no more combinations left
+		if inext < 0 {
+			break
+		}
+
+		// if found move to next element in that array
+		indices[inext][jnext]++
+
+		// for all arrays to the right of this
+		// array current index again points to
+		// first element
+		jnext++
+		for i := inext; i < len(combination); i++ {
+			for j := jnext; j < combination[i]; j++ {
+				if i == inext {
+					indices[i][j] = indices[i][j-1] + 1
+				} else {
+					indices[i][j] = j
+				}
+			}
+			jnext = 0
+		}
+	}
+
+	//setting filteredBids
+	if nil != filterBids {
+		hc.filteredBids = filterBids
+	}
+	return hc
+}
+
+func evaluate(bids [][]*types.Bid, indices [][]int, totalBids int, maxCategoryScore, maxDomainScore int) (*highestCombination, int, int, constant.BidStatus) {
+
+	hbc := &highestCombination{
+		bids:          make([]*types.Bid, totalBids),
+		bidIDs:        make([]string, totalBids),
+		price:         0,
+		categoryScore: make(map[string]int),
+		domainScore:   make(map[string]int),
+		nDealBids:     0,
+	}
+	pos := 0
+
+	for inext := range indices {
+		for jnext := range indices[inext] {
+			bid := bids[inext][indices[inext][jnext]]
+
+			hbc.bids[pos] = bid
+			hbc.bidIDs[pos] = bid.ID
+			pos++
+
+			//nDealBids
+			if bid.DealTierSatisfied {
+				hbc.nDealBids++
+			}
+
+			//Price
+			hbc.price = hbc.price + bid.Price
+
+			//Categories
+			for _, cat := range bid.Cat {
+				hbc.categoryScore[cat]++
+				if hbc.categoryScore[cat] > 1 && (hbc.categoryScore[cat]*100/totalBids) > maxCategoryScore {
+					return nil, inext, jnext, constant.StatusCategoryExclusion
+				}
+			}
+
+			//Domain
+			for _, domain := range bid.ADomain {
+				hbc.domainScore[domain]++
+				if hbc.domainScore[domain] > 1 && (hbc.domainScore[domain]*100/totalBids) > maxDomainScore {
+					return nil, inext, jnext, constant.StatusDomainExclusion
+				}
+			}
+		}
+	}
+
+	return hbc, -1, -1, constant.StatusWinningBid
+}
diff --git a/endpoints/openrtb2/ctv/response/adpod_generator_test.go b/endpoints/openrtb2/ctv/response/adpod_generator_test.go
new file mode 100644
index 000000000..54cdce7c3
--- /dev/null
+++ b/endpoints/openrtb2/ctv/response/adpod_generator_test.go
@@ -0,0 +1,397 @@
+package response
+
+import (
+	"sort"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/constant"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/types"
+)
+
+func Test_findUniqueCombinations(t *testing.T) {
+	type args struct {
+		data             [][]*types.Bid
+		combination      []int
+		maxCategoryScore int
+		maxDomainScore   int
+	}
+	tests := []struct {
+		name string
+		args args
+		want *highestCombination
+	}{
+		{
+			name: "sample",
+			args: args{
+				data: [][]*types.Bid{
+					{
+						{
+							Bid:               &openrtb2.Bid{ID: "3-ed72b572-ba62-4220-abba-c19c0bf6346b", Price: 6.339115524232314},
+							DealTierSatisfied: true,
+						},
+						{
+							Bid:               &openrtb2.Bid{ID: "4-ed72b572-ba62-4220-abba-c19c0bf6346b", Price: 3.532468782358357},
+							DealTierSatisfied: true,
+						},
+						{
+							Bid:               &openrtb2.Bid{ID: "7-VIDEO12-89A1-41F1-8708-978FD3C0912A", Price: 5},
+							DealTierSatisfied: false,
+						},
+						{
+							Bid:               &openrtb2.Bid{ID: "8-VIDEO12-89A1-41F1-8708-978FD3C0912A", Price: 5},
+							DealTierSatisfied: false,
+						},
+					}, //20
+
+					{
+						{
+							Bid:               &openrtb2.Bid{ID: "2-ed72b572-ba62-4220-abba-c19c0bf6346b", Price: 3.4502433547413878},
+							DealTierSatisfied: true,
+						},
+						{
+							Bid:               &openrtb2.Bid{ID: "1-ed72b572-ba62-4220-abba-c19c0bf6346b", Price: 3.329644588311827},
+							DealTierSatisfied: true,
+						},
+						{
+							Bid:               &openrtb2.Bid{ID: "5-VIDEO12-89A1-41F1-8708-978FD3C0912A", Price: 5},
+							DealTierSatisfied: false,
+						},
+						{
+							Bid:               &openrtb2.Bid{ID: "6-VIDEO12-89A1-41F1-8708-978FD3C0912A", Price: 5},
+							DealTierSatisfied: false,
+						},
+					}, //25
+				},
+
+				combination:      []int{2, 2},
+				maxCategoryScore: 100,
+				maxDomainScore:   100,
+			},
+			want: &highestCombination{
+				bidIDs:    []string{"3-ed72b572-ba62-4220-abba-c19c0bf6346b", "4-ed72b572-ba62-4220-abba-c19c0bf6346b", "2-ed72b572-ba62-4220-abba-c19c0bf6346b", "1-ed72b572-ba62-4220-abba-c19c0bf6346b"},
+				price:     16.651472249643884,
+				nDealBids: 4,
+			},
+		},
+		// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got := findUniqueCombinations(tt.args.data, tt.args.combination, tt.args.maxCategoryScore, tt.args.maxDomainScore)
+			assert.Equal(t, tt.want.bidIDs, got.bidIDs, "bidIDs")
+			assert.Equal(t, tt.want.nDealBids, got.nDealBids, "nDealBids")
+			assert.Equal(t, tt.want.price, got.price, "price")
+		})
+	}
+}
+
+func TestAdPodGenerator_getMaxAdPodBid(t *testing.T) {
+	type fields struct {
+		request  *openrtb2.BidRequest
+		impIndex int
+	}
+	type args struct {
+		results []*highestCombination
+	}
+	tests := []struct {
+		name   string
+		fields fields
+		args   args
+		want   *types.AdPodBid
+	}{
+		{
+			name: `EmptyResults`,
+			fields: fields{
+				request:  &openrtb2.BidRequest{ID: `req-1`, Imp: []openrtb2.Imp{{ID: `imp-1`}}},
+				impIndex: 0,
+			},
+			args: args{
+				results: nil,
+			},
+			want: nil,
+		},
+		{
+			name: `AllBidsFiltered`,
+			fields: fields{
+				request:  &openrtb2.BidRequest{ID: `req-1`, Imp: []openrtb2.Imp{{ID: `imp-1`}}},
+				impIndex: 0,
+			},
+			args: args{
+				results: []*highestCombination{
+					{
+						filteredBids: map[string]*filteredBid{
+							`bid-1`: {bid: &types.Bid{Bid: &openrtb2.Bid{ID: `bid-1`}}, status: constant.StatusCategoryExclusion},
+							`bid-2`: {bid: &types.Bid{Bid: &openrtb2.Bid{ID: `bid-2`}}, status: constant.StatusCategoryExclusion},
+							`bid-3`: {bid: &types.Bid{Bid: &openrtb2.Bid{ID: `bid-3`}}, status: constant.StatusCategoryExclusion},
+						},
+					},
+				},
+			},
+			want: nil,
+		},
+		{
+			name: `SingleResponse`,
+			fields: fields{
+				request:  &openrtb2.BidRequest{ID: `req-1`, Imp: []openrtb2.Imp{{ID: `imp-1`}}},
+				impIndex: 0,
+			},
+			args: args{
+				results: []*highestCombination{
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-1`}},
+							{Bid: &openrtb2.Bid{ID: `bid-2`}},
+							{Bid: &openrtb2.Bid{ID: `bid-3`}},
+						},
+						bidIDs:    []string{`bid-1`, `bid-2`, `bid-3`},
+						price:     20,
+						nDealBids: 0,
+						categoryScore: map[string]int{
+							`cat-1`: 1,
+							`cat-2`: 1,
+						},
+						domainScore: map[string]int{
+							`domain-1`: 1,
+							`domain-2`: 1,
+						},
+						filteredBids: map[string]*filteredBid{
+							`bid-4`: {bid: &types.Bid{Bid: &openrtb2.Bid{ID: `bid-4`}}, status: constant.StatusCategoryExclusion},
+						},
+					},
+				},
+			},
+			want: &types.AdPodBid{
+				Bids: []*types.Bid{
+					{Bid: &openrtb2.Bid{ID: `bid-1`}},
+					{Bid: &openrtb2.Bid{ID: `bid-2`}},
+					{Bid: &openrtb2.Bid{ID: `bid-3`}},
+				},
+				Cat:     []string{`cat-1`, `cat-2`},
+				ADomain: []string{`domain-1`, `domain-2`},
+				Price:   20,
+			},
+		},
+		{
+			name: `MultiResponse-AllNonDealBids`,
+			fields: fields{
+				request:  &openrtb2.BidRequest{ID: `req-1`, Imp: []openrtb2.Imp{{ID: `imp-1`}}},
+				impIndex: 0,
+			},
+			args: args{
+				results: []*highestCombination{
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-11`}},
+						},
+						bidIDs:    []string{`bid-11`},
+						price:     10,
+						nDealBids: 0,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-21`}},
+						},
+						bidIDs:    []string{`bid-21`},
+						price:     20,
+						nDealBids: 0,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-31`}},
+						},
+						bidIDs:    []string{`bid-31`},
+						price:     10,
+						nDealBids: 0,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-41`}},
+						},
+						bidIDs:    []string{`bid-41`},
+						price:     15,
+						nDealBids: 0,
+					},
+				},
+			},
+			want: &types.AdPodBid{
+				Bids: []*types.Bid{
+					{Bid: &openrtb2.Bid{ID: `bid-21`}},
+				},
+				Cat:     []string{},
+				ADomain: []string{},
+				Price:   20,
+			},
+		},
+		{
+			name: `MultiResponse-AllDealBids-SameCount`,
+			fields: fields{
+				request:  &openrtb2.BidRequest{ID: `req-1`, Imp: []openrtb2.Imp{{ID: `imp-1`}}},
+				impIndex: 0,
+			},
+			args: args{
+				results: []*highestCombination{
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-11`}},
+						},
+						bidIDs:    []string{`bid-11`},
+						price:     10,
+						nDealBids: 1,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-21`}},
+						},
+						bidIDs:    []string{`bid-21`},
+						price:     20,
+						nDealBids: 1,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-31`}},
+						},
+						bidIDs:    []string{`bid-31`},
+						price:     10,
+						nDealBids: 1,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-41`}},
+						},
+						bidIDs:    []string{`bid-41`},
+						price:     15,
+						nDealBids: 1,
+					},
+				},
+			},
+			want: &types.AdPodBid{
+				Bids: []*types.Bid{
+					{Bid: &openrtb2.Bid{ID: `bid-21`}},
+				},
+				Cat:     []string{},
+				ADomain: []string{},
+				Price:   20,
+			},
+		},
+		{
+			name: `MultiResponse-AllDealBids-DifferentCount`,
+			fields: fields{
+				request:  &openrtb2.BidRequest{ID: `req-1`, Imp: []openrtb2.Imp{{ID: `imp-1`}}},
+				impIndex: 0,
+			},
+			args: args{
+				results: []*highestCombination{
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-11`}},
+						},
+						bidIDs:    []string{`bid-11`},
+						price:     10,
+						nDealBids: 2,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-21`}},
+						},
+						bidIDs:    []string{`bid-21`},
+						price:     20,
+						nDealBids: 1,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-31`}},
+						},
+						bidIDs:    []string{`bid-31`},
+						price:     10,
+						nDealBids: 3,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-41`}},
+						},
+						bidIDs:    []string{`bid-41`},
+						price:     15,
+						nDealBids: 2,
+					},
+				},
+			},
+			want: &types.AdPodBid{
+				Bids: []*types.Bid{
+					{Bid: &openrtb2.Bid{ID: `bid-31`}},
+				},
+				Cat:     []string{},
+				ADomain: []string{},
+				Price:   10,
+			},
+		},
+		{
+			name: `MultiResponse-Mixed-DealandNonDealBids`,
+			fields: fields{
+				request:  &openrtb2.BidRequest{ID: `req-1`, Imp: []openrtb2.Imp{{ID: `imp-1`}}},
+				impIndex: 0,
+			},
+			args: args{
+				results: []*highestCombination{
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-11`}},
+						},
+						bidIDs:    []string{`bid-11`},
+						price:     10,
+						nDealBids: 2,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-21`}},
+						},
+						bidIDs:    []string{`bid-21`},
+						price:     20,
+						nDealBids: 0,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-31`}},
+						},
+						bidIDs:    []string{`bid-31`},
+						price:     10,
+						nDealBids: 3,
+					},
+					{
+						bids: []*types.Bid{
+							{Bid: &openrtb2.Bid{ID: `bid-41`}},
+						},
+						bidIDs:    []string{`bid-41`},
+						price:     15,
+						nDealBids: 0,
+					},
+				},
+			},
+			want: &types.AdPodBid{
+				Bids: []*types.Bid{
+					{Bid: &openrtb2.Bid{ID: `bid-31`}},
+				},
+				Cat:     []string{},
+				ADomain: []string{},
+				Price:   10,
+			},
+		},
+		// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			o := &AdPodGenerator{
+				request:  tt.fields.request,
+				impIndex: tt.fields.impIndex,
+			}
+			got := o.getMaxAdPodBid(tt.args.results)
+			if nil != got {
+				sort.Strings(got.ADomain)
+				sort.Strings(got.Cat)
+			}
+			assert.Equal(t, tt.want, got)
+		})
+	}
+}
diff --git a/endpoints/openrtb2/ctv/response/adpod_generator_test.go.bak b/endpoints/openrtb2/ctv/response/adpod_generator_test.go.bak
new file mode 100644
index 000000000..fa3590a1e
--- /dev/null
+++ b/endpoints/openrtb2/ctv/response/adpod_generator_test.go.bak
@@ -0,0 +1,124 @@
+package ctv
+
+/*
+func (o *AdPodGenerator) getUniqueBids(responseCh chan<- *highestCombination, durationSequence []int) {
+	data := [][]*Bid{}
+	combinations := []int{}
+
+	for index, duration := range durationSequence {
+		data[index] = o.buckets[duration][:]
+	}
+
+	responseCh <- findUniqueCombinations(data[:], *o.adpod.IABCategoryExclusionPercent, *o.adpod.AdvertiserExclusionPercent)
+}
+*/
+
+// Todo: this function is still returning (B3 B4) and (B4 B3), need to work on it
+// func findUniqueCombinations(arr [][]Bid) ([][]Bid) {
+func findUniqueCombinationsOld(arr [][]*Bid, maxCategoryScore, maxDomainScore int) *highestCombination {
+	// number of arrays
+	n := len(arr)
+	//  to keep track of next element in each of the n arrays
+	indices := make([]int, n)
+	// indices is initialized with all zeros
+
+	// maintain highest price combination
+	var ehc *highestCombination
+	var rc FilterReasonCode
+	next := n - 1
+	hc := &highestCombination{price: 0}
+	for true {
+
+		row := []*Bid{}
+		// We do not want the same bid to appear twice in a combination
+		bidsInRow := make(map[string]bool)
+		good := true
+
+		for i := 0; i < n; i++ {
+			if _, present := bidsInRow[arr[i][indices[i]].ID]; !present {
+				row = append(row, arr[i][indices[i]])
+				bidsInRow[arr[i][indices[i]].ID] = true
+			} else {
+				good = false
+				break
+			}
+		}
+
+		if good {
+			// output = append(output, row)
+			// give a call for exclusion checking here only
+			ehc, next, rc = evaluateOld(row, maxCategoryScore, maxDomainScore)
+			if nil != ehc {
+				if nil == hc || hc.price < ehc.price {
+					hc = ehc
+				} else {
+					// if you see current combination price lower than the highest one then break the loop
+					return hc
+				}
+			} else {
+				arr[next][indices[next]].FilterReasonCode = rc
+			}
+		}
+
+		// find the rightmost array that has more
+		// elements left after the current element
+		// in that array
+		if -1 == next {
+			next = n - 1
+		}
+
+		for next >= 0 && (indices[next]+1 >= len(arr[next])) {
+			next--
+		}
+
+		// no such array is found so no more combinations left
+		if next < 0 {
+			// return output
+			return nil
+		}
+
+		// if found move to next element in that array
+		indices[next]++
+
+		// for all arrays to the right of this
+		// array current index again points to
+		// first element
+		for i := next + 1; i < n; i++ {
+			indices[i] = 0
+		}
+	}
+	// return output
+	return hc
+}
+
+func evaluateOld(bids []*Bid, maxCategoryScore, maxDomainScore int) (*highestCombination, int, FilterReasonCode) {
+
+	hbc := &highestCombination{
+		bids:          bids,
+		price:         0,
+		categoryScore: make(map[string]int),
+		domainScore:   make(map[string]int),
+	}
+
+	totalBids := len(bids)
+
+	for index, bid := range bids {
+		hbc.price = hbc.price + bid.Price
+
+		for _, cat := range bid.Cat {
+			hbc.categoryScore[cat]++
+			if (hbc.categoryScore[cat] * 100 / totalBids) > maxCategoryScore {
+				return nil, index, CTVRCCategoryExclusion
+			}
+		}
+
+		for _, domain := range bid.ADomain {
+			hbc.domainScore[domain]++
+			if (hbc.domainScore[domain] * 100 / totalBids) > maxDomainScore {
+				return nil, index, CTVRCDomainExclusion
+			}
+		}
+	}
+
+	return hbc, -1, CTVRCWinningBid
+}
diff --git a/endpoints/openrtb2/ctv/types/adpod_types.go b/endpoints/openrtb2/ctv/types/adpod_types.go
new file mode 100644
index 000000000..1949dcdf4
--- /dev/null
+++ b/endpoints/openrtb2/ctv/types/adpod_types.go
@@ -0,0 +1,64 @@
+package types
+
+import (
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/constant"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// Bid openrtb bid object with extra parameters
+type Bid struct {
+	*openrtb2.Bid
+	openrtb_ext.ExtBid
+	Duration          int
+	Status            constant.BidStatus
+	DealTierSatisfied bool
+	Seat              string
+}
+
+// ExtCTVBidResponse object for ctv bid resposne object
+type ExtCTVBidResponse struct {
+	openrtb_ext.ExtBidResponse
+	AdPod *BidResponseAdPodExt `json:"adpod,omitempty"`
+}
+
+// BidResponseAdPodExt object for ctv bidresponse adpod object
+type BidResponseAdPodExt struct {
+	Response openrtb2.BidResponse `json:"bidresponse,omitempty"`
+	Config   map[string]*ImpData  `json:"config,omitempty"`
+}
+
+// AdPodBid combination contains ImpBid
+type AdPodBid struct {
+	Bids          []*Bid
+	Price         float64
+	Cat           []string
+	ADomain       []string
+	OriginalImpID string
+	SeatName      string
+}
+
+// AdPodBids combination contains ImpBid
+type AdPodBids []*AdPodBid
+
+// BidsBuckets bids bucket
+type BidsBuckets map[int][]*Bid
+
+// ImpAdPodConfig configuration for creating ads in adpod
+type ImpAdPodConfig struct {
+	ImpID          string `json:"id,omitempty"`
+	SequenceNumber int8   `json:"seq,omitempty"`
+	MinDuration    int64  `json:"minduration,omitempty"`
+	MaxDuration    int64  `json:"maxduration,omitempty"`
+}
+
+// ImpData example
+type ImpData struct {
+	//AdPodGenerator
+	ImpID           string                        `json:"-"`
+	Bid             *AdPodBid                     `json:"-"`
+	VideoExt        *openrtb_ext.ExtVideoAdPod    `json:"vidext,omitempty"`
+	Config          []*ImpAdPodConfig             `json:"imp,omitempty"`
+	BlockedVASTTags map[string][]string           `json:"blockedtags,omitempty"`
+	Error           *openrtb_ext.ExtBidderMessage `json:"ec,omitempty"`
+}
diff --git a/endpoints/openrtb2/ctv/util/util.go b/endpoints/openrtb2/ctv/util/util.go
new file mode 100644
index 000000000..f0ea886cf
--- /dev/null
+++ b/endpoints/openrtb2/ctv/util/util.go
@@ -0,0 +1,141 @@
+package util
+
+import (
+	"encoding/json"
+	"fmt"
+	"math"
+	"sort"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/buger/jsonparser"
+	"github.com/golang/glog"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/constant"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/types"
+	"github.com/prebid/prebid-server/errortypes"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+var (
+	//prebid_ctv_errors
+	UnableToGenerateImpressionsError = &errortypes.AdpodPrefiltering{Message: `prebid_ctv unable to generate impressions for adpod`}
+
+	//prebid_ctv_warnings
+	DurationMismatchWarning      = &openrtb_ext.ExtBidderMessage{Code: errortypes.AdpodPostFilteringWarningCode, Message: `prebid_ctv all bids filtered while matching lineitem duration`}
+	UnableToGenerateAdPodWarning = &openrtb_ext.ExtBidderMessage{Code: errortypes.AdpodPostFilteringWarningCode, Message: `prebid_ctv unable to generate adpod from bids combinations`}
+)
+
+func GetDurationWiseBidsBucket(bids []*types.Bid) types.BidsBuckets {
+	result := types.BidsBuckets{}
+
+	for i, bid := range bids {
+		if constant.StatusOK == bid.Status {
+			result[bid.Duration] = append(result[bid.Duration], bids[i])
+		}
+	}
+
+	for k, v := range result {
+		//sort.Slice(v[:], func(i, j int) bool { return v[i].Price > v[j].Price })
+		sortBids(v[:])
+		result[k] = v
+	}
+
+	return result
+}
+
+func sortBids(bids []*types.Bid) {
+	sort.Slice(bids, func(i, j int) bool {
+		if bids[i].DealTierSatisfied == bids[j].DealTierSatisfied {
+			return bids[i].Price > bids[j].Price
+		}
+		return bids[i].DealTierSatisfied
+	})
+}
+
+// GetDealTierSatisfied ...
+func GetDealTierSatisfied(ext *openrtb_ext.ExtBid) bool {
+	return ext != nil && ext.Prebid != nil && ext.Prebid.DealTierSatisfied
+}
+
+func DecodeImpressionID(id string) (string, int) {
+	index := strings.LastIndex(id, constant.CTVImpressionIDSeparator)
+	if index == -1 {
+		return id, 0
+	}
+
+	sequence, err := strconv.Atoi(id[index+1:])
+	if nil != err || 0 == sequence {
+		return id, 0
+	}
+
+	return id[:index], sequence
+}
+
+func GetCTVImpressionID(impID string, seqNo int) string {
+	return fmt.Sprintf(constant.CTVImpressionIDFormat, impID, seqNo)
+}
+
+func GetUniqueBidID(bidID string, id int) string {
+	return fmt.Sprintf(constant.CTVUniqueBidIDFormat, id, bidID)
+}
+
+var Logf = func(msg string, args ...interface{}) {
+	if glog.V(3) {
+		glog.Infof(msg, args...)
+	}
+	//fmt.Printf(msg+"\n", args...)
+}
+
+func JLogf(msg string, obj interface{}) {
+	if glog.V(3) {
+		data, _ := json.Marshal(obj)
+		glog.Infof("[OPENWRAP] %v:%v", msg, string(data))
+	}
+}
+
+func TimeTrack(start time.Time, name string) {
+	elapsed := time.Since(start)
+	Logf("[TIMETRACK] %s took %s", name, elapsed)
+	//eg: defer TimeTrack(time.Now(), "factorial")
+}
+
+// GetTargeting returns the value of targeting key associated with bidder
+// it is expected that bid.Ext contains prebid.targeting map
+// if value not present or any error occured empty value will be returned
+// along with error.
+func GetTargeting(key openrtb_ext.TargetingKey, bidder openrtb_ext.BidderName, bid openrtb2.Bid) (string, error) {
+	bidderSpecificKey := key.BidderKey(openrtb_ext.BidderName(bidder), 20)
+	return jsonparser.GetString(bid.Ext, "prebid", "targeting", bidderSpecificKey)
+}
+
+// GetNearestDuration will return nearest duration value present in ImpAdPodConfig objects
+// it will return -1 if it doesn't found any match
+func GetNearestDuration(duration int64, config []*types.ImpAdPodConfig) int64 {
+	tmp := int64(-1)
+	diff := int64(math.MaxInt64)
+	for _, c := range config {
+		tdiff := (c.MaxDuration - duration)
+		if tdiff == 0 {
+			tmp = c.MaxDuration
+			break
+		}
+		if tdiff > 0 && tdiff <= diff {
+			tmp = c.MaxDuration
+			diff = tdiff
+		}
+	}
+	return tmp
+}
+
+// ErrToBidderMessage will return error message in ExtBidderMessage format
+func ErrToBidderMessage(err error) *openrtb_ext.ExtBidderMessage {
+	if err == nil {
+		return nil
+	}
+	return &openrtb_ext.ExtBidderMessage{
+		Code:    errortypes.ReadCode(err),
+		Message: err.Error(),
+	}
+}
diff --git a/endpoints/openrtb2/ctv/util/util_test.go b/endpoints/openrtb2/ctv/util/util_test.go
new file mode 100644
index 000000000..b1c4cae55
--- /dev/null
+++ b/endpoints/openrtb2/ctv/util/util_test.go
@@ -0,0 +1,342 @@
+package util
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/types"
+	"github.com/prebid/prebid-server/errortypes"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestDecodeImpressionID(t *testing.T) {
+	type args struct {
+		id string
+	}
+	type want struct {
+		id  string
+		seq int
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "TC1",
+			args: args{id: "impid"},
+			want: want{id: "impid", seq: 0},
+		},
+		{
+			name: "TC2",
+			args: args{id: "impid_1"},
+			want: want{id: "impid", seq: 1},
+		},
+		{
+			name: "TC1",
+			args: args{id: "impid_1_2"},
+			want: want{id: "impid_1", seq: 2},
+		},
+		{
+			name: "TC1",
+			args: args{id: "impid_1_x"},
+			want: want{id: "impid_1_x", seq: 0},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			id, seq := DecodeImpressionID(tt.args.id)
+			assert.Equal(t, tt.want.id, id)
+			assert.Equal(t, tt.want.seq, seq)
+		})
+	}
+}
+
+func TestSortByDealPriority(t *testing.T) {
+
+	type testbid struct {
+		id        string
+		price     float64
+		isDealBid bool
+	}
+
+	testcases := []struct {
+		scenario              string
+		bids                  []testbid
+		expectedBidIDOrdering []string
+	}{
+		/* tests based on truth table */
+		{
+			scenario: "all_deal_bids_do_price_based_sort",
+			bids: []testbid{
+				{id: "DB_$5", price: 5.0, isDealBid: true},   // Deal bid with low price
+				{id: "DB_$10", price: 10.0, isDealBid: true}, // Deal bid with high price
+			},
+			expectedBidIDOrdering: []string{"DB_$10", "DB_$5"}, // sort by price among deal bids
+		},
+		{
+			scenario: "normal_and_deal_bid_mix_case_1",
+			bids: []testbid{
+				{id: "DB_$15", price: 15.0, isDealBid: true}, // Deal bid with low price
+				{id: "B_$30", price: 30.0, isDealBid: false}, // Normal bid with high price
+			},
+			expectedBidIDOrdering: []string{"DB_$15", "B_$30"}, // no sort expected. Deal bid is already 1st in order
+		},
+		{
+			scenario: "normal_and_deal_bid_mix_case_2", // deal bids are not at start position in order
+			bids: []testbid{
+				{id: "B_$30", price: 30.0, isDealBid: false}, // Normal bid with high price
+				{id: "DB_$15", price: 15.0, isDealBid: true}, // Deal bid with low price
+			},
+			expectedBidIDOrdering: []string{"DB_$15", "B_$30"}, // sort based on deal bid
+		},
+		{
+			scenario: "all_normal_bids_sort_by_price_case_1",
+			bids: []testbid{
+				{id: "B_$5", price: 5.0, isDealBid: false},
+				{id: "B_$10", price: 10.0, isDealBid: false},
+			},
+			expectedBidIDOrdering: []string{"B_$10", "B_$5"}, // sort by price
+		},
+		{
+			scenario: "all_normal_bids_sort_by_price_case_2", // already sorted by highest price
+			bids: []testbid{
+				{id: "B_$10", price: 10.0, isDealBid: false},
+				{id: "B_$5", price: 5.0, isDealBid: false},
+			},
+			expectedBidIDOrdering: []string{"B_$10", "B_$5"}, // no sort required as already sorted
+		},
+		/* use cases */
+		{
+			scenario: "deal_bids_with_same_price",
+			bids: []testbid{
+				{id: "DB2_$10", price: 10.0, isDealBid: true},
+				{id: "DB1_$10", price: 10.0, isDealBid: true},
+			},
+			expectedBidIDOrdering: []string{"DB2_$10", "DB1_$10"}, // no sort expected
+		},
+		/* more than 2 Bids testcases */
+		{
+			scenario: "4_bids_with_first_and_last_are_deal_bids",
+			bids: []testbid{
+				{id: "DB_$15", price: 15.0, isDealBid: true}, // deal bid with low CPM than another bid
+				{id: "B_$40", price: 40.0, isDealBid: false}, // normal bid with highest CPM
+				{id: "B_$3", price: 3.0, isDealBid: false},
+				{id: "DB_$20", price: 20.0, isDealBid: true}, // deal bid with high cpm than another deal bid
+			},
+			expectedBidIDOrdering: []string{"DB_$20", "DB_$15", "B_$40", "B_$3"},
+		},
+		{
+			scenario: "deal_bids_and_normal_bids_with_same_price",
+			bids: []testbid{
+				{id: "B1_$7", price: 7.0, isDealBid: false},
+				{id: "DB2_$7", price: 7.0, isDealBid: true},
+				{id: "B3_$7", price: 7.0, isDealBid: false},
+				{id: "DB1_$7", price: 7.0, isDealBid: true},
+				{id: "B2_$7", price: 7.0, isDealBid: false},
+			},
+			expectedBidIDOrdering: []string{"DB2_$7", "DB1_$7", "B1_$7", "B3_$7", "B2_$7"}, // no sort expected
+		},
+	}
+
+	newBid := func(bid testbid) *types.Bid {
+		return &types.Bid{
+			Bid: &openrtb2.Bid{
+				ID:    bid.id,
+				Price: bid.price,
+				//Ext:   json.RawMessage(`{"prebid":{ "dealTierSatisfied" : ` + bid.isDealBid + ` }}`),
+			},
+			DealTierSatisfied: bid.isDealBid,
+		}
+	}
+
+	for _, test := range testcases {
+		// if test.scenario != "deal_bids_and_normal_bids_with_same_price" {
+		// 	continue
+		// }
+		fmt.Println("Scenario : ", test.scenario)
+		bids := []*types.Bid{}
+		for _, bid := range test.bids {
+			bids = append(bids, newBid(bid))
+		}
+		for _, bid := range bids {
+			fmt.Println(bid.ID, ",", bid.Price, ",", bid.DealTierSatisfied)
+		}
+		sortBids(bids[:])
+		fmt.Println("After sort")
+		actual := []string{}
+		for _, bid := range bids {
+			fmt.Println(bid.ID, ",", bid.Price, ", ", bid.DealTierSatisfied)
+			actual = append(actual, bid.ID)
+		}
+		assert.Equal(t, test.expectedBidIDOrdering, actual, test.scenario+" failed")
+		fmt.Println("")
+	}
+}
+
+func TestGetTargeting(t *testing.T) {
+	var tests = []struct {
+		scenario    string // Testcase scenario
+		targeting   string
+		bidder      string
+		key         openrtb_ext.TargetingKey
+		expectValue string
+		expectError bool
+	}{
+		{"no hb_bidder, expect error", "", "", openrtb_ext.HbCategoryDurationKey, "", true},
+		{"hb_bidder present, no key present", `{"x" : "y"}`, "appnexus", openrtb_ext.HbCategoryDurationKey, "", true},
+		{"hb_bidder present, required key present (of length 20)", `{"x" : "y", "hb_pb_cat_dur_appnex" : "5.00_sports_10s"}`, "appnexus", openrtb_ext.HbCategoryDurationKey, "5.00_sports_10s", false},
+	}
+
+	for _, test := range tests {
+		t.Run(test.scenario, func(t *testing.T) {
+			bid := new(openrtb2.Bid)
+			bid.Ext = []byte(`{"prebid" : { "targeting" : ` + test.targeting + `}}`)
+			value, err := GetTargeting(test.key, openrtb_ext.BidderName(test.bidder), *bid)
+			if test.expectError {
+				assert.NotNil(t, err)
+				assert.Empty(t, value)
+			}
+			assert.Equal(t, test.expectValue, value)
+		})
+	}
+}
+
+func TestGetNearestDuration(t *testing.T) {
+	type args struct {
+		duration int64
+		config   []*types.ImpAdPodConfig
+	}
+	tests := []struct {
+		name         string
+		args         args
+		wantDuration int64
+	}{
+		// TODO: Add test cases.
+		{
+			name: "sorted_array_exact_match",
+			args: args{
+				duration: 20,
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 10},
+					{MaxDuration: 20},
+					{MaxDuration: 30},
+					{MaxDuration: 40},
+				},
+			},
+			wantDuration: 20,
+		},
+		{
+			name: "sorted_array_first_element",
+			args: args{
+				duration: 5,
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 10},
+					{MaxDuration: 20},
+					{MaxDuration: 30},
+					{MaxDuration: 40},
+				},
+			},
+			wantDuration: 10,
+		},
+		{
+			name: "sorted_array_not_found",
+			args: args{
+				duration: 45,
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 10},
+					{MaxDuration: 20},
+					{MaxDuration: 30},
+					{MaxDuration: 40},
+				},
+			},
+			wantDuration: -1,
+		},
+		{
+			name: "unsorted_array_exact_match",
+			args: args{
+				duration: 10,
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 40},
+					{MaxDuration: 20},
+					{MaxDuration: 10},
+					{MaxDuration: 30},
+				},
+			},
+			wantDuration: 10,
+		},
+		{
+			name: "unsorted_array_round_to_minimum",
+			args: args{
+				duration: 5,
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 40},
+					{MaxDuration: 20},
+					{MaxDuration: 10},
+					{MaxDuration: 30},
+				},
+			},
+			wantDuration: 10,
+		},
+		{
+			name: "unsorted_array_invalid",
+			args: args{
+				duration: 45,
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 40},
+					{MaxDuration: 20},
+					{MaxDuration: 10},
+					{MaxDuration: 30},
+				},
+			},
+			wantDuration: -1,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			duration := GetNearestDuration(tt.args.duration, tt.args.config)
+			assert.Equal(t, tt.wantDuration, duration)
+		})
+	}
+}
+
+func TestErrToBidderMessage(t *testing.T) {
+	type args struct {
+		err error
+	}
+	tests := []struct {
+		name string
+		args args
+		want *openrtb_ext.ExtBidderMessage
+	}{
+		{
+			name: `nil_check`,
+			args: args{err: nil},
+			want: nil,
+		},
+		{
+			name: `normal_error`,
+			args: args{err: fmt.Errorf(`normal_error`)},
+			want: &openrtb_ext.ExtBidderMessage{
+				Code:    errortypes.UnknownErrorCode,
+				Message: `normal_error`,
+			},
+		},
+		{
+			name: `prebid_ctv_error`,
+			args: args{err: &errortypes.Timeout{Message: `timeout`}},
+			want: &openrtb_ext.ExtBidderMessage{
+				Code:    errortypes.TimeoutErrorCode,
+				Message: `timeout`,
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got := ErrToBidderMessage(tt.args.err)
+			assert.Equal(t, tt.want, got)
+		})
+	}
+}
diff --git a/endpoints/openrtb2/ctv_auction.go b/endpoints/openrtb2/ctv_auction.go
new file mode 100644
index 000000000..a5ee40a49
--- /dev/null
+++ b/endpoints/openrtb2/ctv_auction.go
@@ -0,0 +1,1242 @@
+package openrtb2
+
+import (
+	"context"
+	"encoding/json"
+	"errors"
+	"fmt"
+	"math"
+	"net/http"
+	"net/url"
+	"sort"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/beevik/etree"
+	"github.com/buger/jsonparser"
+	uuid "github.com/gofrs/uuid"
+	"github.com/golang/glog"
+	"github.com/julienschmidt/httprouter"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/openrtb/v19/openrtb3"
+	accountService "github.com/prebid/prebid-server/account"
+	"github.com/prebid/prebid-server/analytics"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/endpoints/events"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/combination"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/constant"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/impressions"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/response"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/types"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/util"
+	"github.com/prebid/prebid-server/errortypes"
+	"github.com/prebid/prebid-server/exchange"
+	"github.com/prebid/prebid-server/gdpr"
+	"github.com/prebid/prebid-server/hooks"
+	"github.com/prebid/prebid-server/hooks/hookexecution"
+	"github.com/prebid/prebid-server/metrics"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/prebid/prebid-server/stored_requests"
+	"github.com/prebid/prebid-server/usersync"
+	"github.com/prebid/prebid-server/util/iputil"
+	"github.com/prebid/prebid-server/util/uuidutil"
+)
+
+// CTV Specific Endpoint
+type ctvEndpointDeps struct {
+	endpointDeps
+	request                   *openrtb2.BidRequest
+	reqExt                    *openrtb_ext.ExtRequestAdPod
+	impData                   []*types.ImpData
+	videoSeats                []*openrtb2.SeatBid //stores pure video impression bids
+	impIndices                map[string]int
+	isAdPodRequest            bool
+	impsExtPrebidBidder       map[string]map[string]map[string]interface{}
+	impPartnerBlockedTagIDMap map[string]map[string][]string
+
+	labels metrics.Labels
+}
+
+// NewCTVEndpoint new ctv endpoint object
+func NewCTVEndpoint(
+	ex exchange.Exchange,
+	validator openrtb_ext.BidderParamValidator,
+	requestsByID stored_requests.Fetcher,
+	videoFetcher stored_requests.Fetcher,
+	accounts stored_requests.AccountFetcher,
+	//categories stored_requests.CategoryFetcher,
+	cfg *config.Configuration,
+	met metrics.MetricsEngine,
+	pbsAnalytics analytics.PBSAnalyticsModule,
+	disabledBidders map[string]string,
+	defReqJSON []byte,
+	bidderMap map[string]openrtb_ext.BidderName) (httprouter.Handle, error) {
+
+	if ex == nil || validator == nil || requestsByID == nil || accounts == nil || cfg == nil || met == nil {
+		return nil, errors.New("NewCTVEndpoint requires non-nil arguments")
+	}
+	defRequest := len(defReqJSON) > 0
+
+	ipValidator := iputil.PublicNetworkIPValidator{
+		IPv4PrivateNetworks: cfg.RequestValidation.IPv4PrivateNetworksParsed,
+		IPv6PrivateNetworks: cfg.RequestValidation.IPv6PrivateNetworksParsed,
+	}
+
+	var uuidGenerator uuidutil.UUIDGenerator
+	return httprouter.Handle((&ctvEndpointDeps{
+		endpointDeps: endpointDeps{
+			uuidGenerator,
+			ex,
+			validator,
+			requestsByID,
+			videoFetcher,
+			accounts,
+			cfg,
+			met,
+			pbsAnalytics,
+			disabledBidders,
+			defRequest,
+			defReqJSON,
+			bidderMap,
+			nil,
+			nil,
+			ipValidator,
+			nil,
+			&hooks.EmptyPlanBuilder{},
+		},
+	}).CTVAuctionEndpoint), nil
+}
+
+func (deps *ctvEndpointDeps) CTVAuctionEndpoint(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
+	defer util.TimeTrack(time.Now(), "CTVAuctionEndpoint")
+
+	var reqWrapper *openrtb_ext.RequestWrapper
+	var request *openrtb2.BidRequest
+	var response *openrtb2.BidResponse
+	var err error
+	var errL []error
+
+	ao := analytics.AuctionObject{
+		LoggableAuctionObject: analytics.LoggableAuctionObject{
+			Context:      r.Context(),
+			Status:       http.StatusOK,
+			Errors:       make([]error, 0),
+			RejectedBids: []analytics.RejectedBid{},
+		},
+	}
+
+	vastUnwrapperEnable := GetContextValueForField(r.Context(), VastUnwrapperEnableKey)
+	util.JLogf("VastUnwrapperEnable", vastUnwrapperEnable)
+
+	// Prebid Server interprets request.tmax to be the maximum amount of time that a caller is willing
+	// to wait for bids. However, tmax may be defined in the Stored Request data.
+	//
+	// If so, then the trip to the backend might use a significant amount of this time.
+	// We can respect timeouts more accurately if we note the *real* start time, and use it
+	// to compute the auction timeout.
+	start := time.Now()
+	//Prebid Stats
+	deps.labels = metrics.Labels{
+		Source:        metrics.DemandUnknown,
+		RType:         metrics.ReqTypeVideo,
+		PubID:         metrics.PublisherUnknown,
+		CookieFlag:    metrics.CookieFlagUnknown,
+		RequestStatus: metrics.RequestStatusOK,
+	}
+	defer func() {
+		deps.metricsEngine.RecordRequest(deps.labels)
+		recordRejectedBids(deps.labels.PubID, ao.LoggableAuctionObject.RejectedBids, deps.metricsEngine)
+		deps.metricsEngine.RecordRequestTime(deps.labels, time.Since(start))
+		deps.analytics.LogAuctionObject(&ao)
+	}()
+
+	hookExecuter := &hookexecution.EmptyHookExecutor{}
+	//Parse ORTB Request and do Standard Validation
+	reqWrapper, _, _, _, _, _, errL = deps.parseRequest(r, &deps.labels, hookExecuter)
+	if errortypes.ContainsFatalError(errL) && writeError(errL, w, &deps.labels) {
+		return
+	}
+	if reqWrapper.RebuildRequestExt() != nil {
+		return
+	}
+	request = reqWrapper.BidRequest
+
+	util.JLogf("Original BidRequest", request) //TODO: REMOVE LOG
+
+	//init
+	deps.init(request)
+
+	//Set Default Values
+	deps.setDefaultValues()
+	util.JLogf("Extensions Request Extension", deps.reqExt)
+	util.JLogf("Extensions ImpData", deps.impData)
+
+	//Validate CTV BidRequest
+	if err := deps.validateBidRequest(); err != nil {
+		errL = append(errL, err...)
+		writeError(errL, w, &deps.labels)
+		return
+	}
+
+	if deps.isAdPodRequest {
+		//Create New BidRequest
+		request = deps.createBidRequest(request)
+		util.JLogf("CTV BidRequest", request) //TODO: REMOVE LOG
+	}
+
+	//Parsing Cookies and Set Stats
+	usersyncs := usersync.ParseCookieFromRequest(r, &(deps.cfg.HostCookie))
+	if request.App != nil {
+		deps.labels.Source = metrics.DemandApp
+		deps.labels.RType = metrics.ReqTypeVideo
+		deps.labels.PubID = getAccountID(request.App.Publisher)
+	} else { //request.Site != nil
+		deps.labels.Source = metrics.DemandWeb
+		if !usersyncs.HasAnyLiveSyncs() {
+			deps.labels.CookieFlag = metrics.CookieFlagNo
+		} else {
+			deps.labels.CookieFlag = metrics.CookieFlagYes
+		}
+		deps.labels.PubID = getAccountID(request.Site.Publisher)
+	}
+	ctx := r.Context()
+
+	// Look up account now that we have resolved the pubID value
+	account, acctIDErrs := accountService.GetAccount(ctx, deps.cfg, deps.accounts, deps.labels.PubID, deps.metricsEngine)
+	if len(acctIDErrs) > 0 {
+		errL = append(errL, acctIDErrs...)
+		writeError(errL, w, &deps.labels)
+		return
+	}
+
+	//Setting Timeout for Request
+	timeout := deps.cfg.AuctionTimeouts.LimitAuctionTimeout(time.Duration(request.TMax) * time.Millisecond)
+	if timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithDeadline(ctx, start.Add(timeout))
+		defer cancel()
+	}
+
+	tcf2Config := gdpr.NewTCF2Config(deps.cfg.GDPR.TCF2, account.GDPR)
+	auctionRequest := exchange.AuctionRequest{
+		BidRequestWrapper: &openrtb_ext.RequestWrapper{BidRequest: request},
+		Account:           *account,
+		UserSyncs:         usersyncs,
+		RequestType:       deps.labels.RType,
+		StartTime:         start,
+		LegacyLabels:      deps.labels,
+		PubID:             deps.labels.PubID,
+		LoggableObject:    &ao.LoggableAuctionObject,
+		HookExecutor:      hookExecuter,
+		TCF2Config:        tcf2Config,
+	}
+
+	response, err = deps.holdAuction(ctx, auctionRequest)
+	exchange.UpdateRejectedBidExt(auctionRequest.LoggableObject)
+	ao.Request = request
+	ao.Response = response
+	if err != nil || nil == response {
+		deps.labels.RequestStatus = metrics.RequestStatusErr
+		w.WriteHeader(http.StatusInternalServerError)
+		fmt.Fprintf(w, "Critical error while running the auction: %v", err)
+		glog.Errorf("/openrtb2/video Critical error: %v", err)
+		ao.Status = http.StatusInternalServerError
+		ao.Errors = append(ao.Errors, err)
+		return
+	}
+	util.JLogf("BidResponse", response) //TODO: REMOVE LOG
+
+	if deps.isAdPodRequest {
+		//Validate Bid Response
+		if err := deps.validateBidResponse(request, response); err != nil {
+			errL = append(errL, err)
+			writeError(errL, w, &deps.labels)
+			return
+		}
+
+		//Create Impression Bids
+		deps.getBids(response)
+
+		//Do AdPod Exclusions
+		bids := deps.doAdPodExclusions()
+
+		//Create Bid Response
+		adPodBidResponse := deps.createAdPodBidResponse(response, bids)
+
+		//Set bid.Ext params - adpod.aprc, prebid.video.duration
+		deps.setBidExtParams()
+
+		deps.recordRejectedAdPodBids(deps.labels.PubID)
+		adPodBidResponse.Ext = deps.getBidResponseExt(response)
+		response = adPodBidResponse
+
+		util.JLogf("CTV BidResponse", response) //TODO: REMOVE LOG
+	}
+	ao.Response = response
+
+	// Response Generation
+	enc := json.NewEncoder(w)
+	enc.SetEscapeHTML(false)
+
+	// Fixes #328
+	w.Header().Set("Content-Type", "application/json")
+
+	// If an error happens when encoding the response, there isn't much we can do.
+	// If we've sent _any_ bytes, then Go would have sent the 200 status code first.
+	// That status code can't be un-sent... so the best we can do is log the error.
+	if err := enc.Encode(response); err != nil {
+		deps.labels.RequestStatus = metrics.RequestStatusNetworkErr
+		ao.Errors = append(ao.Errors, fmt.Errorf("/openrtb2/video Failed to send response: %v", err))
+	}
+}
+
+func (deps *ctvEndpointDeps) holdAuction(ctx context.Context, auctionRequest exchange.AuctionRequest) (*openrtb2.BidResponse, error) {
+	defer util.TimeTrack(time.Now(), fmt.Sprintf("Tid:%v CTVHoldAuction", deps.request.ID))
+
+	//Hold OpenRTB Standard Auction
+	if len(deps.request.Imp) == 0 {
+		//Dummy Response Object
+		return &openrtb2.BidResponse{ID: deps.request.ID}, nil
+	}
+
+	return deps.ex.HoldAuction(ctx, &auctionRequest, nil)
+}
+
+/********************* BidRequest Processing *********************/
+
+func (deps *ctvEndpointDeps) init(req *openrtb2.BidRequest) {
+	deps.request = req
+	deps.impData = make([]*types.ImpData, len(req.Imp))
+	deps.impIndices = make(map[string]int, len(req.Imp))
+
+	for i := range req.Imp {
+		deps.impIndices[req.Imp[i].ID] = i
+		deps.impData[i] = &types.ImpData{}
+	}
+}
+
+func (deps *ctvEndpointDeps) readVideoAdPodExt() (err []error) {
+	for index, imp := range deps.request.Imp {
+		if nil != imp.Video {
+			vidExt := openrtb_ext.ExtVideoAdPod{}
+			if len(imp.Video.Ext) > 0 {
+				errL := json.Unmarshal(imp.Video.Ext, &vidExt)
+				if nil != err {
+					err = append(err, errL)
+					continue
+				}
+
+				imp.Video.Ext = jsonparser.Delete(imp.Video.Ext, constant.CTVAdpod)
+				imp.Video.Ext = jsonparser.Delete(imp.Video.Ext, constant.CTVOffset)
+				if string(imp.Video.Ext) == `{}` {
+					imp.Video.Ext = nil
+				}
+			}
+
+			if nil == vidExt.AdPod {
+				if nil == deps.reqExt {
+					continue
+				}
+				vidExt.AdPod = &openrtb_ext.VideoAdPod{}
+			}
+
+			//Use Request Level Parameters
+			if nil != deps.reqExt {
+				vidExt.AdPod.Merge(&deps.reqExt.VideoAdPod)
+			}
+
+			//Set Default Values
+			vidExt.SetDefaultValue()
+			vidExt.AdPod.SetDefaultAdDurations(imp.Video.MinDuration, imp.Video.MaxDuration)
+
+			deps.impData[index].VideoExt = &vidExt
+		}
+	}
+	return err
+}
+
+func (deps *ctvEndpointDeps) readRequestExtension() (err []error) {
+	if len(deps.request.Ext) > 0 {
+
+		//TODO: use jsonparser library for get adpod and remove that key
+		extAdPod, jsonType, _, errL := jsonparser.Get(deps.request.Ext, constant.CTVAdpod)
+
+		if nil != errL {
+			//parsing error
+			if jsonparser.NotExist != jsonType {
+				//assuming key not present
+				err = append(err, errL)
+				return
+			}
+		} else {
+			deps.reqExt = &openrtb_ext.ExtRequestAdPod{}
+
+			if errL := json.Unmarshal(extAdPod, deps.reqExt); nil != errL {
+				err = append(err, errL)
+				return
+			}
+
+			deps.reqExt.SetDefaultValue()
+		}
+	}
+
+	return
+}
+
+func (deps *ctvEndpointDeps) readExtensions() (err []error) {
+	if errL := deps.readRequestExtension(); nil != errL {
+		err = append(err, errL...)
+	}
+
+	if errL := deps.readVideoAdPodExt(); nil != errL {
+		err = append(err, errL...)
+	}
+	return err
+}
+
+func (deps *ctvEndpointDeps) setIsAdPodRequest() {
+	deps.isAdPodRequest = false
+	for _, data := range deps.impData {
+		if nil != data.VideoExt && nil != data.VideoExt.AdPod {
+			deps.isAdPodRequest = true
+			break
+		}
+	}
+}
+
+// setDefaultValues will set adpod and other default values
+func (deps *ctvEndpointDeps) setDefaultValues() {
+	//read and set extension values
+	deps.readExtensions()
+
+	//set request is adpod request or normal request
+	deps.setIsAdPodRequest()
+
+	if deps.isAdPodRequest {
+		deps.readImpExtensionsAndTags()
+	}
+}
+
+// validateBidRequest will validate AdPod specific mandatory Parameters and returns error
+func (deps *ctvEndpointDeps) validateBidRequest() (err []error) {
+	//validating video extension adpod configurations
+	if nil != deps.reqExt {
+		err = deps.reqExt.Validate()
+	}
+
+	for index, imp := range deps.request.Imp {
+		if nil != imp.Video && nil != deps.impData[index].VideoExt {
+			ext := deps.impData[index].VideoExt
+			if errL := ext.Validate(); nil != errL {
+				err = append(err, errL...)
+			}
+
+			if nil != ext.AdPod {
+				if errL := ext.AdPod.ValidateAdPodDurations(imp.Video.MinDuration, imp.Video.MaxDuration, imp.Video.MaxExtended); nil != errL {
+					err = append(err, errL...)
+				}
+			}
+		}
+
+	}
+	return
+}
+
+// readImpExtensionsAndTags will read the impression extensions
+func (deps *ctvEndpointDeps) readImpExtensionsAndTags() (errs []error) {
+	deps.impsExtPrebidBidder = make(map[string]map[string]map[string]interface{})
+	deps.impPartnerBlockedTagIDMap = make(map[string]map[string][]string) //Initially this will have all tags, eligible tags will be filtered in filterImpsVastTagsByDuration
+
+	for _, imp := range deps.request.Imp {
+		bidderExtBytes, _, _, err := jsonparser.Get(imp.Ext, "prebid", "bidder")
+		if err != nil {
+			errs = append(errs, err)
+			continue
+		}
+		impsExtPrebidBidder := make(map[string]map[string]interface{})
+
+		err = json.Unmarshal(bidderExtBytes, &impsExtPrebidBidder)
+		if err != nil {
+			errs = append(errs, err)
+			continue
+		}
+
+		deps.impPartnerBlockedTagIDMap[imp.ID] = make(map[string][]string)
+
+		for partnerName, partnerExt := range impsExtPrebidBidder {
+			impVastTags, ok := partnerExt["tags"].([]interface{})
+			if !ok {
+				continue
+			}
+
+			for _, tag := range impVastTags {
+				vastTag, ok := tag.(map[string]interface{})
+				if !ok {
+					continue
+				}
+
+				deps.impPartnerBlockedTagIDMap[imp.ID][partnerName] = append(deps.impPartnerBlockedTagIDMap[imp.ID][partnerName], vastTag["tagid"].(string))
+			}
+		}
+
+		deps.impsExtPrebidBidder[imp.ID] = impsExtPrebidBidder
+	}
+
+	return errs
+}
+
+/********************* Creating CTV BidRequest *********************/
+
+// createBidRequest will return new bid request with all things copy from bid request except impression objects
+func (deps *ctvEndpointDeps) createBidRequest(req *openrtb2.BidRequest) *openrtb2.BidRequest {
+	ctvRequest := *req
+
+	//get configurations for all impressions
+	deps.getAllAdPodImpsConfigs()
+
+	//createImpressions
+	ctvRequest.Imp = deps.createImpressions()
+
+	deps.filterImpsVastTagsByDuration(&ctvRequest)
+
+	//TODO: remove adpod extension if not required to send further
+	return &ctvRequest
+}
+
+// filterImpsVastTagsByDuration checks if a Vast tag should be called for a generated impression based on the duration of tag and impression
+func (deps *ctvEndpointDeps) filterImpsVastTagsByDuration(bidReq *openrtb2.BidRequest) {
+
+	for impCount, imp := range bidReq.Imp {
+		index := strings.LastIndex(imp.ID, "_")
+		if index == -1 {
+			continue
+		}
+
+		originalImpID := imp.ID[:index]
+
+		impExtBidder := deps.impsExtPrebidBidder[originalImpID]
+		impExtBidderCopy := make(map[string]map[string]interface{})
+		for partnerName, partnerExt := range impExtBidder {
+			impExtBidderCopy[partnerName] = partnerExt
+		}
+
+		for partnerName, partnerExt := range impExtBidderCopy {
+			if partnerExt["tags"] != nil {
+				impVastTags, ok := partnerExt["tags"].([]interface{})
+				if !ok {
+					continue
+				}
+
+				var compatibleVasts []interface{}
+				for _, tag := range impVastTags {
+					vastTag, ok := tag.(map[string]interface{})
+					if !ok {
+						continue
+					}
+
+					tagDuration := int(vastTag["dur"].(float64))
+					if int(imp.Video.MinDuration) <= tagDuration && tagDuration <= int(imp.Video.MaxDuration) {
+						compatibleVasts = append(compatibleVasts, tag)
+
+						deps.impPartnerBlockedTagIDMap[originalImpID][partnerName] = remove(deps.impPartnerBlockedTagIDMap[originalImpID][partnerName], vastTag["tagid"].(string))
+						if len(deps.impPartnerBlockedTagIDMap[originalImpID][partnerName]) == 0 {
+							delete(deps.impPartnerBlockedTagIDMap[originalImpID], partnerName)
+						}
+					}
+				}
+
+				if len(compatibleVasts) < 1 {
+					delete(impExtBidderCopy, partnerName)
+				} else {
+					impExtBidderCopy[partnerName] = map[string]interface{}{
+						"tags": compatibleVasts,
+					}
+				}
+			}
+		}
+
+		bidderExtBytes, err := json.Marshal(impExtBidderCopy)
+		if err != nil {
+			continue
+		}
+
+		// if imp.ext exists then set prebid.bidder inside it
+		impExt, err := jsonparser.Set(imp.Ext, bidderExtBytes, "prebid", "bidder")
+		if err != nil {
+			continue
+		}
+
+		imp.Ext = impExt
+		bidReq.Imp[impCount] = imp
+	}
+
+	for impID, blockedTags := range deps.impPartnerBlockedTagIDMap {
+		for _, datum := range deps.impData {
+			if datum.ImpID == impID {
+				datum.BlockedVASTTags = blockedTags
+				break
+			}
+		}
+	}
+}
+
+func remove(slice []string, item string) []string {
+	index := -1
+	for i := range slice {
+		if slice[i] == item {
+			index = i
+			break
+		}
+	}
+
+	if index == -1 {
+		return slice
+	}
+
+	return append(slice[:index], slice[index+1:]...)
+}
+
+// getAllAdPodImpsConfigs will return all impression adpod configurations
+func (deps *ctvEndpointDeps) getAllAdPodImpsConfigs() {
+	for index, imp := range deps.request.Imp {
+		if nil == imp.Video || nil == deps.impData[index].VideoExt || nil == deps.impData[index].VideoExt.AdPod {
+			continue
+		}
+		deps.impData[index].ImpID = imp.ID
+
+		config, err := deps.getAdPodImpsConfigs(&imp, deps.impData[index].VideoExt.AdPod)
+		if err != nil {
+			deps.impData[index].Error = util.ErrToBidderMessage(err)
+			continue
+		}
+		deps.impData[index].Config = config[:]
+	}
+}
+
+// getAdPodImpsConfigs will return number of impressions configurations within adpod
+func (deps *ctvEndpointDeps) getAdPodImpsConfigs(imp *openrtb2.Imp, adpod *openrtb_ext.VideoAdPod) ([]*types.ImpAdPodConfig, error) {
+	// monitor
+	start := time.Now()
+	selectedAlgorithm := impressions.SelectAlgorithm(deps.reqExt)
+	impGen := impressions.NewImpressions(imp.Video.MinDuration, imp.Video.MaxDuration, deps.reqExt, adpod, selectedAlgorithm)
+	impRanges := impGen.Get()
+	labels := metrics.PodLabels{AlgorithmName: impressions.MonitorKey[selectedAlgorithm], NoOfImpressions: new(int)}
+
+	//log number of impressions in stats
+	*labels.NoOfImpressions = len(impRanges)
+	deps.metricsEngine.RecordPodImpGenTime(labels, start)
+
+	// check if algorithm has generated impressions
+	if len(impRanges) == 0 {
+		return nil, util.UnableToGenerateImpressionsError
+	}
+
+	config := make([]*types.ImpAdPodConfig, len(impRanges))
+	for i, value := range impRanges {
+		config[i] = &types.ImpAdPodConfig{
+			ImpID:          util.GetCTVImpressionID(imp.ID, i+1),
+			MinDuration:    value[0],
+			MaxDuration:    value[1],
+			SequenceNumber: int8(i + 1), /* Must be starting with 1 */
+		}
+	}
+	return config[:], nil
+}
+
+// createImpressions will create multiple impressions based on adpod configurations
+func (deps *ctvEndpointDeps) createImpressions() []openrtb2.Imp {
+	impCount := 0
+	for _, imp := range deps.impData {
+		if nil == imp.Error {
+			if len(imp.Config) == 0 {
+				impCount = impCount + 1
+			} else {
+				impCount = impCount + len(imp.Config)
+			}
+		}
+	}
+
+	count := 0
+	imps := make([]openrtb2.Imp, impCount)
+	for index, imp := range deps.request.Imp {
+		if nil == deps.impData[index].Error {
+			adPodConfig := deps.impData[index].Config
+			if len(adPodConfig) == 0 {
+				//non adpod request it will be normal video impression
+				imps[count] = imp
+				count++
+			} else {
+				//for adpod request it will create new impression based on configurations
+				for _, config := range adPodConfig {
+					imps[count] = *(newImpression(&imp, config))
+					count++
+				}
+			}
+		}
+	}
+	return imps[:]
+}
+
+// newImpression will clone existing impression object and create video object with ImpAdPodConfig.
+func newImpression(imp *openrtb2.Imp, config *types.ImpAdPodConfig) *openrtb2.Imp {
+	video := *imp.Video
+	video.MinDuration = config.MinDuration
+	video.MaxDuration = config.MaxDuration
+	video.Sequence = config.SequenceNumber
+	video.MaxExtended = 0
+	//TODO: remove video adpod extension if not required
+
+	newImp := *imp
+	newImp.ID = config.ImpID
+	//newImp.BidFloor = 0
+	newImp.Video = &video
+	return &newImp
+}
+
+/********************* Prebid BidResponse Processing *********************/
+
+// validateBidResponse
+func (deps *ctvEndpointDeps) validateBidResponse(req *openrtb2.BidRequest, resp *openrtb2.BidResponse) error {
+	//remove bids withoug cat and adomain
+
+	return nil
+}
+
+// getBids reads bids from bidresponse object
+func (deps *ctvEndpointDeps) getBids(resp *openrtb2.BidResponse) {
+	var vseat *openrtb2.SeatBid
+	result := make(map[string]*types.AdPodBid)
+
+	for i := range resp.SeatBid {
+		seat := resp.SeatBid[i]
+		vseat = nil
+
+		for j := range seat.Bid {
+			bid := &seat.Bid[j]
+
+			if len(bid.ID) == 0 {
+				bidID, err := uuid.NewV4()
+				if nil != err {
+					continue
+				}
+				bid.ID = bidID.String()
+			}
+
+			if bid.Price == 0 {
+				//filter invalid bids
+				continue
+			}
+
+			originalImpID, sequenceNumber := deps.getImpressionID(bid.ImpID)
+			if sequenceNumber < 0 {
+				continue
+			}
+
+			value, err := util.GetTargeting(openrtb_ext.HbCategoryDurationKey, openrtb_ext.BidderName(seat.Seat), *bid)
+			if nil == err {
+				// ignore error
+				addTargetingKey(bid, openrtb_ext.HbCategoryDurationKey, value)
+			}
+
+			value, err = util.GetTargeting(openrtb_ext.HbpbConstantKey, openrtb_ext.BidderName(seat.Seat), *bid)
+			if nil == err {
+				// ignore error
+				addTargetingKey(bid, openrtb_ext.HbpbConstantKey, value)
+			}
+
+			index := deps.impIndices[originalImpID]
+			if len(deps.impData[index].Config) == 0 {
+				//adding pure video bids
+				if vseat == nil {
+					vseat = &openrtb2.SeatBid{
+						Seat:  seat.Seat,
+						Group: seat.Group,
+						Ext:   seat.Ext,
+					}
+					deps.videoSeats = append(deps.videoSeats, vseat)
+				}
+				vseat.Bid = append(vseat.Bid, *bid)
+			} else {
+				//reading extension, ingorning parsing error
+				ext := openrtb_ext.ExtBid{}
+				if nil != bid.Ext {
+					json.Unmarshal(bid.Ext, &ext)
+				}
+
+				//Adding adpod bids
+				impBids, ok := result[originalImpID]
+				if !ok {
+					impBids = &types.AdPodBid{
+						OriginalImpID: originalImpID,
+						SeatName:      string(openrtb_ext.BidderOWPrebidCTV),
+					}
+					result[originalImpID] = impBids
+				}
+
+				if deps.cfg.GenerateBidID == false {
+					//making unique bid.id's per impression
+					bid.ID = util.GetUniqueBidID(bid.ID, len(impBids.Bids)+1)
+				}
+
+				//get duration of creative
+				duration, status := getBidDuration(bid, deps.reqExt, deps.impData[index].Config,
+					deps.impData[index].Config[sequenceNumber-1].MaxDuration)
+
+				impBids.Bids = append(impBids.Bids, &types.Bid{
+					Bid:               bid,
+					ExtBid:            ext,
+					Status:            status,
+					Duration:          int(duration),
+					DealTierSatisfied: util.GetDealTierSatisfied(&ext),
+					Seat:              seat.Seat,
+				})
+			}
+		}
+	}
+
+	//Sort Bids by Price
+	for index, imp := range deps.request.Imp {
+		impBids, ok := result[imp.ID]
+		if ok {
+			//sort bids
+			sort.Slice(impBids.Bids[:], func(i, j int) bool { return impBids.Bids[i].Price > impBids.Bids[j].Price })
+			deps.impData[index].Bid = impBids
+		}
+	}
+}
+
+// getImpressionID will return impression id and sequence number
+func (deps *ctvEndpointDeps) getImpressionID(id string) (string, int) {
+	//get original impression id and sequence number
+	originalImpID, sequenceNumber := util.DecodeImpressionID(id)
+
+	//check originalImpID  present in request or not
+	index, ok := deps.impIndices[originalImpID]
+	if !ok {
+		//if not present check impression id present in request or not
+		_, ok = deps.impIndices[id]
+		if !ok {
+			return id, -1
+		}
+		return originalImpID, 0
+	}
+
+	if sequenceNumber < 0 || sequenceNumber > len(deps.impData[index].Config) {
+		return id, -1
+	}
+
+	return originalImpID, sequenceNumber
+}
+
+// doAdPodExclusions
+func (deps *ctvEndpointDeps) doAdPodExclusions() types.AdPodBids {
+	defer util.TimeTrack(time.Now(), fmt.Sprintf("Tid:%v doAdPodExclusions", deps.request.ID))
+
+	result := types.AdPodBids{}
+	for index := 0; index < len(deps.request.Imp); index++ {
+		bid := deps.impData[index].Bid
+		if nil != bid && len(bid.Bids) > 0 {
+			//TODO: MULTI ADPOD IMPRESSIONS
+			//duration wise buckets sorted
+			buckets := util.GetDurationWiseBidsBucket(bid.Bids[:])
+
+			if len(buckets) == 0 {
+				deps.impData[index].Error = util.DurationMismatchWarning
+				continue
+			}
+
+			//combination generator
+			comb := combination.NewCombination(
+				buckets,
+				uint64(deps.request.Imp[index].Video.MinDuration),
+				uint64(deps.request.Imp[index].Video.MaxDuration),
+				deps.impData[index].VideoExt.AdPod)
+
+			//adpod generator
+			adpodGenerator := response.NewAdPodGenerator(deps.request, index, buckets, comb, deps.impData[index].VideoExt.AdPod, deps.metricsEngine)
+
+			adpodBids := adpodGenerator.GetAdPodBids()
+			if adpodBids == nil {
+				deps.impData[index].Error = util.UnableToGenerateAdPodWarning
+				continue
+			}
+
+			adpodBids.OriginalImpID = bid.OriginalImpID
+			adpodBids.SeatName = bid.SeatName
+			result = append(result, adpodBids)
+		}
+	}
+	return result
+}
+
+/********************* Creating CTV BidResponse *********************/
+
+// createAdPodBidResponse
+func (deps *ctvEndpointDeps) createAdPodBidResponse(resp *openrtb2.BidResponse, adpods types.AdPodBids) *openrtb2.BidResponse {
+	defer util.TimeTrack(time.Now(), fmt.Sprintf("Tid:%v createAdPodBidResponse", deps.request.ID))
+
+	bidResp := &openrtb2.BidResponse{
+		ID:         resp.ID,
+		Cur:        resp.Cur,
+		CustomData: resp.CustomData,
+		SeatBid:    deps.getBidResponseSeatBids(adpods),
+	}
+	return bidResp
+}
+
+func (deps *ctvEndpointDeps) getBidResponseSeatBids(adpods types.AdPodBids) []openrtb2.SeatBid {
+	seats := []openrtb2.SeatBid{}
+
+	//append pure video request seats
+	for _, seat := range deps.videoSeats {
+		seats = append(seats, *seat)
+	}
+
+	var adpodSeat *openrtb2.SeatBid
+	for _, adpod := range adpods {
+		if len(adpod.Bids) == 0 {
+			continue
+		}
+
+		bid := deps.getAdPodBid(adpod)
+		if bid != nil {
+			if nil == adpodSeat {
+				adpodSeat = &openrtb2.SeatBid{
+					Seat: adpod.SeatName,
+				}
+			}
+			adpodSeat.Bid = append(adpodSeat.Bid, *bid.Bid)
+		}
+	}
+	if nil != adpodSeat {
+		seats = append(seats, *adpodSeat)
+	}
+	return seats[:]
+}
+
+// getAdPodBid
+func (deps *ctvEndpointDeps) getAdPodBid(adpod *types.AdPodBid) *types.Bid {
+	bid := types.Bid{
+		Bid: &openrtb2.Bid{},
+	}
+
+	//TODO: Write single for loop to get all details
+	bidID, err := uuid.NewV4()
+	if nil == err {
+		bid.ID = bidID.String()
+	} else {
+		bid.ID = adpod.Bids[0].ID
+	}
+
+	bid.ImpID = adpod.OriginalImpID
+	bid.Price = adpod.Price
+	bid.ADomain = adpod.ADomain[:]
+	bid.Cat = adpod.Cat[:]
+	bid.AdM = *getAdPodBidCreative(deps.request.Imp[deps.impIndices[adpod.OriginalImpID]].Video, adpod, deps.cfg.GenerateBidID)
+	bid.Ext = getAdPodBidExtension(adpod)
+	return &bid
+}
+
+// getAdPodBidCreative get commulative adpod bid details
+func getAdPodBidCreative(video *openrtb2.Video, adpod *types.AdPodBid, generatedBidID bool) *string {
+	doc := etree.NewDocument()
+	vast := doc.CreateElement(constant.VASTElement)
+	sequenceNumber := 1
+	var version float64 = 2.0
+
+	for _, bid := range adpod.Bids {
+		var newAd *etree.Element
+
+		if strings.HasPrefix(bid.AdM, constant.HTTPPrefix) {
+			newAd = etree.NewElement(constant.VASTAdElement)
+			wrapper := newAd.CreateElement(constant.VASTWrapperElement)
+			vastAdTagURI := wrapper.CreateElement(constant.VASTAdTagURIElement)
+			vastAdTagURI.CreateCharData(bid.AdM)
+		} else {
+			adDoc := etree.NewDocument()
+			if err := adDoc.ReadFromString(bid.AdM); err != nil {
+				continue
+			}
+
+			if generatedBidID == false {
+				// adjust bidid in video event trackers and update
+				adjustBidIDInVideoEventTrackers(adDoc, bid.Bid)
+				adm, err := adDoc.WriteToString()
+				if nil != err {
+					util.JLogf("ERROR, %v", err.Error())
+				} else {
+					bid.AdM = adm
+				}
+			}
+
+			vastTag := adDoc.SelectElement(constant.VASTElement)
+
+			//Get Actual VAST Version
+			bidVASTVersion, _ := strconv.ParseFloat(vastTag.SelectAttrValue(constant.VASTVersionAttribute, constant.VASTDefaultVersionStr), 64)
+			version = math.Max(version, bidVASTVersion)
+
+			ads := vastTag.SelectElements(constant.VASTAdElement)
+			if len(ads) > 0 {
+				newAd = ads[0].Copy()
+			}
+		}
+
+		if nil != newAd {
+			//creative.AdId attribute needs to be updated
+			newAd.CreateAttr(constant.VASTSequenceAttribute, fmt.Sprint(sequenceNumber))
+			vast.AddChild(newAd)
+			sequenceNumber++
+		}
+	}
+
+	if int(version) > len(constant.VASTVersionsStr) {
+		version = constant.VASTMaxVersion
+	}
+
+	vast.CreateAttr(constant.VASTVersionAttribute, constant.VASTVersionsStr[int(version)])
+	bidAdM, err := doc.WriteToString()
+	if nil != err {
+		fmt.Printf("ERROR, %v", err.Error())
+		return nil
+	}
+	return &bidAdM
+}
+
+// getAdPodBidExtension get commulative adpod bid details
+func getAdPodBidExtension(adpod *types.AdPodBid) json.RawMessage {
+	bidExt := &openrtb_ext.ExtOWBid{
+		ExtBid: openrtb_ext.ExtBid{
+			Prebid: &openrtb_ext.ExtBidPrebid{
+				Type:  openrtb_ext.BidTypeVideo,
+				Video: &openrtb_ext.ExtBidPrebidVideo{},
+			},
+		},
+		AdPod: &openrtb_ext.BidAdPodExt{
+			RefBids: make([]string, len(adpod.Bids)),
+		},
+	}
+
+	for i, bid := range adpod.Bids {
+		//get unique bid id
+		bidID := bid.ID
+		if bid.ExtBid.Prebid != nil && bid.ExtBid.Prebid.BidId != "" {
+			bidID = bid.ExtBid.Prebid.BidId
+		}
+
+		//adding bid id in adpod.refbids
+		bidExt.AdPod.RefBids[i] = bidID
+
+		//updating exact duration of adpod creative
+		bidExt.Prebid.Video.Duration += int(bid.Duration)
+
+		//setting bid status as winning bid
+		bid.Status = constant.StatusWinningBid
+	}
+	rawExt, _ := json.Marshal(bidExt)
+	return rawExt
+}
+
+// getDurationBasedOnDurationMatchingPolicy will return duration based on durationmatching policy
+func getDurationBasedOnDurationMatchingPolicy(duration int64, policy openrtb_ext.OWVideoAdDurationMatchingPolicy, config []*types.ImpAdPodConfig) (int64, constant.BidStatus) {
+	switch policy {
+	case openrtb_ext.OWExactVideoAdDurationMatching:
+		tmp := util.GetNearestDuration(duration, config)
+		if tmp != duration {
+			return duration, constant.StatusDurationMismatch
+		}
+		//its and valid duration return it with StatusOK
+
+	case openrtb_ext.OWRoundupVideoAdDurationMatching:
+		tmp := util.GetNearestDuration(duration, config)
+		if tmp == -1 {
+			return duration, constant.StatusDurationMismatch
+		}
+		//update duration with nearest one duration
+		duration = tmp
+		//its and valid duration return it with StatusOK
+	}
+
+	return duration, constant.StatusOK
+}
+
+/*
+getBidDuration determines the duration of video ad from given bid.
+it will try to get the actual ad duration returned by the bidder using prebid.video.duration
+if prebid.video.duration not present then uses defaultDuration passed as an argument
+if video lengths matching policy is present for request then it will validate and update duration based on policy
+*/
+func getBidDuration(bid *openrtb2.Bid, reqExt *openrtb_ext.ExtRequestAdPod, config []*types.ImpAdPodConfig, defaultDuration int64) (int64, constant.BidStatus) {
+
+	// C1: Read it from bid.ext.prebid.video.duration field
+	duration, err := jsonparser.GetInt(bid.Ext, "prebid", "video", "duration")
+	if nil != err || duration <= 0 {
+		// incase if duration is not present use impression duration directly as it is
+		return defaultDuration, constant.StatusOK
+	}
+
+	// C2: Based on video lengths matching policy validate and return duration
+	if nil != reqExt && len(reqExt.VideoAdDurationMatching) > 0 {
+		return getDurationBasedOnDurationMatchingPolicy(duration, reqExt.VideoAdDurationMatching, config)
+	}
+
+	//default return duration which is present in bid.ext.prebid.vide.duration field
+	return duration, constant.StatusOK
+}
+
+func addTargetingKey(bid *openrtb2.Bid, key openrtb_ext.TargetingKey, value string) error {
+	if nil == bid {
+		return errors.New("Invalid bid")
+	}
+
+	raw, err := jsonparser.Set(bid.Ext, []byte(strconv.Quote(value)), "prebid", "targeting", string(key))
+	if nil == err {
+		bid.Ext = raw
+	}
+	return err
+}
+
+func adjustBidIDInVideoEventTrackers(doc *etree.Document, bid *openrtb2.Bid) {
+	// adjusment: update bid.id with ctv module generated bid.id
+	creatives := events.FindCreatives(doc)
+	for _, creative := range creatives {
+		trackingEvents := creative.FindElements("TrackingEvents/Tracking")
+		if nil != trackingEvents {
+			// update bidid= value with ctv generated bid id for this bid
+			for _, trackingEvent := range trackingEvents {
+				u, e := url.Parse(trackingEvent.Text())
+				if nil == e {
+					values, e := url.ParseQuery(u.RawQuery)
+					// only do replacment if operId=8
+					if nil == e && nil != values["bidid"] && nil != values["operId"] && values["operId"][0] == "8" {
+						values.Set("bidid", bid.ID)
+					} else {
+						continue
+					}
+
+					//OTT-183: Fix
+					if nil != values["operId"] && values["operId"][0] == "8" {
+						operID := values.Get("operId")
+						values.Del("operId")
+						values.Add("_operId", operID) // _ (underscore) will keep it as first key
+					}
+
+					u.RawQuery = values.Encode() // encode sorts query params by key. _ must be first (assuing no other query param with _)
+					// replace _operId with operId
+					u.RawQuery = strings.ReplaceAll(u.RawQuery, "_operId", "operId")
+					trackingEvent.SetText(u.String())
+				}
+			}
+		}
+	}
+}
+
+// ConvertAPRCToNBRC converts the aprc to NonBidStatusCode
+func ConvertAPRCToNBRC(bidStatus int64) *openrtb3.NonBidStatusCode {
+	var nbrCode openrtb3.NonBidStatusCode
+
+	switch bidStatus {
+	case constant.StatusOK:
+		nbrCode = openrtb3.LossBidLostToHigherBid
+	case constant.StatusCategoryExclusion:
+		nbrCode = openrtb3.LossBidCategoryExclusions
+	case constant.StatusDomainExclusion:
+		nbrCode = openrtb3.LossBidAdvertiserExclusions
+	case constant.StatusDurationMismatch:
+		nbrCode = openrtb3.LossBidInvalidCreative
+
+	default:
+		return nil
+	}
+	return &nbrCode
+}
+
+// recordRejectedAdPodBids records the bids lost in ad-pod auction using metricsEngine
+func (deps *ctvEndpointDeps) recordRejectedAdPodBids(pubID string) {
+
+	for _, imp := range deps.impData {
+		if nil != imp.Bid && len(imp.Bid.Bids) > 0 {
+			for _, bid := range imp.Bid.Bids {
+				if bid.Status != constant.StatusWinningBid {
+					reason := ConvertAPRCToNBRC(bid.Status)
+					if reason == nil {
+						continue
+					}
+					rejReason := strconv.FormatInt(int64(*reason), 10)
+					deps.metricsEngine.RecordRejectedBids(pubID, bid.Seat, rejReason)
+				}
+			}
+		}
+	}
+}
+
+// getBidResponseExt prepare and return the bidresponse extension
+func (deps *ctvEndpointDeps) getBidResponseExt(resp *openrtb2.BidResponse) (data json.RawMessage) {
+
+	var err error
+
+	adpodExt := types.BidResponseAdPodExt{
+		Response: *resp,
+		Config:   make(map[string]*types.ImpData, len(deps.impData)),
+	}
+
+	for index, imp := range deps.impData {
+		if nil != imp.VideoExt && nil != imp.VideoExt.AdPod {
+			adpodExt.Config[deps.request.Imp[index].ID] = imp
+		}
+	}
+
+	//Remove extension parameter
+	adpodExt.Response.Ext = nil
+
+	if resp.Ext == nil {
+		bidResponseExt := &types.ExtCTVBidResponse{
+			AdPod: &adpodExt,
+		}
+
+		data, err = json.Marshal(bidResponseExt)
+		if err != nil {
+			glog.Errorf("JSON Marshal Error: %v", err.Error())
+			return nil
+		}
+	} else {
+		data, err = json.Marshal(adpodExt)
+		if err != nil {
+			glog.Errorf("JSON Marshal Error: %v", err.Error())
+			return nil
+		}
+
+		data, err = jsonparser.Set(resp.Ext, data, constant.CTVAdpod)
+		if err != nil {
+			glog.Errorf("JSONParser Set Error: %v", err.Error())
+			return nil
+		}
+	}
+	return data[:]
+}
+
+// setBidExtParams function sets the prebid.video.duration and adpod.aprc parameters
+func (deps *ctvEndpointDeps) setBidExtParams() {
+
+	for _, imp := range deps.impData {
+		if imp.Bid != nil {
+			for _, bid := range imp.Bid.Bids {
+
+				//update adm
+				//bid.AdM = constant.VASTDefaultTag
+
+				//add duration value
+				raw, err := jsonparser.Set(bid.Ext, []byte(strconv.Itoa(int(bid.Duration))), "prebid", "video", "duration")
+				if nil == err {
+					bid.Ext = raw
+				}
+
+				//add bid filter reason value
+				raw, err = jsonparser.Set(bid.Ext, []byte(strconv.FormatInt(bid.Status, 10)), "adpod", "aprc")
+				if nil == err {
+					bid.Ext = raw
+				}
+			}
+		}
+	}
+}
diff --git a/endpoints/openrtb2/ctv_auction_test.go b/endpoints/openrtb2/ctv_auction_test.go
new file mode 100644
index 000000000..b1e9c8aee
--- /dev/null
+++ b/endpoints/openrtb2/ctv_auction_test.go
@@ -0,0 +1,836 @@
+package openrtb2
+
+import (
+	"encoding/json"
+	"testing"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/constant"
+	"github.com/prebid/prebid-server/endpoints/openrtb2/ctv/types"
+	"github.com/prebid/prebid-server/metrics"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/mock"
+)
+
+func TestAddTargetingKeys(t *testing.T) {
+	var tests = []struct {
+		scenario string // Testcase scenario
+		key      string
+		value    string
+		bidExt   string
+		expect   map[string]string
+	}{
+		{scenario: "key_not_exists", key: "hb_pb_cat_dur", value: "some_value", bidExt: `{"prebid":{"targeting":{}}}`, expect: map[string]string{"hb_pb_cat_dur": "some_value"}},
+		{scenario: "key_already_exists", key: "hb_pb_cat_dur", value: "new_value", bidExt: `{"prebid":{"targeting":{"hb_pb_cat_dur":"old_value"}}}`, expect: map[string]string{"hb_pb_cat_dur": "new_value"}},
+	}
+	for _, test := range tests {
+		t.Run(test.scenario, func(t *testing.T) {
+			bid := new(openrtb2.Bid)
+			bid.Ext = []byte(test.bidExt)
+			key := openrtb_ext.TargetingKey(test.key)
+			assert.Nil(t, addTargetingKey(bid, key, test.value))
+			extBid := openrtb_ext.ExtBid{}
+			json.Unmarshal(bid.Ext, &extBid)
+			assert.Equal(t, test.expect, extBid.Prebid.Targeting)
+		})
+	}
+	assert.Equal(t, "Invalid bid", addTargetingKey(nil, openrtb_ext.HbCategoryDurationKey, "some value").Error())
+}
+
+func TestFilterImpsVastTagsByDuration(t *testing.T) {
+	type inputParams struct {
+		request          *openrtb2.BidRequest
+		generatedRequest *openrtb2.BidRequest
+		impData          []*types.ImpData
+	}
+
+	type output struct {
+		reqs        openrtb2.BidRequest
+		blockedTags []map[string][]string
+	}
+
+	tt := []struct {
+		testName       string
+		input          inputParams
+		expectedOutput output
+	}{
+		{
+			testName: "test_single_impression_single_vast_partner_with_no_excluded_tags",
+			input: inputParams{
+				request: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1", Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder": {"tags": [{"dur": 35,"tagid": "openx_35"}, {"dur": 25,"tagid": "openx_25"}, {"dur": 20,"tagid": "openx_20"}]}}}}`)},
+					},
+				},
+				generatedRequest: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder": {"tags": [{"dur": 35,"tagid": "openx_35"}, {"dur": 25,"tagid": "openx_25"}, {"dur": 20,"tagid": "openx_20"}]}}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder": {"tags": [{"dur": 35,"tagid": "openx_35"}, {"dur": 25,"tagid": "openx_25"}, {"dur": 20,"tagid": "openx_20"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 35}, Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder": {"tags": [{"dur": 35,"tagid": "openx_35"}, {"dur": 25,"tagid": "openx_25"}, {"dur": 20,"tagid": "openx_20"}]}}}}`)},
+					},
+				},
+				impData: []*types.ImpData{},
+			},
+			expectedOutput: output{
+				reqs: openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid": {"bidder": {}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder":{"tags":[{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 35}, Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"}]}}}}`)},
+					},
+				},
+				blockedTags: []map[string][]string{},
+			},
+		},
+		{
+			testName: "test_single_impression_single_vast_partner_with_excluded_tags",
+			input: inputParams{
+				request: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1", Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder": {"tags": [{"dur": 35,"tagid": "openx_35"}, {"dur": 25,"tagid": "openx_25"}, {"dur": 20,"tagid": "openx_20"}]}}}}`)},
+					},
+				},
+				generatedRequest: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder": {"tags": [{"dur": 35,"tagid": "openx_35"}, {"dur": 25,"tagid": "openx_25"}, {"dur": 20,"tagid": "openx_20"}]}}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder": {"tags": [{"dur": 35,"tagid": "openx_35"}, {"dur": 25,"tagid": "openx_25"}, {"dur": 20,"tagid": "openx_20"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 30}, Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder": {"tags": [{"dur": 35,"tagid": "openx_35"}, {"dur": 25,"tagid": "openx_25"}, {"dur": 20,"tagid": "openx_20"}]}}}}`)},
+					},
+				},
+				impData: []*types.ImpData{
+					{ImpID: "imp1"},
+				},
+			},
+			expectedOutput: output{
+				reqs: openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid": {"bidder": {}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder":{"tags":[{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 30}, Ext: []byte(`{"prebid": {"bidder": {"openx_vast_bidder":{"tags":[{"dur":25,"tagid":"openx_25"}]}}}}`)},
+					},
+				},
+				blockedTags: []map[string][]string{
+					{"openx_vast_bidder": []string{"openx_35"}},
+				},
+			},
+		},
+		{
+			testName: "test_single_impression_multiple_vast_partners_no_exclusions",
+			input: inputParams{
+				request: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1", Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":15,"tagid":"spotx_15"},{"dur":25,"tagid":"spotx_25"},{"dur":30,"tagid":"spotx_30"}]},"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+					},
+				},
+				generatedRequest: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":15,"tagid":"spotx_15"},{"dur":25,"tagid":"spotx_25"},{"dur":30,"tagid":"spotx_30"}]},"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":15,"tagid":"spotx_15"},{"dur":25,"tagid":"spotx_25"},{"dur":30,"tagid":"spotx_30"}]},"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":15,"tagid":"spotx_15"},{"dur":25,"tagid":"spotx_25"},{"dur":30,"tagid":"spotx_30"}]},"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+					},
+				},
+				impData: []*types.ImpData{},
+			},
+			expectedOutput: output{
+				reqs: openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid":{"bidder":{}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":20,"tagid":"openx_20"}]},"spotx_vast_bidder":{"tags":[{"dur":15,"tagid":"spotx_15"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":25,"tagid":"openx_25"}]},"spotx_vast_bidder":{"tags":[{"dur":25,"tagid":"spotx_25"},{"dur":30,"tagid":"spotx_30"}]}}}}`)},
+					},
+				},
+				blockedTags: []map[string][]string{},
+			},
+		},
+		{
+			testName: "test_single_impression_multiple_vast_partners_with_exclusions",
+			input: inputParams{
+				request: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1", Ext: []byte(`{"prebid": { "bidder": { "spotx_vast_bidder":{"tags":[{"dur":15,"tagid":"spotx_15"},{"dur":25,"tagid":"spotx_25"},{"dur":35,"tagid":"spotx_35"}]},"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":40,"tagid":"openx_40"}]}}}}`)},
+					},
+				},
+				generatedRequest: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":15,"tagid":"spotx_15"},{"dur":25,"tagid":"spotx_25"},{"dur":35,"tagid":"spotx_35"}]},"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":40,"tagid":"openx_40"}]}}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":15,"tagid":"spotx_15"},{"dur":25,"tagid":"spotx_25"},{"dur":35,"tagid":"spotx_35"}]},"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":40,"tagid":"openx_40"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":15,"tagid":"spotx_15"},{"dur":25,"tagid":"spotx_25"},{"dur":35,"tagid":"spotx_35"}]},"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":40,"tagid":"openx_40"}]}}}}`)},
+					},
+				},
+				impData: []*types.ImpData{
+					{ImpID: "imp1"},
+				},
+			},
+			expectedOutput: output{
+				reqs: openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid":{"bidder":{}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":15,"tagid":"spotx_15"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":25,"tagid":"openx_25"}]},"spotx_vast_bidder":{"tags":[{"dur":25,"tagid":"spotx_25"}]}}}}`)},
+					},
+				},
+				blockedTags: []map[string][]string{
+					{"openx_vast_bidder": []string{"openx_35", "openx_40"}, "spotx_vast_bidder": []string{"spotx_35"}},
+				},
+			},
+		},
+		{
+			testName: "test_multi_impression_multi_partner_no_exclusions",
+			input: inputParams{
+				request: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1", Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp2", Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":30,"tagid":"spotx_30"},{"dur":40,"tagid":"spotx_40"}]}}}}`)},
+					},
+				},
+				generatedRequest: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp2_1", Video: &openrtb2.Video{MinDuration: 5, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":30,"tagid":"spotx_30"},{"dur":40,"tagid":"spotx_40"}]}}}}`)},
+					},
+				},
+				impData: nil,
+			},
+			expectedOutput: output{
+				reqs: openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid":{"bidder":{}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":25,"tagid":"openx_25"}]}}}}`)},
+						{ID: "imp2_1", Video: &openrtb2.Video{MinDuration: 5, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":30,"tagid":"spotx_30"}]}}}}`)},
+					},
+				},
+				blockedTags: nil,
+			},
+		},
+		{
+			testName: "test_multi_impression_multi_partner_with_exclusions",
+			input: inputParams{
+				request: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1", Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp2", Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":30,"tagid":"spotx_30"},{"dur":40,"tagid":"spotx_40"}]}}}}`)},
+					},
+				},
+				generatedRequest: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":35,"tagid":"openx_35"},{"dur":25,"tagid":"openx_25"},{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp2_1", Video: &openrtb2.Video{MinDuration: 5, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":30,"tagid":"spotx_30"},{"dur":40,"tagid":"spotx_40"}]}}}}`)},
+					},
+				},
+				impData: []*types.ImpData{
+					{ImpID: "imp1"},
+					{ImpID: "imp2"},
+				},
+			},
+			expectedOutput: output{
+				reqs: openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1_1", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 10}, Ext: []byte(`{"prebid":{"bidder":{}}}`)},
+						{ID: "imp1_2", Video: &openrtb2.Video{MinDuration: 10, MaxDuration: 20}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":20,"tagid":"openx_20"}]}}}}`)},
+						{ID: "imp1_3", Video: &openrtb2.Video{MinDuration: 25, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"openx_vast_bidder":{"tags":[{"dur":25,"tagid":"openx_25"}]}}}}`)},
+						{ID: "imp2_1", Video: &openrtb2.Video{MinDuration: 5, MaxDuration: 30}, Ext: []byte(`{"prebid":{"bidder":{"spotx_vast_bidder":{"tags":[{"dur":30,"tagid":"spotx_30"}]}}}}`)},
+					},
+				},
+				blockedTags: []map[string][]string{
+					{"openx_vast_bidder": []string{"openx_35"}},
+					{"spotx_vast_bidder": []string{"spotx_40"}},
+				},
+			},
+		},
+	}
+
+	for _, tc := range tt {
+		tc := tc
+		t.Run(tc.testName, func(t *testing.T) {
+			t.Parallel()
+
+			deps := ctvEndpointDeps{request: tc.input.request, impData: tc.input.impData}
+			deps.readImpExtensionsAndTags()
+
+			outputBids := tc.input.generatedRequest
+			deps.filterImpsVastTagsByDuration(outputBids)
+
+			assert.Equal(t, tc.expectedOutput.reqs, *outputBids, "Expected length of impressions array was %d but actual was %d", tc.expectedOutput.reqs, outputBids)
+
+			for i, datum := range deps.impData {
+				assert.Equal(t, tc.expectedOutput.blockedTags[i], datum.BlockedVASTTags, "Expected and actual impData was different")
+			}
+		})
+	}
+}
+
+func TestGetBidDuration(t *testing.T) {
+	type args struct {
+		bid             *openrtb2.Bid
+		reqExt          *openrtb_ext.ExtRequestAdPod
+		config          []*types.ImpAdPodConfig
+		defaultDuration int64
+	}
+	type want struct {
+		duration int64
+		status   constant.BidStatus
+	}
+	var tests = []struct {
+		name   string
+		args   args
+		want   want
+		expect int
+	}{
+		{
+			name: "nil_bid_ext",
+			args: args{
+				bid:             &openrtb2.Bid{},
+				reqExt:          nil,
+				config:          nil,
+				defaultDuration: 100,
+			},
+			want: want{
+				duration: 100,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "use_default_duration",
+			args: args{
+				bid: &openrtb2.Bid{
+					Ext: json.RawMessage(`{"tmp":123}`),
+				},
+				reqExt:          nil,
+				config:          nil,
+				defaultDuration: 100,
+			},
+			want: want{
+				duration: 100,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "invalid_duration_in_bid_ext",
+			args: args{
+				bid: &openrtb2.Bid{
+					Ext: json.RawMessage(`{"prebid":{"video":{"duration":"invalid"}}}`),
+				},
+				reqExt:          nil,
+				config:          nil,
+				defaultDuration: 100,
+			},
+			want: want{
+				duration: 100,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "0sec_duration_in_bid_ext",
+			args: args{
+				bid: &openrtb2.Bid{
+					Ext: json.RawMessage(`{"prebid":{"video":{"duration":0}}}`),
+				},
+				reqExt:          nil,
+				config:          nil,
+				defaultDuration: 100,
+			},
+			want: want{
+				duration: 100,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "negative_duration_in_bid_ext",
+			args: args{
+				bid: &openrtb2.Bid{
+					Ext: json.RawMessage(`{"prebid":{"video":{"duration":-30}}}`),
+				},
+				reqExt:          nil,
+				config:          nil,
+				defaultDuration: 100,
+			},
+			want: want{
+				duration: 100,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "30sec_duration_in_bid_ext",
+			args: args{
+				bid: &openrtb2.Bid{
+					Ext: json.RawMessage(`{"prebid":{"video":{"duration":30}}}`),
+				},
+				reqExt:          nil,
+				config:          nil,
+				defaultDuration: 100,
+			},
+			want: want{
+				duration: 30,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "duration_matching_empty",
+			args: args{
+				bid: &openrtb2.Bid{
+					Ext: json.RawMessage(`{"prebid":{"video":{"duration":30}}}`),
+				},
+				reqExt: &openrtb_ext.ExtRequestAdPod{
+					VideoAdDurationMatching: "",
+				},
+				config:          nil,
+				defaultDuration: 100,
+			},
+			want: want{
+				duration: 30,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "duration_matching_exact",
+			args: args{
+				bid: &openrtb2.Bid{
+					Ext: json.RawMessage(`{"prebid":{"video":{"duration":30}}}`),
+				},
+				reqExt: &openrtb_ext.ExtRequestAdPod{
+					VideoAdDurationMatching: openrtb_ext.OWExactVideoAdDurationMatching,
+				},
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 10},
+					{MaxDuration: 20},
+					{MaxDuration: 30},
+					{MaxDuration: 40},
+				},
+				defaultDuration: 100,
+			},
+			want: want{
+				duration: 30,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "duration_matching_exact_not_present",
+			args: args{
+				bid: &openrtb2.Bid{
+					Ext: json.RawMessage(`{"prebid":{"video":{"duration":35}}}`),
+				},
+				reqExt: &openrtb_ext.ExtRequestAdPod{
+					VideoAdDurationMatching: openrtb_ext.OWExactVideoAdDurationMatching,
+				},
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 10},
+					{MaxDuration: 20},
+					{MaxDuration: 30},
+					{MaxDuration: 40},
+				},
+				defaultDuration: 100,
+			},
+			want: want{
+				duration: 35,
+				status:   constant.StatusDurationMismatch,
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			duration, status := getBidDuration(tt.args.bid, tt.args.reqExt, tt.args.config, tt.args.defaultDuration)
+			assert.Equal(t, tt.want.duration, duration)
+			assert.Equal(t, tt.want.status, status)
+		})
+	}
+}
+
+func Test_getDurationBasedOnDurationMatchingPolicy(t *testing.T) {
+	type args struct {
+		duration int64
+		policy   openrtb_ext.OWVideoAdDurationMatchingPolicy
+		config   []*types.ImpAdPodConfig
+	}
+	type want struct {
+		duration int64
+		status   constant.BidStatus
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "empty_duration_policy",
+			args: args{
+				duration: 10,
+				policy:   "",
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 10},
+					{MaxDuration: 20},
+					{MaxDuration: 30},
+					{MaxDuration: 40},
+				},
+			},
+			want: want{
+				duration: 10,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "policy_exact",
+			args: args{
+				duration: 10,
+				policy:   openrtb_ext.OWExactVideoAdDurationMatching,
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 10},
+					{MaxDuration: 20},
+					{MaxDuration: 30},
+					{MaxDuration: 40},
+				},
+			},
+			want: want{
+				duration: 10,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "policy_exact_didnot_match",
+			args: args{
+				duration: 15,
+				policy:   openrtb_ext.OWExactVideoAdDurationMatching,
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 10},
+					{MaxDuration: 20},
+					{MaxDuration: 30},
+					{MaxDuration: 40},
+				},
+			},
+			want: want{
+				duration: 15,
+				status:   constant.StatusDurationMismatch,
+			},
+		},
+		{
+			name: "policy_roundup_exact",
+			args: args{
+				duration: 20,
+				policy:   openrtb_ext.OWRoundupVideoAdDurationMatching,
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 10},
+					{MaxDuration: 20},
+					{MaxDuration: 30},
+					{MaxDuration: 40},
+				},
+			},
+			want: want{
+				duration: 20,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "policy_roundup",
+			args: args{
+				duration: 25,
+				policy:   openrtb_ext.OWRoundupVideoAdDurationMatching,
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 10},
+					{MaxDuration: 20},
+					{MaxDuration: 30},
+					{MaxDuration: 40},
+				},
+			},
+			want: want{
+				duration: 30,
+				status:   constant.StatusOK,
+			},
+		},
+		{
+			name: "policy_roundup_didnot_match",
+			args: args{
+				duration: 45,
+				policy:   openrtb_ext.OWRoundupVideoAdDurationMatching,
+				config: []*types.ImpAdPodConfig{
+					{MaxDuration: 10},
+					{MaxDuration: 20},
+					{MaxDuration: 30},
+					{MaxDuration: 40},
+				},
+			},
+			want: want{
+				duration: 45,
+				status:   constant.StatusDurationMismatch,
+			},
+		},
+
+		// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			duration, status := getDurationBasedOnDurationMatchingPolicy(tt.args.duration, tt.args.policy, tt.args.config)
+			assert.Equal(t, tt.want.duration, duration)
+			assert.Equal(t, tt.want.status, status)
+		})
+	}
+}
+
+func TestCreateAdPodBidResponse(t *testing.T) {
+	type args struct {
+		resp *openrtb2.BidResponse
+	}
+	type want struct {
+		resp *openrtb2.BidResponse
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "sample bidresponse",
+			args: args{
+				resp: &openrtb2.BidResponse{
+					ID:         "id1",
+					Cur:        "USD",
+					CustomData: "custom",
+				},
+			},
+			want: want{
+				resp: &openrtb2.BidResponse{
+					ID:         "id1",
+					Cur:        "USD",
+					CustomData: "custom",
+					SeatBid:    make([]openrtb2.SeatBid, 0),
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			deps := ctvEndpointDeps{
+				request: &openrtb2.BidRequest{
+					ID: "1",
+				},
+			}
+			actual := deps.createAdPodBidResponse(tt.args.resp, nil)
+			assert.Equal(t, tt.want.resp, actual)
+		})
+
+	}
+}
+
+func TestSetBidExtParams(t *testing.T) {
+	type args struct {
+		impData []*types.ImpData
+	}
+	type want struct {
+		impData []*types.ImpData
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "sample",
+			args: args{
+				impData: []*types.ImpData{
+					{
+						Bid: &types.AdPodBid{
+							Bids: []*types.Bid{
+								{
+									Bid: &openrtb2.Bid{
+										Ext: json.RawMessage(`{"prebid": {"video": {} },"adpod": {}}`),
+									},
+									Duration: 10,
+									Status:   1,
+								},
+							},
+						},
+					},
+				},
+			},
+			want: want{
+				impData: []*types.ImpData{
+					{
+						Bid: &types.AdPodBid{
+							Bids: []*types.Bid{
+								{
+									Bid: &openrtb2.Bid{
+										Ext: json.RawMessage(`{"prebid": {"video": {"duration":10} },"adpod": {"aprc":1}}`),
+									},
+									Duration: 10,
+									Status:   1,
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+
+			deps := ctvEndpointDeps{
+				impData: tt.args.impData,
+			}
+			deps.setBidExtParams()
+			assert.Equal(t, tt.want.impData[0].Bid.Bids[0].Ext, deps.impData[0].Bid.Bids[0].Ext)
+		})
+	}
+}
+
+func TestGetAdPodExt(t *testing.T) {
+	type args struct {
+		resp *openrtb2.BidResponse
+	}
+	type want struct {
+		data json.RawMessage
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "nil-ext",
+			args: args{
+				resp: &openrtb2.BidResponse{
+					ID: "resp1",
+					SeatBid: []openrtb2.SeatBid{
+						{
+							Bid: []openrtb2.Bid{
+								{
+									ID: "b1",
+								},
+								{
+									ID: "b2",
+								},
+							},
+							Seat: "pubmatic",
+						},
+					},
+				},
+			},
+			want: want{
+				data: json.RawMessage(`{"adpod":{"bidresponse":{"id":"resp1","seatbid":[{"bid":[{"id":"b1","impid":"","price":0},{"id":"b2","impid":"","price":0}],"seat":"pubmatic"}]},"config":{"imp1":{"vidext":{"adpod":{}}}}}}`),
+			},
+		},
+		{
+			name: "non-nil-ext",
+			args: args{
+				resp: &openrtb2.BidResponse{
+					ID: "resp1",
+					SeatBid: []openrtb2.SeatBid{
+						{
+							Bid: []openrtb2.Bid{
+								{
+									ID: "b1",
+								},
+								{
+									ID: "b2",
+								},
+							},
+							Seat: "pubmatic",
+						},
+					},
+					Ext: json.RawMessage(`{"xyz":10}`),
+				},
+			},
+			want: want{
+				data: json.RawMessage(`{"xyz":10,"adpod":{"bidresponse":{"id":"resp1","seatbid":[{"bid":[{"id":"b1","impid":"","price":0},{"id":"b2","impid":"","price":0}],"seat":"pubmatic"}]},"config":{"imp1":{"vidext":{"adpod":{}}}}}}`),
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+
+			deps := ctvEndpointDeps{
+				impData: []*types.ImpData{
+					{
+						ImpID: "imp1",
+						VideoExt: &openrtb_ext.ExtVideoAdPod{
+							AdPod: &openrtb_ext.VideoAdPod{},
+						},
+						Bid: &types.AdPodBid{
+							Bids: []*types.Bid{},
+						},
+					},
+				},
+				request: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{
+						{ID: "imp1"},
+					},
+				},
+			}
+			actual := deps.getBidResponseExt(tt.args.resp)
+			assert.Equal(t, string(tt.want.data), string(actual))
+		})
+	}
+}
+
+func TestRecordAdPodRejectedBids(t *testing.T) {
+
+	type args struct {
+		bids types.AdPodBid
+	}
+
+	type want struct {
+		expectedCalls int
+	}
+
+	tests := []struct {
+		description string
+		args        args
+		want        want
+	}{
+		{
+			description: "multiple rejected bids",
+			args: args{
+				bids: types.AdPodBid{
+					Bids: []*types.Bid{
+						{
+							Bid:    &openrtb2.Bid{},
+							Status: constant.StatusCategoryExclusion,
+							Seat:   "pubmatic",
+						},
+						{
+							Bid:    &openrtb2.Bid{},
+							Status: constant.StatusWinningBid,
+							Seat:   "pubmatic",
+						},
+						{
+							Bid:    &openrtb2.Bid{},
+							Status: constant.StatusOK,
+							Seat:   "pubmatic",
+						},
+						{
+							Bid:    &openrtb2.Bid{},
+							Status: 100,
+							Seat:   "pubmatic",
+						},
+					},
+				},
+			},
+			want: want{
+				expectedCalls: 2,
+			},
+		},
+	}
+
+	for _, test := range tests {
+		me := &metrics.MetricsEngineMock{}
+		me.On("RecordRejectedBids", mock.Anything, mock.Anything, mock.Anything).Return()
+
+		deps := ctvEndpointDeps{
+			endpointDeps: endpointDeps{
+				metricsEngine: me,
+			},
+			impData: []*types.ImpData{
+				{
+					Bid: &test.args.bids,
+				},
+			},
+		}
+
+		deps.recordRejectedAdPodBids("pub_001")
+		me.AssertNumberOfCalls(t, "RecordRejectedBids", test.want.expectedCalls)
+	}
+}
diff --git a/endpoints/openrtb2/sample-requests/currency-conversion/custom-rates/valid/origbidcpmusd.json b/endpoints/openrtb2/sample-requests/currency-conversion/custom-rates/valid/origbidcpmusd.json
new file mode 100644
index 000000000..411d6db31
--- /dev/null
+++ b/endpoints/openrtb2/sample-requests/currency-conversion/custom-rates/valid/origbidcpmusd.json
@@ -0,0 +1,76 @@
+{
+  "description": "bid.ext.origbidcpmusd with bid.ext.origbidcpm in USD for wrapper logger and wrapper tracker",
+  "config": {
+    "assertBidExt": true,
+    "currencyRates":{
+      "USD": {
+        "MXN": 20.07
+      },
+      "INR": {
+        "MXN": 0.25
+      }
+    },
+    "mockBidders": [
+      {"bidderName": "pubmatic", "currency": "MXN", "price": 5.00}
+    ]
+  },
+  "mockBidRequest": {
+    "id": "some-request-id",
+    "site": {
+      "page": "test.somepage.com"
+    },
+    "imp": [
+      {
+        "id": "my-imp-id",
+        "video": {
+          "mimes": [
+            "video/mp4"
+          ]
+        },
+        "ext": {
+          "pubmatic": {
+            "placementId": 12883451
+          }
+        }
+      }
+    ],
+    "cur": ["INR"],
+    "ext": {
+      "prebid": {
+        "aliases": {
+          "unknown": "pubmatic"
+        }
+      }
+    }
+  },
+  "expectedBidResponse": {
+      "id":"some-request-id",
+      "bidid":"test bid id",
+      "cur": "INR",
+      "nbr":0,
+      "seatbid": [
+        {
+          "bid": [
+            {
+              "id": "pubmatic-bid",
+              "impid": "my-imp-id",
+              "price": 20,
+              "ext": {
+                "origbidcpm": 5,
+                "origbidcur": "MXN",
+                "prebid": {
+                  "meta": {
+                    "adaptercode": "pubmatic"
+                  },
+                  "type": "banner"
+                },
+                "origbidcpmusd": 0.2491280518186348
+              }
+            }
+          ],
+          "seat": "pubmatic"
+        }
+      ]
+  },
+  "expectedReturnCode": 200
+}
diff --git a/endpoints/openrtb2/sample-requests/hooks/auction_reject_with_error.json b/endpoints/openrtb2/sample-requests/hooks/auction_reject_with_error.json
new file mode 100644
index 000000000..5ca617a46
--- /dev/null
+++ b/endpoints/openrtb2/sample-requests/hooks/auction_reject_with_error.json
@@ -0,0 +1,87 @@
+{
+  "description": "Auction request",
+  "config": {
+    "mockBidders": [
+      {"bidderName": "appnexus", "currency": "USD", "price": 0.00}
+    ]
+  },
+  "mockBidRequest": {
+    "id": "some-request-id",
+    "site": {
+      "page": "prebid.org"
+    },
+    "imp": [
+      {
+        "id": "some-impression-id",
+        "banner": {
+          "format": [
+            {
+              "w": 300,
+              "h": 250
+            }
+          ]
+        },
+        "ext": {
+          "appnexus": {
+            "placementId": 12883451
+          }
+        }
+      }
+    ],
+    "tmax": 500,
+    "test": 1,
+    "ext": {
+      "prebid": {
+        "trace": "verbose"
+      }
+    }
+  },
+  "expectedBidResponse": {
+    "id": "some-request-id",
+    "bidid": "test bid id",
+    "nbr": 123,
+    "ext": {
+      "prebid": {
+        "modules": {
+          "errors": {
+            "foobar": {
+              "foo": [
+                "dummy",
+                "Module foobar (hook: foo) rejected request with code 123 at entrypoint stage"
+              ]
+            }
+          },
+          "trace": {
+            "stages": [
+              {
+                "stage": "entrypoint",
+                "outcomes": [
+                  {
+                    "entity": "http-request",
+                    "groups": [
+                      {
+                        "invocation_results": [
+                          {
+                            "analytics_tags": {},
+                            "hook_id": {
+                              "module_code": "foobar",
+                              "hook_impl_code": "foo"
+                            },
+                            "status": "execution_failure",
+                            "action": "reject",
+                            "message": ""
+                          }
+                        ]
+                      }
+                    ]
+                  }
+                ]
+              }
+            ]
+          }
+        }
+      }
+    }
+  },
+  "expectedReturnCode": 200
+}
diff --git a/endpoints/openrtb2/test_utils.go b/endpoints/openrtb2/test_utils.go
index 814f26112..ba4eb6eb2 100644
--- a/endpoints/openrtb2/test_utils.go
+++ b/endpoints/openrtb2/test_utils.go
@@ -26,6 +26,7 @@ import (
 	"github.com/prebid/prebid-server/errortypes"
 	"github.com/prebid/prebid-server/exchange"
 	"github.com/prebid/prebid-server/experiment/adscert"
+	"github.com/prebid/prebid-server/floors"
 	"github.com/prebid/prebid-server/gdpr"
 	"github.com/prebid/prebid-server/hooks"
 	"github.com/prebid/prebid-server/hooks/hookexecution"
@@ -89,6 +90,7 @@ type testConfigValues struct {
 	CurrencyRates       map[string]map[string]float64 `json:"currencyRates"`
 	MockBidders         []mockBidderHandler           `json:"mockBidders"`
 	RealParamsValidator bool                          `json:"realParamsValidator"`
+	AssertBidExt        bool                          `json:"assertbidext"`
 }
 
 type brokenExchange struct{}
@@ -1211,6 +1213,7 @@ func buildTestExchange(testCfg *testConfigValues, adapterMap map[openrtb_ext.Bid
 		mockCurrencyConverter,
 		mockFetcher,
 		&adscert.NilSigner{},
+		&floors.PriceFloorFetcher{},
 	)
 
 	testExchange = &exchangeTestWrapper{
@@ -1414,6 +1417,7 @@ func (p *fakePermissions) AuctionActivitiesAllowed(ctx context.Context, bidderCo
 type mockPlanBuilder struct {
 	entrypointPlan               hooks.Plan[hookstage.Entrypoint]
 	rawAuctionPlan               hooks.Plan[hookstage.RawAuctionRequest]
+	beforeRequestValidation      hooks.Plan[hookstage.BeforeValidationRequest]
 	processedAuctionPlan         hooks.Plan[hookstage.ProcessedAuctionRequest]
 	bidderRequestPlan            hooks.Plan[hookstage.BidderRequest]
 	rawBidderResponsePlan        hooks.Plan[hookstage.RawBidderResponse]
@@ -1429,6 +1433,10 @@ func (m mockPlanBuilder) PlanForRawAuctionStage(_ string, _ *config.Account) hoo
 	return m.rawAuctionPlan
 }
 
+func (m mockPlanBuilder) PlanForValidationStage(_ string, _ *config.Account) hooks.Plan[hookstage.BeforeValidationRequest] {
+	return m.beforeRequestValidation
+}
+
 func (m mockPlanBuilder) PlanForProcessedAuctionStage(_ string, _ *config.Account) hooks.Plan[hookstage.ProcessedAuctionRequest] {
 	return m.processedAuctionPlan
 }
@@ -1466,6 +1474,7 @@ func makePlan[H any](hook H) hooks.Plan[H] {
 
 type mockRejectionHook struct {
 	nbr int
+	err error
 }
 
 func (m mockRejectionHook) HandleEntrypointHook(
@@ -1473,7 +1482,7 @@ func (m mockRejectionHook) HandleEntrypointHook(
 	_ hookstage.ModuleInvocationContext,
 	_ hookstage.EntrypointPayload,
 ) (hookstage.HookResult[hookstage.EntrypointPayload], error) {
-	return hookstage.HookResult[hookstage.EntrypointPayload]{Reject: true, NbrCode: m.nbr}, nil
+	return hookstage.HookResult[hookstage.EntrypointPayload]{Reject: true, NbrCode: m.nbr}, m.err
 }
 
 func (m mockRejectionHook) HandleRawAuctionHook(
@@ -1481,7 +1490,15 @@ func (m mockRejectionHook) HandleRawAuctionHook(
 	_ hookstage.ModuleInvocationContext,
 	_ hookstage.RawAuctionRequestPayload,
 ) (hookstage.HookResult[hookstage.RawAuctionRequestPayload], error) {
-	return hookstage.HookResult[hookstage.RawAuctionRequestPayload]{Reject: true, NbrCode: m.nbr}, nil
+	return hookstage.HookResult[hookstage.RawAuctionRequestPayload]{Reject: true, NbrCode: m.nbr}, m.err
+}
+
+func (m mockRejectionHook) HandleBeforeValidationHook(
+	_ context.Context,
+	_ hookstage.ModuleInvocationContext,
+	_ hookstage.BeforeValidationRequestPayload,
+) (hookstage.HookResult[hookstage.BeforeValidationRequestPayload], error) {
+	return hookstage.HookResult[hookstage.BeforeValidationRequestPayload]{Reject: true, NbrCode: m.nbr}, nil
 }
 
 func (m mockRejectionHook) HandleProcessedAuctionHook(
@@ -1489,7 +1506,7 @@ func (m mockRejectionHook) HandleProcessedAuctionHook(
 	_ hookstage.ModuleInvocationContext,
 	_ hookstage.ProcessedAuctionRequestPayload,
 ) (hookstage.HookResult[hookstage.ProcessedAuctionRequestPayload], error) {
-	return hookstage.HookResult[hookstage.ProcessedAuctionRequestPayload]{Reject: true, NbrCode: m.nbr}, nil
+	return hookstage.HookResult[hookstage.ProcessedAuctionRequestPayload]{Reject: true, NbrCode: m.nbr}, m.err
 }
 
 func (m mockRejectionHook) HandleBidderRequestHook(
@@ -1503,7 +1520,7 @@ func (m mockRejectionHook) HandleBidderRequestHook(
 		result.NbrCode = m.nbr
 	}
 
-	return result, nil
+	return result, m.err
 }
 
 func (m mockRejectionHook) HandleRawBidderResponseHook(
diff --git a/endpoints/openrtb2/video_auction.go b/endpoints/openrtb2/video_auction.go
index 79ac26149..66b56c598 100644
--- a/endpoints/openrtb2/video_auction.go
+++ b/endpoints/openrtb2/video_auction.go
@@ -119,8 +119,11 @@ func (deps *endpointDeps) VideoAuctionEndpoint(w http.ResponseWriter, r *http.Re
 	start := time.Now()
 
 	vo := analytics.VideoObject{
-		Status:    http.StatusOK,
-		Errors:    make([]error, 0),
+		LoggableAuctionObject: analytics.LoggableAuctionObject{
+			Context: r.Context(),
+			Status:  http.StatusOK,
+			Errors:  make([]error, 0),
+		},
 		StartTime: start,
 	}
 
@@ -306,7 +309,7 @@ func (deps *endpointDeps) VideoAuctionEndpoint(w http.ResponseWriter, r *http.Re
 		LegacyLabels:               labels,
 		GlobalPrivacyControlHeader: secGPC,
 		PubID:                      labels.PubID,
-		HookExecutor:               hookexecution.EmptyHookExecutor{},
+		HookExecutor:               &hookexecution.EmptyHookExecutor{},
 	}
 
 	response, err := deps.ex.HoldAuction(ctx, auctionRequest, &debugLog)
diff --git a/endpoints/openrtb2/video_auction_test.go b/endpoints/openrtb2/video_auction_test.go
index b75a7b99c..490e09d1f 100644
--- a/endpoints/openrtb2/video_auction_test.go
+++ b/endpoints/openrtb2/video_auction_test.go
@@ -850,8 +850,10 @@ func TestHandleError(t *testing.T) {
 
 	for _, tt := range tests {
 		vo := analytics.VideoObject{
-			Status: 200,
-			Errors: make([]error, 0),
+			LoggableAuctionObject: analytics.LoggableAuctionObject{
+				Status: 200,
+				Errors: make([]error, 0),
+			},
 		}
 
 		labels := metrics.Labels{
@@ -984,8 +986,10 @@ func TestParseVideoRequestWithDecodedUserAgentInHeader(t *testing.T) {
 
 func TestHandleErrorDebugLog(t *testing.T) {
 	vo := analytics.VideoObject{
-		Status: 200,
-		Errors: make([]error, 0),
+		LoggableAuctionObject: analytics.LoggableAuctionObject{
+			Status: 200,
+			Errors: make([]error, 0),
+		},
 	}
 
 	labels := metrics.Labels{
@@ -1169,7 +1173,7 @@ func TestVideoAuctionResponseHeaders(t *testing.T) {
 			givenTestFile:  "sample-requests/video/video_valid_sample.json",
 			expectedStatus: 200,
 			expectedHeaders: func(h http.Header) {
-				h.Set("X-Prebid", "pbs-go/unknown")
+				h.Set("X-Prebid", "owpbs-go/unknown")
 				h.Set("Content-Type", "application/json")
 			},
 		}, {
@@ -1177,7 +1181,7 @@ func TestVideoAuctionResponseHeaders(t *testing.T) {
 			givenTestFile:  "sample-requests/video/video_invalid_sample.json",
 			expectedStatus: 500,
 			expectedHeaders: func(h http.Header) {
-				h.Set("X-Prebid", "pbs-go/unknown")
+				h.Set("X-Prebid", "owpbs-go/unknown")
 			},
 		},
 	}
diff --git a/errortypes/code.go b/errortypes/code.go
index c68eb1960..8a6a07c67 100644
--- a/errortypes/code.go
+++ b/errortypes/code.go
@@ -14,6 +14,12 @@ const (
 	NoConversionRateErrorCode
 	MalformedAcctErrorCode
 	ModuleRejectionErrorCode
+
+	// NYC: shall we have different range for OW error codes to avoid change in codes with introduction of new PBS error codes.
+	NoBidPriceErrorCode
+	BidderFailedSchemaValidationErrorCode
+	AdpodPrefilteringErrorCode
+	BidRejectionFloorsErrorCode
 )
 
 // Defines numeric codes for well-known warnings.
@@ -28,6 +34,7 @@ const (
 	AdServerTargetingWarningCode
 	BidAdjustmentWarningCode
 	FloorBidRejectionWarningCode
+	AdpodPostFilteringWarningCode
 )
 
 // Coder provides an error or warning code with severity.
diff --git a/errortypes/errortypes.go b/errortypes/errortypes.go
index d93075b7c..3235b6d71 100644
--- a/errortypes/errortypes.go
+++ b/errortypes/errortypes.go
@@ -200,3 +200,73 @@ func (err *Warning) Code() int {
 func (err *Warning) Severity() Severity {
 	return SeverityWarning
 }
+
+// BidderFailedSchemaValidation is used at the request validation step,
+// when the bidder parameters fail the schema validation, we want to
+// continue processing the request and still return an error message.
+type BidderFailedSchemaValidation struct {
+	Message string
+}
+
+func (err *BidderFailedSchemaValidation) Error() string {
+	return err.Message
+}
+
+func (err *BidderFailedSchemaValidation) Code() int {
+	return BidderFailedSchemaValidationErrorCode
+}
+
+func (err *BidderFailedSchemaValidation) Severity() Severity {
+	return SeverityWarning
+}
+
+// NoBidPrice should be used when vast response doesn't contain any price value
+type NoBidPrice struct {
+	Message string
+}
+
+func (err *NoBidPrice) Error() string {
+	return err.Message
+}
+
+func (err *NoBidPrice) Code() int {
+	return NoBidPriceErrorCode
+}
+
+func (err *NoBidPrice) Severity() Severity {
+	return SeverityWarning
+}
+
+// AdpodPrefiltering should be used when ctv impression algorithm not able to generate impressions
+type AdpodPrefiltering struct {
+	Message string
+}
+
+func (err *AdpodPrefiltering) Error() string {
+	return err.Message
+}
+
+func (err *AdpodPrefiltering) Code() int {
+	return AdpodPrefilteringErrorCode
+}
+
+func (err *AdpodPrefiltering) Severity() Severity {
+	return SeverityFatal
+}
+
+// AdpodPostFiltering should be used when vast response doesn't contain any price value
+type AdpodPostFiltering struct {
+	Message string
+}
+
+func (err *AdpodPostFiltering) Error() string {
+	return err.Message
+}
+
+func (err *AdpodPostFiltering) Code() int {
+	return AdpodPostFilteringWarningCode
+}
+
+func (err *AdpodPostFiltering) Severity() Severity {
+	return SeverityWarning
+}
diff --git a/errortypes/errortypes_test.go b/errortypes/errortypes_test.go
new file mode 100644
index 000000000..a17f4d0f6
--- /dev/null
+++ b/errortypes/errortypes_test.go
@@ -0,0 +1,188 @@
+package errortypes
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+)
+
+func TestErrors(t *testing.T) {
+	type args struct {
+		err error
+	}
+	type want struct {
+		errorMessage string
+		code         int
+		severity     Severity
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: `normal_error`,
+			args: args{
+				err: fmt.Errorf(`normal_error`),
+			},
+			want: want{
+				errorMessage: `normal_error`,
+				code:         UnknownErrorCode,
+				severity:     SeverityUnknown,
+			},
+		},
+		{
+			name: `Timeout`,
+			args: args{
+				err: &Timeout{Message: `Timeout_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `Timeout_ErrorMessage`,
+				code:         TimeoutErrorCode,
+				severity:     SeverityFatal,
+			},
+		},
+		{
+			name: `BadInput`,
+			args: args{
+				err: &BadInput{Message: `BadInput_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `BadInput_ErrorMessage`,
+				code:         BadInputErrorCode,
+				severity:     SeverityFatal,
+			},
+		},
+		{
+			name: `BlacklistedApp`,
+			args: args{
+				err: &BlacklistedApp{Message: `BlacklistedApp_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `BlacklistedApp_ErrorMessage`,
+				code:         BlacklistedAppErrorCode,
+				severity:     SeverityFatal,
+			},
+		},
+		{
+			name: `BlacklistedAcct`,
+			args: args{
+				err: &BlacklistedAcct{Message: `BlacklistedAcct_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `BlacklistedAcct_ErrorMessage`,
+				code:         BlacklistedAcctErrorCode,
+				severity:     SeverityFatal,
+			},
+		},
+		{
+			name: `AcctRequired`,
+			args: args{
+				err: &AcctRequired{Message: `AcctRequired_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `AcctRequired_ErrorMessage`,
+				code:         AcctRequiredErrorCode,
+				severity:     SeverityFatal,
+			},
+		},
+		{
+			name: `BadServerResponse`,
+			args: args{
+				err: &BadServerResponse{Message: `BadServerResponse_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `BadServerResponse_ErrorMessage`,
+				code:         BadServerResponseErrorCode,
+				severity:     SeverityFatal,
+			},
+		},
+		{
+			name: `FailedToRequestBids`,
+			args: args{
+				err: &FailedToRequestBids{Message: `FailedToRequestBids_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `FailedToRequestBids_ErrorMessage`,
+				code:         FailedToRequestBidsErrorCode,
+				severity:     SeverityFatal,
+			},
+		},
+		{
+			name: `BidderTemporarilyDisabled`,
+			args: args{
+				err: &BidderTemporarilyDisabled{Message: `BidderTemporarilyDisabled_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `BidderTemporarilyDisabled_ErrorMessage`,
+				code:         BidderTemporarilyDisabledErrorCode,
+				severity:     SeverityWarning,
+			},
+		},
+		{
+			name: `Warning`,
+			args: args{
+				err: &Warning{Message: `Warning_ErrorMessage`, WarningCode: UnknownWarningCode},
+			},
+			want: want{
+				errorMessage: `Warning_ErrorMessage`,
+				code:         UnknownWarningCode,
+				severity:     SeverityWarning,
+			},
+		},
+		{
+			name: `BidderFailedSchemaValidation`,
+			args: args{
+				err: &BidderFailedSchemaValidation{Message: `BidderFailedSchemaValidation_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `BidderFailedSchemaValidation_ErrorMessage`,
+				code:         BidderFailedSchemaValidationErrorCode,
+				severity:     SeverityWarning,
+			},
+		},
+		{
+			name: `NoBidPrice`,
+			args: args{
+				err: &NoBidPrice{Message: `NoBidPrice_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `NoBidPrice_ErrorMessage`,
+				code:         NoBidPriceErrorCode,
+				severity:     SeverityWarning,
+			},
+		},
+		{
+			name: `AdpodPrefiltering`,
+			args: args{
+				err: &AdpodPrefiltering{Message: `AdpodPrefiltering_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `AdpodPrefiltering_ErrorMessage`,
+				code:         AdpodPrefilteringErrorCode,
+				severity:     SeverityFatal,
+			},
+		},
+		{
+			name: `AdpodPostFiltering`,
+			args: args{
+				err: &AdpodPostFiltering{Message: `AdpodPostFiltering_ErrorMessage`},
+			},
+			want: want{
+				errorMessage: `AdpodPostFiltering_ErrorMessage`,
+				code:         AdpodPostFilteringWarningCode,
+				severity:     SeverityWarning,
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			assert.Equal(t, tt.want.errorMessage, tt.args.err.Error())
+			if code, ok := tt.args.err.(Coder); ok {
+				assert.Equal(t, tt.want.code, code.Code())
+				assert.Equal(t, tt.want.severity, code.Severity())
+			}
+		})
+	}
+}
diff --git a/exchange/adapter_builders.go b/exchange/adapter_builders.go
index e2b3af821..30fd370b8 100755
--- a/exchange/adapter_builders.go
+++ b/exchange/adapter_builders.go
@@ -145,6 +145,7 @@ import (
 	"github.com/prebid/prebid-server/adapters/smilewanted"
 	"github.com/prebid/prebid-server/adapters/sonobi"
 	"github.com/prebid/prebid-server/adapters/sovrn"
+	"github.com/prebid/prebid-server/adapters/spotx"
 	"github.com/prebid/prebid-server/adapters/sspBC"
 	"github.com/prebid/prebid-server/adapters/stroeerCore"
 	"github.com/prebid/prebid-server/adapters/suntContent"
@@ -158,6 +159,7 @@ import (
 	"github.com/prebid/prebid-server/adapters/undertone"
 	"github.com/prebid/prebid-server/adapters/unicorn"
 	"github.com/prebid/prebid-server/adapters/unruly"
+	"github.com/prebid/prebid-server/adapters/vastbidder"
 	"github.com/prebid/prebid-server/adapters/videobyte"
 	"github.com/prebid/prebid-server/adapters/videoheroes"
 	"github.com/prebid/prebid-server/adapters/vidoomy"
@@ -334,6 +336,7 @@ func newAdapterBuilders() map[openrtb_ext.BidderName]adapters.Builder {
 		openrtb_ext.BidderSonobi:            sonobi.Builder,
 		openrtb_ext.BidderSovrn:             sovrn.Builder,
 		openrtb_ext.BidderSspBC:             sspBC.Builder,
+		openrtb_ext.BidderSpotX:             spotx.Builder,
 		openrtb_ext.BidderStreamkey:         adtelligent.Builder,
 		openrtb_ext.BidderSuntContent:       suntContent.Builder,
 		openrtb_ext.BidderStroeerCore:       stroeerCore.Builder,
@@ -349,6 +352,7 @@ func newAdapterBuilders() map[openrtb_ext.BidderName]adapters.Builder {
 		openrtb_ext.BidderUndertone:         undertone.Builder,
 		openrtb_ext.BidderUnicorn:           unicorn.Builder,
 		openrtb_ext.BidderUnruly:            unruly.Builder,
+		openrtb_ext.BidderVASTBidder:        vastbidder.Builder,
 		openrtb_ext.BidderValueImpression:   apacdex.Builder,
 		openrtb_ext.BidderVerizonMedia:      yahoossp.Builder,
 		openrtb_ext.BidderVideoByte:         videobyte.Builder,
diff --git a/exchange/auction.go b/exchange/auction.go
index 330aa50c5..2f9c7a3a4 100644
--- a/exchange/auction.go
+++ b/exchange/auction.go
@@ -334,12 +334,18 @@ func (a *auction) doCache(ctx context.Context, cache prebid_cache_client.Client,
 // makeVAST returns some VAST XML for the given bid. If AdM is defined,
 // it takes precedence. Otherwise the Nurl will be wrapped in a redirect tag.
 func makeVAST(bid *openrtb2.Bid) string {
+	wrapperVASTTemplate := `<VAST version="3.0"><Ad><Wrapper>` +
+		`<AdSystem>prebid.org wrapper</AdSystem>` +
+		`<VASTAdTagURI><![CDATA[%v]]></VASTAdTagURI>` +
+		`<Impression></Impression><Creatives></Creatives>` +
+		`</Wrapper></Ad></VAST>`
+
 	if bid.AdM == "" {
-		return `<VAST version="3.0"><Ad><Wrapper>` +
-			`<AdSystem>prebid.org wrapper</AdSystem>` +
-			`<VASTAdTagURI><![CDATA[` + bid.NURL + `]]></VASTAdTagURI>` +
-			`<Impression></Impression><Creatives></Creatives>` +
-			`</Wrapper></Ad></VAST>`
+		return fmt.Sprintf(wrapperVASTTemplate, bid.NURL) // set nurl as VASTAdTagURI
+	}
+
+	if strings.HasPrefix(bid.AdM, "http") { // check if it contains URL
+		return fmt.Sprintf(wrapperVASTTemplate, bid.AdM) // set adm as VASTAdTagURI
 	}
 	return bid.AdM
 }
diff --git a/exchange/auction_test.go b/exchange/auction_test.go
index ad0f8d4a7..8d8e248ec 100644
--- a/exchange/auction_test.go
+++ b/exchange/auction_test.go
@@ -45,6 +45,20 @@ func TestMakeVASTNurl(t *testing.T) {
 	assert.Equal(t, expect, vast)
 }
 
+func TestMakeVASTAdmContainsURI(t *testing.T) {
+	const url = "http://myvast.com/1.xml"
+	const expect = `<VAST version="3.0"><Ad><Wrapper>` +
+		`<AdSystem>prebid.org wrapper</AdSystem>` +
+		`<VASTAdTagURI><![CDATA[` + url + `]]></VASTAdTagURI>` +
+		`<Impression></Impression><Creatives></Creatives>` +
+		`</Wrapper></Ad></VAST>`
+	bid := &openrtb2.Bid{
+		AdM: url,
+	}
+	vast := makeVAST(bid)
+	assert.Equal(t, expect, vast)
+}
+
 func TestBuildCacheString(t *testing.T) {
 	testCases := []struct {
 		description      string
diff --git a/exchange/bidder.go b/exchange/bidder.go
index f5efcff3e..10f8963df 100644
--- a/exchange/bidder.go
+++ b/exchange/bidder.go
@@ -232,6 +232,7 @@ func (bidder *bidderAdapter) requestBid(ctx context.Context, bidderRequest Bidde
 
 		if httpInfo.err == nil {
 			startTime := time.Now()
+			httpInfo.request.BidderName = bidderRequest.BidderName
 			bidResponse, moreErrs := bidder.Bidder.MakeBids(bidderRequest.BidRequest, httpInfo.request, httpInfo.response)
 			errs = append(errs, moreErrs...)
 
@@ -249,6 +250,13 @@ func (bidder *bidderAdapter) requestBid(ctx context.Context, bidderRequest Bidde
 					bidderRequest.BidRequest.Cur = []string{defaultCurrency}
 				}
 
+				// WL and WTK only accepts USD so we would need to convert prices to USD before sending data to them. But,
+				// PBS-Core's getAuctionCurrencyRates() is not exposed and would be too much work to do so. Also, would be a repeated work for SSHB to convert each bid's price
+				// Hence, we would send a USD conversion rate to SSHB for each bid beside prebid's origbidcpm and origbidcur
+				// Ex. req.cur=INR and resp.cur=JYP. Hence, we cannot use origbidcpm and origbidcur and would need a dedicated field for USD conversion rates
+				var conversionRateUSD float64
+				selectedCur := "USD"
+
 				// Try to get a conversion rate
 				// Try to get the first currency from request.cur having a match in the rate converter,
 				// and use it as currency
@@ -257,10 +265,21 @@ func (bidder *bidderAdapter) requestBid(ctx context.Context, bidderRequest Bidde
 				for _, bidReqCur := range bidderRequest.BidRequest.Cur {
 					if conversionRate, err = conversions.GetRate(bidResponse.Currency, bidReqCur); err == nil {
 						seatBidMap[bidderRequest.BidderName].Currency = bidReqCur
+						selectedCur = bidReqCur
 						break
 					}
 				}
 
+				// no need of conversionRateUSD if
+				// - bids with conversionRate = 0 would be a dropped
+				// - response would be in USD
+				if conversionRate != float64(0) && selectedCur != "USD" {
+					conversionRateUSD, err = conversions.GetRate(bidResponse.Currency, "USD")
+					if err != nil {
+						errs = append(errs, fmt.Errorf("failed to get USD conversion rate for WL and WTK %v", err))
+					}
+				}
+
 				// Only do this for request from mobile app
 				if bidderRequest.BidRequest.App != nil {
 					for i := 0; i < len(bidResponse.Bids); i++ {
@@ -338,10 +357,12 @@ func (bidder *bidderAdapter) requestBid(ctx context.Context, bidderRequest Bidde
 
 						originalBidCpm := 0.0
 						currencyAfterAdjustments := ""
+						originalBidCPMUSD := 0.0
 						if bidResponse.Bids[i].Bid != nil {
 							originalBidCpm = bidResponse.Bids[i].Bid.Price
 							bidResponse.Bids[i].Bid.Price = bidResponse.Bids[i].Bid.Price * adjustmentFactor * conversionRate
 
+							originalBidCPMUSD = originalBidCpm * adjustmentFactor * conversionRateUSD
 							bidType := getBidTypeForAdjustments(bidResponse.Bids[i].BidType, bidResponse.Bids[i].Bid.ImpID, bidderRequest.BidRequest.Imp)
 							bidResponse.Bids[i].Bid.Price, currencyAfterAdjustments = bidadjustment.Apply(ruleToAdjustments, bidResponse.Bids[i], bidderRequest.BidderName, seatBidMap[bidderRequest.BidderName].Currency, reqInfo, bidType)
 						}
@@ -365,6 +386,9 @@ func (bidder *bidderAdapter) requestBid(ctx context.Context, bidderRequest Bidde
 							DealPriority:   bidResponse.Bids[i].DealPriority,
 							OriginalBidCPM: originalBidCpm,
 							OriginalBidCur: bidResponse.Currency,
+							BidTargets:     bidResponse.Bids[i].BidTargets,
+
+							OriginalBidCPMUSD: originalBidCPMUSD,
 						})
 						seatBidMap[bidderName].Currency = currencyAfterAdjustments
 					}
@@ -376,6 +400,9 @@ func (bidder *bidderAdapter) requestBid(ctx context.Context, bidderRequest Bidde
 			reqInfo.MakeBidsTimeInfo.Durations = append(reqInfo.MakeBidsTimeInfo.Durations, time.Since(startTime))
 		} else {
 			errs = append(errs, httpInfo.err)
+			if errortypes.ReadCode(httpInfo.err) == errortypes.TimeoutErrorCode {
+				recordPartnerTimeout(ctx, bidderRequest.BidderLabels.PubID, bidder.BidderName.String())
+			}
 		}
 	}
 	reqInfo.MakeBidsTimeInfo.AfterMakeBidsStartTime = time.Now()
@@ -491,6 +518,12 @@ func makeExt(httpInfo *httpCallInfo) *openrtb_ext.ExtHttpCall {
 			ext.ResponseBody = string(httpInfo.response.Body)
 			ext.Status = httpInfo.response.StatusCode
 		}
+
+		if nil != httpInfo.request.Params {
+			ext.Params = make(map[string]int)
+			ext.Params["ImpIndex"] = httpInfo.request.Params.ImpIndex
+			ext.Params["VASTTagIndex"] = httpInfo.request.Params.VASTTagIndex
+		}
 	}
 
 	return ext
@@ -545,7 +578,6 @@ func (bidder *bidderAdapter) doRequestImpl(ctx context.Context, req *adapters.Re
 				// a loop of trying to report timeouts to the timeout notifications.
 				go bidder.doTimeoutNotification(tb, req, logger)
 			}
-
 		}
 		return &httpCallInfo{
 			request: req,
@@ -662,7 +694,7 @@ func (bidder *bidderAdapter) addClientTrace(ctx context.Context) context.Context
 		TLSHandshakeDone: func(tls.ConnectionState, error) {
 			tlsHandshakeTime := time.Now().Sub(tlsStart)
 
-			bidder.me.RecordTLSHandshakeTime(tlsHandshakeTime)
+			bidder.me.RecordTLSHandshakeTime(bidder.BidderName, tlsHandshakeTime)
 		},
 	}
 	return httptrace.WithClientTrace(ctx, trace)
diff --git a/exchange/bidder_test.go b/exchange/bidder_test.go
index 4e94a18f3..cdd5c2ad8 100644
--- a/exchange/bidder_test.go
+++ b/exchange/bidder_test.go
@@ -344,7 +344,7 @@ func TestRequestBidRemovesSensitiveHeaders(t *testing.T) {
 		{
 			Uri:            server.URL,
 			RequestBody:    "requestJson",
-			RequestHeaders: map[string][]string{"Content-Type": {"application/json"}, "X-Prebid": {"pbs-go/test-version"}},
+			RequestHeaders: map[string][]string{"Content-Type": {"application/json"}, "X-Prebid": {"owpbs-go/test-version"}},
 			ResponseBody:   "responseJson",
 			Status:         200,
 		},
@@ -399,7 +399,7 @@ func TestSetGPCHeader(t *testing.T) {
 		{
 			Uri:            server.URL,
 			RequestBody:    "requestJson",
-			RequestHeaders: map[string][]string{"Content-Type": {"application/json"}, "X-Prebid": {"pbs-go/unknown"}, "Sec-Gpc": {"1"}},
+			RequestHeaders: map[string][]string{"Content-Type": {"application/json"}, "X-Prebid": {"owpbs-go/unknown"}, "Sec-Gpc": {"1"}},
 			ResponseBody:   "responseJson",
 			Status:         200,
 		},
@@ -452,7 +452,7 @@ func TestSetGPCHeaderNil(t *testing.T) {
 		{
 			Uri:            server.URL,
 			RequestBody:    "requestJson",
-			RequestHeaders: map[string][]string{"X-Prebid": {"pbs-go/unknown"}, "Sec-Gpc": {"1"}},
+			RequestHeaders: map[string][]string{"X-Prebid": {"owpbs-go/unknown"}, "Sec-Gpc": {"1"}},
 			ResponseBody:   "responseJson",
 			Status:         200,
 		},
@@ -1090,7 +1090,7 @@ func TestMultiCurrencies_RequestCurrencyPick(t *testing.T) {
 			bidRequestCurrencies:   []string{"EUR", "USD", "JPY"},
 			bidResponsesCurrency:   "EUR",
 			expectedPickedCurrency: "EUR",
-			expectedError:          false,
+			expectedError:          true, //conversionRateUSD fails as currency conversion in this test is default.
 			rates: currency.Rates{
 				Conversions: map[string]map[string]float64{
 					"JPY": {
@@ -1110,7 +1110,7 @@ func TestMultiCurrencies_RequestCurrencyPick(t *testing.T) {
 			bidRequestCurrencies:   []string{"JPY"},
 			bidResponsesCurrency:   "JPY",
 			expectedPickedCurrency: "JPY",
-			expectedError:          false,
+			expectedError:          true, //conversionRateUSD fails as currency conversion in this test is default.
 			rates: currency.Rates{
 				Conversions: map[string]map[string]float64{
 					"JPY": {
@@ -2116,7 +2116,7 @@ func TestCallRecordDNSTime(t *testing.T) {
 func TestCallRecordTLSHandshakeTime(t *testing.T) {
 	// setup a mock metrics engine and its expectation
 	metricsMock := &metrics.MetricsEngineMock{}
-	metricsMock.Mock.On("RecordTLSHandshakeTime", mock.Anything).Return()
+	metricsMock.Mock.On("RecordTLSHandshakeTime", mock.Anything, mock.Anything).Return()
 	metricsMock.On("RecordOverheadTime", metrics.PreBidder, mock.Anything).Once()
 	metricsMock.On("RecordBidderServerResponseTime", mock.Anything).Once()
 
@@ -2916,11 +2916,12 @@ func TestExtraBidWithMultiCurrencies(t *testing.T) {
 					ID:    "groupmImp1",
 					Price: 571.5994430039375,
 				},
-				DealPriority:   5,
-				BidType:        openrtb_ext.BidTypeVideo,
-				OriginalBidCPM: 7,
-				OriginalBidCur: "USD",
-				BidMeta:        &openrtb_ext.ExtBidPrebidMeta{AdapterCode: string(openrtb_ext.BidderPubmatic)},
+				DealPriority:      5,
+				BidType:           openrtb_ext.BidTypeVideo,
+				OriginalBidCPM:    7,
+				OriginalBidCur:    "USD",
+				OriginalBidCPMUSD: 7,
+				BidMeta:           &openrtb_ext.ExtBidPrebidMeta{AdapterCode: string(openrtb_ext.BidderPubmatic)},
 			}},
 			Seat:     "groupm",
 			Currency: "INR",
@@ -2932,11 +2933,12 @@ func TestExtraBidWithMultiCurrencies(t *testing.T) {
 					ID:    "pubmaticImp1",
 					Price: 244.97118985883034,
 				},
-				DealPriority:   4,
-				BidType:        openrtb_ext.BidTypeBanner,
-				OriginalBidCPM: 3,
-				OriginalBidCur: "USD",
-				BidMeta:        &openrtb_ext.ExtBidPrebidMeta{AdapterCode: string(openrtb_ext.BidderPubmatic)},
+				DealPriority:      4,
+				BidType:           openrtb_ext.BidTypeBanner,
+				OriginalBidCPM:    3,
+				OriginalBidCur:    "USD",
+				OriginalBidCPMUSD: 3,
+				BidMeta:           &openrtb_ext.ExtBidPrebidMeta{AdapterCode: string(openrtb_ext.BidderPubmatic)},
 			}},
 			Seat:     string(openrtb_ext.BidderPubmatic),
 			Currency: "INR",
diff --git a/exchange/entities/entities.go b/exchange/entities/entities.go
index 1220da5c8..1295c565e 100644
--- a/exchange/entities/entities.go
+++ b/exchange/entities/entities.go
@@ -22,6 +22,8 @@ type PbsOrtbSeatBid struct {
 	HttpCalls []*openrtb_ext.ExtHttpCall
 	// Seat defines whom these extra Bids belong to.
 	Seat string
+	// bidderCoreName represents the core bidder id.
+	BidderCoreName openrtb_ext.BidderName
 }
 
 // PbsOrtbBid is a Bid returned by an AdaptedBidder.
@@ -36,6 +38,7 @@ type PbsOrtbSeatBid struct {
 // PbsOrtbBid.DealPriority is optionally provided by adapters and used internally by the exchange to support deal targeted campaigns.
 // PbsOrtbBid.DealTierSatisfied is set to true by exchange.updateHbPbCatDur if deal tier satisfied otherwise it will be set to false
 // PbsOrtbBid.GeneratedBidID is unique Bid id generated by prebid server if generate Bid id option is enabled in config
+// pbsOrtbBid.originalBidCPMUSD is USD rate of the bid for WL and WTK as they only accepts USD
 type PbsOrtbBid struct {
 	Bid               *openrtb2.Bid
 	BidMeta           *openrtb_ext.ExtBidPrebidMeta
@@ -50,4 +53,5 @@ type PbsOrtbBid struct {
 	OriginalBidCPM    float64
 	OriginalBidCur    string
 	TargetBidderCode  string
+	OriginalBidCPMUSD float64
 }
diff --git a/exchange/events.go b/exchange/events.go
index fd52d6b67..cb08c052f 100644
--- a/exchange/events.go
+++ b/exchange/events.go
@@ -5,12 +5,13 @@ import (
 	"time"
 
 	"github.com/prebid/prebid-server/exchange/entities"
-	jsonpatch "gopkg.in/evanphx/json-patch.v4"
 
+	"github.com/prebid/openrtb/v19/openrtb2"
 	"github.com/prebid/prebid-server/analytics"
 	"github.com/prebid/prebid-server/config"
 	"github.com/prebid/prebid-server/endpoints/events"
 	"github.com/prebid/prebid-server/openrtb_ext"
+	jsonpatch "gopkg.in/evanphx/json-patch.v4"
 )
 
 // eventTracking has configuration fields needed for adding event tracking to an auction response
@@ -45,13 +46,10 @@ func getIntegrationType(requestExtPrebid *openrtb_ext.ExtRequestPrebid) string {
 }
 
 // modifyBidsForEvents adds bidEvents and modifies VAST AdM if necessary.
-func (ev *eventTracking) modifyBidsForEvents(seatBids map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid) map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid {
+func (ev *eventTracking) modifyBidsForEvents(seatBids map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid, req *openrtb2.BidRequest, trackerURL string) map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid {
 	for bidderName, seatBid := range seatBids {
-		modifyingVastXMLAllowed := ev.isModifyingVASTXMLAllowed(bidderName.String())
 		for _, pbsBid := range seatBid.Bids {
-			if modifyingVastXMLAllowed {
-				ev.modifyBidVAST(pbsBid, bidderName)
-			}
+			ev.modifyBidVAST(pbsBid, bidderName, seatBid.BidderCoreName, req, trackerURL)
 			pbsBid.BidEvents = ev.makeBidExtEvents(pbsBid, bidderName)
 		}
 	}
@@ -64,7 +62,7 @@ func (ev *eventTracking) isModifyingVASTXMLAllowed(bidderName string) bool {
 }
 
 // modifyBidVAST injects event Impression url if needed, otherwise returns original VAST string
-func (ev *eventTracking) modifyBidVAST(pbsBid *entities.PbsOrtbBid, bidderName openrtb_ext.BidderName) {
+func (ev *eventTracking) modifyBidVAST(pbsBid *entities.PbsOrtbBid, bidderName openrtb_ext.BidderName, bidderCoreName openrtb_ext.BidderName, req *openrtb2.BidRequest, trackerURL string) {
 	bid := pbsBid.Bid
 	if pbsBid.BidType != openrtb_ext.BidTypeVideo || len(bid.AdM) == 0 && len(bid.NURL) == 0 {
 		return
@@ -74,8 +72,16 @@ func (ev *eventTracking) modifyBidVAST(pbsBid *entities.PbsOrtbBid, bidderName o
 	if len(pbsBid.GeneratedBidID) > 0 {
 		bidID = pbsBid.GeneratedBidID
 	}
-	if newVastXML, ok := events.ModifyVastXmlString(ev.externalURL, vastXML, bidID, bidderName.String(), ev.accountID, ev.auctionTimestampMs, ev.integrationType); ok {
-		bid.AdM = newVastXML
+
+	if ev.isModifyingVASTXMLAllowed(bidderName.String()) { // condition added for ow fork
+		if newVastXML, ok := events.ModifyVastXmlString(ev.externalURL, vastXML, bidID, bidderName.String(), ev.accountID, ev.auctionTimestampMs, ev.integrationType); ok {
+			bid.AdM = newVastXML
+		}
+	}
+
+	// always inject event  trackers without checkign isModifyingVASTXMLAllowed
+	if newVastXML, injected, _ := events.InjectVideoEventTrackers(trackerURL, vastXML, bid, bidID, bidderName.String(), bidderCoreName.String(), ev.accountID, ev.auctionTimestampMs, req); injected {
+		bid.AdM = string(newVastXML)
 	}
 }
 
diff --git a/exchange/events_test.go b/exchange/events_test.go
index 24dedf1a6..61f29bcac 100644
--- a/exchange/events_test.go
+++ b/exchange/events_test.go
@@ -1,10 +1,13 @@
 package exchange
 
 import (
+	"strings"
 	"testing"
 
 	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/config"
 	"github.com/prebid/prebid-server/exchange/entities"
+
 	"github.com/prebid/prebid-server/openrtb_ext"
 	"github.com/stretchr/testify/assert"
 )
@@ -192,3 +195,108 @@ func Test_isEventAllowed(t *testing.T) {
 		})
 	}
 }
+
+func TestModifyBidVAST(t *testing.T) {
+	type args struct {
+		bidReq *openrtb2.BidRequest
+		bid    *openrtb2.Bid
+	}
+	type want struct {
+		tags []string
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "empty_adm", // expect adm contain vast tag with tracking events and  VASTAdTagURI nurl contents
+			args: args{
+				bidReq: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{{ID: "123", Video: &openrtb2.Video{}}},
+				},
+				bid: &openrtb2.Bid{
+					AdM:   "",
+					NURL:  "nurl_contents",
+					ImpID: "123",
+				},
+			},
+			want: want{
+				tags: []string{
+					// `<Tracking event="firstQuartile"><![CDATA[http://company.tracker.com?e=firstQuartile]]></Tracking>`,
+					// `<Tracking event="midpoint"><![CDATA[http://company.tracker.com?e=midpoint]]></Tracking>`,
+					// `<Tracking event="thirdQuartile"><![CDATA[http://company.tracker.com?e=thirdQuartile]]></Tracking>`,
+					// `<Tracking event="complete"><![CDATA[http://company.tracker.com?e=complete]]></Tracking>`,
+					// "<Wrapper>",
+					// "</Wrapper>",
+					// "<VASTAdTagURI><![CDATA[nurl_contents]]></VASTAdTagURI>",
+					`<Tracking event="firstQuartile"><![CDATA[http://company.tracker.com?e=4]]></Tracking>`,
+					`<Tracking event="midpoint"><![CDATA[http://company.tracker.com?e=3]]></Tracking>`,
+					`<Tracking event="thirdQuartile"><![CDATA[http://company.tracker.com?e=5]]></Tracking>`,
+					`<Tracking event="complete"><![CDATA[http://company.tracker.com?e=6]]></Tracking>`,
+					"<Wrapper>",
+					"</Wrapper>",
+					"<VASTAdTagURI><![CDATA[nurl_contents]]></VASTAdTagURI>",
+				},
+			},
+		},
+		{
+			name: "adm_containing_url", // expect adm contain vast tag with tracking events and  VASTAdTagURI adm url (previous value) contents
+			args: args{
+				bidReq: &openrtb2.BidRequest{
+					Imp: []openrtb2.Imp{{ID: "123", Video: &openrtb2.Video{}}},
+				},
+				bid: &openrtb2.Bid{
+					AdM:   "http://vast_tag_inline.xml",
+					NURL:  "nurl_contents",
+					ImpID: "123",
+				},
+			},
+			want: want{
+				tags: []string{
+					// `<Tracking event="firstQuartile"><![CDATA[http://company.tracker.com?e=firstQuartile]]></Tracking>`,
+					// `<Tracking event="midpoint"><![CDATA[http://company.tracker.com?e=midpoint]]></Tracking>`,
+					// `<Tracking event="thirdQuartile"><![CDATA[http://company.tracker.com?e=thirdQuartile]]></Tracking>`,
+					// `<Tracking event="complete"><![CDATA[http://company.tracker.com?e=complete]]></Tracking>`,
+					// "<Wrapper>",
+					// "</Wrapper>",
+					// "<VASTAdTagURI><![CDATA[http://vast_tag_inline.xml]]></VASTAdTagURI>",
+					`<Tracking event="firstQuartile"><![CDATA[http://company.tracker.com?e=4]]></Tracking>`,
+					`<Tracking event="midpoint"><![CDATA[http://company.tracker.com?e=3]]></Tracking>`,
+					`<Tracking event="thirdQuartile"><![CDATA[http://company.tracker.com?e=5]]></Tracking>`,
+					`<Tracking event="complete"><![CDATA[http://company.tracker.com?e=6]]></Tracking>`,
+					"<Wrapper>",
+					"</Wrapper>",
+					"<VASTAdTagURI><![CDATA[http://vast_tag_inline.xml]]></VASTAdTagURI>",
+				},
+			},
+		},
+	}
+	for _, tc := range tests {
+		t.Run(tc.name, func(t *testing.T) {
+			ev := eventTracking{
+				bidderInfos: config.BidderInfos{
+					"somebidder": config.BidderInfo{
+						ModifyingVastXmlAllowed: false,
+					},
+				},
+			}
+			ev.modifyBidVAST(&entities.PbsOrtbBid{
+				Bid:     tc.args.bid,
+				BidType: openrtb_ext.BidTypeVideo,
+			}, "somebidder", "coreBidder", tc.args.bidReq, "http://company.tracker.com?e=[EVENT_ID]")
+			validator(t, tc.args.bid, tc.want.tags)
+		})
+	}
+}
+
+func validator(t *testing.T, b *openrtb2.Bid, expectedTags []string) {
+	adm := b.AdM
+	assert.NotNil(t, adm)
+	assert.NotEmpty(t, adm)
+	// check tags are present
+
+	for _, tag := range expectedTags {
+		assert.True(t, strings.Contains(adm, tag), "expected '"+tag+"' tag in Adm")
+	}
+}
diff --git a/exchange/exchange.go b/exchange/exchange.go
index 8361fa27e..b665f3a90 100644
--- a/exchange/exchange.go
+++ b/exchange/exchange.go
@@ -16,6 +16,7 @@ import (
 
 	"github.com/prebid/prebid-server/adapters"
 	"github.com/prebid/prebid-server/adservertargeting"
+	"github.com/prebid/prebid-server/analytics"
 	"github.com/prebid/prebid-server/bidadjustment"
 	"github.com/prebid/prebid-server/config"
 	"github.com/prebid/prebid-server/currency"
@@ -77,6 +78,8 @@ type exchange struct {
 	bidValidationEnforcement config.Validations
 	requestSplitter          requestSplitter
 	floor                    config.PriceFloors
+	trakerURL                string
+	priceFloorFetcher        *floors.PriceFloorFetcher
 }
 
 // Container to pass out response ext data from the GetAllBids goroutines back into the main thread
@@ -125,7 +128,7 @@ func (randomDeduplicateBidBooleanGenerator) Generate() bool {
 	return rand.Intn(100) < 50
 }
 
-func NewExchange(adapters map[openrtb_ext.BidderName]AdaptedBidder, cache prebid_cache_client.Client, cfg *config.Configuration, syncersByBidder map[string]usersync.Syncer, metricsEngine metrics.MetricsEngine, infos config.BidderInfos, gdprPermsBuilder gdpr.PermissionsBuilder, currencyConverter *currency.RateConverter, categoriesFetcher stored_requests.CategoryFetcher, adsCertSigner adscert.Signer) Exchange {
+func NewExchange(adapters map[openrtb_ext.BidderName]AdaptedBidder, cache prebid_cache_client.Client, cfg *config.Configuration, syncersByBidder map[string]usersync.Syncer, metricsEngine metrics.MetricsEngine, infos config.BidderInfos, gdprPermsBuilder gdpr.PermissionsBuilder, currencyConverter *currency.RateConverter, categoriesFetcher stored_requests.CategoryFetcher, adsCertSigner adscert.Signer, floorFetcher *floors.PriceFloorFetcher) Exchange {
 	bidderToSyncerKey := map[string]string{}
 	for bidder, syncer := range syncersByBidder {
 		bidderToSyncerKey[bidder] = syncer.Key()
@@ -170,6 +173,9 @@ func NewExchange(adapters map[openrtb_ext.BidderName]AdaptedBidder, cache prebid
 		bidValidationEnforcement: cfg.Validations,
 		requestSplitter:          requestSplitter,
 		floor:                    cfg.PriceFloors,
+
+		trakerURL:         cfg.TrackerURL,
+		priceFloorFetcher: floorFetcher,
 	}
 }
 
@@ -207,6 +213,8 @@ type AuctionRequest struct {
 	QueryParams           url.Values
 	// map of bidder to store duration needed for the MakeBids() calls and start time after MakeBids() calls
 	MakeBidsTimeInfo map[openrtb_ext.BidderName]adapters.MakeBidsTimeInfo
+	// LoggableObject
+	LoggableObject *analytics.LoggableAuctionObject
 }
 
 // BidderRequest holds the bidder specific request and all other
@@ -261,7 +269,7 @@ func (e *exchange) HoldAuction(ctx context.Context, r *AuctionRequest, debugLog
 	conversions := e.getAuctionCurrencyRates(requestExtPrebid.CurrencyConversions)
 
 	if e.floor.Enabled {
-		floorErrs = floors.EnrichWithPriceFloors(r.BidRequestWrapper, r.Account, conversions)
+		floorErrs = floors.EnrichWithPriceFloors(r.BidRequestWrapper, r.Account, conversions, e.priceFloorFetcher)
 	}
 
 	responseDebugAllow, accountDebugAllow, debugLog := getDebugInfo(r.BidRequestWrapper.Test, requestExtPrebid, r.Account.DebugAllow, debugLog)
@@ -363,7 +371,8 @@ func (e *exchange) HoldAuction(ctx context.Context, r *AuctionRequest, debugLog
 		} else if r.Account.AlternateBidderCodes != nil {
 			alternateBidderCodes = *r.Account.AlternateBidderCodes
 		}
-		adapterBids, adapterExtra, fledge, anyBidsReturned = e.getAllBids(auctionCtx, bidderRequests, bidAdjustmentFactors, conversions, accountDebugAllow, r.GlobalPrivacyControlHeader, debugLog.DebugOverride, alternateBidderCodes, requestExtLegacy.Prebid.Experiment, r.HookExecutor, r.StartTime, bidAdjustmentRules)
+
+		adapterBids, adapterExtra, fledge, anyBidsReturned = e.getAllBids(auctionCtx, bidderRequests, bidAdjustmentFactors, conversions, accountDebugAllow, r.GlobalPrivacyControlHeader, debugLog.DebugOverride, alternateBidderCodes, requestExtLegacy.Prebid.Experiment, r.HookExecutor, r.StartTime, bidAdjustmentRules, r.Account.PriceFloors.AdjustForBidAdjustment)
 		r.MakeBidsTimeInfo = buildMakeBidsTimeInfoMap(adapterExtra)
 	}
 
@@ -374,6 +383,9 @@ func (e *exchange) HoldAuction(ctx context.Context, r *AuctionRequest, debugLog
 	)
 
 	if anyBidsReturned {
+		recordBids(ctx, e.me, r.PubID, adapterBids)
+		recordVastVersion(e.me, adapterBids)
+
 		if e.floor.Enabled {
 			var rejectedBids []*entities.PbsOrtbSeatBid
 			var enforceErrs []error
@@ -385,25 +397,56 @@ func (e *exchange) HoldAuction(ctx context.Context, r *AuctionRequest, debugLog
 					Message:     fmt.Sprintf("%s bid id %s rejected - bid price %.4f %s is less than bid floor %.4f %s for imp %s", rejectedBid.Seat, rejectedBid.Bids[0].Bid.ID, rejectedBid.Bids[0].Bid.Price, rejectedBid.Currency, rejectedBid.Bids[0].BidFloors.FloorValue, rejectedBid.Bids[0].BidFloors.FloorCurrency, rejectedBid.Bids[0].Bid.ImpID),
 					WarningCode: errortypes.FloorBidRejectionWarningCode})
 			}
+
+			if floors.RequestHasFloors(r.BidRequestWrapper.BidRequest) {
+				// Record request count with non-zero imp.bidfloor value
+				e.me.RecordFloorsRequestForAccount(r.PubID)
+
+				if r.LoggableObject != nil {
+					r.LoggableObject.RejectedBids = append(r.LoggableObject.RejectedBids, floors.PbsOrtbBidToAnalyticsRejectedBid(rejectedBids)...)
+					if len(r.LoggableObject.RejectedBids) > 0 {
+						// Record rejected bid count at account level
+						e.me.RecordRejectedBidsForAccount(r.PubID)
+					}
+				}
+			}
+
+			if responseDebugAllow {
+				if err := r.BidRequestWrapper.RebuildRequestExt(); err != nil {
+					return nil, err
+				}
+				resolvedBidReq, err := json.Marshal(r.BidRequestWrapper.BidRequest)
+				if err != nil {
+					return nil, err
+				}
+				r.ResolvedBidRequest = resolvedBidReq
+			}
 		}
 
+		adapterBids, rejections := applyAdvertiserBlocking(r, adapterBids)
+		// add advertiser blocking specific errors
+		for _, message := range rejections {
+			errs = append(errs, errors.New(message))
+		}
 		var bidCategory map[string]string
 		//If includebrandcategory is present in ext then CE feature is on.
 		if requestExtPrebid.Targeting != nil && requestExtPrebid.Targeting.IncludeBrandCategory != nil {
 			var rejections []string
-			bidCategory, adapterBids, rejections, err = applyCategoryMapping(ctx, *requestExtPrebid.Targeting, adapterBids, e.categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
+			bidCategory, adapterBids, rejections, err = applyCategoryMapping(ctx, r, *requestExtPrebid.Targeting, adapterBids, e.categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
 			if err != nil {
 				return nil, fmt.Errorf("Error in category mapping : %s", err.Error())
 			}
 			for _, message := range rejections {
 				errs = append(errs, errors.New(message))
 			}
+
 		}
 
 		if e.bidIDGenerator.Enabled() {
 			for _, seatBid := range adapterBids {
 				for _, pbsBid := range seatBid.Bids {
 					pbsBid.GeneratedBidID, err = e.bidIDGenerator.New()
+					glog.Infof("Original BidID = %s Generated BidID = %s", pbsBid.Bid.ID, pbsBid.GeneratedBidID)
 					if err != nil {
 						errs = append(errs, errors.New("Error generating bid.ext.prebid.bidid"))
 					}
@@ -412,7 +455,7 @@ func (e *exchange) HoldAuction(ctx context.Context, r *AuctionRequest, debugLog
 		}
 
 		evTracking := getEventTracking(requestExtPrebid, r.StartTime, &r.Account, e.bidderInfo, e.externalURL)
-		adapterBids = evTracking.modifyBidsForEvents(adapterBids)
+		adapterBids = evTracking.modifyBidsForEvents(adapterBids, r.BidRequestWrapper.BidRequest, e.trakerURL)
 
 		r.HookExecutor.ExecuteAllProcessedBidResponsesStage(adapterBids)
 
@@ -477,6 +520,13 @@ func (e *exchange) HoldAuction(ctx context.Context, r *AuctionRequest, debugLog
 		bidResponseExt.Warnings[openrtb_ext.BidderReservedGeneral] = append(bidResponseExt.Warnings[openrtb_ext.BidderReservedGeneral], generalWarning)
 	}
 
+	if enabled, rules := floorsEnabled(r.Account, r.BidRequestWrapper); enabled && rules != nil {
+		if bidResponseExt.Prebid == nil {
+			bidResponseExt.Prebid = &openrtb_ext.ExtResponsePrebid{}
+		}
+		bidResponseExt.Prebid.Floors = rules
+	}
+
 	e.bidValidationEnforcement.SetBannerCreativeMaxSize(r.Account.Validations)
 
 	// Build the response
@@ -650,7 +700,8 @@ func (e *exchange) getAllBids(
 	experiment *openrtb_ext.Experiment,
 	hookExecutor hookexecution.StageExecutor,
 	pbsRequestStartTime time.Time,
-	bidAdjustmentRules map[string][]openrtb_ext.Adjustment) (
+	bidAdjustmentRules map[string][]openrtb_ext.Adjustment,
+	bidFloorAdjustment bool) (
 	map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid,
 	map[openrtb_ext.BidderName]*seatResponseExtra,
 	*openrtb_ext.Fledge,
@@ -660,6 +711,7 @@ func (e *exchange) getAllBids(
 	adapterExtra := make(map[openrtb_ext.BidderName]*seatResponseExtra, len(bidderRequests))
 	chBids := make(chan *bidResponseWrapper, len(bidderRequests))
 	bidsFound := false
+	bidIDsCollision := false
 
 	e.me.RecordOverheadTime(metrics.MakeBidderRequests, time.Since(pbsRequestStartTime))
 
@@ -683,6 +735,9 @@ func (e *exchange) getAllBids(
 			reqInfo := adapters.NewExtraRequestInfo(conversions)
 			reqInfo.PbsEntryPoint = bidderRequest.BidderLabels.RType
 			reqInfo.GlobalPrivacyControlHeader = globalPrivacyControlHeader
+			if bidAjustmentFactor, ok := bidAdjustments[bidderRequest.BidderName.String()]; ok && bidFloorAdjustment {
+				reqInfo.BidAdjustmentFactor = bidAjustmentFactor
+			}
 			reqInfo.BidderRequestStartTime = start
 
 			bidReqOptions := bidRequestOptions{
@@ -719,9 +774,15 @@ func (e *exchange) getAllBids(
 				if seatBid != nil {
 					for _, bid := range seatBid.Bids {
 						var cpm = float64(bid.Bid.Price * 1000)
+
 						e.me.RecordAdapterPrice(bidderRequest.BidderLabels, cpm)
 						e.me.RecordAdapterBidReceived(bidderRequest.BidderLabels, bid.BidType, bid.Bid.AdM != "")
+						if bid.BidType == openrtb_ext.BidTypeVideo && bid.BidVideo != nil && bid.BidVideo.Duration > 0 {
+							e.me.RecordAdapterVideoBidDuration(bidderRequest.BidderLabels, bid.BidVideo.Duration)
+						}
 					}
+					// Setting bidderCoreName in SeatBid
+					seatBid.BidderCoreName = bidderRequest.BidderCoreName
 				}
 			}
 			chBids <- brw
@@ -754,8 +815,13 @@ func (e *exchange) getAllBids(
 
 		if !bidsFound && adapterBids[brw.bidder] != nil && len(adapterBids[brw.bidder].Bids) > 0 {
 			bidsFound = true
+			bidIDsCollision = recordAdaptorDuplicateBidIDs(e.me, adapterBids)
 		}
 	}
+	if bidIDsCollision {
+		// record this request count this request if bid collision is detected
+		e.me.RecordRequestHavingDuplicateBidID()
+	}
 
 	return adapterBids, adapterExtra, fledge, bidsFound
 }
@@ -796,9 +862,19 @@ func (e *exchange) recoverSafely(bidderRequests []BidderRequest,
 					allBidders = sb.String()[:sb.Len()-1]
 				}
 
+				bidderRequestStr := ""
+				if nil != bidderRequest.BidRequest {
+					value, err := json.Marshal(bidderRequest.BidRequest)
+					if nil == err {
+						bidderRequestStr = string(value)
+					} else {
+						bidderRequestStr = err.Error()
+					}
+				}
+
 				glog.Errorf("OpenRTB auction recovered panic from Bidder %s: %v. "+
-					"Account id: %s, All Bidders: %s, Stack trace is: %v",
-					bidderRequest.BidderCoreName, r, bidderRequest.BidderLabels.PubID, allBidders, string(debug.Stack()))
+					"Account id: %s, All Bidders: %s, BidRequest: %s, Stack trace is: %v",
+					bidderRequest.BidderCoreName, r, bidderRequest.BidderLabels.PubID, allBidders, bidderRequestStr, string(debug.Stack()))
 				e.me.RecordAdapterPanic(bidderRequest.BidderLabels)
 				// Let the master request know that there is no data here
 				brw := new(bidResponseWrapper)
@@ -907,7 +983,8 @@ func encodeBidResponseExt(bidResponseExt *openrtb_ext.ExtBidResponse) ([]byte, e
 	return buffer.Bytes(), err
 }
 
-func applyCategoryMapping(ctx context.Context, targeting openrtb_ext.ExtRequestTargeting, seatBids map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid, categoriesFetcher stored_requests.CategoryFetcher, targData *targetData, booleanGenerator deduplicateChanceGenerator) (map[string]string, map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid, []string, error) {
+func applyCategoryMapping(ctx context.Context, r *AuctionRequest, targeting openrtb_ext.ExtRequestTargeting, seatBids map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid, categoriesFetcher stored_requests.CategoryFetcher, targData *targetData, booleanGenerator deduplicateChanceGenerator) (map[string]string, map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid, []string, error) {
+	bidRequest := r.BidRequestWrapper.BidRequest
 	res := make(map[string]string)
 
 	type bidDedupe struct {
@@ -919,6 +996,8 @@ func applyCategoryMapping(ctx context.Context, targeting openrtb_ext.ExtRequestT
 
 	dedupe := make(map[string]bidDedupe)
 
+	impMap := make(map[string]*openrtb2.Imp)
+
 	// applyCategoryMapping doesn't get called unless
 	brandCatExt := targeting.IncludeBrandCategory
 
@@ -932,6 +1011,11 @@ func applyCategoryMapping(ctx context.Context, targeting openrtb_ext.ExtRequestT
 	var rejections []string
 	var translateCategories = true
 
+	//Maintaining BidRequest Impression Map
+	for i := range bidRequest.Imp {
+		impMap[bidRequest.Imp[i].ID] = &bidRequest.Imp[i]
+	}
+
 	if includeBrandCategory && brandCatExt.WithCategory {
 		if brandCatExt.TranslateCategories != nil {
 			translateCategories = *brandCatExt.TranslateCategories
@@ -962,6 +1046,7 @@ func applyCategoryMapping(ctx context.Context, targeting openrtb_ext.ExtRequestT
 				duration = bid.BidVideo.Duration
 				category = bid.BidVideo.PrimaryCategory
 			}
+
 			if brandCatExt.WithCategory && category == "" {
 				bidIabCat := bid.Bid.Cat
 				if len(bidIabCat) != 1 {
@@ -1010,6 +1095,12 @@ func applyCategoryMapping(ctx context.Context, targeting openrtb_ext.ExtRequestT
 						break
 					}
 				}
+			} else if targData.priceGranularity.Test || newDur == 0 {
+				if imp, ok := impMap[bid.Bid.ImpID]; ok {
+					if nil != imp.Video && imp.Video.MaxDuration > 0 {
+						newDur = int(imp.Video.MaxDuration)
+					}
+				}
 			}
 
 			var categoryDuration string
@@ -1026,50 +1117,52 @@ func applyCategoryMapping(ctx context.Context, targeting openrtb_ext.ExtRequestT
 				categoryDuration = fmt.Sprintf("%s_%s", categoryDuration, bidderName.String())
 			}
 
-			if dupe, ok := dedupe[dupeKey]; ok {
+			if !brandCatExt.SkipDedup {
+				if dupe, ok := dedupe[dupeKey]; ok {
 
-				dupeBidPrice, err := strconv.ParseFloat(dupe.bidPrice, 64)
-				if err != nil {
-					dupeBidPrice = 0
-				}
-				currBidPrice, err := strconv.ParseFloat(pb, 64)
-				if err != nil {
-					currBidPrice = 0
-				}
-				if dupeBidPrice == currBidPrice {
-					if booleanGenerator.Generate() {
-						dupeBidPrice = -1
-					} else {
-						currBidPrice = -1
+					dupeBidPrice, err := strconv.ParseFloat(dupe.bidPrice, 64)
+					if err != nil {
+						dupeBidPrice = 0
+					}
+					currBidPrice, err := strconv.ParseFloat(pb, 64)
+					if err != nil {
+						currBidPrice = 0
+					}
+					if dupeBidPrice == currBidPrice {
+						if booleanGenerator.Generate() {
+							dupeBidPrice = -1
+						} else {
+							currBidPrice = -1
+						}
 					}
-				}
 
-				if dupeBidPrice < currBidPrice {
-					if dupe.bidderName == bidderName {
-						// An older bid from the current bidder
-						bidsToRemove = append(bidsToRemove, dupe.bidIndex)
-						rejections = updateRejections(rejections, dupe.bidID, "Bid was deduplicated")
-					} else {
-						// An older bid from a different seatBid we've already finished with
-						oldSeatBid := (seatBids)[dupe.bidderName]
-						rejections = updateRejections(rejections, dupe.bidID, "Bid was deduplicated")
-						if len(oldSeatBid.Bids) == 1 {
-							seatBidsToRemove = append(seatBidsToRemove, dupe.bidderName)
+					if dupeBidPrice < currBidPrice {
+						if dupe.bidderName == bidderName {
+							// An older bid from the current bidder
+							bidsToRemove = append(bidsToRemove, dupe.bidIndex)
+							rejections = updateRejections(rejections, dupe.bidID, "Bid was deduplicated")
 						} else {
-							// This is a very rare, but still possible case where bid needs to be removed from already processed bidder
-							// This happens when current processing bidder has a bid that has same deduplication key as a bid from already processed bidder
-							// and already processed bid was selected to be removed
-							// See example of input data in unit test `TestCategoryMappingTwoBiddersManyBidsEachNoCategorySamePrice`
-							// Need to remove bid by name, not index in this case
-							removeBidById(oldSeatBid, dupe.bidID)
+							// An older bid from a different seatBid we've already finished with
+							oldSeatBid := (seatBids)[dupe.bidderName]
+							rejections = updateRejections(rejections, dupe.bidID, "Bid was deduplicated")
+							if len(oldSeatBid.Bids) == 1 {
+								seatBidsToRemove = append(seatBidsToRemove, dupe.bidderName)
+							} else {
+								// This is a very rare, but still possible case where bid needs to be removed from already processed bidder
+								// This happens when current processing bidder has a bid that has same deduplication key as a bid from already processed bidder
+								// and already processed bid was selected to be removed
+								// See example of input data in unit test `TestCategoryMappingTwoBiddersManyBidsEachNoCategorySamePrice`
+								// Need to remove bid by name, not index in this case
+								removeBidById(oldSeatBid, dupe.bidID)
+							}
 						}
+						delete(res, dupe.bidID)
+					} else {
+						// Remove this bid
+						bidsToRemove = append(bidsToRemove, bidInd)
+						rejections = updateRejections(rejections, bidID, "Bid was deduplicated")
+						continue
 					}
-					delete(res, dupe.bidID)
-				} else {
-					// Remove this bid
-					bidsToRemove = append(bidsToRemove, bidInd)
-					rejections = updateRejections(rejections, bidID, "Bid was deduplicated")
-					continue
 				}
 			}
 			res[bidID] = categoryDuration
@@ -1080,11 +1173,28 @@ func applyCategoryMapping(ctx context.Context, targeting openrtb_ext.ExtRequestT
 			sort.Ints(bidsToRemove)
 			if len(bidsToRemove) == len(seatBid.Bids) {
 				//if all bids are invalid - remove entire seat bid
+				for _, bid := range seatBid.Bids {
+
+					if r.LoggableObject != nil {
+						r.LoggableObject.RejectedBids = append(r.LoggableObject.RejectedBids, analytics.RejectedBid{
+							Bid:             bid,
+							RejectionReason: openrtb3.LossBidCategoryMapping,
+							Seat:            seatBid.Seat,
+						})
+					}
+				}
 				seatBidsToRemove = append(seatBidsToRemove, bidderName)
 			} else {
 				bids := seatBid.Bids
 				for i := len(bidsToRemove) - 1; i >= 0; i-- {
 					remInd := bidsToRemove[i]
+					if r.LoggableObject != nil {
+						r.LoggableObject.RejectedBids = append(r.LoggableObject.RejectedBids, analytics.RejectedBid{
+							Bid:             bids[remInd],
+							RejectionReason: openrtb3.LossBidCategoryMapping,
+							Seat:            seatBid.Seat,
+						})
+					}
 					bids = append(bids[:remInd], bids[remInd+1:]...)
 				}
 				seatBid.Bids = bids
@@ -1177,6 +1287,7 @@ func (e *exchange) makeExtBidResponse(adapterBids map[openrtb_ext.BidderName]*en
 		}
 		if len(errList) > 0 {
 			bidResponseExt.Errors[openrtb_ext.PrebidExtKey] = errsToBidderErrors(errList)
+			bidResponseExt.Warnings[openrtb_ext.PrebidExtKey] = errsToBidderWarnings(errList)
 		}
 		bidResponseExt.ResponseTimeMillis[bidderName] = responseExtra.ResponseTimeMillis
 		// Defering the filling of bidResponseExt.Usersync[bidderName] until later
@@ -1243,7 +1354,7 @@ func (e *exchange) makeBid(bids []*entities.PbsOrtbBid, auc *auction, returnCrea
 			}
 		}
 
-		if bidExtJSON, err := makeBidExtJSON(bid.Bid.Ext, bidExtPrebid, impExtInfoMap, bid.Bid.ImpID, bid.OriginalBidCPM, bid.OriginalBidCur); err != nil {
+		if bidExtJSON, err := makeBidExtJSON(bid.Bid.Ext, bidExtPrebid, impExtInfoMap, bid.Bid.ImpID, bid.OriginalBidCPM, bid.OriginalBidCur, bid.OriginalBidCPMUSD); err != nil {
 			errs = append(errs, err)
 		} else {
 			result = append(result, *bid.Bid)
@@ -1257,7 +1368,7 @@ func (e *exchange) makeBid(bids []*entities.PbsOrtbBid, auc *auction, returnCrea
 	return result, errs
 }
 
-func makeBidExtJSON(ext json.RawMessage, prebid *openrtb_ext.ExtBidPrebid, impExtInfoMap map[string]ImpExtInfo, impId string, originalBidCpm float64, originalBidCur string) (json.RawMessage, error) {
+func makeBidExtJSON(ext json.RawMessage, prebid *openrtb_ext.ExtBidPrebid, impExtInfoMap map[string]ImpExtInfo, impId string, originalBidCpm float64, originalBidCur string, originalBidCpmUSD float64) (json.RawMessage, error) {
 	var extMap map[string]interface{}
 
 	if len(ext) != 0 {
@@ -1278,6 +1389,11 @@ func makeBidExtJSON(ext json.RawMessage, prebid *openrtb_ext.ExtBidPrebid, impEx
 		extMap[openrtb_ext.OriginalBidCurKey] = originalBidCur
 	}
 
+	//ext.origbidcpmusd
+	if originalBidCpmUSD > float64(0) {
+		extMap[openrtb_ext.OriginalBidCpmUsdKey] = originalBidCpmUSD
+	}
+
 	// ext.prebid
 	if prebid.Meta == nil && maputil.HasElement(extMap, "prebid", "meta") {
 		metaContainer := struct {
@@ -1495,9 +1611,12 @@ func buildStoredAuctionResponse(storedAuctionResponses map[string]json.RawMessag
 				//create new seat bid and add it to live adapters
 				liveAdapters = append(liveAdapters, bidderName)
 				newSeatBid := entities.PbsOrtbSeatBid{
-					Bids:     bidsToAdd,
-					Currency: "",
-					Seat:     "",
+					Bids:                 bidsToAdd,
+					Currency:             "",
+					FledgeAuctionConfigs: nil,
+					HttpCalls:            nil,
+					Seat:                 "",
+					BidderCoreName:       bidderName,
 				}
 				adapterBids[bidderName] = &newSeatBid
 
diff --git a/exchange/exchange_ow.go b/exchange/exchange_ow.go
new file mode 100644
index 000000000..57cee586a
--- /dev/null
+++ b/exchange/exchange_ow.go
@@ -0,0 +1,220 @@
+package exchange
+
+import (
+	"context"
+	"errors"
+	"fmt"
+	"net/url"
+	"regexp"
+	"strings"
+
+	"github.com/golang/glog"
+	"github.com/prebid/openrtb/v19/openrtb3"
+	"github.com/prebid/prebid-server/analytics"
+	"github.com/prebid/prebid-server/exchange/entities"
+	"github.com/prebid/prebid-server/metrics"
+	pubmaticstats "github.com/prebid/prebid-server/metrics/pubmatic_stats"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"golang.org/x/net/publicsuffix"
+)
+
+const (
+	bidCountMetricEnabled = "bidCountMetricEnabled"
+	owProfileId           = "owProfileId"
+	nodeal                = "nodeal"
+	vastVersionUndefined  = "undefined"
+)
+
+var (
+	vastVersionRegex = regexp.MustCompile(`<VAST.+version\s*=[\s\\"']*([\s0-9.]+?)[\\\s"']*>`)
+)
+
+// recordAdaptorDuplicateBidIDs finds the bid.id collisions for each bidder and records them with metrics engine
+// it returns true if collosion(s) is/are detected in any of the bidder's bids
+func recordAdaptorDuplicateBidIDs(metricsEngine metrics.MetricsEngine, adapterBids map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid) bool {
+	bidIDCollisionFound := false
+	if nil == adapterBids {
+		return false
+	}
+	for bidder, bid := range adapterBids {
+		bidIDColisionMap := make(map[string]int, len(adapterBids[bidder].Bids))
+		for _, thisBid := range bid.Bids {
+			if collisions, ok := bidIDColisionMap[thisBid.Bid.ID]; ok {
+				bidIDCollisionFound = true
+				bidIDColisionMap[thisBid.Bid.ID]++
+				glog.Warningf("Bid.id %v :: %v collision(s) [imp.id = %v] for bidder '%v'", thisBid.Bid.ID, collisions, thisBid.Bid.ImpID, string(bidder))
+				metricsEngine.RecordAdapterDuplicateBidID(string(bidder), 1)
+			} else {
+				bidIDColisionMap[thisBid.Bid.ID] = 1
+			}
+		}
+	}
+	return bidIDCollisionFound
+}
+
+// normalizeDomain validates, normalizes and returns valid domain or error if failed to validate
+// checks if domain starts with http by lowercasing entire domain
+// if not it prepends it before domain. This is required for obtaining the url
+// using url.parse method. on successfull url parsing, it will replace first occurance of www.
+// from the domain
+func normalizeDomain(domain string) (string, error) {
+	domain = strings.Trim(strings.ToLower(domain), " ")
+	// not checking if it belongs to icann
+	suffix, _ := publicsuffix.PublicSuffix(domain)
+	if domain != "" && suffix == domain { // input is publicsuffix
+		return "", errors.New("domain [" + domain + "] is public suffix")
+	}
+	if !strings.HasPrefix(domain, "http") {
+		domain = fmt.Sprintf("http://%s", domain)
+	}
+	url, err := url.Parse(domain)
+	if nil == err && url.Host != "" {
+		return strings.Replace(url.Host, "www.", "", 1), nil
+	}
+	return "", err
+}
+
+// applyAdvertiserBlocking rejects the bids of blocked advertisers mentioned in req.badv
+// the rejection is currently only applicable to vast tag bidders. i.e. not for ortb bidders
+// it returns seatbids containing valid bids and rejections containing rejected bid.id with reason
+func applyAdvertiserBlocking(r *AuctionRequest, seatBids map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid) (map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid, []string) {
+	bidRequest := r.BidRequestWrapper.BidRequest
+	rejections := []string{}
+	nBadvs := []string{}
+	if nil != bidRequest.BAdv {
+		for _, domain := range bidRequest.BAdv {
+			nDomain, err := normalizeDomain(domain)
+			if nil == err && nDomain != "" { // skip empty and domains with errors
+				nBadvs = append(nBadvs, nDomain)
+			}
+		}
+	}
+
+	if len(nBadvs) == 0 {
+		return seatBids, rejections
+	}
+
+	for bidderName, seatBid := range seatBids {
+		if seatBid.BidderCoreName == openrtb_ext.BidderVASTBidder {
+			for bidIndex := len(seatBid.Bids) - 1; bidIndex >= 0; bidIndex-- {
+				bid := seatBid.Bids[bidIndex]
+				for _, bAdv := range nBadvs {
+					aDomains := bid.Bid.ADomain
+					rejectBid := false
+					if nil == aDomains {
+						// provision to enable rejecting of bids when req.badv is set
+						rejectBid = true
+					} else {
+						for _, d := range aDomains {
+							if aDomain, err := normalizeDomain(d); nil == err {
+								// compare and reject bid if
+								// 1. aDomain == bAdv
+								// 2. .bAdv is suffix of aDomain
+								// 3. aDomain not present but request has list of block advertisers
+								if aDomain == bAdv || strings.HasSuffix(aDomain, "."+bAdv) || (len(aDomain) == 0 && len(bAdv) > 0) {
+									// aDomain must be subdomain of bAdv
+									rejectBid = true
+									break
+								}
+							}
+						}
+					}
+					if rejectBid {
+						// Add rejectedBid for analytics logging.
+						if r.LoggableObject != nil {
+							r.LoggableObject.RejectedBids = append(r.LoggableObject.RejectedBids, analytics.RejectedBid{
+								RejectionReason: openrtb3.LossBidAdvertiserBlocking,
+								Bid:             bid,
+								Seat:            seatBid.Seat,
+							})
+						}
+						// reject the bid. bid belongs to blocked advertisers list
+						seatBid.Bids = append(seatBid.Bids[:bidIndex], seatBid.Bids[bidIndex+1:]...)
+						rejections = updateRejections(rejections, bid.Bid.ID, fmt.Sprintf("Bid (From '%s') belongs to blocked advertiser '%s'", bidderName, bAdv))
+						break // bid is rejected due to advertiser blocked. No need to check further domains
+					}
+				}
+			}
+		}
+	}
+	return seatBids, rejections
+}
+
+func UpdateRejectedBidExt(loggableObject *analytics.LoggableAuctionObject) {
+	for _, rejectedBid := range loggableObject.RejectedBids {
+		pbsOrtbBid := rejectedBid.Bid
+
+		if loggableObject != nil && pbsOrtbBid != nil && pbsOrtbBid.Bid != nil {
+
+			bidExtPrebid := &openrtb_ext.ExtBidPrebid{
+				DealPriority:      pbsOrtbBid.DealPriority,
+				DealTierSatisfied: pbsOrtbBid.DealTierSatisfied, //NOT_SET
+				Events:            pbsOrtbBid.BidEvents,         //NOT_REQ
+				Targeting:         pbsOrtbBid.BidTargets,        //NOT_REQ
+				Type:              pbsOrtbBid.BidType,
+				Meta:              pbsOrtbBid.BidMeta,
+				Video:             pbsOrtbBid.BidVideo,
+				BidId:             pbsOrtbBid.GeneratedBidID, //NOT_SET
+				Floors:            pbsOrtbBid.BidFloors,
+			}
+
+			rejBid := pbsOrtbBid.Bid
+
+			bidExtJSON, err := makeBidExtJSON(rejBid.Ext, bidExtPrebid, nil, pbsOrtbBid.Bid.ImpID,
+				pbsOrtbBid.OriginalBidCPM, pbsOrtbBid.OriginalBidCur, pbsOrtbBid.OriginalBidCPMUSD)
+
+			if err != nil {
+				glog.Warningf("For bid-id:[%v], bidder:[%v], makeBidExtJSON returned error - [%v]", rejBid.ID, rejectedBid.Seat, err)
+				return
+			}
+			rejBid.Ext = bidExtJSON
+		}
+	}
+}
+
+func recordBids(ctx context.Context, metricsEngine metrics.MetricsEngine, pubID string, adapterBids map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid) {
+	// Temporary code to record bids for publishers
+	if metricEnabled, ok := ctx.Value(bidCountMetricEnabled).(bool); metricEnabled && ok {
+		if profileID, ok := ctx.Value(owProfileId).(string); ok && profileID != "" {
+			for _, seatBid := range adapterBids {
+				for _, pbsBid := range seatBid.Bids {
+					deal := pbsBid.Bid.DealID
+					if deal == "" {
+						deal = nodeal
+					}
+					metricsEngine.RecordBids(pubID, profileID, seatBid.Seat, deal)
+					pubmaticstats.IncBidResponseByDealCountInPBS(pubID, profileID, seatBid.Seat, deal)
+				}
+			}
+		}
+	}
+}
+
+func recordVastVersion(metricsEngine metrics.MetricsEngine, adapterBids map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid) {
+	for _, seatBid := range adapterBids {
+		for _, pbsBid := range seatBid.Bids {
+			if pbsBid.BidType != openrtb_ext.BidTypeVideo {
+				continue
+			}
+			if pbsBid.Bid.AdM == "" {
+				continue
+			}
+			vastVersion := vastVersionUndefined
+			matches := vastVersionRegex.FindStringSubmatch(pbsBid.Bid.AdM)
+			if len(matches) == 2 {
+				vastVersion = matches[1]
+			}
+
+			metricsEngine.RecordVastVersion(string(seatBid.BidderCoreName), vastVersion)
+		}
+	}
+}
+
+// recordPartnerTimeout captures the partnertimeout if any at publisher profile level
+func recordPartnerTimeout(ctx context.Context, pubID, aliasBidder string) {
+	if metricEnabled, ok := ctx.Value(bidCountMetricEnabled).(bool); metricEnabled && ok {
+		if profileID, ok := ctx.Value(owProfileId).(string); ok && profileID != "" {
+			pubmaticstats.IncPartnerTimeoutInPBS(pubID, profileID, aliasBidder)
+		}
+	}
+}
diff --git a/exchange/exchange_ow_test.go b/exchange/exchange_ow_test.go
new file mode 100644
index 000000000..70c42a6c1
--- /dev/null
+++ b/exchange/exchange_ow_test.go
@@ -0,0 +1,1412 @@
+package exchange
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"regexp"
+	"sort"
+	"strings"
+	"testing"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/openrtb/v19/openrtb3"
+	"github.com/prebid/prebid-server/adapters"
+	"github.com/prebid/prebid-server/adapters/vastbidder"
+	"github.com/prebid/prebid-server/analytics"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/exchange/entities"
+	"github.com/prebid/prebid-server/metrics"
+	metricsConf "github.com/prebid/prebid-server/metrics/config"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+)
+
+// TestApplyAdvertiserBlocking verifies advertiser blocking
+// Currently it is expected to work only with TagBidders and not woth
+// normal bidders
+func TestApplyAdvertiserBlocking(t *testing.T) {
+	type args struct {
+		advBlockReq     *AuctionRequest
+		adaptorSeatBids map[*bidderAdapter]*entities.PbsOrtbSeatBid // bidder adaptor and its dummy seat bids map
+	}
+	type want struct {
+		rejectedBidIds       []string
+		validBidCountPerSeat map[string]int
+		expectedRejectedBids []analytics.RejectedBid
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "reject_bid_of_blocked_adv_from_tag_bidder",
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{
+							BAdv: []string{"a.com"}, // block bids returned by a.com
+						},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("vast_tag_bidder"): { // tag bidder returning 1 bid from blocked advertiser
+						Bids: []*entities.PbsOrtbBid{
+							{
+								Bid: &openrtb2.Bid{
+									ID:      "a.com_bid",
+									ADomain: []string{"a.com"},
+								},
+							},
+							{
+								Bid: &openrtb2.Bid{
+									ID:      "b.com_bid",
+									ADomain: []string{"b.com"},
+								},
+							},
+							{
+								Bid: &openrtb2.Bid{
+									ID:      "keep_ba.com",
+									ADomain: []string{"ba.com"},
+								},
+							},
+							{
+								Bid: &openrtb2.Bid{
+									ID:      "keep_ba.com",
+									ADomain: []string{"b.a.com.shri.com"},
+								},
+							},
+							{
+								Bid: &openrtb2.Bid{
+									ID:      "reject_b.a.com.a.com.b.c.d.a.com",
+									ADomain: []string{"b.a.com.a.com.b.c.d.a.com"},
+								},
+							},
+						},
+						BidderCoreName: openrtb_ext.BidderVASTBidder,
+					},
+				},
+			},
+			want: want{
+				expectedRejectedBids: []analytics.RejectedBid{
+					{
+						RejectionReason: openrtb3.LossBidAdvertiserBlocking,
+						Bid: &entities.PbsOrtbBid{Bid: &openrtb2.Bid{
+							ID:      "a.com_bid",
+							ADomain: []string{"a.com"},
+						}},
+						Seat: "",
+					},
+					{
+						RejectionReason: openrtb3.LossBidAdvertiserBlocking,
+						Bid: &entities.PbsOrtbBid{Bid: &openrtb2.Bid{
+							ID:      "reject_b.a.com.a.com.b.c.d.a.com",
+							ADomain: []string{"b.a.com.a.com.b.c.d.a.com"},
+						}},
+						Seat: "",
+					},
+				},
+				rejectedBidIds: []string{"a.com_bid", "reject_b.a.com.a.com.b.c.d.a.com"},
+				validBidCountPerSeat: map[string]int{
+					"vast_tag_bidder": 3,
+				},
+			},
+		},
+		{
+			name: "Badv_is_not_present", // expect no advertiser blocking
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: nil},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("tab_bidder_1"): {
+						Bids: []*entities.PbsOrtbBid{
+							{Bid: &openrtb2.Bid{ID: "bid_1_adapter_1", ADomain: []string{"a.com"}}},
+							{Bid: &openrtb2.Bid{ID: "bid_2_adapter_1"}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{}, // no bid rejection expected
+				validBidCountPerSeat: map[string]int{
+					"tab_bidder_1": 2,
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		},
+		{
+			name: "adomain_is_not_present_but_Badv_is_set", // reject bids without adomain as badv is set
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: []string{"advertiser_1.com"}},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("tag_bidder_1"): {
+						Bids: []*entities.PbsOrtbBid{ // expect all bids are rejected
+							{Bid: &openrtb2.Bid{ID: "bid_1_adapter_1_without_adomain"}},
+							{Bid: &openrtb2.Bid{ID: "bid_2_adapter_1_with_empty_adomain", ADomain: []string{"", " "}}},
+						},
+					},
+					newTestRtbAdapter("rtb_bidder_1"): {
+						Bids: []*entities.PbsOrtbBid{ // all bids should be present. It belongs to RTB adapator
+							{Bid: &openrtb2.Bid{ID: "bid_1_adapter_2_without_adomain"}},
+							{Bid: &openrtb2.Bid{ID: "bid_2_adapter_2_with_empty_adomain", ADomain: []string{"", " "}}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{"bid_1_adapter_1_without_adomain", "bid_2_adapter_1_with_empty_adomain"},
+				validBidCountPerSeat: map[string]int{
+					"tag_bidder_1": 0, // expect 0 bids. i.e. all bids are rejected
+					"rtb_bidder_1": 2, // no bid must be rejected
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		},
+		{
+			name: "adomain_and_badv_is_not_present", // expect no advertiser blocking
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("tag_adaptor_1"): {
+						Bids: []*entities.PbsOrtbBid{
+							{Bid: &openrtb2.Bid{ID: "bid_without_adomain"}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{}, // no rejection expected as badv not present
+				validBidCountPerSeat: map[string]int{
+					"tag_adaptor_1": 1,
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		},
+		{
+			name: "empty_badv", // expect no advertiser blocking
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: []string{}},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("tag_bidder_1"): {
+						Bids: []*entities.PbsOrtbBid{ // expect all bids are rejected
+							{Bid: &openrtb2.Bid{ID: "bid_1_adapter_1", ADomain: []string{"a.com"}}},
+							{Bid: &openrtb2.Bid{ID: "bid_2_adapter_1"}},
+						},
+					},
+					newTestRtbAdapter("rtb_bidder_1"): {
+						Bids: []*entities.PbsOrtbBid{ // all bids should be present. It belongs to RTB adapator
+							{Bid: &openrtb2.Bid{ID: "bid_1_adapter_2_without_adomain"}},
+							{Bid: &openrtb2.Bid{ID: "bid_2_adapter_2_with_empty_adomain", ADomain: []string{"", " "}}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{}, // no rejections expect as there is not badv set
+				validBidCountPerSeat: map[string]int{
+					"tag_bidder_1": 2,
+					"rtb_bidder_1": 2,
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		},
+		{
+			name: "nil_badv", // expect no advertiser blocking
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: nil},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("tag_bidder_1"): {
+						Bids: []*entities.PbsOrtbBid{ // expect all bids are rejected
+							{Bid: &openrtb2.Bid{ID: "bid_1_adapter_1", ADomain: []string{"a.com"}}},
+							{Bid: &openrtb2.Bid{ID: "bid_2_adapter_1"}},
+						},
+					},
+					newTestRtbAdapter("rtb_bidder_1"): {
+						Bids: []*entities.PbsOrtbBid{ // all bids should be present. It belongs to RTB adapator
+							{Bid: &openrtb2.Bid{ID: "bid_1_adapter_2_without_adomain"}},
+							{Bid: &openrtb2.Bid{ID: "bid_2_adapter_2_with_empty_adomain", ADomain: []string{"", " "}}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{}, // no rejections expect as there is not badv set
+				validBidCountPerSeat: map[string]int{
+					"tag_bidder_1": 2,
+					"rtb_bidder_1": 2,
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		},
+		{
+			name: "ad_domains_normalized_and_checked",
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: []string{"a.com"}},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("my_adapter"): {
+						Bids: []*entities.PbsOrtbBid{
+							{Bid: &openrtb2.Bid{ID: "bid_1_of_blocked_adv", ADomain: []string{"www.a.com"}}},
+							// expect a.com is extracted from page url
+							{Bid: &openrtb2.Bid{ID: "bid_2_of_blocked_adv", ADomain: []string{"http://a.com/my/page?k1=v1&k2=v2"}}},
+							// invalid adomain - will be skipped and the bid will be not be rejected
+							{Bid: &openrtb2.Bid{ID: "bid_3_with_domain_abcd1234", ADomain: []string{"abcd1234"}}},
+						},
+					}},
+			},
+			want: want{
+				rejectedBidIds:       []string{"bid_1_of_blocked_adv", "bid_2_of_blocked_adv"},
+				validBidCountPerSeat: map[string]int{"my_adapter": 1},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		}, {
+			name: "multiple_badv",
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: []string{"advertiser_1.com", "advertiser_2.com", "www.advertiser_3.com"}},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("tag_adapter_1"): {
+						Bids: []*entities.PbsOrtbBid{
+							// adomain without www prefix
+							{Bid: &openrtb2.Bid{ID: "bid_1_tag_adapter_1", ADomain: []string{"advertiser_3.com"}}},
+							{Bid: &openrtb2.Bid{ID: "bid_2_tag_adapter_1", ADomain: []string{"advertiser_2.com"}}},
+							{Bid: &openrtb2.Bid{ID: "bid_3_tag_adapter_1", ADomain: []string{"advertiser_4.com"}}},
+							{Bid: &openrtb2.Bid{ID: "bid_4_tag_adapter_1", ADomain: []string{"advertiser_100.com"}}},
+						},
+					},
+					newTestTagAdapter("tag_adapter_2"): {
+						Bids: []*entities.PbsOrtbBid{
+							// adomain has www prefix
+							{Bid: &openrtb2.Bid{ID: "bid_1_tag_adapter_2", ADomain: []string{"www.advertiser_1.com"}}},
+						},
+					},
+					newTestRtbAdapter("rtb_adapter_1"): {
+						Bids: []*entities.PbsOrtbBid{
+							// should not reject following bid though its advertiser is blocked
+							// because this bid belongs to RTB Adaptor
+							{Bid: &openrtb2.Bid{ID: "bid_1_rtb_adapter_2", ADomain: []string{"advertiser_1.com"}}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{"bid_1_tag_adapter_1", "bid_2_tag_adapter_1", "bid_1_tag_adapter_2"},
+				validBidCountPerSeat: map[string]int{
+					"tag_adapter_1": 2,
+					"tag_adapter_2": 0,
+					"rtb_adapter_1": 1,
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		}, {
+			name: "multiple_adomain",
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: []string{"www.advertiser_3.com"}},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("tag_adapter_1"): {
+						Bids: []*entities.PbsOrtbBid{
+							// adomain without www prefix
+							{Bid: &openrtb2.Bid{ID: "bid_1_tag_adapter_1", ADomain: []string{"a.com", "b.com", "advertiser_3.com", "d.com"}}},
+							{Bid: &openrtb2.Bid{ID: "bid_2_tag_adapter_1", ADomain: []string{"a.com", "https://advertiser_3.com"}}},
+							{Bid: &openrtb2.Bid{ID: "bid_3_tag_adapter_1", ADomain: []string{"advertiser_4.com"}}},
+							{Bid: &openrtb2.Bid{ID: "bid_4_tag_adapter_1", ADomain: []string{"advertiser_100.com"}}},
+						},
+					},
+					newTestTagAdapter("tag_adapter_2"): {
+						Bids: []*entities.PbsOrtbBid{
+							// adomain has www prefix
+							{Bid: &openrtb2.Bid{ID: "bid_1_tag_adapter_2", ADomain: []string{"a.com", "b.com", "www.advertiser_3.com"}}},
+						},
+					},
+					newTestRtbAdapter("rtb_adapter_1"): {
+						Bids: []*entities.PbsOrtbBid{
+							// should not reject following bid though its advertiser is blocked
+							// because this bid belongs to RTB Adaptor
+							{Bid: &openrtb2.Bid{ID: "bid_1_rtb_adapter_2", ADomain: []string{"a.com", "b.com", "advertiser_3.com"}}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{"bid_1_tag_adapter_1", "bid_2_tag_adapter_1", "bid_1_tag_adapter_2"},
+				validBidCountPerSeat: map[string]int{
+					"tag_adapter_1": 2,
+					"tag_adapter_2": 0,
+					"rtb_adapter_1": 1,
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		}, {
+			name: "case_insensitive_badv", // case of domain not matters
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: []string{"ADVERTISER_1.COM"}},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("tag_adapter_1"): {
+						Bids: []*entities.PbsOrtbBid{
+							{Bid: &openrtb2.Bid{ID: "bid_1_rtb_adapter_1", ADomain: []string{"advertiser_1.com"}}},
+							{Bid: &openrtb2.Bid{ID: "bid_2_rtb_adapter_1", ADomain: []string{"www.advertiser_1.com"}}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{"bid_1_rtb_adapter_1", "bid_2_rtb_adapter_1"},
+				validBidCountPerSeat: map[string]int{
+					"tag_adapter_1": 0, // expect all bids are rejected as belongs to blocked advertiser
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		},
+		{
+			name: "case_insensitive_adomain",
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: []string{"advertiser_1.com"}},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("tag_adapter_1"): {
+						Bids: []*entities.PbsOrtbBid{
+							{Bid: &openrtb2.Bid{ID: "bid_1_rtb_adapter_1", ADomain: []string{"advertiser_1.COM"}}},
+							{Bid: &openrtb2.Bid{ID: "bid_2_rtb_adapter_1", ADomain: []string{"wWw.ADVERTISER_1.com"}}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{"bid_1_rtb_adapter_1", "bid_2_rtb_adapter_1"},
+				validBidCountPerSeat: map[string]int{
+					"tag_adapter_1": 0, // expect all bids are rejected as belongs to blocked advertiser
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		},
+		{
+			name: "various_tld_combinations",
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: []string{"http://blockme.shri"}},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("block_bidder"): {
+						Bids: []*entities.PbsOrtbBid{
+							{Bid: &openrtb2.Bid{ADomain: []string{"www.blockme.shri"}, ID: "reject_www.blockme.shri"}},
+							{Bid: &openrtb2.Bid{ADomain: []string{"http://www.blockme.shri"}, ID: "rejecthttp://www.blockme.shri"}},
+							{Bid: &openrtb2.Bid{ADomain: []string{"https://blockme.shri"}, ID: "reject_https://blockme.shri"}},
+							{Bid: &openrtb2.Bid{ADomain: []string{"https://www.blockme.shri"}, ID: "reject_https://www.blockme.shri"}},
+						},
+					},
+					newTestRtbAdapter("rtb_non_block_bidder"): {
+						Bids: []*entities.PbsOrtbBid{ // all below bids are eligible and should not be rejected
+							{Bid: &openrtb2.Bid{ADomain: []string{"www.blockme.shri"}, ID: "accept_bid_www.blockme.shri"}},
+							{Bid: &openrtb2.Bid{ADomain: []string{"http://www.blockme.shri"}, ID: "accept_bid__http://www.blockme.shri"}},
+							{Bid: &openrtb2.Bid{ADomain: []string{"https://blockme.shri"}, ID: "accept_bid__https://blockme.shri"}},
+							{Bid: &openrtb2.Bid{ADomain: []string{"https://www.blockme.shri"}, ID: "accept_bid__https://www.blockme.shri"}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{"reject_www.blockme.shri", "reject_http://www.blockme.shri", "reject_https://blockme.shri", "reject_https://www.blockme.shri"},
+				validBidCountPerSeat: map[string]int{
+					"block_bidder":         0,
+					"rtb_non_block_bidder": 4,
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		},
+		{
+			name: "subdomain_tests",
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: []string{"10th.college.puneunv.edu"}},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("block_bidder"): {
+						Bids: []*entities.PbsOrtbBid{
+							{Bid: &openrtb2.Bid{ADomain: []string{"shri.10th.college.puneunv.edu"}, ID: "reject_shri.10th.college.puneunv.edu"}},
+							{Bid: &openrtb2.Bid{ADomain: []string{"puneunv.edu"}, ID: "allow_puneunv.edu"}},
+							{Bid: &openrtb2.Bid{ADomain: []string{"http://WWW.123.456.10th.college.PUNEUNV.edu"}, ID: "reject_123.456.10th.college.puneunv.edu"}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{"reject_shri.10th.college.puneunv.edu", "reject_123.456.10th.college.puneunv.edu"},
+				validBidCountPerSeat: map[string]int{
+					"block_bidder": 1,
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		}, {
+			name: "only_domain_test", // do not expect bid rejection. edu is valid domain
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: []string{"edu"}},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("tag_bidder"): {
+						Bids: []*entities.PbsOrtbBid{
+							{Bid: &openrtb2.Bid{ADomain: []string{"school.edu"}, ID: "keep_bid_school.edu"}},
+							{Bid: &openrtb2.Bid{ADomain: []string{"edu"}, ID: "keep_bid_edu"}},
+							{Bid: &openrtb2.Bid{ADomain: []string{"..edu"}, ID: "keep_bid_..edu"}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{},
+				validBidCountPerSeat: map[string]int{
+					"tag_bidder": 3,
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		},
+		{
+			name: "public_suffix_in_badv",
+			args: args{
+				advBlockReq: &AuctionRequest{
+					BidRequestWrapper: &openrtb_ext.RequestWrapper{
+						BidRequest: &openrtb2.BidRequest{BAdv: []string{"co.in"}},
+					},
+					LoggableObject: &analytics.LoggableAuctionObject{},
+				},
+				// co.in is valid public suffix
+				adaptorSeatBids: map[*bidderAdapter]*entities.PbsOrtbSeatBid{
+					newTestTagAdapter("tag_bidder"): {
+						Bids: []*entities.PbsOrtbBid{
+							{Bid: &openrtb2.Bid{ADomain: []string{"a.co.in"}, ID: "allow_a.co.in"}},
+							{Bid: &openrtb2.Bid{ADomain: []string{"b.com"}, ID: "allow_b.com"}},
+						},
+					},
+				},
+			},
+			want: want{
+				rejectedBidIds: []string{},
+				validBidCountPerSeat: map[string]int{
+					"tag_bidder": 2,
+				},
+				expectedRejectedBids: []analytics.RejectedBid{},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if tt.name != "reject_bid_of_blocked_adv_from_tag_bidder" {
+				return
+			}
+			seatBids := make(map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid)
+			tagBidders := make(map[openrtb_ext.BidderName]adapters.Bidder)
+			adapterMap := make(map[openrtb_ext.BidderName]AdaptedBidder, 0)
+			for adaptor, sbids := range tt.args.adaptorSeatBids {
+				adapterMap[adaptor.BidderName] = adaptor
+				if tagBidder, ok := adaptor.Bidder.(*vastbidder.TagBidder); ok {
+					tagBidders[adaptor.BidderName] = tagBidder
+				}
+				seatBids[adaptor.BidderName] = sbids
+			}
+
+			// applyAdvertiserBlocking internally uses tagBidders from (adapter_map.go)
+			// not testing alias here
+			seatBids, rejections := applyAdvertiserBlocking(tt.args.advBlockReq, seatBids)
+			re := regexp.MustCompile("bid rejected \\[bid ID:(.*?)\\] reason")
+			for bidder, sBid := range seatBids {
+				// verify only eligible bids are returned
+				assert.Equal(t, tt.want.validBidCountPerSeat[string(bidder)], len(sBid.Bids), "Expected eligible bids are %d, but found [%d] ", tt.want.validBidCountPerSeat[string(bidder)], len(sBid.Bids))
+				// verify  rejections
+				assert.Equal(t, len(tt.want.rejectedBidIds), len(rejections), "Expected bid rejections are %d, but found [%d]", len(tt.want.rejectedBidIds), len(rejections))
+				// verify rejected bid ids
+				present := false
+				for _, expectRejectedBidID := range tt.want.rejectedBidIds {
+					for _, rejection := range rejections {
+						match := re.FindStringSubmatch(rejection)
+						rejectedBidID := strings.Trim(match[1], " ")
+						if expectRejectedBidID == rejectedBidID {
+							present = true
+							break
+						}
+					}
+					if present {
+						break
+					}
+				}
+				if len(tt.want.rejectedBidIds) > 0 && !present {
+					assert.Fail(t, "Expected Bid ID [%s] as rejected. But bid is not rejected", re)
+				}
+
+				if sBid.BidderCoreName != openrtb_ext.BidderVASTBidder {
+					continue // advertiser blocking is currently enabled only for tag bidders
+				}
+
+				sort.Slice(tt.args.advBlockReq.LoggableObject.RejectedBids, func(i, j int) bool {
+					return tt.args.advBlockReq.LoggableObject.RejectedBids[i].Bid.Bid.ID > tt.args.advBlockReq.LoggableObject.RejectedBids[j].Bid.Bid.ID
+				})
+				sort.Slice(tt.want.expectedRejectedBids, func(i, j int) bool {
+					return tt.want.expectedRejectedBids[i].Bid.Bid.ID > tt.want.expectedRejectedBids[j].Bid.Bid.ID
+				})
+				assert.Equal(t, tt.want.expectedRejectedBids, tt.args.advBlockReq.LoggableObject.RejectedBids, "Rejected Bids not matching")
+
+				for _, bid := range sBid.Bids {
+					if nil != bid.Bid.ADomain {
+						for _, adomain := range bid.Bid.ADomain {
+							for _, blockDomain := range tt.args.advBlockReq.BidRequestWrapper.BidRequest.BAdv {
+								nDomain, _ := normalizeDomain(adomain)
+								if nDomain == blockDomain {
+									assert.Fail(t, "bid %s with ad domain %s is not blocked", bid.Bid.ID, adomain)
+								}
+							}
+						}
+					}
+
+					// verify this bid not belongs to rejected list
+					for _, rejectedBidID := range tt.want.rejectedBidIds {
+						if rejectedBidID == bid.Bid.ID {
+							assert.Fail(t, "Bid ID [%s] is not expected in list of rejected bids", bid.Bid.ID)
+						}
+					}
+				}
+			}
+		})
+	}
+}
+
+func TestNormalizeDomain(t *testing.T) {
+	type args struct {
+		domain string
+	}
+	type want struct {
+		domain string
+		err    error
+	}
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{name: "a.com", args: args{domain: "a.com"}, want: want{domain: "a.com"}},
+		{name: "http://a.com", args: args{domain: "http://a.com"}, want: want{domain: "a.com"}},
+		{name: "https://a.com", args: args{domain: "https://a.com"}, want: want{domain: "a.com"}},
+		{name: "https://www.a.com", args: args{domain: "https://www.a.com"}, want: want{domain: "a.com"}},
+		{name: "https://www.a.com/my/page?k=1", args: args{domain: "https://www.a.com/my/page?k=1"}, want: want{domain: "a.com"}},
+		{name: "empty_domain", args: args{domain: ""}, want: want{domain: ""}},
+		{name: "trim_domain", args: args{domain: " trim.me?k=v    "}, want: want{domain: "trim.me"}},
+		{name: "trim_domain_with_http_in_it", args: args{domain: " http://trim.me?k=v    "}, want: want{domain: "trim.me"}},
+		{name: "https://www.something.a.com/my/page?k=1", args: args{domain: "https://www.something.a.com/my/page?k=1"}, want: want{domain: "something.a.com"}},
+		{name: "wWW.something.a.com", args: args{domain: "wWW.something.a.com"}, want: want{domain: "something.a.com"}},
+		{name: "2_times_www", args: args{domain: "www.something.www.a.com"}, want: want{domain: "something.www.a.com"}},
+		{name: "consecutive_www", args: args{domain: "www.www.something.a.com"}, want: want{domain: "www.something.a.com"}},
+		{name: "abchttp.com", args: args{domain: "abchttp.com"}, want: want{domain: "abchttp.com"}},
+		{name: "HTTP://CAPS.com", args: args{domain: "HTTP://CAPS.com"}, want: want{domain: "caps.com"}},
+
+		// publicsuffix
+		{name: "co.in", args: args{domain: "co.in"}, want: want{domain: "", err: fmt.Errorf("domain [co.in] is public suffix")}},
+		{name: ".co.in", args: args{domain: ".co.in"}, want: want{domain: ".co.in"}},
+		{name: "amazon.co.in", args: args{domain: "amazon.co.in"}, want: want{domain: "amazon.co.in"}},
+		// we wont check if shriprasad belongs to icann
+		{name: "shriprasad", args: args{domain: "shriprasad"}, want: want{domain: "", err: fmt.Errorf("domain [shriprasad] is public suffix")}},
+		{name: ".shriprasad", args: args{domain: ".shriprasad"}, want: want{domain: ".shriprasad"}},
+		{name: "abc.shriprasad", args: args{domain: "abc.shriprasad"}, want: want{domain: "abc.shriprasad"}},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			adjustedDomain, err := normalizeDomain(tt.args.domain)
+			actualErr := "nil"
+			expectedErr := "nil"
+			if nil != err {
+				actualErr = err.Error()
+			}
+			if nil != tt.want.err {
+				actualErr = tt.want.err.Error()
+			}
+			assert.Equal(t, tt.want.err, err, "Expected error is %s, but found [%s]", expectedErr, actualErr)
+			assert.Equal(t, tt.want.domain, adjustedDomain, "Expected domain is %s, but found [%s]", tt.want.domain, adjustedDomain)
+		})
+	}
+}
+
+func newTestTagAdapter(name string) *bidderAdapter {
+	return &bidderAdapter{
+		Bidder:     vastbidder.NewTagBidder(openrtb_ext.BidderName(name), config.Adapter{}),
+		BidderName: openrtb_ext.BidderName(name),
+	}
+}
+
+func newTestRtbAdapter(name string) *bidderAdapter {
+	return &bidderAdapter{
+		Bidder:     &goodSingleBidder{},
+		BidderName: openrtb_ext.BidderName(name),
+	}
+}
+
+func TestRecordAdaptorDuplicateBidIDs(t *testing.T) {
+	type bidderCollisions = map[string]int
+	testCases := []struct {
+		scenario         string
+		bidderCollisions *bidderCollisions // represents no of collisions detected for bid.id at bidder level for given request
+		hasCollision     bool
+	}{
+		{scenario: "invalid collision value", bidderCollisions: &map[string]int{"bidder-1": -1}, hasCollision: false},
+		{scenario: "no collision", bidderCollisions: &map[string]int{"bidder-1": 0}, hasCollision: false},
+		{scenario: "one collision", bidderCollisions: &map[string]int{"bidder-1": 1}, hasCollision: false},
+		{scenario: "multiple collisions", bidderCollisions: &map[string]int{"bidder-1": 2}, hasCollision: true}, // when 2 collisions it counter will be 1
+		{scenario: "multiple bidders", bidderCollisions: &map[string]int{"bidder-1": 2, "bidder-2": 4}, hasCollision: true},
+		{scenario: "multiple bidders with bidder-1 no collision", bidderCollisions: &map[string]int{"bidder-1": 1, "bidder-2": 4}, hasCollision: true},
+		{scenario: "no bidders", bidderCollisions: nil, hasCollision: false},
+	}
+	testEngine := metricsConf.NewMetricsEngine(&config.Configuration{}, nil, nil, nil)
+
+	for _, testcase := range testCases {
+		var adapterBids map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid
+		if nil == testcase.bidderCollisions {
+			break
+		}
+		adapterBids = make(map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid)
+		for bidder, collisions := range *testcase.bidderCollisions {
+			bids := make([]*entities.PbsOrtbBid, 0)
+			testBidID := "bid_id_for_bidder_" + bidder
+			// add bids as per collisions value
+			bidCount := 0
+			for ; bidCount < collisions; bidCount++ {
+				bids = append(bids, &entities.PbsOrtbBid{
+					Bid: &openrtb2.Bid{
+						ID: testBidID,
+					},
+				})
+			}
+			if nil == adapterBids[openrtb_ext.BidderName(bidder)] {
+				adapterBids[openrtb_ext.BidderName(bidder)] = new(entities.PbsOrtbSeatBid)
+			}
+			adapterBids[openrtb_ext.BidderName(bidder)].Bids = bids
+		}
+		assert.Equal(t, testcase.hasCollision, recordAdaptorDuplicateBidIDs(testEngine, adapterBids))
+	}
+}
+
+func TestMakeBidExtJSONOW(t *testing.T) {
+
+	type aTest struct {
+		description        string
+		ext                json.RawMessage
+		extBidPrebid       openrtb_ext.ExtBidPrebid
+		impExtInfo         map[string]ImpExtInfo
+		origbidcpm         float64
+		origbidcur         string
+		origbidcpmusd      float64
+		expectedBidExt     string
+		expectedErrMessage string
+	}
+
+	testCases := []aTest{
+		{
+			description:        "Valid extension with origbidcpmusd = 0",
+			ext:                json.RawMessage(`{"video":{"h":100}}`),
+			extBidPrebid:       openrtb_ext.ExtBidPrebid{Type: openrtb_ext.BidType("video"), Meta: &openrtb_ext.ExtBidPrebidMeta{BrandName: "foo"}, Passthrough: nil},
+			impExtInfo:         map[string]ImpExtInfo{"test_imp_id": {true, []byte(`{"video":{"h":480,"mimes":["video/mp4"]}}`), json.RawMessage(`{"imp_passthrough_val": 1}`)}},
+			origbidcpm:         10.0000,
+			origbidcur:         "USD",
+			expectedBidExt:     `{"prebid":{"meta": {"brandName": "foo"}, "passthrough":{"imp_passthrough_val":1}, "type":"video"}, "storedrequestattributes":{"h":480,"mimes":["video/mp4"]},"video":{"h":100}, "origbidcpm": 10, "origbidcur": "USD"}`,
+			expectedErrMessage: "",
+		},
+		{
+			description:        "Valid extension with origbidcpmusd > 0",
+			ext:                json.RawMessage(`{"video":{"h":100}}`),
+			extBidPrebid:       openrtb_ext.ExtBidPrebid{Type: openrtb_ext.BidType("video"), Meta: &openrtb_ext.ExtBidPrebidMeta{BrandName: "foo"}, Passthrough: nil},
+			impExtInfo:         map[string]ImpExtInfo{"test_imp_id": {true, []byte(`{"video":{"h":480,"mimes":["video/mp4"]}}`), json.RawMessage(`{"imp_passthrough_val": 1}`)}},
+			origbidcpm:         10.0000,
+			origbidcur:         "USD",
+			origbidcpmusd:      10.0000,
+			expectedBidExt:     `{"prebid":{"meta": {"brandName": "foo"}, "passthrough":{"imp_passthrough_val":1}, "type":"video"}, "storedrequestattributes":{"h":480,"mimes":["video/mp4"]},"video":{"h":100}, "origbidcpm": 10, "origbidcur": "USD", "origbidcpmusd": 10}`,
+			expectedErrMessage: "",
+		},
+	}
+
+	for _, test := range testCases {
+		result, err := makeBidExtJSON(test.ext, &test.extBidPrebid, test.impExtInfo, "test_imp_id", test.origbidcpm, test.origbidcur, test.origbidcpmusd)
+
+		if test.expectedErrMessage == "" {
+			assert.JSONEq(t, test.expectedBidExt, string(result), "Incorrect result")
+			assert.NoError(t, err, "Error should not be returned")
+		} else {
+			assert.Contains(t, err.Error(), test.expectedErrMessage, "incorrect error message")
+		}
+	}
+}
+
+func TestUpdateRejectedBidExt(t *testing.T) {
+	type args struct {
+		loggableObject *analytics.LoggableAuctionObject
+	}
+	type want struct {
+		loggableObject *analytics.LoggableAuctionObject
+	}
+	type test struct {
+		name string
+		args args
+		want want
+	}
+
+	testCases := []test{
+		{
+			name: "nil rejected bid",
+			args: args{
+				loggableObject: &analytics.LoggableAuctionObject{
+					RejectedBids: []analytics.RejectedBid{
+						{
+							Bid: &entities.PbsOrtbBid{Bid: &openrtb2.Bid{
+								ID: "b1",
+							},
+							},
+						},
+					},
+				},
+			},
+			want: want{
+				loggableObject: &analytics.LoggableAuctionObject{
+					RejectedBids: []analytics.RejectedBid{
+						{
+							Bid: &entities.PbsOrtbBid{Bid: &openrtb2.Bid{
+								ID:  "b1",
+								Ext: json.RawMessage(`{"origbidcpm":0,"prebid":{}}`),
+							},
+								OriginalBidCPM: 0,
+								BidType:        "",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "malformed bid.ext json",
+			args: args{
+				loggableObject: &analytics.LoggableAuctionObject{
+					RejectedBids: []analytics.RejectedBid{
+						{
+							Bid: &entities.PbsOrtbBid{Bid: &openrtb2.Bid{
+								ID: "b1",
+							},
+							},
+						},
+					},
+				},
+			},
+			want: want{
+				loggableObject: &analytics.LoggableAuctionObject{
+					RejectedBids: []analytics.RejectedBid{
+						{
+							Bid: &entities.PbsOrtbBid{Bid: &openrtb2.Bid{
+								ID:  "b1",
+								Ext: json.RawMessage(`{"origbidcpm":0,"prebid":{}}`),
+							},
+								OriginalBidCPM: 0,
+								BidType:        "",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "valid pbsOrtbBid",
+			args: args{
+				loggableObject: &analytics.LoggableAuctionObject{
+					RejectedBids: []analytics.RejectedBid{{
+						Bid: &entities.PbsOrtbBid{
+							Bid: &openrtb2.Bid{
+								ID:  "b2",
+								Ext: json.RawMessage(`{"key":"value"}`),
+							},
+							DealPriority:   10,
+							OriginalBidCPM: 10,
+							BidType:        openrtb_ext.BidTypeBanner,
+						},
+						Seat:            "pubmatic",
+						RejectionReason: openrtb3.LossBidAdvertiserBlocking}},
+				},
+			},
+			want: want{
+				loggableObject: &analytics.LoggableAuctionObject{
+					RejectedBids: []analytics.RejectedBid{
+						{
+							Bid: &entities.PbsOrtbBid{Bid: &openrtb2.Bid{
+								ID:  "b2",
+								Ext: json.RawMessage(`{"key":"value","origbidcpm":10,"prebid":{"dealpriority":10,"type":"banner"}}`),
+							},
+								DealPriority:   10,
+								OriginalBidCPM: 10,
+								BidType:        openrtb_ext.BidTypeBanner,
+							},
+							Seat:            "pubmatic",
+							RejectionReason: openrtb3.LossBidAdvertiserBlocking,
+						},
+					},
+				},
+			},
+		},
+	}
+	for _, test := range testCases {
+		t.Run(test.name, func(t *testing.T) {
+			UpdateRejectedBidExt(test.args.loggableObject)
+			assert.Equal(t, test.want.loggableObject.RejectedBids[0].Bid.Bid.Ext, test.args.loggableObject.RejectedBids[0].Bid.Bid.Ext, "mismatched loggableObject for test-[%+v]", test.name)
+
+		})
+	}
+}
+
+func TestCallRecordBids(t *testing.T) {
+
+	type args struct {
+		ctx              context.Context
+		pubID            string
+		adapterBids      map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid
+		getMetricsEngine func() *metrics.MetricsEngineMock
+	}
+
+	tests := []struct {
+		name string
+		args args
+	}{
+		{
+			name: "empty context",
+			args: args{
+				ctx:   context.Background(),
+				pubID: "1010",
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					return &metrics.MetricsEngineMock{}
+				},
+			},
+		},
+		{
+			name: "bidCountMetricEnabled is false",
+			args: args{
+				ctx:   context.WithValue(context.Background(), bidCountMetricEnabled, false),
+				pubID: "1010",
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					return &metrics.MetricsEngineMock{}
+				},
+			},
+		},
+		{
+			name: "bidCountMetricEnabled is true, owProfileId is non-string",
+			args: args{
+				ctx:   context.WithValue(context.WithValue(context.Background(), bidCountMetricEnabled, true), owProfileId, 1),
+				pubID: "1010",
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					return &metrics.MetricsEngineMock{}
+				},
+			},
+		},
+		{
+			name: "bidCountMetricEnabled is true, owProfileId is empty",
+			args: args{
+				ctx:   context.WithValue(context.WithValue(context.Background(), bidCountMetricEnabled, true), owProfileId, ""),
+				pubID: "1010",
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					return &metrics.MetricsEngineMock{}
+				},
+			},
+		},
+		{
+			name: "empty adapterBids",
+			args: args{
+				ctx:         context.WithValue(context.WithValue(context.Background(), bidCountMetricEnabled, true), owProfileId, "11"),
+				pubID:       "1010",
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					return &metrics.MetricsEngineMock{}
+				},
+			},
+		},
+		{
+			name: "empty adapterBids.seat",
+			args: args{
+				ctx:   context.WithValue(context.WithValue(context.Background(), bidCountMetricEnabled, true), owProfileId, "11"),
+				pubID: "1010",
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					return &metrics.MetricsEngineMock{}
+				},
+			},
+		},
+		{
+			name: "empty adapterBids.seat.bids",
+			args: args{
+				ctx:   context.WithValue(context.WithValue(context.Background(), bidCountMetricEnabled, true), owProfileId, "11"),
+				pubID: "1010",
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						Bids: []*entities.PbsOrtbBid{},
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					return &metrics.MetricsEngineMock{}
+				},
+			},
+		},
+		{
+			name: "multiple non deal bid",
+			args: args{
+				ctx:   context.WithValue(context.WithValue(context.Background(), bidCountMetricEnabled, true), owProfileId, "11"),
+				pubID: "1010",
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						Bids: []*entities.PbsOrtbBid{
+							{
+								Bid: &openrtb2.Bid{
+									ID: "bid1",
+								},
+							},
+							{
+								Bid: &openrtb2.Bid{
+									ID: "bid2",
+								},
+							},
+						},
+						Seat: "pubmatic",
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					metricEngine.Mock.On("RecordBids", "1010", "11", "pubmatic", nodeal).Return()
+					metricEngine.Mock.On("RecordBids", "1010", "11", "pubmatic", nodeal).Return()
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "multiple deal bid",
+			args: args{
+				ctx:   context.WithValue(context.WithValue(context.Background(), bidCountMetricEnabled, true), owProfileId, "11"),
+				pubID: "1010",
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						Bids: []*entities.PbsOrtbBid{
+							{
+								Bid: &openrtb2.Bid{
+									ID:     "bid1",
+									DealID: "pubdeal",
+								},
+							},
+							{
+								Bid: &openrtb2.Bid{
+									ID:     "bid2",
+									DealID: "pubdeal",
+								},
+							},
+						},
+						Seat: "pubmatic",
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					metricEngine.Mock.On("RecordBids", "1010", "11", "pubmatic", "pubdeal").Return()
+					metricEngine.Mock.On("RecordBids", "1010", "11", "pubmatic", "pubdeal").Return()
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "multiple bidders",
+			args: args{
+				ctx:   context.WithValue(context.WithValue(context.Background(), bidCountMetricEnabled, true), owProfileId, "11"),
+				pubID: "1010",
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						Bids: []*entities.PbsOrtbBid{
+							{
+								Bid: &openrtb2.Bid{
+									ID:     "bid1",
+									DealID: "pubdeal",
+								},
+							},
+						},
+						Seat: "pubmatic",
+					},
+					"appnexus": {
+						Bids: []*entities.PbsOrtbBid{
+							{
+								Bid: &openrtb2.Bid{
+									ID:     "bid2",
+									DealID: "appnxdeal",
+								},
+							},
+							{
+								Bid: &openrtb2.Bid{
+									ID: "bid3",
+								},
+							},
+						},
+						Seat: "appnexus",
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					metricEngine.Mock.On("RecordBids", "1010", "11", "pubmatic", "pubdeal").Return()
+					metricEngine.Mock.On("RecordBids", "1010", "11", "appnexus", "appnxdeal").Return()
+					metricEngine.Mock.On("RecordBids", "1010", "11", "appnexus", nodeal).Return()
+					return metricEngine
+				},
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			mockMetricEngine := tt.args.getMetricsEngine()
+			recordBids(tt.args.ctx, mockMetricEngine, tt.args.pubID, tt.args.adapterBids)
+			mockMetricEngine.AssertExpectations(t)
+		})
+	}
+}
+
+func TestRecordVastVersion(t *testing.T) {
+	type args struct {
+		metricsEngine    metrics.MetricsEngine
+		adapterBids      map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid
+		getMetricsEngine func() *metrics.MetricsEngineMock
+	}
+	tests := []struct {
+		name string
+		args args
+	}{
+		{
+			name: "No Bids",
+			args: args{
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "Empty Bids in SeatBid",
+			args: args{
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						Bids: []*entities.PbsOrtbBid{},
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "Empty Bids in SeatBid",
+			args: args{
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						Bids: []*entities.PbsOrtbBid{},
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "Invalid Bid Type",
+			args: args{
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						Bids: []*entities.PbsOrtbBid{
+							{
+								BidType: openrtb_ext.BidTypeBanner,
+							},
+						},
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "No Adm in Bids",
+			args: args{
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						Bids: []*entities.PbsOrtbBid{
+							{
+								Bid: &openrtb2.Bid{
+									AdM: "",
+								},
+								BidType: openrtb_ext.BidTypeVideo,
+							},
+						},
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "No version found in Adm",
+			args: args{
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						BidderCoreName: "pubmatic",
+						Bids: []*entities.PbsOrtbBid{
+							{
+								Bid: &openrtb2.Bid{
+									AdM: "<Vast> <Vast>",
+								},
+								BidType: openrtb_ext.BidTypeVideo,
+							},
+						},
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					metricEngine.Mock.On("RecordVastVersion", "pubmatic", vastVersionUndefined).Return()
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "Version found in Adm",
+			args: args{
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						BidderCoreName: "pubmatic",
+						Bids: []*entities.PbsOrtbBid{
+							{
+								BidType: openrtb_ext.BidTypeVideo,
+								Bid: &openrtb2.Bid{
+									AdM: `<VAST version=\"2.0\">
+									  <Ad id="601364">
+									    <InLine>
+									      <AdSystem>Adsystem Example</AdSystem>
+									      <AdTitle>VAST 2.0</AdTitle>
+									      <Description>VAST 2.0</Description>
+									      <Error>http://myErrorURL/error</Error>
+									      <Impression>http://myTrackingURL/impression</Impression>
+									      <Creatives>
+									        <Creative AdID="12345">
+									          <Linear>
+									           <Duration>00:00:30</Duration>
+									            <TrackingEvents>
+									              <Tracking event="creativeView">http://myTrackingURL/creativeView</Tracking>
+									              <Tracking event="start">http://myTrackingURL/start</Tracking>
+									              <Tracking event="midpoint">http://myTrackingURL/midpoint</Tracking>
+									              <Tracking event="firstQuartile">http://myTrackingURL/firstQuartile</Tracking>
+									              <Tracking event="thirdQuartile">http://myTrackingURL/thirdQuartile</Tracking>
+									              <Tracking event="complete">http://myTrackingURL/complete</Tracking>
+									            </TrackingEvents>
+									            <VideoClicks>
+									              <ClickThrough>http://www.examplemedia.com</ClickThrough>
+									              <ClickTracking>http://myTrackingURL/click</ClickTracking>
+									            </VideoClicks>
+									            <MediaFiles>
+									             <MediaFile delivery="progressive" type="video/x-flv" bitrate="500" width="400" height="300" scalable="true" maintainAspectRatio="true">
+									        http://demo.examplemedia.com/video/acudeo/Carrot_400x300_500kb.flv
+									          </MediaFile>
+									         </MediaFiles>
+									          </Linear>
+									    </Creative>
+									    <Creative AdID="601364-Companion">
+									      <CompanionAds>
+									           <Companion width="300" height="250">
+									             <StaticResource creativeType="image/jpeg">
+									             http://demo.examplemedia.com/vast/this_is_the_ad.jpg
+									             </StaticResource>
+									             <TrackingEvents>
+									               <Tracking event="creativeView">http://myTrackingURL/tracking</Tracking>
+									             </TrackingEvents>
+									           <CompanionClickThrough>http://www.examplemedia.com</CompanionClickThrough>
+									           </Companion>
+									           <Companion width="728" height="90">
+									             <StaticResource creativeType="image/jpeg">
+									             http://demo.examplemedia.com/vast/trackingbanner
+									             </StaticResource>
+									           <CompanionClickThrough>http://www.examplemedia.com</CompanionClickThrough>
+									           </Companion>
+									         </CompanionAds>
+									       </Creative>
+									     </Creatives>
+									   </InLine>
+									   </Ad>
+									</VAST>`,
+								},
+							},
+						},
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					metricEngine.Mock.On("RecordVastVersion", "pubmatic", "2.0").Return()
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "Version found in Adm with spaces in tag",
+			args: args{
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						BidderCoreName: "pubmatic",
+						Bids: []*entities.PbsOrtbBid{
+							{
+								BidType: openrtb_ext.BidTypeVideo,
+								Bid: &openrtb2.Bid{
+									AdM: `<VAST version = "4.1">
+									</VAST>`,
+								},
+							},
+						},
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					metricEngine.Mock.On("RecordVastVersion", "pubmatic", "4.1").Return()
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "Version found in Adm with multiple attributes",
+			args: args{
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						BidderCoreName: "pubmatic",
+						Bids: []*entities.PbsOrtbBid{
+							{
+								BidType: openrtb_ext.BidTypeVideo,
+								Bid: &openrtb2.Bid{
+									AdM: `<VAST namespace="test" version = \"2.0\">
+									</VAST>`,
+								},
+							},
+						},
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					metricEngine.Mock.On("RecordVastVersion", "pubmatic", "2.0").Return()
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "Version found xml tag before Vast tag attributes",
+			args: args{
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						BidderCoreName: "pubmatic",
+						Bids: []*entities.PbsOrtbBid{
+							{
+								BidType: openrtb_ext.BidTypeVideo,
+								Bid: &openrtb2.Bid{
+									AdM: `<?xml version="1.0" encoding="UTF-8"?><VAST xmlns:xs="http://www.w3.org/2001/XMLSchema" version="2.0">
+									</VAST>`,
+								},
+							},
+						},
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					metricEngine.Mock.On("RecordVastVersion", "pubmatic", "2.0").Return()
+					return metricEngine
+				},
+			},
+		},
+		{
+			name: "Version found in Adm inside single quote",
+			args: args{
+				adapterBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						BidderCoreName: "pubmatic",
+						Bids: []*entities.PbsOrtbBid{
+							{
+								BidType: openrtb_ext.BidTypeVideo,
+								Bid: &openrtb2.Bid{
+									AdM: `<VAST namespace="test" version = \'2.0\'>
+									</VAST>`,
+								},
+							},
+						},
+					},
+				},
+				getMetricsEngine: func() *metrics.MetricsEngineMock {
+					metricEngine := &metrics.MetricsEngineMock{}
+					metricEngine.Mock.On("RecordVastVersion", "pubmatic", "2.0").Return()
+					return metricEngine
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			mockMetricEngine := tt.args.getMetricsEngine()
+			recordVastVersion(mockMetricEngine, tt.args.adapterBids)
+			mockMetricEngine.AssertExpectations(t)
+		})
+	}
+}
diff --git a/exchange/exchange_test.go b/exchange/exchange_test.go
index 367d3f5bd..63538915c 100644
--- a/exchange/exchange_test.go
+++ b/exchange/exchange_test.go
@@ -20,12 +20,15 @@ import (
 
 	"github.com/buger/jsonparser"
 	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/openrtb/v19/openrtb3"
 	"github.com/prebid/prebid-server/adapters"
+	"github.com/prebid/prebid-server/analytics"
 	"github.com/prebid/prebid-server/config"
 	"github.com/prebid/prebid-server/currency"
 	"github.com/prebid/prebid-server/errortypes"
 	"github.com/prebid/prebid-server/exchange/entities"
 	"github.com/prebid/prebid-server/experiment/adscert"
+	"github.com/prebid/prebid-server/floors"
 	"github.com/prebid/prebid-server/gdpr"
 	"github.com/prebid/prebid-server/hooks"
 	"github.com/prebid/prebid-server/hooks/hookexecution"
@@ -79,7 +82,7 @@ func TestNewExchange(t *testing.T) {
 		},
 	}.Builder
 
-	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &adscert.NilSigner{}).(*exchange)
+	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &adscert.NilSigner{}, &floors.PriceFloorFetcher{}).(*exchange)
 	for _, bidderName := range knownAdapters {
 		if _, ok := e.adapterMap[bidderName]; !ok {
 			if biddersInfo[string(bidderName)].IsEnabled() {
@@ -129,7 +132,7 @@ func TestCharacterEscape(t *testing.T) {
 		},
 	}.Builder
 
-	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &adscert.NilSigner{}).(*exchange)
+	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &adscert.NilSigner{}, &floors.PriceFloorFetcher{}).(*exchange)
 
 	// 	3) Build all the parameters e.buildBidResponse(ctx.Background(), liveA... ) needs
 	//liveAdapters []openrtb_ext.BidderName,
@@ -359,6 +362,7 @@ func TestDebugBehaviour(t *testing.T) {
 			StartTime:         time.Now(),
 			HookExecutor:      &hookexecution.EmptyHookExecutor{},
 			TCF2Config:        gdpr.NewTCF2Config(config.TCF2{}, config.AccountGDPR{}),
+			LoggableObject:    &analytics.LoggableAuctionObject{},
 		}
 		if test.generateWarnings {
 			var errL []error
@@ -527,6 +531,7 @@ func TestTwoBiddersDebugDisabledAndEnabled(t *testing.T) {
 			StartTime:         time.Now(),
 			HookExecutor:      &hookexecution.EmptyHookExecutor{},
 			TCF2Config:        gdpr.NewTCF2Config(config.TCF2{}, config.AccountGDPR{}),
+			LoggableObject:    &analytics.LoggableAuctionObject{},
 		}
 
 		e.adapterMap = map[openrtb_ext.BidderName]AdaptedBidder{
@@ -534,6 +539,7 @@ func TestTwoBiddersDebugDisabledAndEnabled(t *testing.T) {
 			openrtb_ext.BidderTelaria:  AdaptBidder(bidderImpl, server.Client(), &config.Configuration{}, &metricsConfig.NilMetricsEngine{}, openrtb_ext.BidderAppnexus, &config.DebugInfo{Allow: testCase.bidder2DebugEnabled}, ""),
 		}
 		// Run test
+
 		outBidResponse, err := e.HoldAuction(context.Background(), auctionRequest, &debugLog)
 		// Assert no HoldAuction err
 		assert.NoErrorf(t, err, "ex.HoldAuction returned an err")
@@ -706,6 +712,7 @@ func TestOverrideWithCustomCurrency(t *testing.T) {
 			UserSyncs:         &emptyUsersync{},
 			HookExecutor:      &hookexecution.EmptyHookExecutor{},
 			TCF2Config:        gdpr.NewTCF2Config(config.TCF2{}, config.AccountGDPR{}),
+			LoggableObject:    &analytics.LoggableAuctionObject{},
 		}
 
 		// Run test
@@ -798,7 +805,9 @@ func TestAdapterCurrency(t *testing.T) {
 		UserSyncs:         &emptyUsersync{},
 		HookExecutor:      &hookexecution.EmptyHookExecutor{},
 		TCF2Config:        gdpr.NewTCF2Config(config.TCF2{}, config.AccountGDPR{}),
+		LoggableObject:    &analytics.LoggableAuctionObject{},
 	}
+
 	response, err := e.HoldAuction(context.Background(), auctionRequest, &DebugLog{})
 	assert.NoError(t, err)
 	assert.Equal(t, "some-request-id", response.ID, "Response ID")
@@ -1348,10 +1357,12 @@ func TestReturnCreativeEndToEnd(t *testing.T) {
 				UserSyncs:         &emptyUsersync{},
 				HookExecutor:      &hookexecution.EmptyHookExecutor{},
 				TCF2Config:        gdpr.NewTCF2Config(config.TCF2{}, config.AccountGDPR{}),
+				LoggableObject:    &analytics.LoggableAuctionObject{},
 			}
 
 			// Run test
 			debugLog := DebugLog{}
+
 			outBidResponse, err := e.HoldAuction(context.Background(), auctionRequest, &debugLog)
 
 			// Assert return error, if any
@@ -1424,7 +1435,7 @@ func TestGetBidCacheInfoEndToEnd(t *testing.T) {
 		},
 	}.Builder
 
-	e := NewExchange(adapters, pbc, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &adscert.NilSigner{}).(*exchange)
+	e := NewExchange(adapters, pbc, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &adscert.NilSigner{}, &floors.PriceFloorFetcher{}).(*exchange)
 	// 	3) Build all the parameters e.buildBidResponse(ctx.Background(), liveA... ) needs
 	liveAdapters := []openrtb_ext.BidderName{bidderName}
 
@@ -1784,7 +1795,7 @@ func TestBidResponseCurrency(t *testing.T) {
 		},
 	}.Builder
 
-	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &adscert.NilSigner{}).(*exchange)
+	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &adscert.NilSigner{}, &floors.PriceFloorFetcher{}).(*exchange)
 
 	liveAdapters := make([]openrtb_ext.BidderName, 1)
 	liveAdapters[0] = "appnexus"
@@ -1931,7 +1942,7 @@ func TestBidResponseImpExtInfo(t *testing.T) {
 		t.Fatalf("Error intializing adapters: %v", adaptersErr)
 	}
 
-	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, nil, gdprPermsBuilder, nil, nilCategoryFetcher{}, &adscert.NilSigner{}).(*exchange)
+	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, nil, gdprPermsBuilder, nil, nilCategoryFetcher{}, &adscert.NilSigner{}, &floors.PriceFloorFetcher{}).(*exchange)
 
 	liveAdapters := make([]openrtb_ext.BidderName, 1)
 	liveAdapters[0] = "appnexus"
@@ -2014,6 +2025,7 @@ func TestRaceIntegration(t *testing.T) {
 		UserSyncs:         &emptyUsersync{},
 		HookExecutor:      &hookexecution.EmptyHookExecutor{},
 		TCF2Config:        gdpr.NewTCF2Config(config.TCF2{}, config.AccountGDPR{}),
+		LoggableObject:    &analytics.LoggableAuctionObject{},
 	}
 
 	debugLog := DebugLog{}
@@ -2024,7 +2036,7 @@ func TestRaceIntegration(t *testing.T) {
 		},
 	}.Builder
 
-	ex := NewExchange(adapters, &wellBehavedCache{}, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, &nilCategoryFetcher{}, &adscert.NilSigner{}).(*exchange)
+	ex := NewExchange(adapters, &wellBehavedCache{}, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, &nilCategoryFetcher{}, &adscert.NilSigner{}, &floors.PriceFloorFetcher{}).(*exchange)
 	_, err = ex.HoldAuction(context.Background(), auctionRequest, &debugLog)
 	if err != nil {
 		t.Errorf("HoldAuction returned unexpected error: %v", err)
@@ -2122,7 +2134,7 @@ func TestPanicRecovery(t *testing.T) {
 		},
 	}.Builder
 
-	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &adscert.NilSigner{}).(*exchange)
+	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &adscert.NilSigner{}, &floors.PriceFloorFetcher{}).(*exchange)
 
 	chBids := make(chan *bidResponseWrapper, 1)
 	panicker := func(bidderRequest BidderRequest, conversions currency.Conversions) {
@@ -2192,7 +2204,7 @@ func TestPanicRecoveryHighLevel(t *testing.T) {
 			allowAllBidders: true,
 		},
 	}.Builder
-	e := NewExchange(adapters, &mockCache{}, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, categoriesFetcher, &adscert.NilSigner{}).(*exchange)
+	e := NewExchange(adapters, &mockCache{}, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, categoriesFetcher, &adscert.NilSigner{}, &floors.PriceFloorFetcher{}).(*exchange)
 
 	e.adapterMap[openrtb_ext.BidderBeachfront] = panicingAdapter{}
 	e.adapterMap[openrtb_ext.BidderAppnexus] = panicingAdapter{}
@@ -2231,8 +2243,10 @@ func TestPanicRecoveryHighLevel(t *testing.T) {
 		UserSyncs:         &emptyUsersync{},
 		HookExecutor:      &hookexecution.EmptyHookExecutor{},
 		TCF2Config:        gdpr.NewTCF2Config(config.TCF2{}, config.AccountGDPR{}),
+		LoggableObject:    &analytics.LoggableAuctionObject{},
 	}
 	debugLog := DebugLog{}
+
 	_, err = e.HoldAuction(context.Background(), auctionRequest, &debugLog)
 	if err != nil {
 		t.Errorf("HoldAuction returned unexpected error: %v", err)
@@ -2365,10 +2379,11 @@ func runSpec(t *testing.T, filename string, spec *exchangeSpec) {
 			PriceFloors: config.AccountPriceFloors{Enabled: spec.AccountFloorsEnabled},
 			Validations: spec.AccountConfigBidValidation,
 		},
-		UserSyncs:     mockIdFetcher(spec.IncomingRequest.Usersyncs),
-		ImpExtInfoMap: impExtInfoMap,
-		HookExecutor:  &hookexecution.EmptyHookExecutor{},
-		TCF2Config:    gdpr.NewTCF2Config(privacyConfig.GDPR.TCF2, config.AccountGDPR{}),
+		UserSyncs:      mockIdFetcher(spec.IncomingRequest.Usersyncs),
+		ImpExtInfoMap:  impExtInfoMap,
+		LoggableObject: &analytics.LoggableAuctionObject{},
+		HookExecutor:   &hookexecution.EmptyHookExecutor{},
+		TCF2Config:     gdpr.NewTCF2Config(privacyConfig.GDPR.TCF2, config.AccountGDPR{}),
 	}
 
 	if spec.MultiBid != nil {
@@ -2716,6 +2731,12 @@ func TestCategoryMapping(t *testing.T) {
 		t.Errorf("Failed to create a category Fetcher: %v", error)
 	}
 
+	r := &AuctionRequest{
+		BidRequestWrapper: &openrtb_ext.RequestWrapper{
+			BidRequest: &openrtb2.BidRequest{},
+		},
+		LoggableObject: &analytics.LoggableAuctionObject{},
+	}
 	requestExt := newExtRequest()
 
 	targData := &targetData{
@@ -2736,10 +2757,10 @@ func TestCategoryMapping(t *testing.T) {
 	bid3 := openrtb2.Bid{ID: "bid_id3", ImpID: "imp_id3", Price: 30.0000, Cat: cats3, W: 1, H: 1}
 	bid4 := openrtb2.Bid{ID: "bid_id4", ImpID: "imp_id4", Price: 40.0000, Cat: cats4, W: 1, H: 1}
 
-	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
-	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 40}, nil, nil, 0, false, "", 20.0000, "USD", ""}
-	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30, PrimaryCategory: "AdapterOverride"}, nil, nil, 0, false, "", 30.0000, "USD", ""}
-	bid1_4 := entities.PbsOrtbBid{&bid4, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 40.0000, "USD", ""}
+	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
+	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 40}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
+	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30, PrimaryCategory: "AdapterOverride"}, nil, nil, 0, false, "", 30.0000, "USD", "", 30.0000}
+	bid1_4 := entities.PbsOrtbBid{&bid4, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 40.0000, "USD", "", 40.0000}
 
 	innerBids := []*entities.PbsOrtbBid{
 		&bid1_1,
@@ -2752,8 +2773,23 @@ func TestCategoryMapping(t *testing.T) {
 	bidderName1 := openrtb_ext.BidderName("appnexus")
 
 	adapterBids[bidderName1] = &seatBid
+	expectedRejectedBids := []analytics.RejectedBid{
+		{
+			Bid: &entities.PbsOrtbBid{
+				Bid:     bid1_4.Bid,
+				BidType: openrtb_ext.BidTypeVideo,
+				BidVideo: &openrtb_ext.ExtBidPrebidVideo{
+					Duration: 30,
+				},
+				OriginalBidCPM:    40,
+				OriginalBidCur:    "USD",
+				OriginalBidCPMUSD: 40,
+			},
+			RejectionReason: openrtb3.LossBidCategoryMapping,
+		},
+	}
 
-	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
+	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, r, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
 
 	assert.Equal(t, nil, err, "Category mapping error should be empty")
 	assert.Equal(t, 1, len(rejections), "There should be 1 bid rejection message")
@@ -2763,6 +2799,7 @@ func TestCategoryMapping(t *testing.T) {
 	assert.Equal(t, "20.00_AdapterOverride_30s", bidCategory["bid_id3"], "Category mapping override from adapter didn't take")
 	assert.Equal(t, 3, len(adapterBids[bidderName1].Bids), "Bidders number doesn't match")
 	assert.Equal(t, 3, len(bidCategory), "Bidders category mapping doesn't match")
+	assert.Equal(t, expectedRejectedBids, r.LoggableObject.RejectedBids, "Rejected bids for analytics don't match")
 }
 
 func TestCategoryMappingNoIncludeBrandCategory(t *testing.T) {
@@ -2772,6 +2809,12 @@ func TestCategoryMappingNoIncludeBrandCategory(t *testing.T) {
 		t.Errorf("Failed to create a category Fetcher: %v", error)
 	}
 
+	r := &AuctionRequest{
+		BidRequestWrapper: &openrtb_ext.RequestWrapper{
+			BidRequest: &openrtb2.BidRequest{},
+		},
+		LoggableObject: &analytics.LoggableAuctionObject{},
+	}
 	requestExt := newExtRequestNoBrandCat()
 
 	targData := &targetData{
@@ -2791,10 +2834,10 @@ func TestCategoryMappingNoIncludeBrandCategory(t *testing.T) {
 	bid3 := openrtb2.Bid{ID: "bid_id3", ImpID: "imp_id3", Price: 30.0000, Cat: cats3, W: 1, H: 1}
 	bid4 := openrtb2.Bid{ID: "bid_id4", ImpID: "imp_id4", Price: 40.0000, Cat: cats4, W: 1, H: 1}
 
-	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
-	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 40}, nil, nil, 0, false, "", 20.0000, "USD", ""}
-	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30, PrimaryCategory: "AdapterOverride"}, nil, nil, 0, false, "", 30.0000, "USD", ""}
-	bid1_4 := entities.PbsOrtbBid{&bid4, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 50}, nil, nil, 0, false, "", 40.0000, "USD", ""}
+	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
+	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 40}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
+	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30, PrimaryCategory: "AdapterOverride"}, nil, nil, 0, false, "", 30.0000, "USD", "", 30.0000}
+	bid1_4 := entities.PbsOrtbBid{&bid4, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 50}, nil, nil, 0, false, "", 40.0000, "USD", "", 40.0000}
 
 	innerBids := []*entities.PbsOrtbBid{
 		&bid1_1,
@@ -2807,8 +2850,8 @@ func TestCategoryMappingNoIncludeBrandCategory(t *testing.T) {
 	bidderName1 := openrtb_ext.BidderName("appnexus")
 
 	adapterBids[bidderName1] = &seatBid
-
-	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
+	rejectedBids := []analytics.RejectedBid{}
+	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, r, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
 
 	assert.Equal(t, nil, err, "Category mapping error should be empty")
 	assert.Empty(t, rejections, "There should be no bid rejection messages")
@@ -2818,6 +2861,7 @@ func TestCategoryMappingNoIncludeBrandCategory(t *testing.T) {
 	assert.Equal(t, "20.00_50s", bidCategory["bid_id4"], "Category mapping doesn't match")
 	assert.Equal(t, 4, len(adapterBids[bidderName1].Bids), "Bidders number doesn't match")
 	assert.Equal(t, 4, len(bidCategory), "Bidders category mapping doesn't match")
+	assert.Equal(t, []analytics.RejectedBid{}, rejectedBids, "Rejected Bids not matching")
 }
 
 func TestCategoryMappingTranslateCategoriesNil(t *testing.T) {
@@ -2827,6 +2871,13 @@ func TestCategoryMappingTranslateCategoriesNil(t *testing.T) {
 		t.Errorf("Failed to create a category Fetcher: %v", error)
 	}
 
+	r := AuctionRequest{
+		BidRequestWrapper: &openrtb_ext.RequestWrapper{
+			BidRequest: &openrtb2.BidRequest{},
+		},
+		LoggableObject: &analytics.LoggableAuctionObject{},
+	}
+
 	requestExt := newExtRequestTranslateCategories(nil)
 
 	targData := &targetData{
@@ -2845,9 +2896,9 @@ func TestCategoryMappingTranslateCategoriesNil(t *testing.T) {
 	bid2 := openrtb2.Bid{ID: "bid_id2", ImpID: "imp_id2", Price: 20.0000, Cat: cats2, W: 1, H: 1}
 	bid3 := openrtb2.Bid{ID: "bid_id3", ImpID: "imp_id3", Price: 30.0000, Cat: cats3, W: 1, H: 1}
 
-	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
-	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 40}, nil, nil, 0, false, "", 20.0000, "USD", ""}
-	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 30.0000, "USD", ""}
+	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
+	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 40}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
+	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 30.0000, "USD", "", 30.0000}
 
 	innerBids := []*entities.PbsOrtbBid{
 		&bid1_1,
@@ -2859,8 +2910,23 @@ func TestCategoryMappingTranslateCategoriesNil(t *testing.T) {
 	bidderName1 := openrtb_ext.BidderName("appnexus")
 
 	adapterBids[bidderName1] = &seatBid
+	expectedRejectedBids := []analytics.RejectedBid{
+		{
+			Bid: &entities.PbsOrtbBid{
+				Bid:     &bid3,
+				BidType: openrtb_ext.BidTypeVideo,
+				BidVideo: &openrtb_ext.ExtBidPrebidVideo{
+					Duration: 30,
+				},
+				OriginalBidCPM:    30,
+				OriginalBidCur:    "USD",
+				OriginalBidCPMUSD: 30,
+			},
+			RejectionReason: openrtb3.LossBidCategoryMapping,
+		},
+	}
 
-	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
+	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, &r, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
 
 	assert.Equal(t, nil, err, "Category mapping error should be empty")
 	assert.Equal(t, 1, len(rejections), "There should be 1 bid rejection message")
@@ -2869,6 +2935,7 @@ func TestCategoryMappingTranslateCategoriesNil(t *testing.T) {
 	assert.Equal(t, "20.00_Sports_50s", bidCategory["bid_id2"], "Category mapping doesn't match")
 	assert.Equal(t, 2, len(adapterBids[bidderName1].Bids), "Bidders number doesn't match")
 	assert.Equal(t, 2, len(bidCategory), "Bidders category mapping doesn't match")
+	assert.Equal(t, expectedRejectedBids, r.LoggableObject.RejectedBids, "Rejected Bids not matching")
 }
 
 func newExtRequestTranslateCategories(translateCategories *bool) openrtb_ext.ExtRequest {
@@ -2909,6 +2976,13 @@ func TestCategoryMappingTranslateCategoriesFalse(t *testing.T) {
 	}
 
 	translateCategories := false
+
+	r := &AuctionRequest{
+		BidRequestWrapper: &openrtb_ext.RequestWrapper{
+			BidRequest: &openrtb2.BidRequest{},
+		},
+		LoggableObject: &analytics.LoggableAuctionObject{},
+	}
 	requestExt := newExtRequestTranslateCategories(&translateCategories)
 
 	targData := &targetData{
@@ -2927,9 +3001,9 @@ func TestCategoryMappingTranslateCategoriesFalse(t *testing.T) {
 	bid2 := openrtb2.Bid{ID: "bid_id2", ImpID: "imp_id2", Price: 20.0000, Cat: cats2, W: 1, H: 1}
 	bid3 := openrtb2.Bid{ID: "bid_id3", ImpID: "imp_id3", Price: 30.0000, Cat: cats3, W: 1, H: 1}
 
-	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
-	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 40}, nil, nil, 0, false, "", 20.0000, "USD", ""}
-	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 30.0000, "USD", ""}
+	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
+	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 40}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
+	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 30.0000, "USD", "", 30.0000}
 
 	innerBids := []*entities.PbsOrtbBid{
 		&bid1_1,
@@ -2941,8 +3015,8 @@ func TestCategoryMappingTranslateCategoriesFalse(t *testing.T) {
 	bidderName1 := openrtb_ext.BidderName("appnexus")
 
 	adapterBids[bidderName1] = &seatBid
-
-	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
+	rejectedBids := []analytics.RejectedBid{}
+	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, r, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
 
 	assert.Equal(t, nil, err, "Category mapping error should be empty")
 	assert.Empty(t, rejections, "There should be no bid rejection messages")
@@ -2951,6 +3025,8 @@ func TestCategoryMappingTranslateCategoriesFalse(t *testing.T) {
 	assert.Equal(t, "20.00_IAB1-1000_30s", bidCategory["bid_id3"], "Bid should not be rejected")
 	assert.Equal(t, 3, len(adapterBids[bidderName1].Bids), "Bidders number doesn't match")
 	assert.Equal(t, 3, len(bidCategory), "Bidders category mapping doesn't match")
+	assert.Equal(t, []analytics.RejectedBid{}, rejectedBids, "Rejected Bids not matching")
+
 }
 
 func TestCategoryDedupe(t *testing.T) {
@@ -2960,6 +3036,12 @@ func TestCategoryDedupe(t *testing.T) {
 		t.Errorf("Failed to create a category Fetcher: %v", error)
 	}
 
+	r := &AuctionRequest{
+		BidRequestWrapper: &openrtb_ext.RequestWrapper{
+			BidRequest: &openrtb2.BidRequest{},
+		},
+		LoggableObject: &analytics.LoggableAuctionObject{},
+	}
 	requestExt := newExtRequest()
 
 	targData := &targetData{
@@ -2979,11 +3061,11 @@ func TestCategoryDedupe(t *testing.T) {
 	bid4 := openrtb2.Bid{ID: "bid_id4", ImpID: "imp_id4", Price: 20.0000, Cat: cats4, W: 1, H: 1}
 	bid5 := openrtb2.Bid{ID: "bid_id5", ImpID: "imp_id5", Price: 20.0000, Cat: cats1, W: 1, H: 1}
 
-	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
-	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 50}, nil, nil, 0, false, "", 15.0000, "USD", ""}
-	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", ""}
-	bid1_4 := entities.PbsOrtbBid{&bid4, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", ""}
-	bid1_5 := entities.PbsOrtbBid{&bid5, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", ""}
+	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
+	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 50}, nil, nil, 0, false, "", 15.0000, "USD", "", 15.0000}
+	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
+	bid1_4 := entities.PbsOrtbBid{&bid4, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
+	bid1_5 := entities.PbsOrtbBid{&bid5, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
 
 	selectedBids := make(map[string]int)
 	expectedCategories := map[string]string{
@@ -3012,7 +3094,7 @@ func TestCategoryDedupe(t *testing.T) {
 
 		adapterBids[bidderName1] = &seatBid
 
-		bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
+		bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, r, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
 
 		assert.Equal(t, nil, err, "Category mapping error should be empty")
 		assert.Equal(t, 3, len(rejections), "There should be 2 bid rejection messages")
@@ -3040,6 +3122,12 @@ func TestNoCategoryDedupe(t *testing.T) {
 		t.Errorf("Failed to create a category Fetcher: %v", error)
 	}
 
+	r := &AuctionRequest{
+		BidRequestWrapper: &openrtb_ext.RequestWrapper{
+			BidRequest: &openrtb2.BidRequest{},
+		},
+		LoggableObject: &analytics.LoggableAuctionObject{},
+	}
 	requestExt := newExtRequestNoBrandCat()
 
 	targData := &targetData{
@@ -3058,11 +3146,11 @@ func TestNoCategoryDedupe(t *testing.T) {
 	bid4 := openrtb2.Bid{ID: "bid_id4", ImpID: "imp_id4", Price: 20.0000, Cat: cats4, W: 1, H: 1}
 	bid5 := openrtb2.Bid{ID: "bid_id5", ImpID: "imp_id5", Price: 10.0000, Cat: cats1, W: 1, H: 1}
 
-	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 14.0000, "USD", ""}
-	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 14.0000, "USD", ""}
-	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", ""}
-	bid1_4 := entities.PbsOrtbBid{&bid4, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", ""}
-	bid1_5 := entities.PbsOrtbBid{&bid5, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
+	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 14.0000, "USD", "", 14.0000}
+	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 14.0000, "USD", "", 14.0000}
+	bid1_3 := entities.PbsOrtbBid{&bid3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
+	bid1_4 := entities.PbsOrtbBid{&bid4, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
+	bid1_5 := entities.PbsOrtbBid{&bid5, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
 
 	selectedBids := make(map[string]int)
 	expectedCategories := map[string]string{
@@ -3092,7 +3180,7 @@ func TestNoCategoryDedupe(t *testing.T) {
 
 		adapterBids[bidderName1] = &seatBid
 
-		bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
+		bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, r, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
 
 		assert.Equal(t, nil, err, "Category mapping error should be empty")
 		assert.Equal(t, 2, len(rejections), "There should be 2 bid rejection messages")
@@ -3129,6 +3217,14 @@ func TestCategoryMappingBidderName(t *testing.T) {
 		includeWinners:   true,
 	}
 
+	r := &AuctionRequest{
+		BidRequestWrapper: &openrtb_ext.RequestWrapper{
+			BidRequest: &openrtb2.BidRequest{},
+		},
+		LoggableObject: &analytics.LoggableAuctionObject{
+			RejectedBids: []analytics.RejectedBid{},
+		},
+	}
 	requestExt.Prebid.Targeting.DurationRangeSec = []int{15, 30}
 
 	adapterBids := make(map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid)
@@ -3138,8 +3234,8 @@ func TestCategoryMappingBidderName(t *testing.T) {
 	bid1 := openrtb2.Bid{ID: "bid_id1", ImpID: "imp_id1", Price: 10.0000, Cat: cats1, W: 1, H: 1}
 	bid2 := openrtb2.Bid{ID: "bid_id2", ImpID: "imp_id2", Price: 10.0000, Cat: cats2, W: 1, H: 1}
 
-	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
-	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
+	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
+	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
 
 	innerBids1 := []*entities.PbsOrtbBid{
 		&bid1_1,
@@ -3157,7 +3253,7 @@ func TestCategoryMappingBidderName(t *testing.T) {
 	adapterBids[bidderName1] = &seatBid1
 	adapterBids[bidderName2] = &seatBid2
 
-	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
+	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, r, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
 
 	assert.NoError(t, err, "Category mapping error should be empty")
 	assert.Empty(t, rejections, "There should be 0 bid rejection messages")
@@ -3166,6 +3262,7 @@ func TestCategoryMappingBidderName(t *testing.T) {
 	assert.Len(t, adapterBids[bidderName1].Bids, 1, "Bidders number doesn't match")
 	assert.Len(t, adapterBids[bidderName2].Bids, 1, "Bidders number doesn't match")
 	assert.Len(t, bidCategory, 2, "Bidders category mapping doesn't match")
+	assert.Equal(t, []analytics.RejectedBid{}, r.LoggableObject.RejectedBids, "Rejected Bids don't match")
 }
 
 func TestCategoryMappingBidderNameNoCategories(t *testing.T) {
@@ -3183,6 +3280,12 @@ func TestCategoryMappingBidderNameNoCategories(t *testing.T) {
 		includeWinners:   true,
 	}
 
+	r := &AuctionRequest{
+		BidRequestWrapper: &openrtb_ext.RequestWrapper{
+			BidRequest: &openrtb2.BidRequest{},
+		},
+		LoggableObject: &analytics.LoggableAuctionObject{RejectedBids: []analytics.RejectedBid{}},
+	}
 	requestExt.Prebid.Targeting.DurationRangeSec = []int{15, 30}
 
 	adapterBids := make(map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid)
@@ -3192,8 +3295,8 @@ func TestCategoryMappingBidderNameNoCategories(t *testing.T) {
 	bid1 := openrtb2.Bid{ID: "bid_id1", ImpID: "imp_id1", Price: 10.0000, Cat: cats1, W: 1, H: 1}
 	bid2 := openrtb2.Bid{ID: "bid_id2", ImpID: "imp_id2", Price: 12.0000, Cat: cats2, W: 1, H: 1}
 
-	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
-	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 12.0000, "USD", ""}
+	bid1_1 := entities.PbsOrtbBid{&bid1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
+	bid1_2 := entities.PbsOrtbBid{&bid2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 12.0000, "USD", "", 12.0000}
 
 	innerBids1 := []*entities.PbsOrtbBid{
 		&bid1_1,
@@ -3211,7 +3314,7 @@ func TestCategoryMappingBidderNameNoCategories(t *testing.T) {
 	adapterBids[bidderName1] = &seatBid1
 	adapterBids[bidderName2] = &seatBid2
 
-	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
+	bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, r, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
 
 	assert.NoError(t, err, "Category mapping error should be empty")
 	assert.Empty(t, rejections, "There should be 0 bid rejection messages")
@@ -3220,6 +3323,7 @@ func TestCategoryMappingBidderNameNoCategories(t *testing.T) {
 	assert.Len(t, adapterBids[bidderName1].Bids, 1, "Bidders number doesn't match")
 	assert.Len(t, adapterBids[bidderName2].Bids, 1, "Bidders number doesn't match")
 	assert.Len(t, bidCategory, 2, "Bidders category mapping doesn't match")
+	assert.Equal(t, []analytics.RejectedBid{}, r.LoggableObject.RejectedBids, "Rejected bids don't match")
 }
 
 func TestBidRejectionErrors(t *testing.T) {
@@ -3245,12 +3349,13 @@ func TestBidRejectionErrors(t *testing.T) {
 	bidderName := openrtb_ext.BidderName("appnexus")
 
 	testCases := []struct {
-		description        string
-		reqExt             openrtb_ext.ExtRequest
-		bids               []*openrtb2.Bid
-		duration           int
-		expectedRejections []string
-		expectedCatDur     string
+		description          string
+		reqExt               openrtb_ext.ExtRequest
+		bids                 []*openrtb2.Bid
+		duration             int
+		expectedRejections   []string
+		expectedCatDur       string
+		expectedRejectedBids []analytics.RejectedBid
 	}{
 		{
 			description: "Bid should be rejected due to not containing a category",
@@ -3262,6 +3367,16 @@ func TestBidRejectionErrors(t *testing.T) {
 			expectedRejections: []string{
 				"bid rejected [bid ID: bid_id1] reason: Bid did not contain a category",
 			},
+			expectedRejectedBids: []analytics.RejectedBid{
+				{
+					RejectionReason: openrtb3.LossBidCategoryMapping,
+					Bid: &entities.PbsOrtbBid{Bid: &openrtb2.Bid{ID: "bid_id1", ImpID: "imp_id1", Price: 10.0000, Cat: []string{}, W: 1, H: 1},
+						OriginalBidCPM: 10, OriginalBidCur: "USD", OriginalBidCPMUSD: 10,
+						BidType:  openrtb_ext.BidTypeVideo,
+						BidVideo: &openrtb_ext.ExtBidPrebidVideo{Duration: 30}},
+					Seat: "",
+				},
+			},
 		},
 		{
 			description: "Bid should be rejected due to missing category mapping file",
@@ -3273,6 +3388,16 @@ func TestBidRejectionErrors(t *testing.T) {
 			expectedRejections: []string{
 				"bid rejected [bid ID: bid_id1] reason: Category mapping file for primary ad server: 'dfp', publisher: 'some_publisher' not found",
 			},
+			expectedRejectedBids: []analytics.RejectedBid{
+				{
+					RejectionReason: openrtb3.LossBidCategoryMapping,
+					Bid: &entities.PbsOrtbBid{Bid: &openrtb2.Bid{ID: "bid_id1", ImpID: "imp_id1", Price: 10.0000, Cat: []string{"IAB1-1"}, W: 1, H: 1},
+						OriginalBidCPM: 10, OriginalBidCur: "USD", OriginalBidCPMUSD: 10,
+						BidType:  openrtb_ext.BidTypeVideo,
+						BidVideo: &openrtb_ext.ExtBidPrebidVideo{Duration: 30}},
+					Seat: "",
+				},
+			},
 		},
 		{
 			description: "Bid should be rejected due to duration exceeding maximum",
@@ -3284,6 +3409,16 @@ func TestBidRejectionErrors(t *testing.T) {
 			expectedRejections: []string{
 				"bid rejected [bid ID: bid_id1] reason: Bid duration exceeds maximum allowed",
 			},
+			expectedRejectedBids: []analytics.RejectedBid{
+				{
+					RejectionReason: openrtb3.LossBidCategoryMapping,
+					Bid: &entities.PbsOrtbBid{Bid: &openrtb2.Bid{ID: "bid_id1", ImpID: "imp_id1", Price: 10.0000, Cat: []string{"IAB1-1"}, W: 1, H: 1},
+						OriginalBidCPM: 10, OriginalBidCur: "USD", OriginalBidCPMUSD: 10,
+						BidType:  openrtb_ext.BidTypeVideo,
+						BidVideo: &openrtb_ext.ExtBidPrebidVideo{Duration: 70}},
+					Seat: "",
+				},
+			},
 		},
 		{
 			description: "Bid should be rejected due to duplicate bid",
@@ -3297,6 +3432,16 @@ func TestBidRejectionErrors(t *testing.T) {
 				"bid rejected [bid ID: bid_id1] reason: Bid was deduplicated",
 			},
 			expectedCatDur: "10.00_VideoGames_30s",
+			expectedRejectedBids: []analytics.RejectedBid{
+				{
+					RejectionReason: openrtb3.LossBidCategoryMapping,
+					Bid: &entities.PbsOrtbBid{Bid: &openrtb2.Bid{ID: "bid_id1", ImpID: "imp_id1", Price: 10.0000, Cat: []string{"IAB1-1"}, W: 1, H: 1},
+						OriginalBidCPM: 10, OriginalBidCur: "USD", OriginalBidCPMUSD: 10,
+						BidType:  openrtb_ext.BidTypeVideo,
+						BidVideo: &openrtb_ext.ExtBidPrebidVideo{Duration: 30}},
+					Seat: "",
+				},
+			},
 		},
 	}
 
@@ -3304,15 +3449,20 @@ func TestBidRejectionErrors(t *testing.T) {
 		innerBids := []*entities.PbsOrtbBid{}
 		for _, bid := range test.bids {
 			currentBid := entities.PbsOrtbBid{
-				bid, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: test.duration}, nil, nil, 0, false, "", 10.0000, "USD", ""}
+				bid, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: test.duration}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
 			innerBids = append(innerBids, &currentBid)
 		}
 
 		seatBid := entities.PbsOrtbSeatBid{Bids: innerBids, Currency: "USD"}
 
 		adapterBids[bidderName] = &seatBid
-
-		bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, *test.reqExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
+		r := &AuctionRequest{
+			BidRequestWrapper: &openrtb_ext.RequestWrapper{
+				BidRequest: &openrtb2.BidRequest{},
+			},
+			LoggableObject: &analytics.LoggableAuctionObject{},
+		}
+		bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, r, *test.reqExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
 
 		if len(test.expectedCatDur) > 0 {
 			// Bid deduplication case
@@ -3326,6 +3476,7 @@ func TestBidRejectionErrors(t *testing.T) {
 
 		assert.Empty(t, err, "Category mapping error should be empty")
 		assert.Equal(t, test.expectedRejections, rejections, test.description)
+		assert.Equal(t, test.expectedRejectedBids, r.LoggableObject.RejectedBids, "Rejected Bids did not match for %v", test.description)
 	}
 }
 
@@ -3336,6 +3487,15 @@ func TestCategoryMappingTwoBiddersOneBidEachNoCategorySamePrice(t *testing.T) {
 		t.Errorf("Failed to create a category Fetcher: %v", error)
 	}
 
+	r := &AuctionRequest{
+		BidRequestWrapper: &openrtb_ext.RequestWrapper{
+			BidRequest: &openrtb2.BidRequest{},
+		},
+		LoggableObject: &analytics.LoggableAuctionObject{
+			RejectedBids: []analytics.RejectedBid{},
+		},
+	}
+
 	requestExt := newExtRequestTranslateCategories(nil)
 
 	targData := &targetData{
@@ -3352,8 +3512,8 @@ func TestCategoryMappingTwoBiddersOneBidEachNoCategorySamePrice(t *testing.T) {
 	bidApn1 := openrtb2.Bid{ID: "bid_idApn1", ImpID: "imp_idApn1", Price: 10.0000, Cat: cats1, W: 1, H: 1}
 	bidApn2 := openrtb2.Bid{ID: "bid_idApn2", ImpID: "imp_idApn2", Price: 10.0000, Cat: cats2, W: 1, H: 1}
 
-	bid1_Apn1 := entities.PbsOrtbBid{&bidApn1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
-	bid1_Apn2 := entities.PbsOrtbBid{&bidApn2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
+	bid1_Apn1 := entities.PbsOrtbBid{&bidApn1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
+	bid1_Apn2 := entities.PbsOrtbBid{&bidApn2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
 
 	innerBidsApn1 := []*entities.PbsOrtbBid{
 		&bid1_Apn1,
@@ -3375,7 +3535,7 @@ func TestCategoryMappingTwoBiddersOneBidEachNoCategorySamePrice(t *testing.T) {
 		adapterBids[bidderNameApn1] = &seatBidApn1
 		adapterBids[bidderNameApn2] = &seatBidApn2
 
-		bidCategory, _, rejections, err := applyCategoryMapping(nil, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
+		bidCategory, adapterBids, rejections, err := applyCategoryMapping(nil, r, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &randomDeduplicateBidBooleanGenerator{})
 
 		assert.NoError(t, err, "Category mapping error should be empty")
 		assert.Len(t, rejections, 1, "There should be 1 bid rejection message")
@@ -3413,6 +3573,12 @@ func TestCategoryMappingTwoBiddersManyBidsEachNoCategorySamePrice(t *testing.T)
 		t.Errorf("Failed to create a category Fetcher: %v", error)
 	}
 
+	r := &AuctionRequest{
+		BidRequestWrapper: &openrtb_ext.RequestWrapper{
+			BidRequest: &openrtb2.BidRequest{},
+		},
+		LoggableObject: &analytics.LoggableAuctionObject{RejectedBids: []analytics.RejectedBid{}},
+	}
 	requestExt := newExtRequestTranslateCategories(nil)
 
 	targData := &targetData{
@@ -3432,11 +3598,11 @@ func TestCategoryMappingTwoBiddersManyBidsEachNoCategorySamePrice(t *testing.T)
 	bidApn2_1 := openrtb2.Bid{ID: "bid_idApn2_1", ImpID: "imp_idApn2_1", Price: 10.0000, Cat: cats2, W: 1, H: 1}
 	bidApn2_2 := openrtb2.Bid{ID: "bid_idApn2_2", ImpID: "imp_idApn2_2", Price: 20.0000, Cat: cats2, W: 1, H: 1}
 
-	bid1_Apn1_1 := entities.PbsOrtbBid{&bidApn1_1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
-	bid1_Apn1_2 := entities.PbsOrtbBid{&bidApn1_2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", ""}
+	bid1_Apn1_1 := entities.PbsOrtbBid{&bidApn1_1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
+	bid1_Apn1_2 := entities.PbsOrtbBid{&bidApn1_2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
 
-	bid1_Apn2_1 := entities.PbsOrtbBid{&bidApn2_1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
-	bid1_Apn2_2 := entities.PbsOrtbBid{&bidApn2_2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", ""}
+	bid1_Apn2_1 := entities.PbsOrtbBid{&bidApn2_1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
+	bid1_Apn2_2 := entities.PbsOrtbBid{&bidApn2_2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
 
 	innerBidsApn1 := []*entities.PbsOrtbBid{
 		&bid1_Apn1_1,
@@ -3459,7 +3625,7 @@ func TestCategoryMappingTwoBiddersManyBidsEachNoCategorySamePrice(t *testing.T)
 	adapterBids[bidderNameApn1] = &seatBidApn1
 	adapterBids[bidderNameApn2] = &seatBidApn2
 
-	_, adapterBids, rejections, err := applyCategoryMapping(nil, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &fakeRandomDeduplicateBidBooleanGenerator{true})
+	_, adapterBids, rejections, err := applyCategoryMapping(nil, r, *requestExt.Prebid.Targeting, adapterBids, categoriesFetcher, targData, &fakeRandomDeduplicateBidBooleanGenerator{true})
 
 	assert.NoError(t, err, "Category mapping error should be empty")
 
@@ -3483,7 +3649,7 @@ func TestCategoryMappingTwoBiddersManyBidsEachNoCategorySamePrice(t *testing.T)
 
 	assert.Equal(t, 2, totalNumberOfbids, "2 bids total should be returned")
 	assert.Len(t, rejections, 2, "2 bids should be de-duplicated")
-
+	assert.Equal(t, []analytics.RejectedBid{}, r.LoggableObject.RejectedBids, "Bid Rejections not matching")
 	if firstBidderIndicator {
 		assert.Len(t, adapterBids[bidderNameApn1].Bids, 2)
 		assert.Len(t, adapterBids[bidderNameApn2].Bids, 0)
@@ -3514,9 +3680,9 @@ func TestRemoveBidById(t *testing.T) {
 	bidApn1_2 := openrtb2.Bid{ID: "bid_idApn1_2", ImpID: "imp_idApn1_2", Price: 20.0000, Cat: cats1, W: 1, H: 1}
 	bidApn1_3 := openrtb2.Bid{ID: "bid_idApn1_3", ImpID: "imp_idApn1_3", Price: 10.0000, Cat: cats1, W: 1, H: 1}
 
-	bid1_Apn1_1 := entities.PbsOrtbBid{&bidApn1_1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
-	bid1_Apn1_2 := entities.PbsOrtbBid{&bidApn1_2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", ""}
-	bid1_Apn1_3 := entities.PbsOrtbBid{&bidApn1_3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", ""}
+	bid1_Apn1_1 := entities.PbsOrtbBid{&bidApn1_1, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
+	bid1_Apn1_2 := entities.PbsOrtbBid{&bidApn1_2, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 20.0000, "USD", "", 20.0000}
+	bid1_Apn1_3 := entities.PbsOrtbBid{&bidApn1_3, nil, "video", nil, &openrtb_ext.ExtBidPrebidVideo{Duration: 30}, nil, nil, 0, false, "", 10.0000, "USD", "", 10.0000}
 
 	type aTest struct {
 		desc      string
@@ -3641,7 +3807,7 @@ func TestApplyDealSupport(t *testing.T) {
 			},
 		}
 
-		bid := entities.PbsOrtbBid{&openrtb2.Bid{ID: "123456"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, test.dealPriority, false, "", 0, "USD", ""}
+		bid := entities.PbsOrtbBid{&openrtb2.Bid{ID: "123456"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, test.dealPriority, false, "", 0, "USD", "", 0}
 		bidCategory := map[string]string{
 			bid.Bid.ID: test.targ["hb_pb_cat_dur"],
 		}
@@ -3701,8 +3867,8 @@ func TestApplyDealSupportMultiBid(t *testing.T) {
 					winningBidsByBidder: map[string]map[openrtb_ext.BidderName][]*entities.PbsOrtbBid{
 						"imp_id1": {
 							openrtb_ext.BidderName("appnexus"): {
-								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "123456"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", ""},
-								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "789101"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", ""},
+								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "123456"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", "", 0},
+								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "789101"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", "", 0},
 							},
 						},
 					},
@@ -3747,8 +3913,8 @@ func TestApplyDealSupportMultiBid(t *testing.T) {
 					winningBidsByBidder: map[string]map[openrtb_ext.BidderName][]*entities.PbsOrtbBid{
 						"imp_id1": {
 							openrtb_ext.BidderName("appnexus"): {
-								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "123456"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", ""},
-								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "789101"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", ""},
+								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "123456"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", "", 0},
+								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "789101"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", "", 0},
 							},
 						},
 					},
@@ -3798,8 +3964,8 @@ func TestApplyDealSupportMultiBid(t *testing.T) {
 					winningBidsByBidder: map[string]map[openrtb_ext.BidderName][]*entities.PbsOrtbBid{
 						"imp_id1": {
 							openrtb_ext.BidderName("appnexus"): {
-								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "123456"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", ""},
-								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "789101"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", ""},
+								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "123456"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", "", 0},
+								&entities.PbsOrtbBid{&openrtb2.Bid{ID: "789101"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, 5, false, "", 0, "USD", "", 0},
 							},
 						},
 					},
@@ -3893,6 +4059,7 @@ func TestGetDealTiers(t *testing.T) {
 			},
 			expected: map[string]openrtb_ext.DealTierBidderMap{
 				"imp1": {openrtb_ext.BidderAppnexus: {Prefix: "tier1", MinDealTier: 5}},
+				"imp2": {},
 			},
 		},
 	}
@@ -3990,7 +4157,7 @@ func TestUpdateHbPbCatDur(t *testing.T) {
 	}
 
 	for _, test := range testCases {
-		bid := entities.PbsOrtbBid{&openrtb2.Bid{ID: "123456"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, test.dealPriority, false, "", 0, "USD", ""}
+		bid := entities.PbsOrtbBid{&openrtb2.Bid{ID: "123456"}, nil, "video", map[string]string{}, &openrtb_ext.ExtBidPrebidVideo{}, nil, nil, test.dealPriority, false, "", 0, "USD", "", 0}
 		bidCategory := map[string]string{
 			bid.Bid.ID: test.targ["hb_pb_cat_dur"],
 		}
@@ -4011,6 +4178,7 @@ func TestMakeBidExtJSON(t *testing.T) {
 		impExtInfo         map[string]ImpExtInfo
 		origbidcpm         float64
 		origbidcur         string
+		origbidcpmusd      float64
 		expectedBidExt     string
 		expectedErrMessage string
 	}
@@ -4193,7 +4361,7 @@ func TestMakeBidExtJSON(t *testing.T) {
 	}
 
 	for _, test := range testCases {
-		result, err := makeBidExtJSON(test.ext, &test.extBidPrebid, test.impExtInfo, "test_imp_id", test.origbidcpm, test.origbidcur)
+		result, err := makeBidExtJSON(test.ext, &test.extBidPrebid, test.impExtInfo, "test_imp_id", test.origbidcpm, test.origbidcur, test.origbidcpmusd)
 
 		if test.expectedErrMessage == "" {
 			assert.JSONEq(t, test.expectedBidExt, string(result), "Incorrect result")
@@ -4273,8 +4441,10 @@ func TestStoredAuctionResponses(t *testing.T) {
 			StoredAuctionResponses: test.storedAuctionResp,
 			HookExecutor:           &hookexecution.EmptyHookExecutor{},
 			TCF2Config:             gdpr.NewTCF2Config(config.TCF2{}, config.AccountGDPR{}),
+			LoggableObject:         &analytics.LoggableAuctionObject{},
 		}
 		// Run test
+
 		outBidResponse, err := e.HoldAuction(context.Background(), auctionRequest, &DebugLog{})
 		if test.errorExpected {
 			assert.Error(t, err, "Error should be returned")
@@ -4607,9 +4777,11 @@ func TestAuctionDebugEnabled(t *testing.T) {
 		RequestType:       metrics.ReqTypeORTB2Web,
 		HookExecutor:      &hookexecution.EmptyHookExecutor{},
 		TCF2Config:        gdpr.NewTCF2Config(config.TCF2{}, config.AccountGDPR{}),
+		LoggableObject:    &analytics.LoggableAuctionObject{},
 	}
 
 	debugLog := &DebugLog{DebugOverride: true, DebugEnabledOrOverridden: true}
+
 	resp, err := e.HoldAuction(ctx, auctionRequest, debugLog)
 
 	assert.NoError(t, err, "error should be nil")
@@ -4657,7 +4829,7 @@ func TestPassExperimentConfigsToHoldAuction(t *testing.T) {
 		},
 	}.Builder
 
-	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &signer).(*exchange)
+	e := NewExchange(adapters, nil, cfg, map[string]usersync.Syncer{}, &metricsConf.NilMetricsEngine{}, biddersInfo, gdprPermsBuilder, currencyConverter, nilCategoryFetcher{}, &signer, &floors.PriceFloorFetcher{}).(*exchange)
 
 	// Define mock incoming bid requeset
 	mockBidRequest := &openrtb2.BidRequest{
@@ -4677,9 +4849,11 @@ func TestPassExperimentConfigsToHoldAuction(t *testing.T) {
 		UserSyncs:         &emptyUsersync{},
 		HookExecutor:      &hookexecution.EmptyHookExecutor{},
 		TCF2Config:        gdpr.NewTCF2Config(config.TCF2{}, config.AccountGDPR{}),
+		LoggableObject:    &analytics.LoggableAuctionObject{},
 	}
 
 	debugLog := DebugLog{}
+
 	_, err = e.HoldAuction(context.Background(), auctionRequest, &debugLog)
 
 	assert.NoError(t, err, "unexpected error occured")
diff --git a/exchange/exchangetest/bid-id-invalid.json b/exchange/exchangetest/bid-id-invalid.json
index 9c5cb84c3..6bd6809da 100644
--- a/exchange/exchangetest/bid-id-invalid.json
+++ b/exchange/exchangetest/bid-id-invalid.json
@@ -191,6 +191,9 @@
                         "message": "Error generating bid.ext.prebid.bidid"
                     }
                 ]
+            },
+            "warnings": {
+                "prebid": []
             }
         }
     }
diff --git a/exchange/floors_ow.go b/exchange/floors_ow.go
new file mode 100644
index 000000000..92ba516d8
--- /dev/null
+++ b/exchange/floors_ow.go
@@ -0,0 +1,23 @@
+package exchange
+
+import (
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// floorsEnabled will return true if floors are enabled in both account and request level
+func floorsEnabled(account config.Account, bidRequestWrapper *openrtb_ext.RequestWrapper) (bool, *openrtb_ext.PriceFloorRules) {
+	var (
+		reqEnabled bool
+		floorRules *openrtb_ext.PriceFloorRules
+	)
+
+	if requestExt, err := bidRequestWrapper.GetRequestExt(); err == nil {
+		if prebidExt := requestExt.GetPrebid(); prebidExt != nil {
+			reqEnabled = prebidExt.Floors.GetEnabled()
+			floorRules = prebidExt.Floors
+		}
+	}
+
+	return account.PriceFloors.Enabled && reqEnabled, floorRules
+}
diff --git a/exchange/floors_ow_test.go b/exchange/floors_ow_test.go
new file mode 100644
index 000000000..6e247c70a
--- /dev/null
+++ b/exchange/floors_ow_test.go
@@ -0,0 +1,157 @@
+package exchange
+
+import (
+	"encoding/json"
+	"testing"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/prebid/prebid-server/util/boolutil"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestFloorsEnabled(t *testing.T) {
+	type args struct {
+		account           config.Account
+		bidRequestWrapper *openrtb_ext.RequestWrapper
+	}
+	tests := []struct {
+		name        string
+		args        args
+		wantEnabled bool
+		wantRules   *openrtb_ext.PriceFloorRules
+	}{
+		{
+			name: "Floors data available in request and its enabled",
+			args: args{
+				account: config.Account{
+					PriceFloors: config.AccountPriceFloors{
+						Enabled: true,
+					},
+				},
+				bidRequestWrapper: &openrtb_ext.RequestWrapper{
+					BidRequest: &openrtb2.BidRequest{
+						Ext: func() json.RawMessage {
+							ext := make(map[string]interface{})
+							prebidExt := openrtb_ext.ExtRequestPrebid{
+								Floors: &openrtb_ext.PriceFloorRules{
+									Enabled:     boolutil.BoolPtr(true),
+									FloorMin:    2,
+									FloorMinCur: "INR",
+									Data: &openrtb_ext.PriceFloorData{
+										Currency: "INR",
+									},
+								},
+							}
+							ext["prebid"] = prebidExt
+							data, _ := json.Marshal(ext)
+							return data
+						}(),
+					},
+				},
+			},
+			wantEnabled: true,
+			wantRules: func() *openrtb_ext.PriceFloorRules {
+				floors := openrtb_ext.PriceFloorRules{
+					Enabled:     boolutil.BoolPtr(true),
+					FloorMin:    2,
+					FloorMinCur: "INR",
+					Data: &openrtb_ext.PriceFloorData{
+						Currency: "INR",
+					},
+				}
+				return &floors
+			}(),
+		},
+		{
+			name: "Floors data available in request and floors is disabled",
+			args: args{
+				account: config.Account{
+					PriceFloors: config.AccountPriceFloors{
+						Enabled: false,
+					},
+				},
+				bidRequestWrapper: &openrtb_ext.RequestWrapper{
+					BidRequest: &openrtb2.BidRequest{
+						Ext: func() json.RawMessage {
+							ext := map[string]interface{}{
+								"prebid": openrtb_ext.ExtRequestPrebid{
+									Floors: &openrtb_ext.PriceFloorRules{
+										Enabled:     boolutil.BoolPtr(true),
+										FloorMin:    2,
+										FloorMinCur: "INR",
+										Data: &openrtb_ext.PriceFloorData{
+											Currency: "INR",
+										},
+									},
+								},
+							}
+							data, _ := json.Marshal(ext)
+							return data
+						}(),
+					},
+				},
+			},
+			wantEnabled: false,
+			wantRules: func() *openrtb_ext.PriceFloorRules {
+				floors := openrtb_ext.PriceFloorRules{
+					Enabled:     boolutil.BoolPtr(true),
+					FloorMin:    2,
+					FloorMinCur: "INR",
+					Data: &openrtb_ext.PriceFloorData{
+						Currency: "INR",
+					},
+				}
+				return &floors
+			}(),
+		},
+		{
+			name: "Floors data is nil in request but floors is enabled in account",
+			args: args{
+				account: config.Account{
+					PriceFloors: config.AccountPriceFloors{
+						Enabled: true,
+					},
+				},
+				bidRequestWrapper: &openrtb_ext.RequestWrapper{
+					BidRequest: &openrtb2.BidRequest{
+						Ext: func() json.RawMessage {
+							ext := map[string]interface{}{
+								"prebid": openrtb_ext.ExtRequestPrebid{},
+							}
+							data, _ := json.Marshal(ext)
+							return data
+						}(),
+					},
+				},
+			},
+			wantEnabled: true,
+			wantRules:   nil,
+		},
+		{
+			name: "extension is empty but floors is enabled in account",
+			args: args{
+				account: config.Account{
+					PriceFloors: config.AccountPriceFloors{
+						Enabled: true,
+					},
+				},
+				bidRequestWrapper: &openrtb_ext.RequestWrapper{
+					BidRequest: &openrtb2.BidRequest{},
+				},
+			},
+			wantEnabled: false,
+			wantRules:   nil,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			gotEnabled, gotRules := floorsEnabled(tt.args.account, tt.args.bidRequestWrapper)
+			if gotEnabled != tt.wantEnabled {
+				t.Errorf("floorsEnabled() got = %v, want %v", gotEnabled, tt.wantEnabled)
+			}
+			assert.Equal(t, tt.wantRules, gotRules, "Invalid Floors rules")
+		})
+	}
+}
diff --git a/exchange/price_granularity.go b/exchange/price_granularity.go
index 1af56ea2a..63645b118 100644
--- a/exchange/price_granularity.go
+++ b/exchange/price_granularity.go
@@ -26,7 +26,8 @@ func GetPriceBucket(cpm float64, config openrtb_ext.PriceGranularity) string {
 		}
 	}
 
-	if cpm > bucketMax {
+	//OTT-603: Adding Test Price Granularity
+	if config.Test || cpm > bucketMax {
 		// We are over max, just return that
 		cpmStr = strconv.FormatFloat(bucketMax, 'f', precision, 64)
 	} else if increment > 0 {
diff --git a/exchange/price_granularity_test.go b/exchange/price_granularity_test.go
index 50e837785..08cb8c85e 100644
--- a/exchange/price_granularity_test.go
+++ b/exchange/price_granularity_test.go
@@ -15,7 +15,7 @@ func TestGetPriceBucketString(t *testing.T) {
 	high, _ := openrtb_ext.NewPriceGranularityFromLegacyID("high")
 	auto, _ := openrtb_ext.NewPriceGranularityFromLegacyID("auto")
 	dense, _ := openrtb_ext.NewPriceGranularityFromLegacyID("dense")
-
+	testPG, _ := openrtb_ext.NewPriceGranularityFromLegacyID("testpg")
 	custom1 := openrtb_ext.PriceGranularity{
 		Precision: ptrutil.ToPtr(2),
 		Ranges: []openrtb_ext.GranularityRange{
@@ -68,6 +68,7 @@ func TestGetPriceBucketString(t *testing.T) {
 				{"high", high, "1.87"},
 				{"auto", auto, "1.85"},
 				{"dense", dense, "1.87"},
+				{"testpg", testPG, "50.00"},
 				{"custom1", custom1, "1.86"},
 				{"custom2", custom2, "1.50"},
 			},
@@ -81,6 +82,7 @@ func TestGetPriceBucketString(t *testing.T) {
 				{"high", high, "5.72"},
 				{"auto", auto, "5.70"},
 				{"dense", dense, "5.70"},
+				{"testpg", testPG, "50.00"},
 				{"custom1", custom1, "5.70"},
 				{"custom2", custom2, "5.10"},
 			},
@@ -150,6 +152,13 @@ func TestGetPriceBucketString(t *testing.T) {
 			cpm:       math.MaxFloat64,
 			testCases: []aTest{{"low", low, "5.00"}},
 		},
+		{
+			groupDesc: "cpm above max test price granularity value",
+			cpm:       60,
+			testCases: []aTest{
+				{"testpg", testPG, "50.00"},
+			},
+		},
 	}
 
 	for _, testGroup := range testGroups {
diff --git a/exchange/targeting.go b/exchange/targeting.go
index 987c6aa6e..453bc5dbe 100644
--- a/exchange/targeting.go
+++ b/exchange/targeting.go
@@ -95,6 +95,7 @@ func (targData *targetData) setTargeting(auc *auction, isApp bool, categoryMappi
 				if len(categoryMapping) > 0 {
 					targData.addKeys(targets, openrtb_ext.HbCategoryDurationKey, categoryMapping[topBid.Bid.ID], targetingBidderCode, isOverallWinner, truncateTargetAttr)
 				}
+				targData.addBidderKeys(targets, topBid.BidTargets)
 				topBid.BidTargets = targets
 			}
 		}
@@ -135,3 +136,11 @@ func getMultiBidMeta(multiBidMap map[string]openrtb_ext.ExtMultiBid, bidder stri
 
 	return "", openrtb_ext.DefaultBidLimit
 }
+
+func (targData *targetData) addBidderKeys(keys map[string]string, bidderKeys map[string]string) {
+	if targData.includeBidderKeys {
+		for index, element := range bidderKeys {
+			keys[index] = element
+		}
+	}
+}
diff --git a/exchange/targeting_test.go b/exchange/targeting_test.go
index f1f5df421..f4f1237a6 100644
--- a/exchange/targeting_test.go
+++ b/exchange/targeting_test.go
@@ -9,6 +9,7 @@ import (
 	"time"
 
 	"github.com/prebid/prebid-server/adapters"
+	"github.com/prebid/prebid-server/analytics"
 	"github.com/prebid/prebid-server/config"
 	"github.com/prebid/prebid-server/currency"
 	"github.com/prebid/prebid-server/exchange/entities"
@@ -126,9 +127,11 @@ func runTargetingAuction(t *testing.T, mockBids map[openrtb_ext.BidderName][]*op
 		UserSyncs:         &emptyUsersync{},
 		HookExecutor:      &hookexecution.EmptyHookExecutor{},
 		TCF2Config:        gdpr.NewTCF2Config(config.TCF2{}, config.AccountGDPR{}),
+		LoggableObject:    &analytics.LoggableAuctionObject{},
 	}
 
 	debugLog := DebugLog{}
+
 	bidResp, err := ex.HoldAuction(context.Background(), auctionRequest, &debugLog)
 
 	if err != nil {
diff --git a/exchange/utils.go b/exchange/utils.go
index de74c10dc..c4067551f 100644
--- a/exchange/utils.go
+++ b/exchange/utils.go
@@ -91,6 +91,7 @@ func (rs *requestSplitter) cleanOpenRTBRequests(ctx context.Context,
 			errs = append(errs, err)
 		}
 	}
+	updateContentObjectForBidder(allBidderRequests, requestExt)
 
 	gdprSignal, err := getGDPR(req)
 	if err != nil {
@@ -543,6 +544,11 @@ func createSanitizedImpExt(impExt, impExtPrebid map[string]json.RawMessage) (map
 		}
 	}
 
+	// Dont send this to adapters
+	// if v, exists := impExtPrebid["floors"]; exists {
+	// 	sanitizedImpPrebidExt["floors"] = v
+	// }
+
 	// marshal sanitized imp[].ext.prebid
 	if len(sanitizedImpPrebidExt) > 0 {
 		if impExtPrebidJSON, err := json.Marshal(sanitizedImpPrebidExt); err == nil {
diff --git a/exchange/utils_ow.go b/exchange/utils_ow.go
new file mode 100644
index 000000000..b4a7c4f9c
--- /dev/null
+++ b/exchange/utils_ow.go
@@ -0,0 +1,259 @@
+package exchange
+
+import (
+	"encoding/json"
+
+	"github.com/golang/glog"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func JLogf(msg string, obj interface{}) {
+	if glog.V(3) {
+		data, _ := json.Marshal(obj)
+		glog.Infof("[OPENWRAP] %v:%v", msg, string(data))
+	}
+}
+
+// updateContentObjectForBidder updates the content object for each bidder based on content transparency rules
+func updateContentObjectForBidder(allBidderRequests []BidderRequest, requestExt *openrtb_ext.ExtRequest) {
+	if requestExt == nil || requestExt.Prebid.Transparency == nil || requestExt.Prebid.Transparency.Content == nil {
+		return
+	}
+
+	rules := requestExt.Prebid.Transparency.Content
+
+	if len(rules) == 0 {
+		return
+	}
+
+	var contentObject *openrtb2.Content
+	isApp := false
+	bidderRequest := allBidderRequests[0]
+	if bidderRequest.BidRequest.App != nil && bidderRequest.BidRequest.App.Content != nil {
+		contentObject = bidderRequest.BidRequest.App.Content
+		isApp = true
+	} else if bidderRequest.BidRequest.Site != nil && bidderRequest.BidRequest.Site.Content != nil {
+		contentObject = bidderRequest.BidRequest.Site.Content
+	} else {
+		return
+	}
+
+	// Dont send content object if no rule and default is not present
+	var defaultRule = openrtb_ext.TransparencyRule{}
+	if rule, ok := rules["default"]; ok {
+		defaultRule = rule
+	}
+
+	for _, bidderRequest := range allBidderRequests {
+		var newContentObject *openrtb2.Content
+
+		rule, ok := rules[string(bidderRequest.BidderName)]
+		if !ok {
+			rule = defaultRule
+		}
+
+		if len(rule.Keys) != 0 {
+			newContentObject = createNewContentObject(contentObject, rule.Include, rule.Keys)
+		} else if rule.Include {
+			newContentObject = contentObject
+		}
+		deepCopyContentObj(bidderRequest.BidRequest, newContentObject, isApp)
+	}
+}
+
+func deepCopyContentObj(request *openrtb2.BidRequest, contentObject *openrtb2.Content, isApp bool) {
+	if isApp {
+		app := *request.App
+		app.Content = contentObject
+		request.App = &app
+	} else {
+		site := *request.Site
+		site.Content = contentObject
+		request.Site = &site
+	}
+}
+
+// func createNewContentObject(contentObject *openrtb2.Content, include bool, keys []string) *openrtb2.Content {
+// 	if include {
+// 		return includeKeys(contentObject, keys)
+// 	}
+// 	return excludeKeys(contentObject, keys)
+
+// }
+
+// func excludeKeys(contentObject *openrtb2.Content, keys []string) *openrtb2.Content {
+// 	newContentObject := *contentObject
+
+// 	keyMap := make(map[string]struct{}, 1)
+// 	for _, key := range keys {
+// 		keyMap[key] = struct{}{}
+// 	}
+
+// 	rt := reflect.TypeOf(newContentObject)
+// 	for i := 0; i < rt.NumField(); i++ {
+// 		key := strings.Split(rt.Field(i).Tag.Get("json"), ",")[0] // remove omitempty, etc
+// 		if _, ok := keyMap[key]; ok {
+// 			reflect.ValueOf(&newContentObject).Elem().FieldByName(rt.Field(i).Name).Set(reflect.Zero(rt.Field(i).Type))
+// 		}
+// 	}
+
+// 	return &newContentObject
+// }
+
+// func includeKeys(contentObject *openrtb2.Content, keys []string) *openrtb2.Content {
+// 	newContentObject := openrtb2.Content{}
+// 	v := reflect.ValueOf(contentObject).Elem()
+// 	keyMap := make(map[string]struct{}, 1)
+// 	for _, key := range keys {
+// 		keyMap[key] = struct{}{}
+// 	}
+
+// 	rt := reflect.TypeOf(newContentObject)
+// 	rvElem := reflect.ValueOf(&newContentObject).Elem()
+// 	for i := 0; i < rt.NumField(); i++ {
+// 		field := rt.Field(i)
+// 		key := strings.Split(field.Tag.Get("json"), ",")[0] // remove omitempty, etc
+// 		if _, ok := keyMap[key]; ok {
+// 			rvElem.FieldByName(field.Name).Set(v.FieldByName(field.Name))
+// 		}
+// 	}
+
+// 	return &newContentObject
+// }
+
+func createNewContentObject(contentObject *openrtb2.Content, include bool, keys []string) *openrtb2.Content {
+	newContentObject := &openrtb2.Content{}
+	if !include {
+		*newContentObject = *contentObject
+		for _, key := range keys {
+
+			switch key {
+			case "id":
+				newContentObject.ID = ""
+			case "episode":
+				newContentObject.Episode = 0
+			case "title":
+				newContentObject.Title = ""
+			case "series":
+				newContentObject.Series = ""
+			case "season":
+				newContentObject.Season = ""
+			case "artist":
+				newContentObject.Artist = ""
+			case "genre":
+				newContentObject.Genre = ""
+			case "album":
+				newContentObject.Album = ""
+			case "isrc":
+				newContentObject.ISRC = ""
+			case "producer":
+				newContentObject.Producer = nil
+			case "url":
+				newContentObject.URL = ""
+			case "cat":
+				newContentObject.Cat = nil
+			case "prodq":
+				newContentObject.ProdQ = nil
+			case "videoquality":
+				newContentObject.VideoQuality = nil
+			case "context":
+				newContentObject.Context = 0
+			case "contentrating":
+				newContentObject.ContentRating = ""
+			case "userrating":
+				newContentObject.UserRating = ""
+			case "qagmediarating":
+				newContentObject.QAGMediaRating = 0
+			case "keywords":
+				newContentObject.Keywords = ""
+			case "livestream":
+				newContentObject.LiveStream = 0
+			case "sourcerelationship":
+				newContentObject.SourceRelationship = 0
+			case "len":
+				newContentObject.Len = 0
+			case "language":
+				newContentObject.Language = ""
+			case "embeddable":
+				newContentObject.Embeddable = 0
+			case "data":
+				newContentObject.Data = nil
+			case "ext":
+				newContentObject.Ext = nil
+			}
+
+		}
+		return newContentObject
+	}
+
+	for _, key := range keys {
+		switch key {
+		case "id":
+			newContentObject.ID = contentObject.ID
+		case "episode":
+			newContentObject.Episode = contentObject.Episode
+		case "title":
+			newContentObject.Title = contentObject.Title
+		case "series":
+			newContentObject.Series = contentObject.Series
+		case "season":
+			newContentObject.Season = contentObject.Season
+		case "artist":
+			newContentObject.Artist = contentObject.Artist
+		case "genre":
+			newContentObject.Genre = contentObject.Genre
+		case "album":
+			newContentObject.Album = contentObject.Album
+		case "isrc":
+			newContentObject.ISRC = contentObject.ISRC
+		case "producer":
+			if contentObject.Producer != nil {
+				producer := *contentObject.Producer
+				newContentObject.Producer = &producer
+			}
+		case "url":
+			newContentObject.URL = contentObject.URL
+		case "cat":
+			newContentObject.Cat = contentObject.Cat
+		case "prodq":
+			if contentObject.ProdQ != nil {
+				prodQ := *contentObject.ProdQ
+				newContentObject.ProdQ = &prodQ
+			}
+		case "videoquality":
+			if contentObject.VideoQuality != nil {
+				videoQuality := *contentObject.VideoQuality
+				newContentObject.VideoQuality = &videoQuality
+			}
+		case "context":
+			newContentObject.Context = contentObject.Context
+		case "contentrating":
+			newContentObject.ContentRating = contentObject.ContentRating
+		case "userrating":
+			newContentObject.UserRating = contentObject.UserRating
+		case "qagmediarating":
+			newContentObject.QAGMediaRating = contentObject.QAGMediaRating
+		case "keywords":
+			newContentObject.Keywords = contentObject.Keywords
+		case "livestream":
+			newContentObject.LiveStream = contentObject.LiveStream
+		case "sourcerelationship":
+			newContentObject.SourceRelationship = contentObject.SourceRelationship
+		case "len":
+			newContentObject.Len = contentObject.Len
+		case "language":
+			newContentObject.Language = contentObject.Language
+		case "embeddable":
+			newContentObject.Embeddable = contentObject.Embeddable
+		case "data":
+			if contentObject.Data != nil {
+				newContentObject.Data = contentObject.Data
+			}
+		case "ext":
+			newContentObject.Ext = contentObject.Ext
+		}
+	}
+
+	return newContentObject
+}
diff --git a/exchange/utils_ow_test.go b/exchange/utils_ow_test.go
new file mode 100644
index 000000000..ad1d44ca0
--- /dev/null
+++ b/exchange/utils_ow_test.go
@@ -0,0 +1,1049 @@
+package exchange
+
+import (
+	"testing"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/stretchr/testify/assert"
+)
+
+func Test_updateContentObjectForBidder(t *testing.T) {
+
+	createBidderRequest := func(BidRequest *openrtb2.BidRequest) []BidderRequest {
+		newReq := *BidRequest
+		newReq.ID = "2"
+		return []BidderRequest{{
+			BidderName: "pubmatic",
+			BidRequest: BidRequest,
+		},
+			{
+				BidderName: "appnexus",
+				BidRequest: &newReq,
+			},
+		}
+	}
+
+	type args struct {
+		BidRequest *openrtb2.BidRequest
+		requestExt *openrtb_ext.ExtRequest
+	}
+	tests := []struct {
+		name                    string
+		args                    args
+		wantedAllBidderRequests []BidderRequest
+	}{
+		{
+			name: "No Transparency Object",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "No Content Object in App/Site",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+					},
+					Site: &openrtb2.Site{
+						ID:   "1",
+						Name: "Site1",
+					},
+				},
+
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"pubmatic": {
+									Include: true,
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+						},
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Site1",
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+						},
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Site1",
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "No partner/ default rules in tranpsarency",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					Site: &openrtb2.Site{
+						ID:   "1",
+						Name: "Test",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+							Genre: "Genre1",
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Test",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Test",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Include All keys for bidder",
+			args: args{
+
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					Site: &openrtb2.Site{
+						ID:   "1",
+						Name: "Test",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+							Genre: "Genre1",
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"pubmatic": {
+									Include: true,
+									Keys:    []string{},
+								},
+								"appnexus": {
+									Include: false,
+									Keys:    []string{},
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Test",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Test",
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Exclude All keys for pubmatic bidder",
+			args: args{
+
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+							Genre: "Genre1",
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"pubmatic": {
+									Include: false,
+									Keys:    []string{},
+								},
+								"appnexus": {
+									Include: true,
+									Keys:    []string{},
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Include title field for pubmatic bidder",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+							Genre: "Genre1",
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"pubmatic": {
+									Include: true,
+									Keys:    []string{"title"},
+								},
+								"appnexus": {
+									Include: false,
+									Keys:    []string{"genre"},
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Exclude title field for pubmatic bidder",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+							Genre: "Genre1",
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"pubmatic": {
+									Include: false,
+									Keys:    []string{"title"},
+								},
+								"appnexus": {
+									Include: true,
+									Keys:    []string{"genre"},
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Use default rule for pubmatic bidder",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+						Content: &openrtb2.Content{
+							Title:    "Title1",
+							Genre:    "Genre1",
+							Series:   "Series1",
+							Season:   "Season1",
+							Artist:   "Artist1",
+							Album:    "Album1",
+							ISRC:     "isrc1",
+							Producer: &openrtb2.Producer{},
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"default": {
+									Include: true,
+									Keys: []string{
+										"id", "episode", "series", "season", "artist", "genre", "album", "isrc", "producer", "url", "cat", "prodq", "videoquality", "context", "contentrating", "userrating", "qagmediarating", "livestream", "sourcerelationship", "len", "language", "embeddable", "data", "ext"},
+								},
+								"pubmatic": {
+									Include: true,
+									Keys:    []string{"title", "genre"},
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Genre:    "Genre1",
+								Series:   "Series1",
+								Season:   "Season1",
+								Artist:   "Artist1",
+								Album:    "Album1",
+								ISRC:     "isrc1",
+								Producer: &openrtb2.Producer{},
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			allBidderRequests := createBidderRequest(tt.args.BidRequest)
+			updateContentObjectForBidder(allBidderRequests, tt.args.requestExt)
+			assert.Equal(t, tt.wantedAllBidderRequests, allBidderRequests, tt.name)
+		})
+	}
+}
+
+func Benchmark_updateContentObjectForBidder(b *testing.B) {
+
+	createBidderRequest := func(BidRequest *openrtb2.BidRequest) []BidderRequest {
+		newReq := *BidRequest
+		newReq.ID = "2"
+		return []BidderRequest{{
+			BidderName: "pubmatic",
+			BidRequest: BidRequest,
+		},
+			{
+				BidderName: "appnexus",
+				BidRequest: &newReq,
+			},
+		}
+	}
+
+	type args struct {
+		BidRequest *openrtb2.BidRequest
+		requestExt *openrtb_ext.ExtRequest
+	}
+	tests := []struct {
+		name                    string
+		args                    args
+		wantedAllBidderRequests []BidderRequest
+	}{
+		{
+			name: "No Transparency Object",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "No Content Object in App/Site",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+					},
+					Site: &openrtb2.Site{
+						ID:   "1",
+						Name: "Site1",
+					},
+				},
+
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"pubmatic": {
+									Include: true,
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+						},
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Site1",
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+						},
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Site1",
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "No partner/ default rules in tranpsarency",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					Site: &openrtb2.Site{
+						ID:   "1",
+						Name: "Test",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+							Genre: "Genre1",
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Test",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Test",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Include All keys for bidder",
+			args: args{
+
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					Site: &openrtb2.Site{
+						ID:   "1",
+						Name: "Test",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+							Genre: "Genre1",
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"pubmatic": {
+									Include: true,
+									Keys:    []string{},
+								},
+								"appnexus": {
+									Include: false,
+									Keys:    []string{},
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Test",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						Site: &openrtb2.Site{
+							ID:   "1",
+							Name: "Test",
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Exclude All keys for pubmatic bidder",
+			args: args{
+
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+							Genre: "Genre1",
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"pubmatic": {
+									Include: false,
+									Keys:    []string{},
+								},
+								"appnexus": {
+									Include: true,
+									Keys:    []string{},
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Include title field for pubmatic bidder",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+							Genre: "Genre1",
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"pubmatic": {
+									Include: true,
+									Keys:    []string{"title"},
+								},
+								"appnexus": {
+									Include: false,
+									Keys:    []string{"genre"},
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Exclude title field for pubmatic bidder",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+						Content: &openrtb2.Content{
+							Title: "Title1",
+							Genre: "Genre1",
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"pubmatic": {
+									Include: false,
+									Keys:    []string{"title"},
+								},
+								"appnexus": {
+									Include: true,
+									Keys:    []string{"genre"},
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Use default rule for pubmatic bidder",
+			args: args{
+				BidRequest: &openrtb2.BidRequest{
+					ID: "1",
+					App: &openrtb2.App{
+						ID:     "1",
+						Name:   "Test",
+						Bundle: "com.pubmatic.app",
+						Content: &openrtb2.Content{
+							Title:    "Title1",
+							Genre:    "Genre1",
+							Series:   "Series1",
+							Season:   "Season1",
+							Artist:   "Artist1",
+							Album:    "Album1",
+							ISRC:     "isrc1",
+							Producer: &openrtb2.Producer{},
+						},
+					},
+				},
+				requestExt: &openrtb_ext.ExtRequest{
+					Prebid: openrtb_ext.ExtRequestPrebid{
+						Transparency: &openrtb_ext.TransparencyExt{
+							Content: map[string]openrtb_ext.TransparencyRule{
+								"default": {
+									Include: true,
+									Keys: []string{
+										"id", "episode", "series", "season", "artist", "genre", "album", "isrc", "producer", "url", "cat", "prodq", "videoquality", "context", "contentrating", "userrating", "qagmediarating", "livestream", "sourcerelationship", "len", "language", "embeddable", "data", "ext"},
+								},
+								"pubmatic": {
+									Include: true,
+									Keys:    []string{"title", "genre"},
+								},
+							},
+						},
+					},
+				},
+			},
+			wantedAllBidderRequests: []BidderRequest{
+				{
+					BidderName: "pubmatic",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "1",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Title: "Title1",
+								Genre: "Genre1",
+							},
+						},
+					},
+				},
+				{
+					BidderName: "appnexus",
+					BidRequest: &openrtb2.BidRequest{
+						ID: "2",
+						App: &openrtb2.App{
+							ID:     "1",
+							Name:   "Test",
+							Bundle: "com.pubmatic.app",
+							Content: &openrtb2.Content{
+								Genre:    "Genre1",
+								Series:   "Series1",
+								Season:   "Season1",
+								Artist:   "Artist1",
+								Album:    "Album1",
+								ISRC:     "isrc1",
+								Producer: &openrtb2.Producer{},
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		b.Run(tt.name, func(b *testing.B) {
+			allBidderRequests := createBidderRequest(tt.args.BidRequest)
+			for i := 0; i < b.N; i++ {
+				updateContentObjectForBidder(allBidderRequests, tt.args.requestExt)
+			}
+			//assert.Equal(t, tt.wantedAllBidderRequests, allBidderRequests, tt.name)
+		})
+	}
+}
diff --git a/exchange/utils_test.go b/exchange/utils_test.go
index e054f33c2..ed5099155 100644
--- a/exchange/utils_test.go
+++ b/exchange/utils_test.go
@@ -11,6 +11,7 @@ import (
 	gpplib "github.com/prebid/go-gpp"
 	"github.com/prebid/go-gpp/constants"
 	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/analytics"
 	"github.com/prebid/prebid-server/config"
 	"github.com/prebid/prebid-server/errortypes"
 	"github.com/prebid/prebid-server/firstpartydata"
@@ -447,14 +448,14 @@ func TestCleanOpenRTBRequests(t *testing.T) {
 		consentedVendors map[string]bool
 	}{
 		{
-			req:              AuctionRequest{BidRequestWrapper: &openrtb_ext.RequestWrapper{BidRequest: getTestBuildRequest(t)}, UserSyncs: &emptyUsersync{}, TCF2Config: emptyTCF2Config},
+			req:              AuctionRequest{BidRequestWrapper: &openrtb_ext.RequestWrapper{BidRequest: getTestBuildRequest(t)}, UserSyncs: &emptyUsersync{}, TCF2Config: emptyTCF2Config, LoggableObject: &analytics.LoggableAuctionObject{}},
 			bidReqAssertions: assertReq,
 			hasError:         false,
 			applyCOPPA:       true,
 			consentedVendors: map[string]bool{"appnexus": true},
 		},
 		{
-			req:              AuctionRequest{BidRequestWrapper: &openrtb_ext.RequestWrapper{BidRequest: newAdapterAliasBidRequest(t)}, UserSyncs: &emptyUsersync{}, TCF2Config: emptyTCF2Config},
+			req:              AuctionRequest{BidRequestWrapper: &openrtb_ext.RequestWrapper{BidRequest: newAdapterAliasBidRequest(t)}, UserSyncs: &emptyUsersync{}, TCF2Config: emptyTCF2Config, LoggableObject: &analytics.LoggableAuctionObject{}},
 			bidReqAssertions: assertReq,
 			hasError:         false,
 			applyCOPPA:       false,
@@ -528,7 +529,7 @@ func TestCleanOpenRTBRequestsWithFPD(t *testing.T) {
 		},
 		{
 			description: "Pass valid FPD data for bidders specified in request",
-			req:         AuctionRequest{BidRequestWrapper: &openrtb_ext.RequestWrapper{BidRequest: newAdapterAliasBidRequest(t)}, UserSyncs: &emptyUsersync{}, FirstPartyData: fpd, TCF2Config: emptyTCF2Config},
+			req:         AuctionRequest{LoggableObject: &analytics.LoggableAuctionObject{}, BidRequestWrapper: &openrtb_ext.RequestWrapper{BidRequest: newAdapterAliasBidRequest(t)}, UserSyncs: &emptyUsersync{}, FirstPartyData: fpd, TCF2Config: emptyTCF2Config},
 			fpdExpected: true,
 		},
 		{
diff --git a/floors/enforce.go b/floors/enforce.go
index 8bfc31c38..c05c0ef46 100644
--- a/floors/enforce.go
+++ b/floors/enforce.go
@@ -24,7 +24,7 @@ func Enforce(bidRequestWrapper *openrtb_ext.RequestWrapper, seatBids map[openrtb
 	}
 
 	if !isPriceFloorsEnabled(account, bidRequestWrapper) {
-		return seatBids, []error{errors.New("Floors feature is disabled at account or in the request")}, rejectedBids
+		return seatBids, nil, rejectedBids
 	}
 
 	if isSignalingSkipped(requestExt) || !isValidImpBidFloorPresent(bidRequestWrapper.BidRequest.Imp) {
@@ -92,7 +92,7 @@ func updateBidExt(bidRequestWrapper *openrtb_ext.RequestWrapper, seatBids map[op
 		for _, bid := range seatBid.Bids {
 			reqImp, ok := impMap[bid.Bid.ImpID]
 			if ok {
-				updateBidExtWithFloors(reqImp, bid, reqImp.BidFloorCur)
+				updateBidExtWithFloors(reqImp, bid)
 			}
 		}
 	}
@@ -138,6 +138,11 @@ func enforceFloorToBids(bidRequestWrapper *openrtb_ext.RequestWrapper, seatBids
 
 				bidPrice := rate * bid.Bid.Price
 				if reqImp.BidFloor > bidPrice {
+					if bid.BidFloors != nil {
+						// Need USD for OW analytics
+						// TODO: Move this to better place where 'conversions' (deduced from host+request) is available
+						// bid.BidFloors.FloorValueUSD = getOriginalBidCpmUsd(reqImp.BidFloor, reqImp.BidFloorCur, conversions)
+					}
 					rejectedBid := &entities.PbsOrtbSeatBid{
 						Currency: seatBid.Currency,
 						Seat:     seatBid.Seat,
@@ -236,25 +241,27 @@ func getCurrencyConversionRate(seatBidCur, reqImpCur string, conversions currenc
 }
 
 // updateBidExtWithFloors updates floors related details in bid extension
-func updateBidExtWithFloors(reqImp *openrtb_ext.ImpWrapper, bid *entities.PbsOrtbBid, floorCurrency string) {
+func updateBidExtWithFloors(reqImp *openrtb_ext.ImpWrapper, bid *entities.PbsOrtbBid) {
 	impExt, err := reqImp.GetImpExt()
 	if err != nil {
 		return
 	}
 
-	var bidExtFloors openrtb_ext.ExtBidPrebidFloors
 	prebidExt := impExt.GetPrebid()
-	if prebidExt == nil || prebidExt.Floors == nil {
-		if reqImp.BidFloor > 0 {
-			bidExtFloors.FloorValue = reqImp.BidFloor
-			bidExtFloors.FloorCurrency = reqImp.BidFloorCur
-			bid.BidFloors = &bidExtFloors
+	if prebidExt != nil && prebidExt.Floors != nil {
+		bid.BidFloors = &openrtb_ext.ExtBidPrebidFloors{
+			FloorRule:      prebidExt.Floors.FloorRule,
+			FloorRuleValue: prebidExt.Floors.FloorRuleValue,
+			FloorValue:     prebidExt.Floors.FloorValue,
+			FloorCurrency:  reqImp.BidFloorCur,
+		}
+		return
+	}
+
+	if reqImp.Imp != nil && reqImp.Imp.BidFloor != 0 {
+		bid.BidFloors = &openrtb_ext.ExtBidPrebidFloors{
+			FloorValue:    reqImp.Imp.BidFloor,
+			FloorCurrency: reqImp.BidFloorCur,
 		}
-	} else {
-		bidExtFloors.FloorRule = prebidExt.Floors.FloorRule
-		bidExtFloors.FloorRuleValue = prebidExt.Floors.FloorRuleValue
-		bidExtFloors.FloorValue = prebidExt.Floors.FloorValue
-		bidExtFloors.FloorCurrency = floorCurrency
-		bid.BidFloors = &bidExtFloors
 	}
 }
diff --git a/floors/enforce_ow.go b/floors/enforce_ow.go
new file mode 100644
index 000000000..d2acdcf11
--- /dev/null
+++ b/floors/enforce_ow.go
@@ -0,0 +1,8 @@
+package floors
+
+import "github.com/prebid/prebid-server/currency"
+
+func getOriginalBidCpmUsd(price float64, from string, conversions currency.Conversions) float64 {
+	rate, _ := getCurrencyConversionRate(from, "USD", conversions)
+	return rate * price
+}
diff --git a/floors/enforce_test.go b/floors/enforce_test.go
index 826306a08..7830760d6 100644
--- a/floors/enforce_test.go
+++ b/floors/enforce_test.go
@@ -3,7 +3,6 @@ package floors
 import (
 	"encoding/json"
 	"errors"
-	"reflect"
 	"testing"
 
 	"github.com/prebid/openrtb/v19/openrtb2"
@@ -431,7 +430,7 @@ func TestEnforce(t *testing.T) {
 					Currency: "USD",
 				},
 			},
-			expErrs:         []error{errors.New("Floors feature is disabled at account or in the request")},
+			expErrs:         nil,
 			expRejectedBids: []*entities.PbsOrtbSeatBid{},
 		},
 		{
@@ -470,7 +469,7 @@ func TestEnforce(t *testing.T) {
 					Currency: "USD",
 				},
 			},
-			expErrs:         []error{errors.New("Floors feature is disabled at account or in the request")},
+			expErrs:         nil,
 			expRejectedBids: []*entities.PbsOrtbSeatBid{},
 		},
 		{
@@ -503,6 +502,7 @@ func TestEnforce(t *testing.T) {
 			expEligibleBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
 				"pubmatic": {
 					Bids: []*entities.PbsOrtbBid{
+						// {Bid: &openrtb2.Bid{ID: "some-bid-1", Price: 1.2, ImpID: "some-impression-id-1"}, BidFloors: &openrtb_ext.ExtBidPrebidFloors{FloorValue: 5.01, FloorValueUSD: 0, FloorCurrency: "USD"}},
 						{Bid: &openrtb2.Bid{ID: "some-bid-1", Price: 1.2, ImpID: "some-impression-id-1"}, BidFloors: &openrtb_ext.ExtBidPrebidFloors{FloorValue: 5.01, FloorCurrency: "USD"}},
 					},
 					Seat:     "pubmatic",
@@ -575,7 +575,7 @@ func TestEnforce(t *testing.T) {
 					},
 				},
 				conversions:    convert{},
-				priceFloorsCfg: config.AccountPriceFloors{Enabled: true, EnforceFloorsRate: 100, EnforceDealFloors: true},
+				priceFloorsCfg: config.AccountPriceFloors{Enabled: true, EnforceFloorsRate: 0, EnforceDealFloors: true},
 			},
 			expEligibleBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
 				"pubmatic": {
@@ -593,12 +593,14 @@ func TestEnforce(t *testing.T) {
 				{
 					Seat:     "pubmatic",
 					Currency: "USD",
-					Bids:     []*entities.PbsOrtbBid{{Bid: &openrtb2.Bid{ID: "some-bid-1", Price: 1.2, DealID: "deal_Id_1", ImpID: "some-impression-id-1"}, BidFloors: &openrtb_ext.ExtBidPrebidFloors{FloorCurrency: "USD", FloorValue: 20.01}}},
+					// Bids:     []*entities.PbsOrtbBid{{Bid: &openrtb2.Bid{ID: "some-bid-1", Price: 1.2, DealID: "deal_Id_1", ImpID: "some-impression-id-1"}, BidFloors: &openrtb_ext.ExtBidPrebidFloors{FloorCurrency: "USD", FloorValue: 20.01, FloorValueUSD: 20.01}}},
+					Bids: []*entities.PbsOrtbBid{{Bid: &openrtb2.Bid{ID: "some-bid-1", Price: 1.2, DealID: "deal_Id_1", ImpID: "some-impression-id-1"}, BidFloors: &openrtb_ext.ExtBidPrebidFloors{FloorCurrency: "USD", FloorValue: 20.01}}},
 				},
 				{
 					Seat:     "appnexus",
 					Currency: "USD",
-					Bids:     []*entities.PbsOrtbBid{{Bid: &openrtb2.Bid{ID: "some-bid-11", Price: 0.5, DealID: "deal_Id_3", ImpID: "some-impression-id-1"}, BidFloors: &openrtb_ext.ExtBidPrebidFloors{FloorCurrency: "USD", FloorValue: 20.01}}},
+					// Bids:     []*entities.PbsOrtbBid{{Bid: &openrtb2.Bid{ID: "some-bid-11", Price: 0.5, DealID: "deal_Id_3", ImpID: "some-impression-id-1"}, BidFloors: &openrtb_ext.ExtBidPrebidFloors{FloorCurrency: "USD", FloorValue: 20.01, FloorValueUSD: 20.01}}},
+					Bids: []*entities.PbsOrtbBid{{Bid: &openrtb2.Bid{ID: "some-bid-11", Price: 0.5, DealID: "deal_Id_3", ImpID: "some-impression-id-1"}, BidFloors: &openrtb_ext.ExtBidPrebidFloors{FloorCurrency: "USD", FloorValue: 20.01}}},
 				},
 			},
 			expErrs: []error{},
@@ -632,7 +634,7 @@ func TestEnforce(t *testing.T) {
 					},
 				},
 				conversions:    convert{},
-				priceFloorsCfg: config.AccountPriceFloors{Enabled: true, EnforceFloorsRate: 100, EnforceDealFloors: false},
+				priceFloorsCfg: config.AccountPriceFloors{Enabled: true, EnforceFloorsRate: 0, EnforceDealFloors: false},
 			},
 			expEligibleBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
 				"pubmatic": {
@@ -652,7 +654,8 @@ func TestEnforce(t *testing.T) {
 				{
 					Seat:     "appnexus",
 					Currency: "USD",
-					Bids:     []*entities.PbsOrtbBid{{Bid: &openrtb2.Bid{ID: "some-bid-11", Price: 4.5, ImpID: "some-impression-id-1"}, BidFloors: &openrtb_ext.ExtBidPrebidFloors{FloorValue: 5.01, FloorCurrency: "USD"}}},
+					// Bids:     []*entities.PbsOrtbBid{{Bid: &openrtb2.Bid{ID: "some-bid-11", Price: 4.5, ImpID: "some-impression-id-1"}, BidFloors: &openrtb_ext.ExtBidPrebidFloors{FloorValue: 5.01, FloorValueUSD: 5.01, FloorCurrency: "USD"}}},
+					Bids: []*entities.PbsOrtbBid{{Bid: &openrtb2.Bid{ID: "some-bid-11", Price: 4.5, ImpID: "some-impression-id-1"}, BidFloors: &openrtb_ext.ExtBidPrebidFloors{FloorValue: 5.01, FloorCurrency: "USD"}}},
 				},
 			},
 			expErrs: []error{},
@@ -661,21 +664,18 @@ func TestEnforce(t *testing.T) {
 	for _, tt := range tests {
 		actEligibleBids, actErrs, actRejecteBids := Enforce(tt.args.bidRequestWrapper, tt.args.seatBids, config.Account{PriceFloors: tt.args.priceFloorsCfg}, tt.args.conversions)
 		assert.Equal(t, tt.expErrs, actErrs, tt.name)
-		if !reflect.DeepEqual(tt.expRejectedBids, actRejecteBids) {
-			assert.Fail(t, "rejected bids don't match")
-		}
+		assert.ElementsMatch(t, tt.expRejectedBids, actRejecteBids, tt.name)
 
-		if !reflect.DeepEqual(tt.expEligibleBids, actEligibleBids) {
-			assert.Fail(t, "eligible bids don't match")
+		if !assert.Equal(t, tt.expEligibleBids, actEligibleBids) {
+			assert.Failf(t, "eligible bids don't match", "Expected: %v, Got: %v", tt.expEligibleBids, actEligibleBids)
 		}
 	}
 }
 
 func TestUpdateBidExtWithFloors(t *testing.T) {
 	type args struct {
-		reqImp        *openrtb_ext.ImpWrapper
-		bid           *entities.PbsOrtbBid
-		floorCurrency string
+		reqImp *openrtb_ext.ImpWrapper
+		bid    *entities.PbsOrtbBid
 	}
 	tests := []struct {
 		name        string
@@ -694,7 +694,6 @@ func TestUpdateBidExtWithFloors(t *testing.T) {
 						AdM:   "Adm",
 					},
 				},
-				floorCurrency: "USD",
 			},
 			expBidFloor: &openrtb_ext.ExtBidPrebidFloors{
 				FloorValue:    10,
@@ -711,18 +710,16 @@ func TestUpdateBidExtWithFloors(t *testing.T) {
 						AdM:   "Adm",
 					},
 				},
-				floorCurrency: "USD",
 			},
 			expBidFloor: &openrtb_ext.ExtBidPrebidFloors{
 				FloorRule:      "test|123|xyz",
 				FloorRuleValue: 5.5,
 				FloorValue:     5.5,
-				FloorCurrency:  "USD",
 			},
 		},
 	}
 	for _, tt := range tests {
-		updateBidExtWithFloors(tt.args.reqImp, tt.args.bid, tt.args.floorCurrency)
+		updateBidExtWithFloors(tt.args.reqImp, tt.args.bid)
 		assert.Equal(t, tt.expBidFloor, tt.args.bid.BidFloors, tt.name)
 	}
 }
@@ -1162,3 +1159,92 @@ func TestUpdateEnforcePBS(t *testing.T) {
 		})
 	}
 }
+
+func TestUpdateBidExt(t *testing.T) {
+	type args struct {
+		bidRequestWrapper *openrtb_ext.RequestWrapper
+		seatBids          map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid
+	}
+	tests := []struct {
+		name string
+		args args
+		want *openrtb_ext.ExtBidPrebidFloors
+	}{
+		{
+			name: "Update Bid Ext with different impression id in request and seatbid",
+			args: args{
+				bidRequestWrapper: &openrtb_ext.RequestWrapper{
+					BidRequest: &openrtb2.BidRequest{
+						ID: "some-request-id",
+						Imp: []openrtb2.Imp{{
+							ID:          "some-impression-id-1",
+							Banner:      &openrtb2.Banner{Format: []openrtb2.Format{{W: 300, H: 250}, {W: 300, H: 600}}},
+							BidFloor:    20.01,
+							BidFloorCur: "USD",
+							Ext:         json.RawMessage(`{"prebid":{"floors":{"floorRule":"*|*|*","floorRuleValue":26.02,"floorValue":12,"floorMin":5,"FloorMinCur":"INR"}}}`),
+						}},
+						Ext: json.RawMessage(`{"prebid":{"floors":{"floormin":1,"data":{"currency":"USD","skiprate":100,"modelgroups":[{"modelversion":"version1","skiprate":10,"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"},"values":{"*|*|*":20.01,"*|*|www.website1.com":16.01},"default":21}]},"enforcement":{"enforcepbs":true,"floordeals":true},"enabled":true,"skipped":false}}}`),
+					},
+				},
+				seatBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						Bids: []*entities.PbsOrtbBid{
+							{
+								Bid: &openrtb2.Bid{
+									ID:     "some-bid-1",
+									Price:  1.2,
+									ImpID:  "some-impression-id-2",
+									DealID: "1",
+								},
+							},
+						},
+						Currency: "USD",
+					},
+				},
+			},
+		},
+		{
+			name: "Update Bid Ext with same impression id in request and seatbid",
+			args: args{
+				bidRequestWrapper: &openrtb_ext.RequestWrapper{
+					BidRequest: &openrtb2.BidRequest{
+						ID: "some-request-id",
+						Imp: []openrtb2.Imp{{
+							ID:          "some-impression-id-1",
+							Banner:      &openrtb2.Banner{Format: []openrtb2.Format{{W: 300, H: 250}, {W: 300, H: 600}}},
+							BidFloor:    20.01,
+							BidFloorCur: "USD",
+							Ext:         json.RawMessage(`{"prebid":{"floors":{"floorRule":"*|*|*","floorRuleValue":26.02,"floorValue":12,"floorMin":5,"FloorMinCur":"INR"}}}`),
+						}},
+						Ext: json.RawMessage(`{"prebid":{"floors":{"floormin":1,"data":{"currency":"USD","skiprate":100,"modelgroups":[{"modelversion":"version1","skiprate":10,"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"},"values":{"*|*|*":20.01,"*|*|www.website1.com":16.01},"default":21}]},"enforcement":{"enforcepbs":true,"floordeals":true},"enabled":true,"skipped":false}}}`),
+					},
+				},
+				seatBids: map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid{
+					"pubmatic": {
+						Bids: []*entities.PbsOrtbBid{
+							{
+								Bid: &openrtb2.Bid{
+									ID:     "some-bid-1",
+									Price:  1.2,
+									ImpID:  "some-impression-id-1",
+									DealID: "1",
+								},
+							},
+						},
+						Currency: "USD",
+					},
+				},
+			},
+			want: &openrtb_ext.ExtBidPrebidFloors{
+				FloorValue:     12,
+				FloorRuleValue: 26.02,
+				FloorRule:      "*|*|*",
+				FloorCurrency:  "USD",
+			},
+		},
+	}
+	for _, tt := range tests {
+		updateBidExt(tt.args.bidRequestWrapper, tt.args.seatBids)
+		assert.Equal(t, tt.want, tt.args.seatBids["pubmatic"].Bids[0].BidFloors, "Bid is not updated with data")
+	}
+}
diff --git a/floors/fetcher.go b/floors/fetcher.go
new file mode 100644
index 000000000..1a0b75261
--- /dev/null
+++ b/floors/fetcher.go
@@ -0,0 +1,310 @@
+package floors
+
+import (
+	"container/heap"
+	"context"
+	"encoding/json"
+	"errors"
+	"fmt"
+	"io"
+	"math"
+	"net/http"
+	"strconv"
+	"time"
+
+	"github.com/alitto/pond"
+	validator "github.com/asaskevich/govalidator"
+	"github.com/golang/glog"
+	"github.com/patrickmn/go-cache"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/metrics"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+type FloorFetcher interface {
+	Fetch(configs config.AccountPriceFloors) (*openrtb_ext.PriceFloorRules, string)
+}
+
+type WorkerPool interface {
+	TrySubmit(task func()) bool
+	Stop()
+}
+
+var refetchCheckInterval = 300
+
+type PriceFloorFetcher struct {
+	pool            WorkerPool      // Goroutines worker pool
+	fetchQueue      FetchQueue      // Priority Queue to fetch floor data
+	fetchInprogress map[string]bool // Map of URL with fetch status
+	configReceiver  chan FetchInfo  // Channel which recieves URLs to be fetched
+	done            chan struct{}   // Channel to close fetcher
+	cache           *cache.Cache    // cache
+	cacheExpiry     time.Duration   // cache expiry time
+	metricEngine    metrics.MetricsEngine
+}
+
+type FetchInfo struct {
+	config.AccountFloorFetch
+	FetchTime      int64
+	RefetchRequest bool
+}
+
+type FetchQueue []*FetchInfo
+
+func (fq FetchQueue) Len() int {
+	return len(fq)
+}
+
+func (fq FetchQueue) Less(i, j int) bool {
+	return fq[i].FetchTime < fq[j].FetchTime
+}
+
+func (fq FetchQueue) Swap(i, j int) {
+	fq[i], fq[j] = fq[j], fq[i]
+}
+
+func (fq *FetchQueue) Push(element interface{}) {
+	fetchInfo := element.(*FetchInfo)
+	*fq = append(*fq, fetchInfo)
+}
+
+func (fq *FetchQueue) Pop() interface{} {
+	old := *fq
+	n := len(old)
+	fetchInfo := old[n-1]
+	old[n-1] = nil // avoid memory leak
+	*fq = old[0 : n-1]
+	return fetchInfo
+}
+
+func (fq *FetchQueue) Top() *FetchInfo {
+	old := *fq
+	if len(old) == 0 {
+		return nil
+	}
+	return old[0]
+}
+
+func workerPanicHandler(p interface{}) {
+	glog.Errorf("floor fetcher worker panicked: %v", p)
+}
+
+func NewPriceFloorFetcher(maxWorkers, maxCapacity, cacheCleanUpInt, cacheExpiry int, metricEngine metrics.MetricsEngine) *PriceFloorFetcher {
+
+	floorFetcher := PriceFloorFetcher{
+		pool:            pond.New(maxWorkers, maxCapacity, pond.PanicHandler(workerPanicHandler)),
+		fetchQueue:      make(FetchQueue, 0, 100),
+		fetchInprogress: make(map[string]bool),
+		configReceiver:  make(chan FetchInfo, maxCapacity),
+		done:            make(chan struct{}),
+		cacheExpiry:     time.Duration(cacheExpiry) * time.Second,
+		cache:           cache.New(time.Duration(cacheExpiry)*time.Second, time.Duration(cacheCleanUpInt)*time.Second),
+		metricEngine:    metricEngine,
+	}
+
+	go floorFetcher.Fetcher()
+
+	return &floorFetcher
+}
+
+func (f *PriceFloorFetcher) SetWithExpiry(key string, value interface{}, cacheExpiry time.Duration) {
+	f.cache.Set(key, value, cacheExpiry)
+}
+
+func (f *PriceFloorFetcher) Get(key string) (interface{}, bool) {
+	return f.cache.Get(key)
+}
+
+func (f *PriceFloorFetcher) Fetch(configs config.AccountPriceFloors) (*openrtb_ext.PriceFloorRules, string) {
+
+	if !configs.UseDynamicData || len(configs.Fetch.URL) == 0 || !validator.IsURL(configs.Fetch.URL) {
+		return nil, openrtb_ext.FetchNone
+	}
+
+	// Check for floors JSON in cache
+	result, found := f.Get(configs.Fetch.URL)
+	if found {
+		fetcheRes, ok := result.(*openrtb_ext.PriceFloorRules)
+		if !ok || fetcheRes.Data == nil {
+			return nil, openrtb_ext.FetchError
+		}
+		return fetcheRes, openrtb_ext.FetchSuccess
+	}
+
+	//miss: push to channel to fetch and return empty response
+	if configs.Enabled && configs.Fetch.Enabled && configs.Fetch.Timeout > 0 {
+		fetchInfo := FetchInfo{AccountFloorFetch: configs.Fetch, FetchTime: time.Now().Unix(), RefetchRequest: false}
+		f.configReceiver <- fetchInfo
+	}
+
+	return nil, openrtb_ext.FetchInprogress
+}
+
+func (f *PriceFloorFetcher) worker(configs config.AccountFloorFetch) {
+
+	floorData, fetchedMaxAge := fetchAndValidate(configs, f.metricEngine)
+	if floorData != nil {
+		// Update cache with new floor rules
+		glog.Infof("Updating Value in cache for URL %s", configs.URL)
+		cacheExpiry := f.cacheExpiry
+		if fetchedMaxAge != 0 && fetchedMaxAge > configs.Period && fetchedMaxAge < math.MaxInt32 {
+			cacheExpiry = time.Duration(fetchedMaxAge) * time.Second
+		}
+		f.SetWithExpiry(configs.URL, floorData, cacheExpiry)
+	}
+
+	// Send to refetch channel
+	f.configReceiver <- FetchInfo{AccountFloorFetch: configs, FetchTime: time.Now().Add(time.Duration(configs.Period) * time.Second).Unix(), RefetchRequest: true}
+
+}
+
+func (f *PriceFloorFetcher) Stop() {
+	close(f.done)
+}
+
+func (f *PriceFloorFetcher) submit(fetchInfo *FetchInfo) {
+	status := f.pool.TrySubmit(func() {
+		f.worker(fetchInfo.AccountFloorFetch)
+	})
+	if !status {
+		heap.Push(&f.fetchQueue, fetchInfo)
+	}
+}
+
+func (f *PriceFloorFetcher) Fetcher() {
+
+	//Create Ticker of 5 minutes
+	ticker := time.NewTicker(time.Duration(refetchCheckInterval) * time.Second)
+
+	for {
+		select {
+		case fetchInfo := <-f.configReceiver:
+			if fetchInfo.RefetchRequest {
+				heap.Push(&f.fetchQueue, &fetchInfo)
+			} else {
+				if _, ok := f.fetchInprogress[fetchInfo.URL]; !ok {
+					f.fetchInprogress[fetchInfo.URL] = true
+					f.submit(&fetchInfo)
+				}
+			}
+		case <-ticker.C:
+			currentTime := time.Now().Unix()
+			for top := f.fetchQueue.Top(); top != nil && top.FetchTime <= currentTime; top = f.fetchQueue.Top() {
+				nextFetch := heap.Pop(&f.fetchQueue)
+				f.submit(nextFetch.(*FetchInfo))
+			}
+		case <-f.done:
+			f.pool.Stop()
+			glog.Info("Price Floor fetcher terminated")
+			return
+		}
+	}
+}
+
+func fetchAndValidate(configs config.AccountFloorFetch, metricEngine metrics.MetricsEngine) (*openrtb_ext.PriceFloorRules, int) {
+
+	floorResp, maxAge, err := fetchFloorRulesFromURL(configs)
+	if err != nil {
+		metricEngine.RecordDynamicFetchFailure(configs.AccountID, "1")
+		glog.Errorf("Error while fetching floor data from URL: %s, reason : %s", configs.URL, err.Error())
+		return nil, 0
+	}
+
+	if len(floorResp) > (configs.MaxFileSize * 1024) {
+		glog.Errorf("Recieved invalid floor data from URL: %s, reason : floor file size is greater than MaxFileSize", configs.URL)
+		return nil, 0
+	}
+
+	var priceFloors openrtb_ext.PriceFloorRules
+	if err = json.Unmarshal(floorResp, &priceFloors.Data); err != nil {
+		metricEngine.RecordDynamicFetchFailure(configs.AccountID, "2")
+		glog.Errorf("Recieved invalid price floor json from URL: %s", configs.URL)
+		return nil, 0
+	} else {
+		err := validateRules(configs, &priceFloors)
+		if err != nil {
+			metricEngine.RecordDynamicFetchFailure(configs.AccountID, "3")
+			glog.Errorf("Validation failed for floor JSON from URL: %s, reason: %s", configs.URL, err.Error())
+			return nil, 0
+		}
+	}
+
+	return &priceFloors, maxAge
+}
+
+// fetchFloorRulesFromURL returns a price floor JSON and time for which this JSON is valid
+// from provided URL with timeout constraints
+func fetchFloorRulesFromURL(configs config.AccountFloorFetch) ([]byte, int, error) {
+
+	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(configs.Timeout)*time.Millisecond)
+	defer cancel()
+
+	httpReq, err := http.NewRequestWithContext(ctx, http.MethodGet, configs.URL, nil)
+	if err != nil {
+		return nil, 0, errors.New("error while forming http fetch request : " + err.Error())
+	}
+
+	httpResp, err := http.DefaultClient.Do(httpReq)
+	if err != nil {
+		return nil, 0, errors.New("error while getting response from url : " + err.Error())
+	}
+
+	if httpResp.StatusCode != 200 {
+		return nil, 0, errors.New("no response from server")
+	}
+
+	var maxAge int
+	if maxAgeStr := httpResp.Header.Get("max-age"); maxAgeStr != "" {
+		maxAge, _ = strconv.Atoi(maxAgeStr)
+		if maxAge <= configs.Period || maxAge > math.MaxInt32 {
+			glog.Errorf("Invalid max-age = %s provided, value should be valid integer and should be within (%v, %v)", maxAgeStr, configs.Period, math.MaxInt32)
+		}
+	}
+
+	respBody, err := io.ReadAll(httpResp.Body)
+	if err != nil {
+		return nil, 0, errors.New("unable to read response")
+	}
+	defer httpResp.Body.Close()
+
+	return respBody, maxAge, nil
+}
+
+func validateRules(configs config.AccountFloorFetch, priceFloors *openrtb_ext.PriceFloorRules) error {
+
+	if priceFloors.Data == nil {
+		return errors.New("empty data in floor JSON")
+	}
+
+	if len(priceFloors.Data.ModelGroups) == 0 {
+		return errors.New("no model groups found in price floor data")
+	}
+
+	if priceFloors.Data.SkipRate < skipRateMin || priceFloors.Data.SkipRate > skipRateMax {
+		return fmt.Errorf("skip rate should be greater than or equal to %d and less than %d", skipRateMin, skipRateMax)
+	}
+
+	if priceFloors.Data.UseFetchDataRate != nil && (*priceFloors.Data.UseFetchDataRate < dataRateMin || *priceFloors.Data.UseFetchDataRate > dataRateMax) {
+		return fmt.Errorf("useFetchDataRate should be greater than or equal to %d and less than or equal to %d", dataRateMin, dataRateMax)
+	}
+
+	for _, modelGroup := range priceFloors.Data.ModelGroups {
+		if len(modelGroup.Values) == 0 || len(modelGroup.Values) > configs.MaxRules {
+			return errors.New("invalid number of floor rules, floor rules should be greater than zero and less than MaxRules specified in account config")
+		}
+
+		if modelGroup.ModelWeight != nil && (*modelGroup.ModelWeight < 1 || *modelGroup.ModelWeight > 100) {
+			return errors.New("modelGroup[].modelWeight should be greater than or equal to 1 and less than 100")
+		}
+
+		if modelGroup.SkipRate < 0 || modelGroup.SkipRate > 100 {
+			return errors.New("model group skip rate should be greater than or equal to 0 and less than 100")
+		}
+
+		if modelGroup.Default < 0 {
+			return errors.New("modelGroup.Default should be greater than 0")
+		}
+	}
+
+	return nil
+}
diff --git a/floors/fetcher_test.go b/floors/fetcher_test.go
new file mode 100644
index 000000000..83b13cf53
--- /dev/null
+++ b/floors/fetcher_test.go
@@ -0,0 +1,1095 @@
+package floors
+
+import (
+	"encoding/json"
+	"fmt"
+	"math/rand"
+	"net/http"
+	"net/http/httptest"
+	"reflect"
+	"testing"
+	"time"
+
+	"github.com/alitto/pond"
+	"github.com/patrickmn/go-cache"
+	"github.com/prebid/prebid-server/config"
+	metricsConf "github.com/prebid/prebid-server/metrics/config"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/prebid/prebid-server/util/ptrutil"
+	"github.com/stretchr/testify/assert"
+)
+
+const MaxAge = "max-age"
+
+func TestFetchQueueLen(t *testing.T) {
+	tests := []struct {
+		name string
+		fq   FetchQueue
+		want int
+	}{
+		{
+			name: "Queue is empty",
+			fq:   make(FetchQueue, 0),
+			want: 0,
+		},
+		{
+			name: "Queue is of lenght 1",
+			fq:   make(FetchQueue, 1),
+			want: 1,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := tt.fq.Len(); got != tt.want {
+				t.Errorf("FetchQueue.Len() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
+
+func TestFetchQueueLess(t *testing.T) {
+	type args struct {
+		i int
+		j int
+	}
+	tests := []struct {
+		name string
+		fq   FetchQueue
+		args args
+		want bool
+	}{
+		{
+			name: "first fetchperiod is less than second",
+			fq:   FetchQueue{&FetchInfo{FetchTime: 10}, &FetchInfo{FetchTime: 20}},
+			args: args{i: 0, j: 1},
+			want: true,
+		},
+		{
+			name: "first fetchperiod is greater than second",
+			fq:   FetchQueue{&FetchInfo{FetchTime: 30}, &FetchInfo{FetchTime: 10}},
+			args: args{i: 0, j: 1},
+			want: false,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := tt.fq.Less(tt.args.i, tt.args.j); got != tt.want {
+				t.Errorf("FetchQueue.Less() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
+
+func TestFetchQueueSwap(t *testing.T) {
+	type args struct {
+		i int
+		j int
+	}
+	tests := []struct {
+		name string
+		fq   FetchQueue
+		args args
+	}{
+		{
+			name: "Swap two elements at index i and j",
+			fq:   FetchQueue{&FetchInfo{FetchTime: 30}, &FetchInfo{FetchTime: 10}},
+			args: args{i: 0, j: 1},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			fInfo1, fInfo2 := tt.fq[0], tt.fq[1]
+			tt.fq.Swap(tt.args.i, tt.args.j)
+			assert.Equal(t, fInfo1, tt.fq[1], "elements are not swapped")
+			assert.Equal(t, fInfo2, tt.fq[0], "elements are not swapped")
+		})
+	}
+}
+
+func TestFetchQueuePush(t *testing.T) {
+	type args struct {
+		element interface{}
+	}
+	tests := []struct {
+		name string
+		fq   *FetchQueue
+		args args
+	}{
+		{
+			name: "Push element to queue",
+			fq:   &FetchQueue{},
+			args: args{element: &FetchInfo{FetchTime: 10}},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			tt.fq.Push(tt.args.element)
+			q := *tt.fq
+			assert.Equal(t, q[0], &FetchInfo{FetchTime: 10})
+		})
+	}
+}
+
+func TestFetchQueuePop(t *testing.T) {
+	tests := []struct {
+		name string
+		fq   *FetchQueue
+		want interface{}
+	}{
+		{
+			name: "Pop element from queue",
+			fq:   &FetchQueue{&FetchInfo{FetchTime: 10}},
+			want: &FetchInfo{FetchTime: 10},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := tt.fq.Pop(); !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("FetchQueue.Pop() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
+
+func TestFetchQueueTop(t *testing.T) {
+	tests := []struct {
+		name string
+		fq   *FetchQueue
+		want *FetchInfo
+	}{
+		{
+			name: "Get top element from queue",
+			fq:   &FetchQueue{&FetchInfo{FetchTime: 20}},
+			want: &FetchInfo{FetchTime: 20},
+		},
+		{
+			name: "Queue is empty",
+			fq:   &FetchQueue{},
+			want: nil,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := tt.fq.Top(); !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("FetchQueue.Top() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
+
+func TestValidatePriceFloorRules(t *testing.T) {
+
+	var zero = 0
+	var one_o_one = 101
+	var testURL = "abc.com"
+	type args struct {
+		configs     config.AccountFloorFetch
+		priceFloors *openrtb_ext.PriceFloorRules
+	}
+	tests := []struct {
+		name    string
+		args    args
+		wantErr bool
+	}{
+		{
+			name: "Price floor data is empty",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					URL:         testURL,
+					Timeout:     5,
+					MaxFileSize: 20,
+					MaxRules:    5,
+					MaxAge:      20,
+					Period:      10,
+				},
+				priceFloors: &openrtb_ext.PriceFloorRules{},
+			},
+			wantErr: true,
+		},
+		{
+			name: "Model group array is empty",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					URL:         testURL,
+					Timeout:     5,
+					MaxFileSize: 20,
+					MaxRules:    5,
+					MaxAge:      20,
+					Period:      10,
+				},
+				priceFloors: &openrtb_ext.PriceFloorRules{
+					Data: &openrtb_ext.PriceFloorData{},
+				},
+			},
+			wantErr: true,
+		},
+		{
+			name: "floor rules is empty",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					URL:         testURL,
+					Timeout:     5,
+					MaxFileSize: 20,
+					MaxRules:    5,
+					MaxAge:      20,
+					Period:      10,
+				},
+				priceFloors: &openrtb_ext.PriceFloorRules{
+					Data: &openrtb_ext.PriceFloorData{
+						ModelGroups: []openrtb_ext.PriceFloorModelGroup{{
+							Values: map[string]float64{},
+						}},
+					},
+				},
+			},
+			wantErr: true,
+		},
+		{
+			name: "floor rules is grater than max floor rules",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					URL:         testURL,
+					Timeout:     5,
+					MaxFileSize: 20,
+					MaxRules:    0,
+					MaxAge:      20,
+					Period:      10,
+				},
+				priceFloors: &openrtb_ext.PriceFloorRules{
+					Data: &openrtb_ext.PriceFloorData{
+						ModelGroups: []openrtb_ext.PriceFloorModelGroup{{
+							Values: map[string]float64{
+								"*|*|www.website.com": 15.01,
+							},
+						}},
+					},
+				},
+			},
+			wantErr: true,
+		},
+		{
+			name: "Modelweight is zero",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					URL:         testURL,
+					Timeout:     5,
+					MaxFileSize: 20,
+					MaxRules:    1,
+					MaxAge:      20,
+					Period:      10,
+				},
+				priceFloors: &openrtb_ext.PriceFloorRules{
+					Data: &openrtb_ext.PriceFloorData{
+						ModelGroups: []openrtb_ext.PriceFloorModelGroup{{
+							Values: map[string]float64{
+								"*|*|www.website.com": 15.01,
+							},
+							ModelWeight: &zero,
+						}},
+					},
+				},
+			},
+			wantErr: true,
+		},
+		{
+			name: "Modelweight is 101",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					URL:         testURL,
+					Timeout:     5,
+					MaxFileSize: 20,
+					MaxRules:    1,
+					MaxAge:      20,
+					Period:      10,
+				},
+				priceFloors: &openrtb_ext.PriceFloorRules{
+					Data: &openrtb_ext.PriceFloorData{
+						ModelGroups: []openrtb_ext.PriceFloorModelGroup{{
+							Values: map[string]float64{
+								"*|*|www.website.com": 15.01,
+							},
+							ModelWeight: &one_o_one,
+						}},
+					},
+				},
+			},
+			wantErr: true,
+		},
+		{
+			name: "skiprate is 101",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					URL:         testURL,
+					Timeout:     5,
+					MaxFileSize: 20,
+					MaxRules:    1,
+					MaxAge:      20,
+					Period:      10,
+				},
+				priceFloors: &openrtb_ext.PriceFloorRules{
+					Data: &openrtb_ext.PriceFloorData{
+						ModelGroups: []openrtb_ext.PriceFloorModelGroup{{
+							Values: map[string]float64{
+								"*|*|www.website.com": 15.01,
+							},
+							SkipRate: 101,
+						}},
+					},
+				},
+			},
+			wantErr: true,
+		},
+		{
+			name: "Default is -1",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					URL:         testURL,
+					Timeout:     5,
+					MaxFileSize: 20,
+					MaxRules:    1,
+					MaxAge:      20,
+					Period:      10,
+				},
+				priceFloors: &openrtb_ext.PriceFloorRules{
+					Data: &openrtb_ext.PriceFloorData{
+						ModelGroups: []openrtb_ext.PriceFloorModelGroup{{
+							Values: map[string]float64{
+								"*|*|www.website.com": 15.01,
+							},
+							Default: -1,
+						}},
+					},
+				},
+			},
+			wantErr: true,
+		},
+		{
+			name: "Invalid skip rate in data",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					URL:         testURL,
+					Timeout:     5,
+					MaxFileSize: 20,
+					MaxRules:    1,
+					MaxAge:      20,
+					Period:      10,
+				},
+				priceFloors: &openrtb_ext.PriceFloorRules{
+					Data: &openrtb_ext.PriceFloorData{
+						SkipRate: -44,
+						ModelGroups: []openrtb_ext.PriceFloorModelGroup{{
+							Values: map[string]float64{
+								"*|*|www.website.com": 15.01,
+							},
+						}},
+					},
+				},
+			},
+			wantErr: true,
+		},
+		{
+			name: "Invalid useFetchDataRate",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					URL:         testURL,
+					Timeout:     5,
+					MaxFileSize: 20,
+					MaxRules:    1,
+					MaxAge:      20,
+					Period:      10,
+				},
+				priceFloors: &openrtb_ext.PriceFloorRules{
+					Data: &openrtb_ext.PriceFloorData{
+						SkipRate: 10,
+						ModelGroups: []openrtb_ext.PriceFloorModelGroup{{
+							Values: map[string]float64{
+								"*|*|www.website.com": 15.01,
+							},
+						}},
+						UseFetchDataRate: ptrutil.ToPtr(-11),
+					},
+				},
+			},
+			wantErr: true,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if err := validateRules(tt.args.configs, tt.args.priceFloors); (err != nil) != tt.wantErr {
+				t.Errorf("validatePriceFloorRules() error = %v, wantErr %v", err, tt.wantErr)
+			}
+		})
+	}
+}
+
+func TestFetchFloorRulesFromURL(t *testing.T) {
+
+	mockHandler := func(mockResponse []byte, mockStatus int) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
+			w.Header().Add("Content-Length", "645")
+			w.Header().Add(MaxAge, "20")
+			w.WriteHeader(mockStatus)
+			w.Write(mockResponse)
+		})
+	}
+
+	type args struct {
+		configs config.AccountFloorFetch
+	}
+	tests := []struct {
+		name           string
+		args           args
+		response       []byte
+		responseStatus int
+		want           []byte
+		want1          int
+		wantErr        bool
+	}{
+		{
+			name: "Floor data is successfully returned",
+			args: args{
+				configs: config.AccountFloorFetch{
+					URL:     "",
+					Timeout: 60,
+					Period:  300,
+				},
+			},
+			response: func() []byte {
+				data := `{"data":{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]},"enabled":true,"floormin":1,"enforcement":{"enforcepbs":false,"floordeals":true}}`
+				return []byte(data)
+			}(),
+			responseStatus: 200,
+			want: func() []byte {
+				data := `{"data":{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]},"enabled":true,"floormin":1,"enforcement":{"enforcepbs":false,"floordeals":true}}`
+				return []byte(data)
+			}(),
+			want1:   20,
+			wantErr: false,
+		},
+		{
+			name: "Time out occured",
+			args: args{
+				configs: config.AccountFloorFetch{
+					URL:     "",
+					Timeout: 0,
+					Period:  300,
+				},
+			},
+			want1:          0,
+			responseStatus: 200,
+			wantErr:        true,
+		},
+		{
+			name: "Invalid URL",
+			args: args{
+				configs: config.AccountFloorFetch{
+					URL:     "%%",
+					Timeout: 10,
+					Period:  300,
+				},
+			},
+			want1:          0,
+			responseStatus: 200,
+			wantErr:        true,
+		},
+		{
+			name: "No response from server",
+			args: args{
+				configs: config.AccountFloorFetch{
+					URL:     "",
+					Timeout: 10,
+					Period:  300,
+				},
+			},
+			want1:          0,
+			responseStatus: 500,
+			wantErr:        true,
+		},
+		{
+			name: "Invalid response",
+			args: args{
+				configs: config.AccountFloorFetch{
+					URL:     "",
+					Timeout: 10,
+					Period:  300,
+				},
+			},
+			want1:          0,
+			response:       []byte("1"),
+			responseStatus: 200,
+			wantErr:        true,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			mockHttpServer := httptest.NewServer(mockHandler(tt.response, tt.responseStatus))
+			defer mockHttpServer.Close()
+
+			if tt.args.configs.URL == "" {
+				tt.args.configs.URL = mockHttpServer.URL
+			}
+			got, got1, err := fetchFloorRulesFromURL(tt.args.configs)
+			if (err != nil) != tt.wantErr {
+				t.Errorf("fetchFloorRulesFromURL() error = %v, wantErr %v", err, tt.wantErr)
+				return
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("fetchFloorRulesFromURL() got = %v, want %v", got, tt.want)
+			}
+			if got1 != tt.want1 {
+				t.Errorf("fetchFloorRulesFromURL() got1 = %v, want %v", got1, tt.want1)
+			}
+		})
+	}
+}
+
+func TestFetchFloorRulesFromURLInvalidMaxAge(t *testing.T) {
+
+	mockHandler := func(mockResponse []byte, mockStatus int) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
+			w.Header().Add("Content-Length", "645")
+			w.Header().Add(MaxAge, "abc")
+			w.WriteHeader(mockStatus)
+			w.Write(mockResponse)
+		})
+	}
+
+	type args struct {
+		configs config.AccountFloorFetch
+	}
+	tests := []struct {
+		name           string
+		args           args
+		response       []byte
+		responseStatus int
+		want           []byte
+		want1          int
+		wantErr        bool
+	}{
+		{
+			name: "Floor data is successfully returned",
+			args: args{
+				configs: config.AccountFloorFetch{
+					URL:     "",
+					Timeout: 60,
+					Period:  300,
+				},
+			},
+			response: func() []byte {
+				data := `{"data":{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]},"enabled":true,"floormin":1,"enforcement":{"enforcepbs":false,"floordeals":true}}`
+				return []byte(data)
+			}(),
+			responseStatus: 200,
+			want: func() []byte {
+				data := `{"data":{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]},"enabled":true,"floormin":1,"enforcement":{"enforcepbs":false,"floordeals":true}}`
+				return []byte(data)
+			}(),
+			want1:   0,
+			wantErr: false,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			mockHttpServer := httptest.NewServer(mockHandler(tt.response, tt.responseStatus))
+			defer mockHttpServer.Close()
+
+			if tt.args.configs.URL == "" {
+				tt.args.configs.URL = mockHttpServer.URL
+			}
+
+			got, got1, err := fetchFloorRulesFromURL(tt.args.configs)
+			if (err != nil) != tt.wantErr {
+				t.Errorf("fetchFloorRulesFromURL() error = %v, wantErr %v", err, tt.wantErr)
+				return
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("fetchFloorRulesFromURL() got = %v, want %v", got, tt.want)
+			}
+			if got1 != tt.want1 {
+				t.Errorf("fetchFloorRulesFromURL() got1 = %v, want %v", got1, tt.want1)
+			}
+		})
+	}
+}
+
+func TestFetchAndValidate(t *testing.T) {
+
+	mockHandler := func(mockResponse []byte, mockStatus int) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
+			w.Header().Add(MaxAge, "30")
+			w.WriteHeader(mockStatus)
+			w.Write(mockResponse)
+		})
+	}
+
+	type args struct {
+		configs config.AccountFloorFetch
+	}
+	tests := []struct {
+		name           string
+		args           args
+		response       []byte
+		responseStatus int
+		want           *openrtb_ext.PriceFloorRules
+		want1          int
+	}{
+		{
+			name: "Recieved valid price floor rules response",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     30,
+					MaxFileSize: 700,
+					MaxRules:    30,
+					MaxAge:      60,
+					Period:      40,
+				},
+			},
+			response: func() []byte {
+				data := `{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]}`
+				return []byte(data)
+			}(),
+			responseStatus: 200,
+			want: func() *openrtb_ext.PriceFloorRules {
+				var res openrtb_ext.PriceFloorRules
+				data := `{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]}`
+				_ = json.Unmarshal([]byte(data), &res.Data)
+				return &res
+			}(),
+			want1: 30,
+		},
+		{
+			name: "No response from server",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     30,
+					MaxFileSize: 700,
+					MaxRules:    30,
+					MaxAge:      60,
+					Period:      40,
+				},
+			},
+			response:       []byte{},
+			responseStatus: 500,
+			want:           nil,
+			want1:          0,
+		},
+		{
+			name: "File is greater than MaxFileSize",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     30,
+					MaxFileSize: 1,
+					MaxRules:    30,
+					MaxAge:      60,
+					Period:      40,
+				},
+			},
+			response: func() []byte {
+				data := `{"currency":"USD","floorProvider":"PM","floorsSchemaVersion":2,"modelGroups":[{"modelVersion":"M_0","modelWeight":1,"schema":{"fields":["domain"]},"values":{"missyusa.com":0.85,"www.missyusa.com":0.7}},{"modelVersion":"M_1","modelWeight":1,"schema":{"fields":["domain"]},"values":{"missyusa.com":1,"www.missyusa.com":1.85}},{"modelVersion":"M_2","modelWeight":5,"schema":{"fields":["domain"]},"values":{"missyusa.com":1.6,"www.missyusa.com":0.7}},{"modelVersion":"M_3","modelWeight":2,"schema":{"fields":["domain"]},"values":{"missyusa.com":1.9,"www.missyusa.com":0.75}},{"modelVersion":"M_4","modelWeight":1,"schema":{"fields":["domain"]},"values":{"www.missyusa.com":1.35,"missyusa.com":1.75}},{"modelVersion":"M_5","modelWeight":2,"schema":{"fields":["domain"]},"values":{"missyusa.com":1.4,"www.missyusa.com":0.9}},{"modelVersion":"M_6","modelWeight":43,"schema":{"fields":["domain"]},"values":{"www.missyusa.com":2,"missyusa.com":2}},{"modelVersion":"M_7","modelWeight":1,"schema":{"fields":["domain"]},"values":{"missyusa.com":1.4,"www.missyusa.com":1.85}},{"modelVersion":"M_8","modelWeight":3,"schema":{"fields":["domain"]},"values":{"www.missyusa.com":1.7,"missyusa.com":0.1}},{"modelVersion":"M_9","modelWeight":7,"schema":{"fields":["domain"]},"values":{"missyusa.com":1.9,"www.missyusa.com":1.05}},{"modelVersion":"M_10","modelWeight":9,"schema":{"fields":["domain"]},"values":{"www.missyusa.com":2,"missyusa.com":0.1}},{"modelVersion":"M_11","modelWeight":1,"schema":{"fields":["domain"]},"values":{"missyusa.com":0.45,"www.missyusa.com":1.5}},{"modelVersion":"M_12","modelWeight":8,"schema":{"fields":["domain"]},"values":{"missyusa.com":1.2,"www.missyusa.com":1.7}},{"modelVersion":"M_13","modelWeight":8,"schema":{"fields":["domain"]},"values":{"missyusa.com":0.85,"www.missyusa.com":0.75}},{"modelVersion":"M_14","modelWeight":1,"schema":{"fields":["domain"]},"values":{"missyusa.com":1.8,"www.missyusa.com":1}},{"modelVersion":"M_15","modelWeight":1,"schema":{"fields":["domain"]},"values":{"www.missyusa.com":1.2,"missyusa.com":1.75}},{"modelVersion":"M_16","modelWeight":2,"schema":{"fields":["domain"]},"values":{"missyusa.com":1,"www.missyusa.com":0.7}},{"modelVersion":"M_17","modelWeight":1,"schema":{"fields":["domain"]},"values":{"missyusa.com":0.45,"www.missyusa.com":0.35}},{"modelVersion":"M_18","modelWeight":3,"schema":{"fields":["domain"]},"values":{"missyusa.com":1.2,"www.missyusa.com":1.05}}],"skipRate":10}`
+				return []byte(data)
+			}(),
+			responseStatus: 200,
+			want:           nil,
+			want1:          0,
+		},
+		{
+			name: "Malformed response : json unmarshalling failed",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     30,
+					MaxFileSize: 800,
+					MaxRules:    30,
+					MaxAge:      60,
+					Period:      40,
+				},
+			},
+			response: func() []byte {
+				data := `{"data":nil?}`
+				return []byte(data)
+			}(),
+			responseStatus: 200,
+			want:           nil,
+			want1:          0,
+		},
+		{
+			name: "Validations failed for price floor rules response",
+			args: args{
+				configs: config.AccountFloorFetch{
+					Enabled:     true,
+					Timeout:     30,
+					MaxFileSize: 700,
+					MaxRules:    30,
+					MaxAge:      60,
+					Period:      40,
+				},
+			},
+			response: func() []byte {
+				data := `{"data":{"currency":"USD","modelgroups":[]},"enabled":true,"floormin":1,"enforcement":{"enforcepbs":false,"floordeals":true}}`
+				return []byte(data)
+			}(),
+			responseStatus: 200,
+			want:           nil,
+			want1:          0,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			mockHttpServer := httptest.NewServer(mockHandler(tt.response, tt.responseStatus))
+			defer mockHttpServer.Close()
+
+			tt.args.configs.URL = mockHttpServer.URL
+			got, got1 := fetchAndValidate(tt.args.configs, &metricsConf.NilMetricsEngine{})
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("fetchAndValidate() got = %v, want %v", got, tt.want)
+			}
+			if got1 != tt.want1 {
+				t.Errorf("fetchAndValidate() got1 = %v, want %v", got1, tt.want1)
+			}
+		})
+	}
+}
+
+func TestFetcherWhenRequestGetSameURLInrequest(t *testing.T) {
+
+	refetchCheckInterval = 1
+	response := []byte(`{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]}`)
+	mockHandler := func(mockResponse []byte, mockStatus int) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
+			w.WriteHeader(mockStatus)
+			w.Write(mockResponse)
+		})
+	}
+
+	mockHttpServer := httptest.NewServer(mockHandler(response, 200))
+	defer mockHttpServer.Close()
+
+	fectherInstance := NewPriceFloorFetcher(5, 10, 1, 20, &metricsConf.NilMetricsEngine{})
+	defer fectherInstance.Stop()
+	defer fectherInstance.pool.Stop()
+
+	fetchConfig := config.AccountPriceFloors{
+		Enabled:        true,
+		UseDynamicData: true,
+		Fetch: config.AccountFloorFetch{
+			Enabled:     true,
+			URL:         mockHttpServer.URL,
+			Timeout:     100,
+			MaxFileSize: 1000,
+			MaxRules:    100,
+			MaxAge:      20,
+			Period:      1,
+		},
+	}
+
+	for i := 0; i < 50; i++ {
+		fectherInstance.Fetch(fetchConfig)
+	}
+
+	assert.Never(t, func() bool { return len(fectherInstance.fetchQueue) > 1 }, time.Duration(2*time.Second), 100*time.Millisecond, "Queue Got more than one entry")
+	assert.Never(t, func() bool { return len(fectherInstance.fetchInprogress) > 1 }, time.Duration(2*time.Second), 100*time.Millisecond, "Map Got more than one entry")
+
+}
+
+func TestFetcherDataPresentInCache(t *testing.T) {
+
+	fectherInstance := NewPriceFloorFetcher(2, 5, 5, 20, &metricsConf.NilMetricsEngine{})
+	defer fectherInstance.Stop()
+	defer fectherInstance.pool.Stop()
+
+	fetchConfig := config.AccountPriceFloors{
+		Enabled:        true,
+		UseDynamicData: true,
+		Fetch: config.AccountFloorFetch{
+			Enabled:     true,
+			URL:         "http://test.com/floor",
+			Timeout:     100,
+			MaxFileSize: 1000,
+			MaxRules:    100,
+			MaxAge:      20,
+			Period:      5,
+		},
+	}
+	var res *openrtb_ext.PriceFloorRules
+	data := `{"data":{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]},"enabled":true,"floormin":1,"enforcement":{"enforcepbs":false,"floordeals":true}}`
+	_ = json.Unmarshal([]byte(data), &res)
+	fectherInstance.SetWithExpiry("http://test.com/floor", res, fectherInstance.cacheExpiry)
+
+	val, status := fectherInstance.Fetch(fetchConfig)
+	assert.Equal(t, res, val, "Invalid value in cache or cache is empty")
+	assert.Equal(t, "success", status, "Floor fetch should be success")
+}
+
+func TestFetcherDataNotPresentInCache(t *testing.T) {
+
+	fectherInstance := NewPriceFloorFetcher(2, 5, 5, 20, &metricsConf.NilMetricsEngine{})
+	defer fectherInstance.Stop()
+	defer fectherInstance.pool.Stop()
+
+	fetchConfig := config.AccountPriceFloors{
+		Enabled:        true,
+		UseDynamicData: true,
+		Fetch: config.AccountFloorFetch{
+			Enabled:     true,
+			URL:         "http://test.com/floor",
+			Timeout:     100,
+			MaxFileSize: 1000,
+			MaxRules:    100,
+			MaxAge:      20,
+			Period:      5,
+		},
+	}
+	fectherInstance.SetWithExpiry("http://test.com/floor", nil, fectherInstance.cacheExpiry)
+
+	val, status := fectherInstance.Fetch(fetchConfig)
+
+	assert.Equal(t, (*openrtb_ext.PriceFloorRules)(nil), val, "Floor data should be nil")
+	assert.Equal(t, "error", status, "Floor fetch should be error")
+}
+
+func TestPriceFloorFetcherWorker(t *testing.T) {
+
+	var floorData openrtb_ext.PriceFloorData
+	response := []byte(`{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]}`)
+	_ = json.Unmarshal(response, &floorData)
+	floorResp := &openrtb_ext.PriceFloorRules{
+		Data: &floorData,
+	}
+
+	mockHandler := func(mockResponse []byte, mockStatus int) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
+			w.Header().Add(MaxAge, "5")
+			w.WriteHeader(mockStatus)
+			w.Write(mockResponse)
+		})
+	}
+
+	mockHttpServer := httptest.NewServer(mockHandler(response, 200))
+	defer mockHttpServer.Close()
+
+	fectherInstance := PriceFloorFetcher{
+		pool:            nil,
+		fetchQueue:      nil,
+		fetchInprogress: nil,
+		configReceiver:  make(chan FetchInfo, 1),
+		done:            nil,
+		cache:           cache.New(time.Duration(5)*time.Second, time.Duration(2)*time.Second),
+		cacheExpiry:     10,
+	}
+
+	fetchConfig := config.AccountFloorFetch{
+		Enabled:     true,
+		URL:         mockHttpServer.URL,
+		Timeout:     100,
+		MaxFileSize: 1000,
+		MaxRules:    100,
+		MaxAge:      20,
+		Period:      1,
+	}
+
+	fectherInstance.worker(fetchConfig)
+	dataInCache, _ := fectherInstance.Get(mockHttpServer.URL)
+	assert.Equal(t, floorResp, dataInCache, "Data should be stored in cache")
+
+	info := <-fectherInstance.configReceiver
+	assert.Equal(t, true, info.RefetchRequest, "Recieved request is not refetch request")
+	assert.Equal(t, mockHttpServer.URL, info.AccountFloorFetch.URL, "Recieved request with different url")
+
+}
+
+func TestPriceFloorFetcherWorkerDefaultCacheExpiry(t *testing.T) {
+
+	var floorData openrtb_ext.PriceFloorData
+	response := []byte(`{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]}`)
+	_ = json.Unmarshal(response, &floorData)
+	floorResp := &openrtb_ext.PriceFloorRules{
+		Data: &floorData,
+	}
+
+	mockHandler := func(mockResponse []byte, mockStatus int) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
+			w.WriteHeader(mockStatus)
+			w.Write(mockResponse)
+		})
+	}
+
+	mockHttpServer := httptest.NewServer(mockHandler(response, 200))
+	defer mockHttpServer.Close()
+
+	fectherInstance := &PriceFloorFetcher{
+		pool:            nil,
+		fetchQueue:      nil,
+		fetchInprogress: nil,
+		configReceiver:  make(chan FetchInfo, 1),
+		done:            nil,
+		cache:           cache.New(time.Duration(5)*time.Second, time.Duration(2)*time.Second),
+		cacheExpiry:     time.Duration(10) * time.Second,
+	}
+
+	fetchConfig := config.AccountFloorFetch{
+		Enabled:     true,
+		URL:         mockHttpServer.URL,
+		Timeout:     100,
+		MaxFileSize: 1000,
+		MaxRules:    100,
+		MaxAge:      20,
+		Period:      1,
+	}
+
+	fectherInstance.worker(fetchConfig)
+	dataInCache, _ := fectherInstance.Get(mockHttpServer.URL)
+	assert.Equal(t, floorResp, dataInCache, "Data should be stored in cache")
+
+	info := <-fectherInstance.configReceiver
+	close(fectherInstance.configReceiver)
+	assert.Equal(t, true, info.RefetchRequest, "Recieved request is not refetch request")
+	assert.Equal(t, mockHttpServer.URL, info.AccountFloorFetch.URL, "Recieved request with different url")
+
+}
+
+func TestPriceFloorFetcherSubmit(t *testing.T) {
+
+	response := []byte(`{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]}`)
+	mockHandler := func(mockResponse []byte, mockStatus int) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
+			w.WriteHeader(mockStatus)
+			w.Write(mockResponse)
+		})
+	}
+
+	mockHttpServer := httptest.NewServer(mockHandler(response, 200))
+	defer mockHttpServer.Close()
+
+	fectherInstance := &PriceFloorFetcher{
+		pool:            pond.New(1, 1),
+		fetchQueue:      make(FetchQueue, 0),
+		fetchInprogress: nil,
+		configReceiver:  make(chan FetchInfo, 1),
+		done:            nil,
+		cache:           cache.New(time.Duration(2)*time.Second, time.Duration(1)*time.Second),
+		cacheExpiry:     2,
+	}
+	defer fectherInstance.pool.Stop()
+
+	fetchInfo := FetchInfo{
+		RefetchRequest: false,
+		FetchTime:      time.Now().Unix(),
+		AccountFloorFetch: config.AccountFloorFetch{
+			Enabled:     true,
+			URL:         mockHttpServer.URL,
+			Timeout:     100,
+			MaxFileSize: 1000,
+			MaxRules:    100,
+			MaxAge:      2,
+			Period:      1,
+		},
+	}
+
+	fectherInstance.submit(&fetchInfo)
+
+	info := <-fectherInstance.configReceiver
+	close(fectherInstance.configReceiver)
+	assert.Equal(t, true, info.RefetchRequest, "Recieved request is not refetch request")
+	assert.Equal(t, mockHttpServer.URL, info.AccountFloorFetch.URL, "Recieved request with different url")
+
+}
+
+type testPool struct{}
+
+func (t *testPool) TrySubmit(task func()) bool {
+	return false
+}
+
+func (t *testPool) Stop() {}
+
+func TestPriceFloorFetcherSubmitFailed(t *testing.T) {
+
+	fectherInstance := &PriceFloorFetcher{
+		pool:            &testPool{},
+		fetchQueue:      make(FetchQueue, 0),
+		fetchInprogress: nil,
+		configReceiver:  nil,
+		done:            nil,
+		cache:           nil,
+		cacheExpiry:     2,
+	}
+	defer fectherInstance.pool.Stop()
+
+	fetchInfo := FetchInfo{
+		RefetchRequest: false,
+		FetchTime:      time.Now().Unix(),
+		AccountFloorFetch: config.AccountFloorFetch{
+			Enabled:     true,
+			URL:         "http://test.com",
+			Timeout:     100,
+			MaxFileSize: 1000,
+			MaxRules:    100,
+			MaxAge:      2,
+			Period:      1,
+		},
+	}
+
+	fectherInstance.submit(&fetchInfo)
+	assert.Equal(t, 1, len(fectherInstance.fetchQueue), "Unable to submit the task")
+}
+
+func getRandomNumber() int {
+	rand.Seed(time.Now().UnixNano())
+	min := 1
+	max := 10
+	return rand.Intn(max-min+1) + min
+}
+
+func TestFetcherWhenRequestGetDifferentURLInrequest(t *testing.T) {
+
+	refetchCheckInterval = 1
+	response := []byte(`{"currency":"USD","modelgroups":[{"modelweight":40,"modelversion":"version1","default":5,"values":{"banner|300x600|www.website.com":3,"banner|728x90|www.website.com":5,"banner|300x600|*":4,"banner|300x250|*":2,"*|*|*":16,"*|300x250|*":10,"*|300x600|*":12,"*|300x600|www.website.com":11,"banner|*|*":8,"banner|300x250|www.website.com":1,"*|728x90|www.website.com":13,"*|300x250|www.website.com":9,"*|728x90|*":14,"banner|728x90|*":6,"banner|*|www.website.com":7,"*|*|www.website.com":15},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]}`)
+	mockHandler := func(mockResponse []byte, mockStatus int) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
+			w.WriteHeader(mockStatus)
+			w.Write(mockResponse)
+		})
+	}
+
+	mockHttpServer := httptest.NewServer(mockHandler(response, 200))
+	defer mockHttpServer.Close()
+
+	fectherInstance := NewPriceFloorFetcher(5, 10, 1, 20, &metricsConf.NilMetricsEngine{})
+	defer fectherInstance.Stop()
+	defer fectherInstance.pool.Stop()
+
+	fetchConfig := config.AccountPriceFloors{
+		Enabled:        true,
+		UseDynamicData: true,
+		Fetch: config.AccountFloorFetch{
+			Enabled:     true,
+			URL:         mockHttpServer.URL,
+			Timeout:     100,
+			MaxFileSize: 1000,
+			MaxRules:    100,
+			MaxAge:      5,
+			Period:      1,
+		},
+	}
+
+	for i := 0; i < 50; i++ {
+		fetchConfig.Fetch.URL = fmt.Sprintf("%s?id=%d", mockHttpServer.URL, getRandomNumber())
+		fectherInstance.Fetch(fetchConfig)
+	}
+
+	assert.Never(t, func() bool { return len(fectherInstance.fetchQueue) > 10 }, time.Duration(2*time.Second), 100*time.Millisecond, "Queue Got more than one entry")
+	assert.Never(t, func() bool { return len(fectherInstance.fetchInprogress) > 10 }, time.Duration(2*time.Second), 100*time.Millisecond, "Map Got more than one entry")
+}
diff --git a/floors/floors.go b/floors/floors.go
index f9e13ec05..aca897283 100644
--- a/floors/floors.go
+++ b/floors/floors.go
@@ -25,11 +25,13 @@ const (
 	modelWeightMin   int    = 1
 	enforceRateMin   int    = 0
 	enforceRateMax   int    = 100
+	dataRateMin      int    = 0
+	dataRateMax      int    = 100
 )
 
 // EnrichWithPriceFloors checks for floors enabled in account and request and selects floors data from dynamic fetched if present
 // else selects floors data from req.ext.prebid.floors and update request with selected floors details
-func EnrichWithPriceFloors(bidRequestWrapper *openrtb_ext.RequestWrapper, account config.Account, conversions currency.Conversions) []error {
+func EnrichWithPriceFloors(bidRequestWrapper *openrtb_ext.RequestWrapper, account config.Account, conversions currency.Conversions, priceFloorFetcher FloorFetcher) []error {
 
 	if bidRequestWrapper == nil || bidRequestWrapper.BidRequest == nil {
 		return []error{errors.New("Empty bidrequest")}
@@ -39,7 +41,7 @@ func EnrichWithPriceFloors(bidRequestWrapper *openrtb_ext.RequestWrapper, accoun
 		return []error{errors.New("Floors feature is disabled at account or in the request")}
 	}
 
-	floors, err := resolveFloors(account, bidRequestWrapper, conversions)
+	floors, err := resolveFloors(account, bidRequestWrapper, conversions, priceFloorFetcher)
 
 	updateReqErrs := updateBidRequestWithFloors(floors, bidRequestWrapper, conversions)
 	updateFloorsInRequest(bidRequestWrapper, floors)
@@ -94,11 +96,9 @@ func updateBidRequestWithFloors(extFloorRules *openrtb_ext.PriceFloorRules, requ
 				imp.BidFloor = bidFloor
 				imp.BidFloorCur = floorCur
 
-				if isRuleMatched {
-					err = updateImpExtWithFloorDetails(imp, matchedRule, floorVal, imp.BidFloor)
-					if err != nil {
-						floorErrList = append(floorErrList, err)
-					}
+				err = updateImpExtWithFloorDetails(imp, matchedRule, floorVal, imp.BidFloor)
+				if err != nil {
+					floorErrList = append(floorErrList, err)
 				}
 			} else {
 				floorErrList = append(floorErrList, err)
@@ -134,18 +134,36 @@ func isPriceFloorsEnabledForRequest(bidRequestWrapper *openrtb_ext.RequestWrappe
 	return true
 }
 
-// resolveFloors does selection of floors fields from request data and dynamic fetched data if dynamic fetch is enabled
-func resolveFloors(account config.Account, bidRequestWrapper *openrtb_ext.RequestWrapper, conversions currency.Conversions) (*openrtb_ext.PriceFloorRules, []error) {
-	var errList []error
-	var floorRules *openrtb_ext.PriceFloorRules
+// shouldUseFetchedData will check if to use fetched data or request data
+func shouldUseFetchedData(rate *int) bool {
+	if rate == nil {
+		return true
+	}
+	randomNumber := rand.Intn(dataRateMax)
+	return randomNumber < *rate
+}
+
+// resolveFloors does selection of floors fields from requet JSON and dynamic fetched floors JSON if dynamic fetch is enabled
+func resolveFloors(account config.Account, bidRequestWrapper *openrtb_ext.RequestWrapper, conversions currency.Conversions, priceFloorFetcher FloorFetcher) (*openrtb_ext.PriceFloorRules, []error) {
+	var errlist []error
+	var floorsJson *openrtb_ext.PriceFloorRules
 
 	reqFloor := extractFloorsFromRequest(bidRequestWrapper)
-	if reqFloor != nil {
-		floorRules, errList = createFloorsFrom(reqFloor, account, openrtb_ext.FetchNone, openrtb_ext.RequestLocation)
+	if reqFloor != nil && reqFloor.Location != nil && len(reqFloor.Location.URL) > 0 {
+		account.PriceFloors.Fetch.URL = reqFloor.Location.URL
+	}
+	account.PriceFloors.Fetch.AccountID = account.ID
+	fetchResult, fetchStatus := priceFloorFetcher.Fetch(account.PriceFloors)
+
+	if shouldUseDynamicFetchedFloor(account) && fetchResult != nil && fetchStatus == openrtb_ext.FetchSuccess && shouldUseFetchedData(fetchResult.Data.UseFetchDataRate) {
+		mergedFloor := mergeFloors(reqFloor, *fetchResult, conversions)
+		floorsJson, errlist = createFloorsFrom(mergedFloor, account, fetchStatus, openrtb_ext.FetchLocation)
+	} else if reqFloor != nil {
+		floorsJson, errlist = createFloorsFrom(reqFloor, account, openrtb_ext.FetchNone, openrtb_ext.RequestLocation)
 	} else {
-		floorRules, errList = createFloorsFrom(nil, account, openrtb_ext.FetchNone, openrtb_ext.NoDataLocation)
+		floorsJson, errlist = createFloorsFrom(nil, account, openrtb_ext.FetchNone, openrtb_ext.NoDataLocation)
 	}
-	return floorRules, errList
+	return floorsJson, errlist
 }
 
 // createFloorsFrom does preparation of floors data which shall be used for further processing
@@ -181,9 +199,80 @@ func createFloorsFrom(floors *openrtb_ext.PriceFloorRules, account config.Accoun
 		}
 	}
 
+	if floorLocation == openrtb_ext.RequestLocation && finalFloors.Data == nil {
+		finalFloors.PriceFloorLocation = openrtb_ext.NoDataLocation
+	}
+
 	return finalFloors, floorModelErrList
 }
 
+// mergeFloors does merging for floors data from request and dynamic fetch
+func mergeFloors(reqFloors *openrtb_ext.PriceFloorRules, fetchFloors openrtb_ext.PriceFloorRules, conversions currency.Conversions) *openrtb_ext.PriceFloorRules {
+	var enforceRate int
+
+	mergedFloors := fetchFloors
+	floorsEnabledByRequest := reqFloors.GetEnabled()
+	floorMinPrice := resolveFloorMin(reqFloors, fetchFloors, conversions)
+
+	if reqFloors != nil && reqFloors.Enforcement != nil {
+		enforceRate = reqFloors.Enforcement.EnforceRate
+	}
+
+	if floorsEnabledByRequest || enforceRate > 0 || floorMinPrice.FloorMin > float64(0) {
+		floorsEnabledByProvider := getFloorsEnabledFlag(fetchFloors)
+		floorsProviderEnforcement := fetchFloors.Enforcement
+
+		if mergedFloors.Enabled == nil {
+			mergedFloors.Enabled = new(bool)
+		}
+		*mergedFloors.Enabled = floorsEnabledByProvider && floorsEnabledByRequest
+		mergedFloors.Enforcement = resolveEnforcement(floorsProviderEnforcement, enforceRate)
+		if reqFloors != nil && reqFloors.Enforcement != nil && reqFloors.Enforcement.EnforcePBS != nil {
+			enforcepbs := *reqFloors.Enforcement.EnforcePBS
+			mergedFloors.Enforcement.EnforcePBS = &enforcepbs
+		}
+		if floorMinPrice.FloorMin > float64(0) {
+			mergedFloors.FloorMin = floorMinPrice.FloorMin
+			mergedFloors.FloorMinCur = floorMinPrice.FloorMinCur
+		}
+	}
+	if reqFloors != nil && reqFloors.Location != nil && reqFloors.Location.URL != "" {
+		if mergedFloors.Location == nil {
+			mergedFloors.Location = new(openrtb_ext.PriceFloorEndpoint)
+		}
+		(*mergedFloors.Location).URL = (*reqFloors.Location).URL
+	}
+
+	return &mergedFloors
+}
+
+// resolveEnforcement does retrieval of enforceRate from request
+func resolveEnforcement(enforcement *openrtb_ext.PriceFloorEnforcement, enforceRate int) *openrtb_ext.PriceFloorEnforcement {
+	if enforcement == nil {
+		enforcement = new(openrtb_ext.PriceFloorEnforcement)
+	}
+	enforcement.EnforceRate = enforceRate
+	return enforcement
+}
+
+// getFloorsEnabledFlag gets floors enabled flag from request
+func getFloorsEnabledFlag(reqFloors openrtb_ext.PriceFloorRules) bool {
+	if reqFloors.Enabled != nil {
+		return *reqFloors.Enabled
+	}
+	return true
+}
+
+// resolveFloorMin gets floorMin valud from request and dynamic fetched data
+func resolveFloorMin(reqFloors *openrtb_ext.PriceFloorRules, fetchFloors openrtb_ext.PriceFloorRules, conversions currency.Conversions) Price {
+	return resolveFloorMinOW(reqFloors, &fetchFloors, conversions)
+}
+
+// shouldUseDynamicFetchedFloor gets UseDynamicData flag from account level config
+func shouldUseDynamicFetchedFloor(Account config.Account) bool {
+	return Account.PriceFloors.UseDynamicData
+}
+
 // extractFloorsFromRequest gets floors data from req.ext.prebid.floors
 func extractFloorsFromRequest(bidRequestWrapper *openrtb_ext.RequestWrapper) *openrtb_ext.PriceFloorRules {
 	requestExt, err := bidRequestWrapper.GetRequestExt()
diff --git a/floors/floors_ow.go b/floors/floors_ow.go
new file mode 100644
index 000000000..a271ff7dd
--- /dev/null
+++ b/floors/floors_ow.go
@@ -0,0 +1,90 @@
+package floors
+
+import (
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/openrtb/v19/openrtb3"
+	"github.com/prebid/prebid-server/analytics"
+	"github.com/prebid/prebid-server/currency"
+	"github.com/prebid/prebid-server/exchange/entities"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func RequestHasFloors(bidRequest *openrtb2.BidRequest) bool {
+	for i := range bidRequest.Imp {
+		if bidRequest.Imp[i].BidFloor > 0 {
+			return true
+		}
+	}
+	return false
+}
+
+func PbsOrtbBidToAnalyticsRejectedBid(pbsRejSeatBids []*entities.PbsOrtbSeatBid) []analytics.RejectedBid {
+	var rejectedBid []analytics.RejectedBid
+	for _, pbsRejSeatBid := range pbsRejSeatBids {
+		for _, pbsRejBid := range pbsRejSeatBid.Bids {
+			var rejectionReason = openrtb3.LossBidBelowAuctionFloor
+			if pbsRejBid.Bid.DealID != "" {
+				rejectionReason = openrtb3.LossBidBelowDealFloor
+			}
+			rejectedBid = append(rejectedBid, analytics.RejectedBid{
+				Bid:             pbsRejBid,
+				Seat:            pbsRejSeatBid.Seat,
+				RejectionReason: rejectionReason,
+			})
+		}
+	}
+	return rejectedBid
+}
+
+// resolveFloorMin gets floorMin value from request and dynamic fetched data
+func resolveFloorMinOW(reqFloors *openrtb_ext.PriceFloorRules, fetchFloors *openrtb_ext.PriceFloorRules, conversions currency.Conversions) Price {
+	var requestFloorMinCur, providerFloorMinCur string
+	var requestFloorMin, providerFloorMin float64
+
+	if reqFloors != nil {
+		requestFloorMin = reqFloors.FloorMin
+		requestFloorMinCur = reqFloors.FloorMinCur
+		if len(requestFloorMinCur) == 0 && reqFloors.Data != nil {
+			requestFloorMinCur = reqFloors.Data.Currency
+		}
+	}
+
+	if fetchFloors != nil {
+		providerFloorMin = fetchFloors.FloorMin
+		providerFloorMinCur = fetchFloors.FloorMinCur
+		if len(providerFloorMinCur) == 0 && fetchFloors.Data != nil {
+			providerFloorMinCur = fetchFloors.Data.Currency
+		}
+	}
+
+	if len(requestFloorMinCur) > 0 {
+		if requestFloorMin > 0 {
+			return Price{FloorMin: requestFloorMin, FloorMinCur: requestFloorMinCur}
+		}
+
+		if providerFloorMin > 0 {
+			if strings.Compare(providerFloorMinCur, requestFloorMinCur) == 0 || len(providerFloorMinCur) == 0 {
+				return Price{FloorMin: providerFloorMin, FloorMinCur: requestFloorMinCur}
+			}
+			rate, err := conversions.GetRate(providerFloorMinCur, requestFloorMinCur)
+			if err != nil {
+				return Price{FloorMin: 0, FloorMinCur: requestFloorMinCur}
+			}
+			return Price{FloorMin: roundToFourDecimals(rate * providerFloorMin), FloorMinCur: requestFloorMinCur}
+		}
+	}
+
+	if len(providerFloorMinCur) > 0 {
+		if providerFloorMin > 0 {
+			return Price{FloorMin: providerFloorMin, FloorMinCur: providerFloorMinCur}
+		}
+		if requestFloorMin > 0 {
+			return Price{FloorMin: requestFloorMin, FloorMinCur: providerFloorMinCur}
+		}
+	}
+
+	return Price{FloorMin: 0, FloorMinCur: ""}
+
+}
diff --git a/floors/floors_ow_test.go b/floors/floors_ow_test.go
new file mode 100644
index 000000000..e1753fb60
--- /dev/null
+++ b/floors/floors_ow_test.go
@@ -0,0 +1,125 @@
+package floors
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/openrtb/v19/openrtb3"
+	"github.com/prebid/prebid-server/analytics"
+	"github.com/prebid/prebid-server/exchange/entities"
+)
+
+func TestRequestHasFloors(t *testing.T) {
+
+	tests := []struct {
+		name       string
+		bidRequest *openrtb2.BidRequest
+		want       bool
+	}{
+		{
+			bidRequest: &openrtb2.BidRequest{
+				Site: &openrtb2.Site{
+					Publisher: &openrtb2.Publisher{Domain: "www.website.com"},
+				},
+				Imp: []openrtb2.Imp{{ID: "1234", Banner: &openrtb2.Banner{Format: []openrtb2.Format{{W: 300, H: 250}}}}},
+			},
+			want: false,
+		},
+		{
+			bidRequest: &openrtb2.BidRequest{
+				Site: &openrtb2.Site{
+					Publisher: &openrtb2.Publisher{Domain: "www.website.com"},
+				},
+				Imp: []openrtb2.Imp{{ID: "1234", BidFloor: 10, BidFloorCur: "USD", Banner: &openrtb2.Banner{Format: []openrtb2.Format{{W: 300, H: 250}}}}},
+			},
+			want: true,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := RequestHasFloors(tt.bidRequest); got != tt.want {
+				t.Errorf("RequestHasFloors() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
+
+func TestPbsOrtbBidToAnalyticsRejectedBid(t *testing.T) {
+	type args struct {
+		pbsRejSeatBids []*entities.PbsOrtbSeatBid
+	}
+	tests := []struct {
+		name string
+		args args
+		want []analytics.RejectedBid
+	}{
+		{
+			name: "empty PbsRejSeatBids",
+			args: args{
+				pbsRejSeatBids: []*entities.PbsOrtbSeatBid{},
+			},
+			want: nil,
+		},
+		{
+			name: "Multiple Bids with DealId and without DealId",
+			args: args{
+				pbsRejSeatBids: []*entities.PbsOrtbSeatBid{
+					{
+						Bids: []*entities.PbsOrtbBid{
+							{
+								Bid: &openrtb2.Bid{
+									DealID: "123",
+								},
+							},
+							{
+								Bid: &openrtb2.Bid{},
+							},
+							{
+								Bid: &openrtb2.Bid{
+									DealID: "1234",
+								},
+							},
+						},
+						Seat: "xandrr",
+					},
+				},
+			},
+			want: []analytics.RejectedBid{
+				{
+					Bid: &entities.PbsOrtbBid{
+						Bid: &openrtb2.Bid{
+							DealID: "123",
+						},
+					},
+					RejectionReason: openrtb3.LossBidBelowDealFloor,
+					Seat:            "xandrr",
+				},
+				{
+					Bid: &entities.PbsOrtbBid{
+						Bid: &openrtb2.Bid{},
+					},
+					RejectionReason: openrtb3.LossBidBelowAuctionFloor,
+					Seat:            "xandrr",
+				},
+				{
+					Bid: &entities.PbsOrtbBid{
+						Bid: &openrtb2.Bid{
+							DealID: "1234",
+						},
+					},
+					RejectionReason: openrtb3.LossBidBelowDealFloor,
+					Seat:            "xandrr",
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if got := PbsOrtbBidToAnalyticsRejectedBid(tt.args.pbsRejSeatBids); !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("PbsOrtbBidToAnalyticsRejectedBid() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/floors/floors_test.go b/floors/floors_test.go
index 7f27e1a26..62fb1d92c 100644
--- a/floors/floors_test.go
+++ b/floors/floors_test.go
@@ -3,12 +3,14 @@ package floors
 import (
 	"encoding/json"
 	"errors"
+	"reflect"
 	"testing"
 
 	"github.com/prebid/openrtb/v19/openrtb2"
 	"github.com/prebid/prebid-server/config"
 	"github.com/prebid/prebid-server/currency"
 	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/prebid/prebid-server/util/ptrutil"
 	"github.com/stretchr/testify/assert"
 )
 
@@ -364,7 +366,7 @@ func TestEnrichWithPriceFloors(t *testing.T) {
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
 
-			ErrList := EnrichWithPriceFloors(tc.bidRequestWrapper, tc.account, getCurrencyRates(rates))
+			ErrList := EnrichWithPriceFloors(tc.bidRequestWrapper, tc.account, getCurrencyRates(rates), &PriceFloorFetcher{})
 			if tc.bidRequestWrapper != nil {
 				assert.Equal(t, tc.bidRequestWrapper.Imp[0].BidFloor, tc.expFloorVal, tc.name)
 				assert.Equal(t, tc.bidRequestWrapper.Imp[0].BidFloorCur, tc.expFloorCur, tc.name)
@@ -387,11 +389,210 @@ func TestEnrichWithPriceFloors(t *testing.T) {
 	}
 }
 
+func TestResolveFloorMin(t *testing.T) {
+	rates := map[string]map[string]float64{
+		"USD": {
+			"INR": 70,
+			"EUR": 0.9,
+			"JPY": 5.09,
+		},
+	}
+
+	tt := []struct {
+		name        string
+		reqFloors   openrtb_ext.PriceFloorRules
+		fetchFloors openrtb_ext.PriceFloorRules
+		conversions currency.Conversions
+		expPrice    Price
+	}{
+		{
+			name: "FloorsMin present in request Floors only",
+			reqFloors: openrtb_ext.PriceFloorRules{
+				FloorMin:    10,
+				FloorMinCur: "JPY",
+			},
+			fetchFloors: openrtb_ext.PriceFloorRules{},
+			expPrice:    Price{FloorMin: 10, FloorMinCur: "JPY"},
+		},
+		{
+			name: "FloorsMin present in request Floors and data currency present",
+			reqFloors: openrtb_ext.PriceFloorRules{
+				FloorMin:    10,
+				FloorMinCur: "JPY",
+				Data: &openrtb_ext.PriceFloorData{
+					Currency: "JPY",
+				},
+			},
+			fetchFloors: openrtb_ext.PriceFloorRules{},
+			expPrice:    Price{FloorMin: 10, FloorMinCur: "JPY"},
+		},
+		{
+			name: "FloorsMin present in request Floors and fetched floors",
+			reqFloors: openrtb_ext.PriceFloorRules{
+				FloorMin:    10,
+				FloorMinCur: "USD",
+			},
+			fetchFloors: openrtb_ext.PriceFloorRules{
+				FloorMin:    15,
+				FloorMinCur: "USD",
+			},
+			expPrice: Price{FloorMin: 10, FloorMinCur: "USD"},
+		},
+		{
+			name:      "FloorsMin present fetched floors only",
+			reqFloors: openrtb_ext.PriceFloorRules{},
+			fetchFloors: openrtb_ext.PriceFloorRules{
+				FloorMin:    15,
+				FloorMinCur: "EUR",
+			},
+			expPrice: Price{FloorMin: 15, FloorMinCur: "EUR"},
+		},
+		{
+			name: "FloorMinCur present in reqFloors And FloorsMin, FloorMinCur present fetched floors (Same Currency)",
+			reqFloors: openrtb_ext.PriceFloorRules{
+				FloorMinCur: "EUR",
+			},
+			fetchFloors: openrtb_ext.PriceFloorRules{
+				FloorMin:    15,
+				FloorMinCur: "EUR",
+			},
+			expPrice: Price{FloorMin: 15, FloorMinCur: "EUR"},
+		},
+		{
+			name: "FloorMinCur present in reqFloors And FloorsMin, FloorMinCur present fetched floors (Different Currency)",
+			reqFloors: openrtb_ext.PriceFloorRules{
+				FloorMinCur: "USD",
+			},
+			fetchFloors: openrtb_ext.PriceFloorRules{
+				FloorMin:    15,
+				FloorMinCur: "EUR",
+			},
+			expPrice: Price{FloorMin: 16.6667, FloorMinCur: "USD"},
+		},
+		{
+			name: "FloorMin present in reqFloors And FloorMinCur present fetched floors",
+			reqFloors: openrtb_ext.PriceFloorRules{
+				FloorMin: 11,
+			},
+			fetchFloors: openrtb_ext.PriceFloorRules{
+				FloorMinCur: "EUR",
+			},
+			expPrice: Price{FloorMin: 11, FloorMinCur: "EUR"},
+		},
+		{
+			name: "FloorMinCur present in reqFloors And FloorMin present fetched floors",
+			reqFloors: openrtb_ext.PriceFloorRules{
+				FloorMinCur: "INR",
+			},
+			fetchFloors: openrtb_ext.PriceFloorRules{
+				FloorMin: 12,
+			},
+			expPrice: Price{FloorMin: 12, FloorMinCur: "INR"},
+		},
+		{
+			name: "FloorMinCur present in reqFloors And FloorMin present fetched floors",
+			reqFloors: openrtb_ext.PriceFloorRules{
+				FloorMinCur: "INR",
+			},
+			fetchFloors: openrtb_ext.PriceFloorRules{
+				FloorMin: 1,
+				Data:     &openrtb_ext.PriceFloorData{Currency: "USD"},
+			},
+			expPrice: Price{FloorMin: 70, FloorMinCur: "INR"},
+		},
+		{
+			name: "FloorMinCur present in fetched Floors And FloorMin present reqFloors",
+			reqFloors: openrtb_ext.PriceFloorRules{
+				FloorMin: 2,
+			},
+			fetchFloors: openrtb_ext.PriceFloorRules{
+				Data: &openrtb_ext.PriceFloorData{Currency: "USD"},
+			},
+			expPrice: Price{FloorMin: 2, FloorMinCur: "USD"},
+		},
+		{
+			name:      "FloorMinCur and FloorMin present in fetched floors",
+			reqFloors: openrtb_ext.PriceFloorRules{},
+			fetchFloors: openrtb_ext.PriceFloorRules{
+				FloorMin: 12,
+				Data:     &openrtb_ext.PriceFloorData{Currency: "USD"},
+			},
+			expPrice: Price{FloorMin: 12, FloorMinCur: "USD"},
+		},
+		{
+			name: "FloorsMin, FloorCur present in request Floors",
+			reqFloors: openrtb_ext.PriceFloorRules{
+				FloorMin: 11,
+				Data: &openrtb_ext.PriceFloorData{
+					Currency: "EUR",
+				},
+			},
+			fetchFloors: openrtb_ext.PriceFloorRules{},
+			expPrice:    Price{FloorMin: 11, FloorMinCur: "EUR"},
+		},
+		{
+			name:        "Empty reqFloors And Empty fetched floors",
+			reqFloors:   openrtb_ext.PriceFloorRules{},
+			fetchFloors: openrtb_ext.PriceFloorRules{},
+			expPrice:    Price{FloorMin: 0.0, FloorMinCur: ""},
+		},
+	}
+	for _, tc := range tt {
+		t.Run(tc.name, func(t *testing.T) {
+			price := resolveFloorMin(&tc.reqFloors, tc.fetchFloors, getCurrencyRates(rates))
+			if !reflect.DeepEqual(price.FloorMin, tc.expPrice.FloorMin) {
+				t.Errorf("Floor Value error: \nreturn:\t%v\nwant:\t%v", price.FloorMin, tc.expPrice.FloorMin)
+			}
+			if !reflect.DeepEqual(price.FloorMinCur, tc.expPrice.FloorMinCur) {
+				t.Errorf("Floor Currency error: \nreturn:\t%v\nwant:\t%v", price.FloorMinCur, tc.expPrice.FloorMinCur)
+			}
+
+		})
+	}
+}
+
 func getTrue() *bool {
 	trueFlag := true
 	return &trueFlag
 }
 
+type MockFetch struct {
+	FakeFetch func(configs config.AccountPriceFloors) (*openrtb_ext.PriceFloorRules, string)
+}
+
+func (m *MockFetch) Fetch(configs config.AccountPriceFloors) (*openrtb_ext.PriceFloorRules, string) {
+
+	if !configs.UseDynamicData {
+		return nil, openrtb_ext.FetchNone
+	}
+	priceFloors := openrtb_ext.PriceFloorRules{
+		Enabled:            getTrue(),
+		PriceFloorLocation: openrtb_ext.RequestLocation,
+		Enforcement: &openrtb_ext.PriceFloorEnforcement{
+			EnforcePBS:  getTrue(),
+			EnforceRate: 100,
+			FloorDeals:  getTrue(),
+		},
+		Data: &openrtb_ext.PriceFloorData{
+			Currency: "USD",
+			ModelGroups: []openrtb_ext.PriceFloorModelGroup{
+				{
+					ModelVersion: "model from fetched",
+					Currency:     "USD",
+					Values: map[string]float64{
+						"banner|300x600|www.website5.com": 15,
+						"*|*|*":                           25,
+					},
+					Schema: openrtb_ext.PriceFloorSchema{
+						Fields: []string{"mediaType", "size", "domain"},
+					},
+				},
+			},
+		},
+	}
+	return &priceFloors, openrtb_ext.FetchSuccess
+}
+
 func TestResolveFloors(t *testing.T) {
 	rates := map[string]map[string]float64{
 		"USD": {
@@ -401,7 +602,7 @@ func TestResolveFloors(t *testing.T) {
 		},
 	}
 
-	testCases := []struct {
+	tt := []struct {
 		name              string
 		bidRequestWrapper *openrtb_ext.RequestWrapper
 		account           config.Account
@@ -409,6 +610,139 @@ func TestResolveFloors(t *testing.T) {
 		expErr            []error
 		expFloors         *openrtb_ext.PriceFloorRules
 	}{
+		{
+			name: "Dynamic fetch disabled, floors from request selected",
+			bidRequestWrapper: &openrtb_ext.RequestWrapper{
+				BidRequest: &openrtb2.BidRequest{
+					Site: &openrtb2.Site{
+						Publisher: &openrtb2.Publisher{Domain: "www.website.com"},
+					},
+					Imp: []openrtb2.Imp{{ID: "1234", Banner: &openrtb2.Banner{Format: []openrtb2.Format{{W: 300, H: 250}}}}},
+					Ext: json.RawMessage(`{"prebid":{"floors":{"data":{"currency":"USD","modelgroups":[{"modelversion":"model 1 from req","currency":"USD","values":{"banner|300x600|www.website5.com":5,"*|*|*":7},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]},"enabled":true,"enforcement":{"enforcepbs":true,"floordeals":true,"enforcerate":100}}}}`),
+				},
+			},
+			account: config.Account{
+				PriceFloors: config.AccountPriceFloors{
+					Enabled:        true,
+					UseDynamicData: false,
+				},
+			},
+			expFloors: &openrtb_ext.PriceFloorRules{
+				Enabled:            getTrue(),
+				FetchStatus:        openrtb_ext.FetchNone,
+				PriceFloorLocation: openrtb_ext.RequestLocation,
+				Enforcement: &openrtb_ext.PriceFloorEnforcement{
+					EnforcePBS:  getTrue(),
+					EnforceRate: 100,
+					FloorDeals:  getTrue(),
+				},
+				Data: &openrtb_ext.PriceFloorData{
+					Currency: "USD",
+					ModelGroups: []openrtb_ext.PriceFloorModelGroup{
+						{
+							ModelVersion: "model 1 from req",
+							Currency:     "USD",
+							Values: map[string]float64{
+								"banner|300x600|www.website5.com": 5,
+								"*|*|*":                           7,
+							},
+							Schema: openrtb_ext.PriceFloorSchema{
+								Fields:    []string{"mediaType", "size", "domain"},
+								Delimiter: "|",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Dynamic fetch enabled, floors from fetched selected",
+			bidRequestWrapper: &openrtb_ext.RequestWrapper{
+				BidRequest: &openrtb2.BidRequest{
+					Site: &openrtb2.Site{
+						Publisher: &openrtb2.Publisher{Domain: "www.website.com"},
+					},
+					Imp: []openrtb2.Imp{{ID: "1234", Banner: &openrtb2.Banner{Format: []openrtb2.Format{{W: 300, H: 250}}}}},
+				},
+			},
+			account: config.Account{
+				PriceFloors: config.AccountPriceFloors{
+					Enabled:        true,
+					UseDynamicData: true,
+				},
+			},
+			expFloors: &openrtb_ext.PriceFloorRules{
+				Enabled:            getTrue(),
+				FetchStatus:        openrtb_ext.FetchSuccess,
+				PriceFloorLocation: openrtb_ext.FetchLocation,
+				Enforcement: &openrtb_ext.PriceFloorEnforcement{
+					EnforcePBS: getTrue(),
+					FloorDeals: getTrue(),
+				},
+				Data: &openrtb_ext.PriceFloorData{
+					Currency: "USD",
+					ModelGroups: []openrtb_ext.PriceFloorModelGroup{
+						{
+							ModelVersion: "model from fetched",
+							Currency:     "USD",
+							Values: map[string]float64{
+								"banner|300x600|www.website5.com": 15,
+								"*|*|*":                           25,
+							},
+							Schema: openrtb_ext.PriceFloorSchema{
+								Fields: []string{"mediaType", "size", "domain"},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Dynamic fetch enabled, floors formed after merging",
+			bidRequestWrapper: &openrtb_ext.RequestWrapper{
+				BidRequest: &openrtb2.BidRequest{
+					Site: &openrtb2.Site{
+						Publisher: &openrtb2.Publisher{Domain: "www.website.com"},
+					},
+					Imp: []openrtb2.Imp{{ID: "1234", Banner: &openrtb2.Banner{Format: []openrtb2.Format{{W: 300, H: 250}}}}},
+					Ext: json.RawMessage(`{"prebid":{"floors":{"floormincur":"EUR","enabled":true,"data":{"currency":"USD","modelgroups":[{"modelversion":"model 1 from req","currency":"USD","values":{"banner|300x600|www.website5.com":5,"*|*|*":7},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]},"floormin":10.11,"enforcement":{"enforcepbs":true,"floordeals":true,"enforcerate":100}}}}`),
+				},
+			},
+			account: config.Account{
+				PriceFloors: config.AccountPriceFloors{
+					Enabled:        true,
+					UseDynamicData: true,
+				},
+			},
+			expFloors: &openrtb_ext.PriceFloorRules{
+				Enabled:            getTrue(),
+				FloorMin:           10.11,
+				FloorMinCur:        "EUR",
+				FetchStatus:        openrtb_ext.FetchSuccess,
+				PriceFloorLocation: openrtb_ext.FetchLocation,
+				Enforcement: &openrtb_ext.PriceFloorEnforcement{
+					EnforcePBS:  getTrue(),
+					EnforceRate: 100,
+					FloorDeals:  getTrue(),
+				},
+				Data: &openrtb_ext.PriceFloorData{
+					Currency: "USD",
+					ModelGroups: []openrtb_ext.PriceFloorModelGroup{
+						{
+							ModelVersion: "model from fetched",
+							Currency:     "USD",
+							Values: map[string]float64{
+								"banner|300x600|www.website5.com": 15,
+								"*|*|*":                           25,
+							},
+							Schema: openrtb_ext.PriceFloorSchema{
+								Fields: []string{"mediaType", "size", "domain"},
+							},
+						},
+					},
+				},
+			},
+		},
 		{
 			name: "Dynamic fetch disabled, only enforcement object present in req.ext",
 			bidRequestWrapper: &openrtb_ext.RequestWrapper{
@@ -433,14 +767,252 @@ func TestResolveFloors(t *testing.T) {
 					FloorDeals:  getTrue(),
 				},
 				FetchStatus:        openrtb_ext.FetchNone,
+				PriceFloorLocation: openrtb_ext.NoDataLocation,
+			},
+		},
+		{
+			name: "Dynamic fetch enabled, floors from fetched selected and new URL is updated",
+			bidRequestWrapper: &openrtb_ext.RequestWrapper{
+				BidRequest: &openrtb2.BidRequest{
+					Site: &openrtb2.Site{
+						Publisher: &openrtb2.Publisher{Domain: "www.website.com"},
+					},
+					Imp: []openrtb2.Imp{{ID: "1234", Banner: &openrtb2.Banner{Format: []openrtb2.Format{{W: 300, H: 250}}}}},
+					Ext: json.RawMessage(`{"prebid":{"floors":{"floorendpoint":{"url":"http://test.com/floor"},"enabled":true}}}`),
+				},
+			},
+			account: config.Account{
+				PriceFloors: config.AccountPriceFloors{
+					Enabled:        true,
+					UseDynamicData: true,
+				},
+			},
+			expFloors: &openrtb_ext.PriceFloorRules{
+				Enabled:            getTrue(),
+				FetchStatus:        openrtb_ext.FetchSuccess,
+				PriceFloorLocation: openrtb_ext.FetchLocation,
+				Enforcement: &openrtb_ext.PriceFloorEnforcement{
+					EnforcePBS: getTrue(),
+					FloorDeals: getTrue(),
+				},
+				Location: &openrtb_ext.PriceFloorEndpoint{
+					URL: "http://test.com/floor",
+				},
+				Data: &openrtb_ext.PriceFloorData{
+					Currency: "USD",
+					ModelGroups: []openrtb_ext.PriceFloorModelGroup{
+						{
+							ModelVersion: "model from fetched",
+							Currency:     "USD",
+							Values: map[string]float64{
+								"banner|300x600|www.website5.com": 15,
+								"*|*|*":                           25,
+							},
+							Schema: openrtb_ext.PriceFloorSchema{
+								Fields: []string{"mediaType", "size", "domain"},
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+
+	for _, tc := range tt {
+		t.Run(tc.name, func(t *testing.T) {
+			resolvedFloors, _ := resolveFloors(tc.account, tc.bidRequestWrapper, getCurrencyRates(rates), &MockFetch{})
+			if !reflect.DeepEqual(resolvedFloors, tc.expFloors) {
+				t.Errorf("resolveFloors  error: \nreturn:\t%v\nwant:\t%v", printFloors(resolvedFloors), printFloors(tc.expFloors))
+			}
+		})
+	}
+}
+
+type MockFetchDataRate0 struct{}
+
+func (m *MockFetchDataRate0) Fetch(configs config.AccountPriceFloors) (*openrtb_ext.PriceFloorRules, string) {
+
+	if !configs.UseDynamicData {
+		return nil, openrtb_ext.FetchNone
+	}
+	priceFloors := openrtb_ext.PriceFloorRules{
+		Enabled:            getTrue(),
+		PriceFloorLocation: openrtb_ext.RequestLocation,
+		Enforcement: &openrtb_ext.PriceFloorEnforcement{
+			EnforcePBS:  getTrue(),
+			EnforceRate: 100,
+			FloorDeals:  getTrue(),
+		},
+		Data: &openrtb_ext.PriceFloorData{
+			Currency: "USD",
+			ModelGroups: []openrtb_ext.PriceFloorModelGroup{
+				{
+					ModelVersion: "model from fetched",
+					Currency:     "USD",
+					Values: map[string]float64{
+						"banner|300x600|www.website5.com": 15,
+						"*|*|*":                           25,
+					},
+					Schema: openrtb_ext.PriceFloorSchema{
+						Fields: []string{"mediaType", "size", "domain"},
+					},
+				},
+			},
+			UseFetchDataRate: ptrutil.ToPtr(0),
+		},
+	}
+	return &priceFloors, openrtb_ext.FetchSuccess
+}
+
+type MockFetchDataRate100 struct{}
+
+func (m *MockFetchDataRate100) Fetch(configs config.AccountPriceFloors) (*openrtb_ext.PriceFloorRules, string) {
+
+	if !configs.UseDynamicData {
+		return nil, openrtb_ext.FetchNone
+	}
+	priceFloors := openrtb_ext.PriceFloorRules{
+		Enabled:            getTrue(),
+		PriceFloorLocation: openrtb_ext.RequestLocation,
+		Enforcement: &openrtb_ext.PriceFloorEnforcement{
+			EnforcePBS:  getTrue(),
+			EnforceRate: 100,
+			FloorDeals:  getTrue(),
+		},
+		Data: &openrtb_ext.PriceFloorData{
+			Currency: "USD",
+			ModelGroups: []openrtb_ext.PriceFloorModelGroup{
+				{
+					ModelVersion: "model from fetched",
+					Currency:     "USD",
+					Values: map[string]float64{
+						"banner|300x600|www.website5.com": 15,
+						"*|*|*":                           25,
+					},
+					Schema: openrtb_ext.PriceFloorSchema{
+						Fields: []string{"mediaType", "size", "domain"},
+					},
+				},
+			},
+			UseFetchDataRate: ptrutil.ToPtr(100),
+		},
+	}
+	return &priceFloors, openrtb_ext.FetchSuccess
+}
+
+func TestResolveFloorsWithUseDataRate(t *testing.T) {
+	rates := map[string]map[string]float64{
+		"USD": {
+			"INR": 70,
+			"EUR": 0.9,
+			"JPY": 5.09,
+		},
+	}
+
+	testCases := []struct {
+		name              string
+		bidRequestWrapper *openrtb_ext.RequestWrapper
+		account           config.Account
+		conversions       currency.Conversions
+		expErr            []error
+		expFloors         *openrtb_ext.PriceFloorRules
+		fetcher           FloorFetcher
+	}{
+		{
+			name:    "Dynamic fetch enabled, floors from request selected as data rate 0",
+			fetcher: &MockFetchDataRate0{},
+			bidRequestWrapper: &openrtb_ext.RequestWrapper{
+				BidRequest: &openrtb2.BidRequest{
+					Site: &openrtb2.Site{
+						Publisher: &openrtb2.Publisher{Domain: "www.website.com"},
+					},
+					Imp: []openrtb2.Imp{{ID: "1234", Banner: &openrtb2.Banner{Format: []openrtb2.Format{{W: 300, H: 250}}}}},
+					Ext: json.RawMessage(`{"prebid":{"floors":{"data":{"currency":"USD","modelgroups":[{"modelversion":"model 1 from req","currency":"USD","values":{"banner|300x600|www.website5.com":5,"*|*|*":7},"schema":{"fields":["mediaType","size","domain"],"delimiter":"|"}}]},"enabled":true,"enforcement":{"enforcepbs":true,"floordeals":true,"enforcerate":100}}}}`),
+				},
+			},
+			account: config.Account{
+				PriceFloors: config.AccountPriceFloors{
+					Enabled:        true,
+					UseDynamicData: true,
+				},
+			},
+			expFloors: &openrtb_ext.PriceFloorRules{
+				Enabled:            getTrue(),
+				FetchStatus:        openrtb_ext.FetchNone,
 				PriceFloorLocation: openrtb_ext.RequestLocation,
+				Enforcement: &openrtb_ext.PriceFloorEnforcement{
+					EnforcePBS:  getTrue(),
+					FloorDeals:  getTrue(),
+					EnforceRate: 100,
+				},
+				Data: &openrtb_ext.PriceFloorData{
+					Currency: "USD",
+					ModelGroups: []openrtb_ext.PriceFloorModelGroup{
+						{
+							ModelVersion: "model 1 from req",
+							Currency:     "USD",
+							Values: map[string]float64{
+								"banner|300x600|www.website5.com": 5,
+								"*|*|*":                           7,
+							},
+							Schema: openrtb_ext.PriceFloorSchema{
+								Fields:    []string{"mediaType", "size", "domain"},
+								Delimiter: "|",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name:    "Dynamic fetch enabled, floors from fetched selected as data rate is 100",
+			fetcher: &MockFetchDataRate100{},
+			bidRequestWrapper: &openrtb_ext.RequestWrapper{
+				BidRequest: &openrtb2.BidRequest{
+					Site: &openrtb2.Site{
+						Publisher: &openrtb2.Publisher{Domain: "www.website.com"},
+					},
+					Imp: []openrtb2.Imp{{ID: "1234", Banner: &openrtb2.Banner{Format: []openrtb2.Format{{W: 300, H: 250}}}}},
+				},
+			},
+			account: config.Account{
+				PriceFloors: config.AccountPriceFloors{
+					Enabled:        true,
+					UseDynamicData: true,
+				},
+			},
+			expFloors: &openrtb_ext.PriceFloorRules{
+				Enabled:            getTrue(),
+				FetchStatus:        openrtb_ext.FetchSuccess,
+				PriceFloorLocation: openrtb_ext.FetchLocation,
+				Enforcement: &openrtb_ext.PriceFloorEnforcement{
+					EnforcePBS: getTrue(),
+					FloorDeals: getTrue(),
+				},
+				Data: &openrtb_ext.PriceFloorData{
+					Currency: "USD",
+					ModelGroups: []openrtb_ext.PriceFloorModelGroup{
+						{
+							ModelVersion: "model from fetched",
+							Currency:     "USD",
+							Values: map[string]float64{
+								"banner|300x600|www.website5.com": 15,
+								"*|*|*":                           25,
+							},
+							Schema: openrtb_ext.PriceFloorSchema{
+								Fields: []string{"mediaType", "size", "domain"},
+							},
+						},
+					},
+					UseFetchDataRate: ptrutil.ToPtr(100),
+				},
 			},
 		},
 	}
 
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
-			resolvedFloors, _ := resolveFloors(tc.account, tc.bidRequestWrapper, getCurrencyRates(rates))
+			resolvedFloors, _ := resolveFloors(tc.account, tc.bidRequestWrapper, getCurrencyRates(rates), tc.fetcher)
 			assert.Equal(t, resolvedFloors, tc.expFloors, tc.name)
 		})
 	}
@@ -619,7 +1191,7 @@ func TestCreateFloorsFrom(t *testing.T) {
 			},
 			want: &openrtb_ext.PriceFloorRules{
 				FetchStatus:        openrtb_ext.FetchNone,
-				PriceFloorLocation: openrtb_ext.RequestLocation,
+				PriceFloorLocation: openrtb_ext.NoDataLocation,
 				Enforcement: &openrtb_ext.PriceFloorEnforcement{
 					EnforcePBS:  getTrue(),
 					EnforceRate: 100,
diff --git a/floors/rule.go b/floors/rule.go
index f5f74cb6a..785dabb20 100644
--- a/floors/rule.go
+++ b/floors/rule.go
@@ -125,9 +125,13 @@ func updateImpExtWithFloorDetails(imp *openrtb_ext.ImpWrapper, matchedRule strin
 	if extImpPrebid == nil {
 		extImpPrebid = &openrtb_ext.ExtImpPrebid{}
 	}
+	floorRuleValue := 0.0
+	if matchedRule != "" {
+		floorRuleValue = floorRuleVal
+	}
 	extImpPrebid.Floors = &openrtb_ext.ExtImpPrebidFloors{
 		FloorRule:      matchedRule,
-		FloorRuleValue: floorRuleVal,
+		FloorRuleValue: roundToFourDecimals(floorRuleValue),
 		FloorValue:     floorVal,
 	}
 	impExt.SetPrebid(extImpPrebid)
diff --git a/floors/rule_test.go b/floors/rule_test.go
index 27be6ef0d..90d073646 100644
--- a/floors/rule_test.go
+++ b/floors/rule_test.go
@@ -214,11 +214,19 @@ func TestUpdateImpExtWithFloorDetails(t *testing.T) {
 			imp:          &openrtb_ext.ImpWrapper{Imp: &openrtb2.Imp{ID: "1234", Video: &openrtb2.Video{W: 300, H: 250}, Ext: []byte(`{"prebid": {"test": true}}`)}},
 			expected:     []byte(`{"prebid":{"floors":{"floorrule":"banner|www.test.com|*","floorrulevalue":5.5,"floorvalue":15.5}}}`),
 		},
+		{
+			name:         "non matching rule",
+			matchedRule:  "",
+			floorRuleVal: 5.5,
+			floorVal:     15.5,
+			imp:          &openrtb_ext.ImpWrapper{Imp: &openrtb2.Imp{ID: "1234", Video: &openrtb2.Video{W: 300, H: 250}, Ext: []byte(`{"prebid": {"test": true}}`)}},
+			expected:     []byte(`{"prebid":{"floors":{"floorvalue":15.5}}}`),
+		},
 	}
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
 			updateImpExtWithFloorDetails(tc.imp, tc.matchedRule, tc.floorRuleVal, tc.floorVal)
-			_ = tc.imp.RebuildImp()
+			_ = tc.imp.RebuildImpressionExt()
 			if tc.imp.Ext != nil {
 				assert.Equal(t, tc.imp.Ext, tc.expected, tc.name)
 			}
diff --git a/gdpr/vendorlist-fetching.go b/gdpr/vendorlist-fetching.go
index 864cf00f8..3683e5bd0 100644
--- a/gdpr/vendorlist-fetching.go
+++ b/gdpr/vendorlist-fetching.go
@@ -21,6 +21,9 @@ import (
 type saveVendors func(uint16, api.VendorList)
 type VendorListFetcher func(ctx context.Context, id uint16) (vendorlist.VendorList, error)
 
+var cacheSave func(vendorListVersion uint16, list api.VendorList)
+var cacheLoad func(vendorListVersion uint16) api.VendorList
+
 // This file provides the vendorlist-fetching function for Prebid Server.
 //
 // For more info, see https://github.com/prebid/prebid-server/issues/504
@@ -28,7 +31,7 @@ type VendorListFetcher func(ctx context.Context, id uint16) (vendorlist.VendorLi
 // Nothing in this file is exported. Public APIs can be found in gdpr.go
 
 func NewVendorListFetcher(initCtx context.Context, cfg config.GDPR, client *http.Client, urlMaker func(uint16) string) VendorListFetcher {
-	cacheSave, cacheLoad := newVendorListCache()
+	cacheSave, cacheLoad = newVendorListCache()
 
 	preloadContext, cancel := context.WithTimeout(initCtx, cfg.Timeouts.InitTimeout())
 	defer cancel()
diff --git a/gdpr/vendorlist-scheduler.go b/gdpr/vendorlist-scheduler.go
new file mode 100644
index 000000000..faf5b1870
--- /dev/null
+++ b/gdpr/vendorlist-scheduler.go
@@ -0,0 +1,120 @@
+package gdpr
+
+import (
+	"context"
+	"errors"
+	"net/http"
+	"sync"
+	"time"
+
+	"github.com/golang/glog"
+)
+
+type vendorListScheduler struct {
+	ticker    *time.Ticker
+	interval  time.Duration
+	done      chan bool
+	isRunning bool
+	isStarted bool
+	lastRun   time.Time
+
+	httpClient *http.Client
+	timeout    time.Duration
+}
+
+// Only single instance must be created
+var _instance *vendorListScheduler
+var once sync.Once
+
+func GetVendorListScheduler(interval, timeout string, httpClient *http.Client) (*vendorListScheduler, error) {
+	if _instance != nil {
+		return _instance, nil
+	}
+
+	intervalDuration, err := time.ParseDuration(interval)
+	if err != nil {
+		return nil, errors.New("error parsing vendor list scheduler interval: " + err.Error())
+	}
+
+	timeoutDuration, err := time.ParseDuration(timeout)
+	if err != nil {
+		return nil, errors.New("error parsing vendor list scheduler timeout: " + err.Error())
+	}
+
+	if httpClient == nil {
+		return nil, errors.New("http-client can not be nil")
+	}
+
+	once.Do(func() {
+		_instance = &vendorListScheduler{
+			ticker:     nil,
+			interval:   intervalDuration,
+			done:       make(chan bool),
+			httpClient: httpClient,
+			timeout:    timeoutDuration,
+		}
+	})
+
+	return _instance, nil
+}
+
+func (scheduler *vendorListScheduler) Start() {
+	if scheduler == nil || scheduler.isStarted {
+		return
+	}
+
+	scheduler.ticker = time.NewTicker(scheduler.interval)
+	scheduler.isStarted = true
+	go func() {
+		for {
+			select {
+			case <-scheduler.done:
+				scheduler.isRunning = false
+				scheduler.isStarted = false
+				scheduler.ticker = nil
+				return
+			case t := <-scheduler.ticker.C:
+				if !scheduler.isRunning {
+					scheduler.isRunning = true
+
+					glog.Info("Running vendor list scheduler at ", t)
+					scheduler.runLoadCache()
+
+					scheduler.lastRun = t
+					scheduler.isRunning = false
+				}
+			}
+		}
+	}()
+}
+
+func (scheduler *vendorListScheduler) Stop() {
+	if scheduler == nil || !scheduler.isStarted {
+		return
+	}
+	scheduler.ticker.Stop()
+	scheduler.done <- true
+}
+
+func (scheduler *vendorListScheduler) runLoadCache() {
+	if scheduler == nil {
+		return
+	}
+
+	preloadContext, cancel := context.WithTimeout(context.Background(), scheduler.timeout)
+	defer cancel()
+
+	latestVersion := saveOne(preloadContext, scheduler.httpClient, VendorListURLMaker(0), cacheSave)
+
+	// The GVL for TCF2 has no vendors defined in its first version. It's very unlikely to be used, so don't preload it.
+	firstVersionToLoad := uint16(2)
+
+	for i := latestVersion; i >= firstVersionToLoad; i-- {
+		// Check if version is present in the cache
+		if list := cacheLoad(i); list != nil {
+			continue
+		}
+		glog.Infof("Downloading: " + VendorListURLMaker(i))
+		saveOne(preloadContext, scheduler.httpClient, VendorListURLMaker(i), cacheSave)
+	}
+}
diff --git a/gdpr/vendorlist-scheduler_test.go b/gdpr/vendorlist-scheduler_test.go
new file mode 100644
index 000000000..f343a270b
--- /dev/null
+++ b/gdpr/vendorlist-scheduler_test.go
@@ -0,0 +1,194 @@
+package gdpr
+
+import (
+	"context"
+	"net/http"
+	"net/http/httptest"
+	"testing"
+	"time"
+
+	"github.com/prebid/go-gdpr/api"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestGetVendorListScheduler(t *testing.T) {
+	type args struct {
+		interval   string
+		timeout    string
+		httpClient *http.Client
+	}
+	tests := []struct {
+		name    string
+		args    args
+		want    *vendorListScheduler
+		wantErr bool
+	}{
+		{
+			name: "Test singleton",
+			args: args{
+				interval:   "1m",
+				timeout:    "1s",
+				httpClient: http.DefaultClient,
+			},
+			want:    GetExpectedVendorListScheduler("1m", "1s", http.DefaultClient),
+			wantErr: false,
+		},
+		{
+			name: "Test singleton again",
+			args: args{
+				interval:   "2m",
+				timeout:    "2s",
+				httpClient: http.DefaultClient,
+			},
+			want:    GetExpectedVendorListScheduler("2m", "2s", http.DefaultClient),
+			wantErr: false,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			//Mark instance as nil for recreating new instance
+			if tt.want == nil {
+				//_instance = nil
+			}
+
+			got, err := GetVendorListScheduler(tt.args.interval, tt.args.timeout, tt.args.httpClient)
+			if got != tt.want {
+				t.Errorf("GetVendorListScheduler() got = %v, want %v", got, tt.want)
+			}
+			if (err != nil) != tt.wantErr {
+				t.Errorf("GetVendorListScheduler() error = %v, wantErr %v", err, tt.wantErr)
+				return
+			}
+		})
+	}
+}
+
+func GetExpectedVendorListScheduler(interval string, timeout string, httpClient *http.Client) *vendorListScheduler {
+	s, _ := GetVendorListScheduler(interval, timeout, httpClient)
+	return s
+}
+
+func Test_vendorListScheduler_Start(t *testing.T) {
+	type fields struct {
+		scheduler *vendorListScheduler
+	}
+	tests := []struct {
+		name   string
+		fields fields
+	}{
+		{
+			name: "Start test",
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			scheduler, err := GetVendorListScheduler("1m", "30s", http.DefaultClient)
+			assert.Nil(t, err, "error should be nil")
+			assert.NotNil(t, scheduler, "scheduler instance should not be nil")
+
+			scheduler.Start()
+
+			assert.NotNil(t, scheduler.ticker, "ticker should not be nil")
+			assert.True(t, scheduler.isStarted, "isStarted should be true")
+
+			scheduler.Stop()
+		})
+	}
+}
+
+func Test_vendorListScheduler_Stop(t *testing.T) {
+	type fields struct {
+		scheduler *vendorListScheduler
+	}
+	tests := []struct {
+		name   string
+		fields fields
+	}{
+		{
+			name: "Stop test",
+		},
+		{
+			name: "Calling stop again",
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			scheduler, err := GetVendorListScheduler("1m", "30s", http.DefaultClient)
+			assert.Nil(t, err, "error should be nil")
+			assert.NotNil(t, scheduler, "scheduler instance should not be nil")
+
+			scheduler.Start()
+			scheduler.Stop()
+
+			assert.Nil(t, scheduler.ticker, "ticker should not be nil")
+			assert.False(t, scheduler.isStarted, "isStarted should be true")
+		})
+	}
+}
+
+func Test_vendorListScheduler_runLoadCache(t *testing.T) {
+	type fields struct {
+		scheduler *vendorListScheduler
+	}
+	tests := []struct {
+		name   string
+		fields fields
+	}{
+		{
+			name: "runLoadCache caches all files",
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			var err error
+			tt.fields.scheduler, err = GetVendorListScheduler("5m", "5m", http.DefaultClient)
+			assert.Nil(t, err, "error should be nil")
+			assert.False(t, tt.fields.scheduler.isStarted, "VendorListScheduler should not be already running")
+
+			tt.fields.scheduler.timeout = 2 * time.Minute
+
+			mockCacheSave := func(uint16, api.VendorList) {}
+			latestVersion := saveOne(context.Background(), http.DefaultClient, VendorListURLMaker(0), mockCacheSave)
+
+			cacheSave, cacheLoad = newVendorListCache()
+			tt.fields.scheduler.runLoadCache()
+
+			firstVersionToLoad := uint16(2)
+			for i := latestVersion; i >= firstVersionToLoad; i-- {
+				list := cacheLoad(i)
+				assert.NotNil(t, list, "vendor-list file should be present in cache")
+			}
+		})
+	}
+}
+
+func Benchmark_vendorListScheduler_runLoadCache(b *testing.B) {
+	scheduler, err := GetVendorListScheduler("1m", "30m", http.DefaultClient)
+	assert.Nil(b, err, "")
+	assert.NotNil(b, scheduler, "")
+
+	scheduler.timeout = 2 * time.Minute
+
+	for n := 0; n < b.N; n++ {
+		cacheSave, cacheLoad = newVendorListCache()
+		scheduler.runLoadCache()
+	}
+
+}
+
+func Test_vendorListScheduler_cacheFuncs(t *testing.T) {
+	server := httptest.NewServer(http.HandlerFunc(mockServer(serverSettings{
+		vendorListLatestVersion: 1,
+		vendorLists: map[int]string{
+			1: vendorList1,
+			2: vendorList2,
+		},
+	})))
+	defer server.Close()
+	config := testConfig()
+
+	_ = NewVendorListFetcher(context.Background(), config, server.Client(), testURLMaker(server))
+
+	assert.NotNil(t, cacheSave, "Error gdpr.cacheSave nil")
+	assert.NotNil(t, cacheLoad, "Error gdpr.cacheLoad nil")
+}
diff --git a/go.mod b/go.mod
index 14aae8de8..7bc67c28b 100644
--- a/go.mod
+++ b/go.mod
@@ -1,4 +1,4 @@
-module github.com/prebid/prebid-server
+module github.com/PubMatic-OpenWrap/prebid-server
 
 go 1.19
 
@@ -6,31 +6,37 @@ require (
 	github.com/DATA-DOG/go-sqlmock v1.5.0
 	github.com/IABTechLab/adscert v0.34.0
 	github.com/NYTimes/gziphandler v1.1.1
+	github.com/alitto/pond v1.8.2
 	github.com/asaskevich/govalidator v0.0.0-20210307081110-f21760c49a8d
+	github.com/beevik/etree v1.0.2
 	github.com/benbjohnson/clock v1.3.0
 	github.com/buger/jsonparser v1.1.1
 	github.com/chasex/glog v0.0.0-20160217080310-c62392af379c
 	github.com/coocood/freecache v1.2.1
 	github.com/docker/go-units v0.4.0
-	github.com/go-sql-driver/mysql v1.6.0
 	github.com/gofrs/uuid v4.2.0+incompatible
 	github.com/golang/glog v1.0.0
 	github.com/julienschmidt/httprouter v1.3.0
 	github.com/lib/pq v1.10.4
+	github.com/magiconair/properties v1.8.6
 	github.com/mitchellh/copystructure v1.2.0
+	github.com/patrickmn/go-cache v2.1.0+incompatible
 	github.com/pkg/errors v0.9.1
 	github.com/prebid/go-gdpr v1.11.0
 	github.com/prebid/go-gpp v0.1.1
 	github.com/prebid/openrtb/v19 v19.0.0
+	github.com/prebid/prebid-server v0.0.0-00010101000000-000000000000
 	github.com/prometheus/client_golang v1.12.1
 	github.com/prometheus/client_model v0.2.0
 	github.com/rcrowley/go-metrics v0.0.0-20201227073835-cf1acfcdf475
 	github.com/rs/cors v1.8.2
+	github.com/sergi/go-diff v1.3.1 // indirect
 	github.com/spf13/viper v1.12.0
 	github.com/stretchr/testify v1.8.1
 	github.com/vrischmann/go-metrics-influxdb v0.1.1
 	github.com/xeipuuv/gojsonschema v1.2.0
 	github.com/yudai/gojsondiff v1.0.0
+	github.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82 // indirect
 	golang.org/x/net v0.7.0
 	golang.org/x/text v0.7.0
 	google.golang.org/grpc v1.46.2
@@ -38,6 +44,12 @@ require (
 	gopkg.in/yaml.v3 v3.0.1
 )
 
+require (
+	github.com/go-sql-driver/mysql v1.7.0
+	github.com/satori/go.uuid v1.2.0
+	github.com/golang/mock v1.6.0
+)
+
 require (
 	github.com/beorn7/perks v1.0.1 // indirect
 	github.com/cespare/xxhash/v2 v2.1.2 // indirect
@@ -46,7 +58,6 @@ require (
 	github.com/golang/protobuf v1.5.2 // indirect
 	github.com/hashicorp/hcl v1.0.0 // indirect
 	github.com/influxdata/influxdb1-client v0.0.0-20191209144304-8bf82d3c094d // indirect
-	github.com/magiconair/properties v1.8.6 // indirect
 	github.com/matttproud/golang_protobuf_extensions v1.0.1 // indirect
 	github.com/mitchellh/mapstructure v1.5.0 // indirect
 	github.com/mitchellh/reflectwalk v1.0.2 // indirect
@@ -55,7 +66,6 @@ require (
 	github.com/pmezard/go-difflib v1.0.0 // indirect
 	github.com/prometheus/common v0.32.1 // indirect
 	github.com/prometheus/procfs v0.7.3 // indirect
-	github.com/sergi/go-diff v1.2.0 // indirect
 	github.com/spf13/afero v1.8.2 // indirect
 	github.com/spf13/cast v1.5.0 // indirect
 	github.com/spf13/jwalterweatherman v1.1.0 // indirect
@@ -64,7 +74,6 @@ require (
 	github.com/subosito/gotenv v1.3.0 // indirect
 	github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f // indirect
 	github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 // indirect
-	github.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82 // indirect
 	github.com/yudai/pp v2.0.1+incompatible // indirect
 	golang.org/x/crypto v0.0.0-20220411220226-7b82a4e95df4 // indirect
 	golang.org/x/sys v0.5.0 // indirect
@@ -73,3 +82,9 @@ require (
 	gopkg.in/ini.v1 v1.66.4 // indirect
 	gopkg.in/yaml.v2 v2.4.0 // indirect
 )
+
+replace github.com/prebid/prebid-server => ./
+
+replace github.com/prebid/openrtb/v19 => github.com/PubMatic-OpenWrap/prebid-openrtb/v19 v19.0.0-20230517094918-56ce40c97ced
+
+replace github.com/beevik/etree v1.0.2 => github.com/PubMatic-OpenWrap/etree v1.0.2-0.20210129100623-8f30cfecf9f4
diff --git a/go.sum b/go.sum
index 8e64faa69..a1d9bd218 100644
--- a/go.sum
+++ b/go.sum
@@ -59,11 +59,17 @@ github.com/IABTechLab/adscert v0.34.0/go.mod h1:pCLd3Up1kfTrH6kYFUGGeavxIc1f6Tvv
 github.com/NYTimes/gziphandler v1.1.1 h1:ZUDjpQae29j0ryrS0u/B8HZfJBtBQHjqw2rQ2cqUQ3I=
 github.com/NYTimes/gziphandler v1.1.1/go.mod h1:n/CVRwUEOgIxrgPvAQhUUr9oeUtvrhMomdKFjzJNB0c=
 github.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=
+github.com/PubMatic-OpenWrap/etree v1.0.2-0.20210129100623-8f30cfecf9f4 h1:EhiijwjoKTx7FVP8p2wwC/z4n5l4c8l2CGmsrFv2uhI=
+github.com/PubMatic-OpenWrap/etree v1.0.2-0.20210129100623-8f30cfecf9f4/go.mod h1:5Y8qgcuDoy3XXG907UXkGnVTwihF16rXyJa4zRT7hOE=
+github.com/PubMatic-OpenWrap/prebid-openrtb/v19 v19.0.0-20230517094918-56ce40c97ced h1:a4dslMnlBKJTTgBuKKKPT4V43/cespgaVd1y0TO0b4M=
+github.com/PubMatic-OpenWrap/prebid-openrtb/v19 v19.0.0-20230517094918-56ce40c97ced/go.mod h1:jK+/g4Dh5vOnNl0Nh7isbZlub29aJYyrtoBkjmhzTIg=
 github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
 github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
 github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=
 github.com/alecthomas/units v0.0.0-20190717042225-c3de453c63f4/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=
 github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d/go.mod h1:rBZYJk541a8SKzHPHnH3zbiI+7dagKZ0cgpgrD7Fyho=
+github.com/alitto/pond v1.8.2 h1:k0k3GIE7CFLW/kyMJj5DDKLFg1VH09l8skZqg/yJNng=
+github.com/alitto/pond v1.8.2/go.mod h1:CmvIIGd5jKLasGI3D87qDkQxjzChdKMmnXMg3fG6M6Q=
 github.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=
 github.com/armon/circbuf v0.0.0-20150827004946-bbbad097214e/go.mod h1:3U/XgcO3hCbHZ8TKRvWD2dDTCfh9M9ya+I9JpbB7O8o=
 github.com/armon/go-metrics v0.0.0-20180917152333-f0300d1749da/go.mod h1:Q73ZrmVTwzkszR9V5SSuryQ31EELlFMUz1kKyl939pY=
@@ -149,8 +155,8 @@ github.com/go-ldap/ldap v3.0.2+incompatible/go.mod h1:qfd9rJvER9Q0/D/Sqn1DfHRoBp
 github.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=
 github.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=
 github.com/go-logfmt/logfmt v0.5.0/go.mod h1:wCYkCAKZfumFQihp8CzCvQ3paCTfi41vtzG1KdI/P7A=
-github.com/go-sql-driver/mysql v1.6.0 h1:BCTh4TKNUYmOmMUcQ3IipzF5prigylS7XXjEkfCHuOE=
-github.com/go-sql-driver/mysql v1.6.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=
+github.com/go-sql-driver/mysql v1.7.0 h1:ueSltNNllEqE3qcWBTD0iQd3IpL/6U+mJxLkazJ7YPc=
+github.com/go-sql-driver/mysql v1.7.0/go.mod h1:OXbVy3sEdcQ2Doequ6Z5BW6fXNQTmx+9S1MCJN5yJMI=
 github.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=
 github.com/go-task/slim-sprig v0.0.0-20210107165309-348f09dbbbc0/go.mod h1:fyg7847qk6SyHyPtNmDHnmrv/HOrqktSC+C9fM+CJOE=
 github.com/go-test/deep v1.0.2-0.20181118220953-042da051cf31/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3aSFNA=
@@ -174,6 +180,7 @@ github.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt
 github.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
 github.com/golang/mock v1.4.4/go.mod h1:l3mdAwkq5BuhzHwde/uurv3sEJeZMXNpwsxVWU71h+4=
 github.com/golang/mock v1.5.0/go.mod h1:CWnOUgYIOo4TcNZ0wHX3YZCqsaM1I1Jvs6v3mP3KVu8=
+github.com/golang/mock v1.6.0 h1:ErTB+efbowRARo13NNdxyJji2egdxLGQhRaY+DUumQc=
 github.com/golang/mock v1.6.0/go.mod h1:p6yTPP+5HYm5mzsMV8JkE6ZKdX+/wYM6Hr+LicevLPs=
 github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
 github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
@@ -376,6 +383,8 @@ github.com/onsi/gomega v1.11.0 h1:+CqWgvj0OZycCaqclBD1pxKHAU+tOkHmQIWvDHq2aug=
 github.com/onsi/gomega v1.11.0/go.mod h1:azGKhqFUon9Vuj0YmTfLSmx0FUwqXYSTl5re8lQLTUg=
 github.com/pascaldekloe/goe v0.0.0-20180627143212-57f6aae5913c/go.mod h1:lzWF7FIEvWOWxwDKqyGYQf6ZUaNfKdP144TG7ZOy1lc=
 github.com/pascaldekloe/goe v0.1.0/go.mod h1:lzWF7FIEvWOWxwDKqyGYQf6ZUaNfKdP144TG7ZOy1lc=
+github.com/patrickmn/go-cache v2.1.0+incompatible h1:HRMgzkcYKYpi3C8ajMPV8OFXaaRUnok+kx1WdO15EQc=
+github.com/patrickmn/go-cache v2.1.0+incompatible/go.mod h1:3Qf8kWWT7OJRJbdiICTKqZju1ZixQ/KpMGzzAfe6+WQ=
 github.com/pelletier/go-toml v1.9.4/go.mod h1:u1nR/EPcESfeI/szUZKdtJ0xRNbUoANCkoOuaOx1Y+c=
 github.com/pelletier/go-toml v1.9.5 h1:4yBQzkHv+7BHq2PQUZF3Mx0IYxG7LsP222s7Agd3ve8=
 github.com/pelletier/go-toml v1.9.5/go.mod h1:u1nR/EPcESfeI/szUZKdtJ0xRNbUoANCkoOuaOx1Y+c=
@@ -396,8 +405,6 @@ github.com/prebid/go-gdpr v1.11.0 h1:QbMjscuw3Ul0mDVWeMy5tP0Kii6lmTSSVhV6fm8rY9s
 github.com/prebid/go-gdpr v1.11.0/go.mod h1:mPZAdkRxn+iuSjaUuJAi9+0SppBOdM1PCzv/55UH3pY=
 github.com/prebid/go-gpp v0.1.1 h1:uTMJ+eHmKWL9WvDuxFT4LDoOeJW1yOsfWITqi49ZuY0=
 github.com/prebid/go-gpp v0.1.1/go.mod h1:b0TLoVln+HXFD9L9xeimxIH3FN8WDKPJ42auslxEkow=
-github.com/prebid/openrtb/v19 v19.0.0 h1:NA7okrg7KcvL5wEg6yI0mAyujpyfkC8XSQr3h5ocN88=
-github.com/prebid/openrtb/v19 v19.0.0/go.mod h1:jK+/g4Dh5vOnNl0Nh7isbZlub29aJYyrtoBkjmhzTIg=
 github.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=
 github.com/prometheus/client_golang v1.0.0/go.mod h1:db9x61etRT2tGnBNRi70OPL5FsnadC4Ky3P0J6CfImo=
 github.com/prometheus/client_golang v1.4.0/go.mod h1:e9GMxYsXl05ICDXkRhurwBS4Q3OK1iX/F2sw+iXX5zU=
@@ -436,9 +443,11 @@ github.com/ryanuber/columnize v0.0.0-20160712163229-9b3edd62028f/go.mod h1:sm1tb
 github.com/ryanuber/columnize v2.1.0+incompatible/go.mod h1:sm1tb6uqfes/u+d4ooFouqFdy9/2g9QGwK3SQygK0Ts=
 github.com/ryanuber/go-glob v1.0.0/go.mod h1:807d1WSdnB0XRJzKNil9Om6lcp/3a0v4qIHxIXzX/Yc=
 github.com/sagikazarmark/crypt v0.3.0/go.mod h1:uD/D+6UF4SrIR1uGEv7bBNkNqLGqUr43MRiaGWX1Nig=
+github.com/satori/go.uuid v1.2.0 h1:0uYX9dsZ2yD7q2RtLRtPSdGDWzjeM3TbMJP9utgA0ww=
+github.com/satori/go.uuid v1.2.0/go.mod h1:dA0hQrYB0VpLJoorglMZABFdXlWrHn1NEOzdhQKdks0=
 github.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529/go.mod h1:DxrIzT+xaE7yg65j358z/aeFdxmN0P9QXhEzd20vsDc=
-github.com/sergi/go-diff v1.2.0 h1:XU+rvMAioB0UC3q1MFrIQy4Vo5/4VsRDQQXHsEya6xQ=
-github.com/sergi/go-diff v1.2.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=
+github.com/sergi/go-diff v1.3.1 h1:xkr+Oxo4BOQKmkn/B9eMK0g5Kg/983T9DqqPHwYqD+8=
+github.com/sergi/go-diff v1.3.1/go.mod h1:aMJSSKb2lpPvRNec0+w3fl7LP9IOFzdc9Pa4NFbPK1I=
 github.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=
 github.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=
 github.com/sirupsen/logrus v1.6.0/go.mod h1:7uNnSEd1DgxDLC74fIahvMZmmYsHGZGEOFrfsX/uA88=
diff --git a/hooks/empty_plan.go b/hooks/empty_plan.go
index 01e018433..15aa7e697 100644
--- a/hooks/empty_plan.go
+++ b/hooks/empty_plan.go
@@ -17,6 +17,10 @@ func (e EmptyPlanBuilder) PlanForRawAuctionStage(endpoint string, account *confi
 	return nil
 }
 
+func (e EmptyPlanBuilder) PlanForValidationStage(endpoint string, account *config.Account) Plan[hookstage.BeforeValidationRequest] {
+	return nil
+}
+
 func (e EmptyPlanBuilder) PlanForProcessedAuctionStage(endpoint string, account *config.Account) Plan[hookstage.ProcessedAuctionRequest] {
 	return nil
 }
diff --git a/hooks/hookexecution/enricher.go b/hooks/hookexecution/enricher.go
index ef517c508..2978c2195 100644
--- a/hooks/hookexecution/enricher.go
+++ b/hooks/hookexecution/enricher.go
@@ -6,7 +6,6 @@ import (
 	"github.com/buger/jsonparser"
 	"github.com/prebid/openrtb/v19/openrtb2"
 	"github.com/prebid/prebid-server/config"
-	"github.com/prebid/prebid-server/hooks/hookanalytics"
 	jsonpatch "gopkg.in/evanphx/json-patch.v4"
 )
 
@@ -169,7 +168,6 @@ func prepareModulesOutcome(modulesOutcome *ModulesOutcome, groups []GroupOutcome
 		for i, hookOutcome := range group.InvocationResults {
 			if !trace.isVerbose() {
 				group.InvocationResults[i].DebugMessages = nil
-				group.InvocationResults[i].AnalyticsTags = hookanalytics.Analytics{}
 			}
 
 			if isDebugEnabled {
diff --git a/hooks/hookexecution/execution.go b/hooks/hookexecution/execution.go
index 20fa76d8a..18c927896 100644
--- a/hooks/hookexecution/execution.go
+++ b/hooks/hookexecution/execution.go
@@ -190,12 +190,10 @@ func handleHookResponse[P any](
 		ExecutionTime: ExecutionTime{ExecutionTimeMillis: hr.ExecutionTime},
 	}
 
-	switch true {
-	case hr.Err != nil:
+	if hr.Err != nil || hr.Result.Reject {
 		handleHookError(hr, &hookOutcome, metricEngine, labels)
-	case hr.Result.Reject:
 		rejectErr = handleHookReject(ctx, hr, &hookOutcome, metricEngine, labels)
-	default:
+	} else {
 		payload = handleHookMutations(payload, hr, &hookOutcome, metricEngine, labels)
 	}
 
diff --git a/hooks/hookexecution/executor.go b/hooks/hookexecution/executor.go
index ce5166307..155bc450f 100644
--- a/hooks/hookexecution/executor.go
+++ b/hooks/hookexecution/executor.go
@@ -38,6 +38,7 @@ type StageExecutor interface {
 	ExecuteRawBidderResponseStage(response *adapters.BidderResponse, bidder string) *RejectError
 	ExecuteAllProcessedBidResponsesStage(adapterBids map[openrtb_ext.BidderName]*entities.PbsOrtbSeatBid)
 	ExecuteAuctionResponseStage(response *openrtb2.BidResponse)
+	ExecuteBeforeRequestValidationStage(req *openrtb2.BidRequest) *RejectError
 }
 
 type HookStageExecutor interface {
@@ -139,6 +140,35 @@ func (e *hookExecutor) ExecuteRawAuctionStage(requestBody []byte) ([]byte, *Reje
 	return payload, reject
 }
 
+func (e *hookExecutor) ExecuteBeforeRequestValidationStage(request *openrtb2.BidRequest) *RejectError {
+	plan := e.planBuilder.PlanForValidationStage(e.endpoint, e.account)
+	if len(plan) == 0 {
+		return nil
+	}
+
+	handler := func(
+		ctx context.Context,
+		moduleCtx hookstage.ModuleInvocationContext,
+		hook hookstage.BeforeValidationRequest,
+		payload hookstage.BeforeValidationRequestPayload,
+	) (hookstage.HookResult[hookstage.BeforeValidationRequestPayload], error) {
+		return hook.HandleBeforeValidationHook(ctx, moduleCtx, payload)
+	}
+
+	stageName := hooks.StageBeforeValidationRequest.String()
+	executionCtx := e.newContext(stageName)
+	payload := hookstage.BeforeValidationRequestPayload{BidRequest: request}
+
+	outcome, _, contexts, reject := executeStage(executionCtx, plan, payload, handler, e.metricEngine)
+	outcome.Entity = entityAuctionRequest
+	outcome.Stage = stageName
+
+	e.saveModuleContexts(contexts)
+	e.pushStageOutcome(outcome)
+
+	return reject
+}
+
 func (e *hookExecutor) ExecuteProcessedAuctionStage(request *openrtb_ext.RequestWrapper) error {
 	plan := e.planBuilder.PlanForProcessedAuctionStage(e.endpoint, e.account)
 	if len(plan) == 0 {
@@ -344,3 +374,7 @@ func (executor EmptyHookExecutor) ExecuteAllProcessedBidResponsesStage(_ map[ope
 }
 
 func (executor EmptyHookExecutor) ExecuteAuctionResponseStage(_ *openrtb2.BidResponse) {}
+
+func (executor *EmptyHookExecutor) ExecuteBeforeRequestValidationStage(_ *openrtb2.BidRequest) *RejectError {
+	return nil
+}
diff --git a/hooks/hookexecution/executor_test.go b/hooks/hookexecution/executor_test.go
index 68b990bb5..a936d05fa 100644
--- a/hooks/hookexecution/executor_test.go
+++ b/hooks/hookexecution/executor_test.go
@@ -2083,6 +2083,17 @@ func (e TestApplyHookMutationsBuilder) PlanForRawAuctionStage(_ string, _ *confi
 	}
 }
 
+func (e TestApplyHookMutationsBuilder) PlanForValidationStage(_ string, _ *config.Account) hooks.Plan[hookstage.BeforeValidationRequest] {
+	return hooks.Plan[hookstage.BeforeValidationRequest]{
+		hooks.Group[hookstage.BeforeValidationRequest]{
+			Timeout: 10 * time.Millisecond,
+			Hooks: []hooks.HookWrapper[hookstage.BeforeValidationRequest]{
+				{Module: "foobar", Code: "foo", Hook: mockUpdateBidRequestHook{}},
+			},
+		},
+	}
+}
+
 func (e TestApplyHookMutationsBuilder) PlanForProcessedAuctionStage(_ string, _ *config.Account) hooks.Plan[hookstage.ProcessedAuctionRequest] {
 	return hooks.Plan[hookstage.ProcessedAuctionRequest]{
 		hooks.Group[hookstage.ProcessedAuctionRequest]{
diff --git a/hooks/hookexecution/mocks_test.go b/hooks/hookexecution/mocks_test.go
index e8670ff89..52b30c848 100644
--- a/hooks/hookexecution/mocks_test.go
+++ b/hooks/hookexecution/mocks_test.go
@@ -299,6 +299,23 @@ func (h mockFailedMutationHook) HandleAllProcessedBidResponsesHook(_ context.Con
 	return hookstage.HookResult[hookstage.AllProcessedBidResponsesPayload]{ChangeSet: changeSet}, nil
 }
 
+func (e mockUpdateBidRequestHook) HandleBeforeValidationHook(_ context.Context, _ hookstage.ModuleInvocationContext, _ hookstage.BeforeValidationRequestPayload) (hookstage.HookResult[hookstage.BeforeValidationRequestPayload], error) {
+	c := hookstage.ChangeSet[hookstage.BeforeValidationRequestPayload]{}
+	// c.AddMutation(
+	// 	func(payload hookstage.BeforeValidationRequestPayload) (hookstage.BeforeValidationRequestPayload, error) {
+	// 		payload.BidRequest.User.Yob = 2000
+	// 		return payload, nil
+	// 	}, hookstage.MutationUpdate, "bidRequest", "user.yob",
+	// ).AddMutation(
+	// 	func(payload hookstage.ProcessedAuctionRequestPayload) (hookstage.ProcessedAuctionRequestPayload, error) {
+	// 		payload.BidRequest.User.Consent = "true"
+	// 		return payload, nil
+	// 	}, hookstage.MutationUpdate, "bidRequest", "user.consent",
+	// )
+
+	return hookstage.HookResult[hookstage.BeforeValidationRequestPayload]{ChangeSet: c}, nil
+}
+
 type mockUpdateBidRequestHook struct{}
 
 func (e mockUpdateBidRequestHook) HandleProcessedAuctionHook(_ context.Context, _ hookstage.ModuleInvocationContext, _ hookstage.ProcessedAuctionRequestPayload) (hookstage.HookResult[hookstage.ProcessedAuctionRequestPayload], error) {
diff --git a/hooks/hookexecution/test/complete-stage-outcomes/expected-basic-debug-response.json b/hooks/hookexecution/test/complete-stage-outcomes/expected-basic-debug-response.json
index 1f52d1878..591f6e914 100644
--- a/hooks/hookexecution/test/complete-stage-outcomes/expected-basic-debug-response.json
+++ b/hooks/hookexecution/test/complete-stage-outcomes/expected-basic-debug-response.json
@@ -47,7 +47,32 @@
                         "status": "success",
                         "action": "update",
                         "execution_time_millis": 200,
-                        "analytics_tags": {},
+                        "analytics_tags": {
+                          "activities": [
+                            {
+                              "name": "device-id",
+                              "status": "success",
+                              "results": [
+                                {
+                                  "status": "success-allow",
+                                  "values": {
+                                    "foo": "bar"
+                                  },
+                                  "appliedto": {
+                                    "impids": [
+                                      "impId1"
+                                    ],
+                                    "request": true
+                                  }
+                                }
+                              ]
+                            },
+                            {
+                              "name": "define-blocks",
+                              "status": "error"
+                            }
+                          ]
+                        },
                         "message": ""
                       },
                       {
diff --git a/hooks/hookstage/processedbeforerequestvalidation.go b/hooks/hookstage/processedbeforerequestvalidation.go
new file mode 100644
index 000000000..219d0eed5
--- /dev/null
+++ b/hooks/hookstage/processedbeforerequestvalidation.go
@@ -0,0 +1,22 @@
+package hookstage
+
+import (
+	"context"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+)
+
+// BeforeValidationRequest
+type BeforeValidationRequest interface {
+	HandleBeforeValidationHook(
+		context.Context,
+		ModuleInvocationContext,
+		BeforeValidationRequestPayload,
+	) (HookResult[BeforeValidationRequestPayload], error)
+}
+
+// ProcessedBeforeRequestValidationPayload consists of the openrtb2.BidRequest object.
+// Hooks are allowed to modify openrtb2.BidRequest using mutations.
+type BeforeValidationRequestPayload struct {
+	BidRequest *openrtb2.BidRequest
+}
diff --git a/hooks/plan.go b/hooks/plan.go
index c6fda9597..d83db2f77 100644
--- a/hooks/plan.go
+++ b/hooks/plan.go
@@ -14,6 +14,7 @@ type Stage string
 const (
 	StageEntrypoint               Stage = "entrypoint"
 	StageRawAuctionRequest        Stage = "raw_auction_request"
+	StageBeforeValidationRequest  Stage = "before_validation_request"
 	StageProcessedAuctionRequest  Stage = "processed_auction_request"
 	StageBidderRequest            Stage = "bidder_request"
 	StageRawBidderResponse        Stage = "raw_bidder_response"
@@ -36,6 +37,7 @@ func (s Stage) IsRejectable() bool {
 type ExecutionPlanBuilder interface {
 	PlanForEntrypointStage(endpoint string) Plan[hookstage.Entrypoint]
 	PlanForRawAuctionStage(endpoint string, account *config.Account) Plan[hookstage.RawAuctionRequest]
+	PlanForValidationStage(endpoint string, account *config.Account) Plan[hookstage.BeforeValidationRequest]
 	PlanForProcessedAuctionStage(endpoint string, account *config.Account) Plan[hookstage.ProcessedAuctionRequest]
 	PlanForBidderRequestStage(endpoint string, account *config.Account) Plan[hookstage.BidderRequest]
 	PlanForRawBidderResponseStage(endpoint string, account *config.Account) Plan[hookstage.RawBidderResponse]
@@ -106,6 +108,16 @@ func (p PlanBuilder) PlanForRawAuctionStage(endpoint string, account *config.Acc
 	)
 }
 
+func (p PlanBuilder) PlanForValidationStage(endpoint string, account *config.Account) Plan[hookstage.BeforeValidationRequest] {
+	return getMergedPlan(
+		p.hooks,
+		account,
+		endpoint,
+		StageBeforeValidationRequest,
+		p.repo.GetBeforeValidationHook,
+	)
+}
+
 func (p PlanBuilder) PlanForProcessedAuctionStage(endpoint string, account *config.Account) Plan[hookstage.ProcessedAuctionRequest] {
 	return getMergedPlan(
 		p.hooks,
diff --git a/hooks/plan_test.go b/hooks/plan_test.go
index 5d2a504f0..f5e063452 100644
--- a/hooks/plan_test.go
+++ b/hooks/plan_test.go
@@ -821,6 +821,16 @@ func (f fakeRawAuctionHook) HandleRawAuctionHook(
 	return hookstage.HookResult[hookstage.RawAuctionRequestPayload]{}, nil
 }
 
+type fakeBeforeValidationHooks struct{}
+
+func (f fakeBeforeValidationHooks) HandleBeforeValidationHook(
+	_ context.Context,
+	_ hookstage.ModuleInvocationContext,
+	_ hookstage.BeforeValidationRequestPayload,
+) (hookstage.HookResult[hookstage.BeforeValidationRequestPayload], error) {
+	return hookstage.HookResult[hookstage.BeforeValidationRequestPayload]{}, nil
+}
+
 type fakeProcessedAuctionHook struct{}
 
 func (f fakeProcessedAuctionHook) HandleProcessedAuctionHook(
diff --git a/hooks/repo.go b/hooks/repo.go
index 033a3f8f7..c34413e88 100644
--- a/hooks/repo.go
+++ b/hooks/repo.go
@@ -2,6 +2,7 @@ package hooks
 
 import (
 	"fmt"
+
 	"github.com/prebid/prebid-server/hooks/hookstage"
 )
 
@@ -15,6 +16,7 @@ import (
 type HookRepository interface {
 	GetEntrypointHook(id string) (hookstage.Entrypoint, bool)
 	GetRawAuctionHook(id string) (hookstage.RawAuctionRequest, bool)
+	GetBeforeValidationHook(id string) (hookstage.BeforeValidationRequest, bool)
 	GetProcessedAuctionHook(id string) (hookstage.ProcessedAuctionRequest, bool)
 	GetBidderRequestHook(id string) (hookstage.BidderRequest, bool)
 	GetRawBidderResponseHook(id string) (hookstage.RawBidderResponse, bool)
@@ -43,6 +45,7 @@ func NewHookRepository(hooks map[string]interface{}) (HookRepository, error) {
 type hookRepository struct {
 	entrypointHooks              map[string]hookstage.Entrypoint
 	rawAuctionHooks              map[string]hookstage.RawAuctionRequest
+	beforeValidationHooks        map[string]hookstage.BeforeValidationRequest
 	processedAuctionHooks        map[string]hookstage.ProcessedAuctionRequest
 	bidderRequestHooks           map[string]hookstage.BidderRequest
 	rawBidderResponseHooks       map[string]hookstage.RawBidderResponse
@@ -58,6 +61,10 @@ func (r *hookRepository) GetRawAuctionHook(id string) (hookstage.RawAuctionReque
 	return getHook(r.rawAuctionHooks, id)
 }
 
+func (r *hookRepository) GetBeforeValidationHook(id string) (hookstage.BeforeValidationRequest, bool) {
+	return getHook(r.beforeValidationHooks, id)
+}
+
 func (r *hookRepository) GetProcessedAuctionHook(id string) (hookstage.ProcessedAuctionRequest, bool) {
 	return getHook(r.processedAuctionHooks, id)
 }
@@ -96,6 +103,13 @@ func (r *hookRepository) add(id string, hook interface{}) error {
 		}
 	}
 
+	if h, ok := hook.(hookstage.BeforeValidationRequest); ok {
+		hasAnyHooks = true
+		if r.beforeValidationHooks, err = addHook(r.beforeValidationHooks, h, id); err != nil {
+			return err
+		}
+	}
+
 	if h, ok := hook.(hookstage.ProcessedAuctionRequest); ok {
 		hasAnyHooks = true
 		if r.processedAuctionHooks, err = addHook(r.processedAuctionHooks, h, id); err != nil {
diff --git a/main.go b/main.go
index a83266665..0a95c4ffe 100644
--- a/main.go
+++ b/main.go
@@ -1,4 +1,4 @@
-package main
+package main_ow
 
 import (
 	"flag"
@@ -23,7 +23,8 @@ func init() {
 	rand.Seed(time.Now().UnixNano())
 }
 
-func main() {
+// TODO: revert this after PBS-OpenWrap module
+func Main() {
 	flag.Parse() // required for glog flags and testing package flags
 
 	bidderInfoPath, err := filepath.Abs(infoDirectory)
@@ -54,7 +55,7 @@ func main() {
 	}
 }
 
-const configFileName = "pbs"
+const configFileName = "pbs.yaml"
 const infoDirectory = "./static/bidder-info"
 
 func loadConfig(bidderInfos config.BidderInfos) (*config.Configuration, error) {
diff --git a/main_test.go b/main_test.go
index 25812ba96..13be3a2b4 100644
--- a/main_test.go
+++ b/main_test.go
@@ -1,4 +1,4 @@
-package main
+package main_ow
 
 import (
 	"os"
diff --git a/metrics/config/metrics.go b/metrics/config/metrics.go
index 0cf0533d1..5aa776a8b 100644
--- a/metrics/config/metrics.go
+++ b/metrics/config/metrics.go
@@ -128,6 +128,20 @@ func (me *MultiMetricsEngine) RecordAdapterRequest(labels metrics.AdapterLabels)
 	}
 }
 
+// RecordRejectedBidsForBidder across all engines
+func (me *MultiMetricsEngine) RecordRejectedBidsForBidder(bidder openrtb_ext.BidderName) {
+	for _, thisME := range *me {
+		thisME.RecordRejectedBidsForBidder(bidder)
+	}
+}
+
+// RecordDynamicFetchFailure across all engines
+func (me *MultiMetricsEngine) RecordDynamicFetchFailure(pubId, code string) {
+	for _, thisME := range *me {
+		thisME.RecordDynamicFetchFailure(pubId, code)
+	}
+}
+
 // Keeps track of created and reused connections to adapter bidders and the time from the
 // connection request, to the connection creation, or reuse from the pool across all engines
 func (me *MultiMetricsEngine) RecordAdapterConnections(bidderName openrtb_ext.BidderName, connWasReused bool, connWaitTime time.Duration) {
@@ -143,9 +157,9 @@ func (me *MultiMetricsEngine) RecordDNSTime(dnsLookupTime time.Duration) {
 	}
 }
 
-func (me *MultiMetricsEngine) RecordTLSHandshakeTime(tlsHandshakeTime time.Duration) {
+func (me *MultiMetricsEngine) RecordTLSHandshakeTime(adapterName openrtb_ext.BidderName, tlsHandshakeTime time.Duration) {
 	for _, thisME := range *me {
-		thisME.RecordTLSHandshakeTime(tlsHandshakeTime)
+		thisME.RecordTLSHandshakeTime(adapterName, tlsHandshakeTime)
 	}
 }
 
@@ -260,6 +274,52 @@ func (me *MultiMetricsEngine) RecordRequestPrivacy(privacy metrics.PrivacyLabels
 	}
 }
 
+// RecordAdapterDuplicateBidID across all engines
+func (me *MultiMetricsEngine) RecordAdapterDuplicateBidID(adaptor string, collisions int) {
+	for _, thisME := range *me {
+		thisME.RecordAdapterDuplicateBidID(adaptor, collisions)
+	}
+}
+
+// RecordRequestHavingDuplicateBidID across all engines
+func (me *MultiMetricsEngine) RecordRequestHavingDuplicateBidID() {
+	for _, thisME := range *me {
+		thisME.RecordRequestHavingDuplicateBidID()
+	}
+}
+
+// RecordPodImpGenTime across all engines
+func (me *MultiMetricsEngine) RecordPodImpGenTime(labels metrics.PodLabels, startTime time.Time) {
+	for _, thisME := range *me {
+		thisME.RecordPodImpGenTime(labels, startTime)
+	}
+}
+
+// RecordRejectedBidsForBidder as a noop
+func (me *NilMetricsEngine) RecordRejectedBidsForBidder(bidder openrtb_ext.BidderName) {
+}
+
+// RecordPodCombGenTime as a noop
+func (me *MultiMetricsEngine) RecordPodCombGenTime(labels metrics.PodLabels, elapsedTime time.Duration) {
+	for _, thisME := range *me {
+		thisME.RecordPodCombGenTime(labels, elapsedTime)
+	}
+}
+
+// RecordPodCompititveExclusionTime as a noop
+func (me *MultiMetricsEngine) RecordPodCompititveExclusionTime(labels metrics.PodLabels, elapsedTime time.Duration) {
+	for _, thisME := range *me {
+		thisME.RecordPodCompititveExclusionTime(labels, elapsedTime)
+	}
+}
+
+// RecordAdapterVideoBidDuration as a noop
+func (me *MultiMetricsEngine) RecordAdapterVideoBidDuration(labels metrics.AdapterLabels, videoBidDuration int) {
+	for _, thisME := range *me {
+		thisME.RecordAdapterVideoBidDuration(labels, videoBidDuration)
+	}
+}
+
 // RecordAdapterGDPRRequestBlocked across all engines
 func (me *MultiMetricsEngine) RecordAdapterGDPRRequestBlocked(adapter openrtb_ext.BidderName) {
 	for _, thisME := range *me {
@@ -280,6 +340,18 @@ func (me *MultiMetricsEngine) RecordStoredResponse(pubId string) {
 	}
 }
 
+func (me *MultiMetricsEngine) RecordRejectedBidsForAccount(pubId string) {
+	for _, thisME := range *me {
+		thisME.RecordRejectedBidsForAccount(pubId)
+	}
+}
+
+func (me *MultiMetricsEngine) RecordFloorsRequestForAccount(pubId string) {
+	for _, thisME := range *me {
+		thisME.RecordFloorsRequestForAccount(pubId)
+	}
+}
+
 func (me *MultiMetricsEngine) RecordAdsCertReq(success bool) {
 	for _, thisME := range *me {
 		thisME.RecordAdsCertReq(success)
@@ -378,11 +450,48 @@ func (me *MultiMetricsEngine) RecordModuleTimeout(labels metrics.ModuleLabels) {
 		thisME.RecordModuleTimeout(labels)
 	}
 }
+func (me *MultiMetricsEngine) RecordRejectedBids(pubid, bidder, code string) {
+	for _, thisME := range *me {
+		thisME.RecordRejectedBids(pubid, bidder, code)
+	}
+}
+
+func (me *MultiMetricsEngine) RecordBids(pubid, profileid, biddder, deal string) {
+	for _, thisME := range *me {
+		thisME.RecordBids(pubid, profileid, biddder, deal)
+	}
+}
+func (me *MultiMetricsEngine) RecordHttpCounter() {
+}
+
+func (me *MultiMetricsEngine) RecordVastVersion(biddder, vastVersion string) {
+	for _, thisME := range *me {
+		thisME.RecordVastVersion(biddder, vastVersion)
+	}
+}
 
 // NilMetricsEngine implements the MetricsEngine interface where no metrics are actually captured. This is
 // used if no metric backend is configured and also for tests.
 type NilMetricsEngine struct{}
 
+func (me *NilMetricsEngine) RecordAdapterDuplicateBidID(adaptor string, collisions int) {
+}
+
+func (me *NilMetricsEngine) RecordRequestHavingDuplicateBidID() {
+}
+
+func (me *NilMetricsEngine) RecordPodImpGenTime(labels metrics.PodLabels, startTime time.Time) {
+}
+
+func (me *NilMetricsEngine) RecordPodCombGenTime(labels metrics.PodLabels, elapsedTime time.Duration) {
+}
+
+func (me *NilMetricsEngine) RecordPodCompititveExclusionTime(labels metrics.PodLabels, elapsedTime time.Duration) {
+}
+
+func (me *NilMetricsEngine) RecordAdapterVideoBidDuration(labels metrics.AdapterLabels, videoBidDuration int) {
+}
+
 // RecordRequest as a noop
 func (me *NilMetricsEngine) RecordRequest(labels metrics.Labels) {
 }
@@ -428,7 +537,7 @@ func (me *NilMetricsEngine) RecordDNSTime(dnsLookupTime time.Duration) {
 }
 
 // RecordTLSHandshakeTime as a noop
-func (me *NilMetricsEngine) RecordTLSHandshakeTime(tlsHandshakeTime time.Duration) {
+func (me *NilMetricsEngine) RecordTLSHandshakeTime(adapterName openrtb_ext.BidderName, tlsHandshakeTime time.Duration) {
 }
 
 // RecordBidderServerResponseTime as a noop
@@ -506,6 +615,12 @@ func (me *NilMetricsEngine) RecordDebugRequest(debugEnabled bool, pubId string)
 func (me *NilMetricsEngine) RecordStoredResponse(pubId string) {
 }
 
+func (me *NilMetricsEngine) RecordRejectedBidsForAccount(pubId string) {
+}
+
+func (me *NilMetricsEngine) RecordFloorsRequestForAccount(pubId string) {
+}
+
 func (me *NilMetricsEngine) RecordAdsCertReq(success bool) {
 
 }
@@ -558,3 +673,22 @@ func (me *NilMetricsEngine) RecordModuleExecutionError(labels metrics.ModuleLabe
 
 func (me *NilMetricsEngine) RecordModuleTimeout(labels metrics.ModuleLabels) {
 }
+
+// RecordDynamicFetchFailure as a noop
+func (me *NilMetricsEngine) RecordDynamicFetchFailure(pubId, code string) {
+}
+
+// RecordRejectedBids as a noop
+func (me *NilMetricsEngine) RecordRejectedBids(pubid, bidder, code string) {
+}
+
+// RecordBids as a noop
+func (me *NilMetricsEngine) RecordBids(pubid, profileid, biddder, deal string) {
+}
+
+// RecordVastVersion as a noop
+func (me *NilMetricsEngine) RecordVastVersion(biddder, vastVersion string) {
+}
+
+func (m *NilMetricsEngine) RecordHttpCounter() {
+}
diff --git a/metrics/go_metrics.go b/metrics/go_metrics.go
index 64726e30f..38ea8156f 100644
--- a/metrics/go_metrics.go
+++ b/metrics/go_metrics.go
@@ -35,14 +35,15 @@ type Metrics struct {
 	StoredResponsesMeter           metrics.Meter
 
 	// Metrics for OpenRTB requests specifically
-	RequestStatuses       map[RequestType]map[RequestStatus]metrics.Meter
-	AmpNoCookieMeter      metrics.Meter
-	CookieSyncMeter       metrics.Meter
-	CookieSyncStatusMeter map[CookieSyncStatus]metrics.Meter
-	SyncerRequestsMeter   map[string]map[SyncerCookieSyncStatus]metrics.Meter
-	SetUidMeter           metrics.Meter
-	SetUidStatusMeter     map[SetUidStatus]metrics.Meter
-	SyncerSetsMeter       map[string]map[SyncerSetUidStatus]metrics.Meter
+	RequestStatuses        map[RequestType]map[RequestStatus]metrics.Meter
+	AmpNoCookieMeter       metrics.Meter
+	CookieSyncMeter        metrics.Meter
+	CookieSyncStatusMeter  map[CookieSyncStatus]metrics.Meter
+	SyncerRequestsMeter    map[string]map[SyncerCookieSyncStatus]metrics.Meter
+	SetUidMeter            metrics.Meter
+	SetUidStatusMeter      map[SetUidStatus]metrics.Meter
+	SyncerSetsMeter        map[string]map[SyncerSetUidStatus]metrics.Meter
+	FloorRejectedBidsMeter map[openrtb_ext.BidderName]metrics.Meter
 
 	// Media types found in the "imp" JSON object
 	ImpsTypeBanner metrics.Meter
@@ -61,6 +62,20 @@ type Metrics struct {
 	PrivacyLMTRequest        metrics.Meter
 	PrivacyTCFRequestVersion map[TCFVersionValue]metrics.Meter
 
+	// Ad Pod Metrics
+
+	// podImpGenTimer indicates time taken by impression generator
+	// algorithm to generate impressions for given ad pod request
+	podImpGenTimer metrics.Timer
+
+	// podImpGenTimer indicates time taken by combination generator
+	// algorithm to generate combination based on bid response and ad pod request
+	podCombGenTimer metrics.Timer
+
+	// podCompExclTimer indicates time taken by compititve exclusion
+	// algorithm to generate final pod response based on bid response and ad pod request
+	podCompExclTimer metrics.Timer
+
 	AdapterMetrics map[openrtb_ext.BidderName]*AdapterMetrics
 	// Don't export accountMetrics because we need helper functions here to insure its properly populated dynamically
 	accountMetrics        map[string]*accountMetrics
@@ -103,6 +118,7 @@ type AdapterMetrics struct {
 
 	BidValidationSecureMarkupErrorMeter metrics.Meter
 	BidValidationSecureMarkupWarnMeter  metrics.Meter
+	TLSHandshakeTimer                   metrics.Timer
 }
 
 type MarkupDeliveryMetrics struct {
@@ -111,10 +127,12 @@ type MarkupDeliveryMetrics struct {
 }
 
 type accountMetrics struct {
-	requestMeter      metrics.Meter
-	debugRequestMeter metrics.Meter
-	bidsReceivedMeter metrics.Meter
-	priceHistogram    metrics.Histogram
+	requestMeter       metrics.Meter
+	rejecteBidMeter    metrics.Meter
+	floorsRequestMeter metrics.Meter
+	debugRequestMeter  metrics.Meter
+	bidsReceivedMeter  metrics.Meter
+	priceHistogram     metrics.Histogram
 	// store account by adapter metrics. Type is map[PBSBidder.BidderCode]
 	adapterMetrics       map[openrtb_ext.BidderName]*AdapterMetrics
 	moduleMetrics        map[string]*ModuleMetrics
@@ -139,6 +157,7 @@ type accountMetrics struct {
 	channelEnabledGDPRMeter                  metrics.Meter
 	channelEnabledCCPAMeter                  metrics.Meter
 	accountDeprecationSummaryMeter           metrics.Meter
+	dynamicFetchFailureMeter                 metrics.Meter
 }
 
 type ModuleMetrics struct {
@@ -175,7 +194,6 @@ func NewBlankMetrics(registry metrics.Registry, exchanges []openrtb_ext.BidderNa
 		NoCookieMeter:                  blankMeter,
 		RequestTimer:                   blankTimer,
 		DNSLookupTimer:                 blankTimer,
-		TLSHandshakeTimer:              blankTimer,
 		RequestsQueueTimer:             make(map[RequestType]map[bool]metrics.Timer),
 		PrebidCacheRequestTimerSuccess: blankTimer,
 		PrebidCacheRequestTimerError:   blankTimer,
@@ -192,6 +210,7 @@ func NewBlankMetrics(registry metrics.Registry, exchanges []openrtb_ext.BidderNa
 		SetUidStatusMeter:              make(map[SetUidStatus]metrics.Meter),
 		SyncerSetsMeter:                make(map[string]map[SyncerSetUidStatus]metrics.Meter),
 		StoredResponsesMeter:           blankMeter,
+		FloorRejectedBidsMeter:         make(map[openrtb_ext.BidderName]metrics.Meter),
 
 		ImpsTypeBanner: blankMeter,
 		ImpsTypeVideo:  blankMeter,
@@ -302,7 +321,6 @@ func NewMetrics(registry metrics.Registry, exchanges []openrtb_ext.BidderName, d
 	newMetrics.DebugRequestMeter = metrics.GetOrRegisterMeter("debug_requests", registry)
 	newMetrics.RequestTimer = metrics.GetOrRegisterTimer("request_time", registry)
 	newMetrics.DNSLookupTimer = metrics.GetOrRegisterTimer("dns_lookup_time", registry)
-	newMetrics.TLSHandshakeTimer = metrics.GetOrRegisterTimer("tls_handshake_time", registry)
 	newMetrics.PrebidCacheRequestTimerSuccess = metrics.GetOrRegisterTimer("prebid_cache_request_time.ok", registry)
 	newMetrics.PrebidCacheRequestTimerError = metrics.GetOrRegisterTimer("prebid_cache_request_time.err", registry)
 	newMetrics.StoredResponsesMeter = metrics.GetOrRegisterMeter("stored_responses", registry)
@@ -346,6 +364,7 @@ func NewMetrics(registry metrics.Registry, exchanges []openrtb_ext.BidderName, d
 
 	for _, a := range exchanges {
 		registerAdapterMetrics(registry, "adapter", string(a), newMetrics.AdapterMetrics[a])
+		newMetrics.FloorRejectedBidsMeter[a] = metrics.GetOrRegisterMeter(fmt.Sprintf("rejected_bid.%s", a), registry)
 	}
 
 	for typ, statusMap := range newMetrics.RequestStatuses {
@@ -412,6 +431,7 @@ func makeBlankAdapterMetrics(disabledMetrics config.DisabledMetrics) *AdapterMet
 		newAdapter.ConnCreated = metrics.NilCounter{}
 		newAdapter.ConnReused = metrics.NilCounter{}
 		newAdapter.ConnWaitTime = &metrics.NilTimer{}
+		newAdapter.TLSHandshakeTimer = &metrics.NilTimer{}
 	}
 	if !disabledMetrics.AdapterGDPRRequestBlocked {
 		newAdapter.GDPRRequestBlocked = blankMeter
@@ -484,6 +504,7 @@ func registerAdapterMetrics(registry metrics.Registry, adapterOrAccount string,
 	am.ConnCreated = metrics.GetOrRegisterCounter(fmt.Sprintf("%[1]s.%[2]s.connections_created", adapterOrAccount, exchange), registry)
 	am.ConnReused = metrics.GetOrRegisterCounter(fmt.Sprintf("%[1]s.%[2]s.connections_reused", adapterOrAccount, exchange), registry)
 	am.ConnWaitTime = metrics.GetOrRegisterTimer(fmt.Sprintf("%[1]s.%[2]s.connection_wait_time", adapterOrAccount, exchange), registry)
+	am.TLSHandshakeTimer = metrics.GetOrRegisterTimer(fmt.Sprintf("%[1]s.%[2]s.tls_handshake_time", adapterOrAccount, exchange), registry)
 	for err := range am.ErrorMeters {
 		am.ErrorMeters[err] = metrics.GetOrRegisterMeter(fmt.Sprintf("%s.%s.requests.%s", adapterOrAccount, exchange, err), registry)
 	}
@@ -556,6 +577,9 @@ func (me *Metrics) getAccountMetrics(id string) *accountMetrics {
 	}
 	am = &accountMetrics{}
 	am.requestMeter = metrics.GetOrRegisterMeter(fmt.Sprintf("account.%s.requests", id), me.MetricsRegistry)
+	am.rejecteBidMeter = metrics.GetOrRegisterMeter(fmt.Sprintf("account.%s.rejected_bidrequests", id), me.MetricsRegistry)
+	am.dynamicFetchFailureMeter = metrics.GetOrRegisterMeter(fmt.Sprintf("account.%s.floors_account_fetch_err", id), me.MetricsRegistry)
+	am.floorsRequestMeter = metrics.GetOrRegisterMeter(fmt.Sprintf("account.%s.bidfloor_requests", id), me.MetricsRegistry)
 	am.debugRequestMeter = metrics.GetOrRegisterMeter(fmt.Sprintf("account.%s.debug_requests", id), me.MetricsRegistry)
 	am.bidsReceivedMeter = metrics.GetOrRegisterMeter(fmt.Sprintf("account.%s.bids_received", id), me.MetricsRegistry)
 	am.priceHistogram = metrics.GetOrRegisterHistogram(fmt.Sprintf("account.%s.prices", id), me.MetricsRegistry, metrics.NewExpDecaySample(1028, 0.015))
@@ -689,6 +713,24 @@ func (me *Metrics) RecordStoredResponse(pubId string) {
 	}
 }
 
+func (me *Metrics) RecordRejectedBidsForAccount(pubId string) {
+	if pubId != PublisherUnknown {
+		me.getAccountMetrics(pubId).rejecteBidMeter.Mark(1)
+	}
+}
+
+// RecordDynamicFetchFailure implements a part of the MetricsEngine interface. Records dynamic fetch failure
+func (me *Metrics) RecordDynamicFetchFailure(pubId, code string) {
+	if pubId != PublisherUnknown {
+		me.getAccountMetrics(pubId).dynamicFetchFailureMeter.Mark(1)
+	}
+}
+func (me *Metrics) RecordFloorsRequestForAccount(pubId string) {
+	if pubId != PublisherUnknown {
+		me.getAccountMetrics(pubId).floorsRequestMeter.Mark(1)
+	}
+}
+
 func (me *Metrics) RecordImps(labels ImpLabels) {
 	me.ImpMeter.Mark(int64(1))
 	if labels.BannerImps {
@@ -810,8 +852,18 @@ func (me *Metrics) RecordDNSTime(dnsLookupTime time.Duration) {
 	me.DNSLookupTimer.Update(dnsLookupTime)
 }
 
-func (me *Metrics) RecordTLSHandshakeTime(tlsHandshakeTime time.Duration) {
-	me.TLSHandshakeTimer.Update(tlsHandshakeTime)
+func (me *Metrics) RecordTLSHandshakeTime(adapterName openrtb_ext.BidderName, tlsHandshakeTime time.Duration) {
+	if me.MetricsDisabled.AdapterConnectionMetrics {
+		return
+	}
+
+	am, ok := me.AdapterMetrics[adapterName]
+	if !ok {
+		glog.Errorf("Trying to log adapter TLS Handshake metrics for %s: adapter not found", string(adapterName))
+		return
+	}
+
+	am.TLSHandshakeTimer.Update(tlsHandshakeTime)
 }
 
 func (me *Metrics) RecordBidderServerResponseTime(bidderServerResponseTime time.Duration) {
@@ -860,6 +912,13 @@ func (me *Metrics) RecordAdapterPrice(labels AdapterLabels, cpm float64) {
 	}
 }
 
+// RecordRejectedBidsForBidder implements a part of the MetricsEngine interface. Records rejected bids from bidder
+func (me *Metrics) RecordRejectedBidsForBidder(bidder openrtb_ext.BidderName) {
+	if keyMeter, exists := me.FloorRejectedBidsMeter[bidder]; exists {
+		keyMeter.Mark(1)
+	}
+}
+
 // RecordAdapterTime implements a part of the MetricsEngine interface. Records the adapter response time
 func (me *Metrics) RecordAdapterTime(labels AdapterLabels, length time.Duration) {
 	am, ok := me.AdapterMetrics[labels.Adapter]
diff --git a/metrics/go_metrics_ow.go b/metrics/go_metrics_ow.go
new file mode 100644
index 000000000..2ef51f2f1
--- /dev/null
+++ b/metrics/go_metrics_ow.go
@@ -0,0 +1,42 @@
+package metrics
+
+import "time"
+
+// RecordAdapterDuplicateBidID as noop
+func (me *Metrics) RecordAdapterDuplicateBidID(adaptor string, collisions int) {
+}
+
+// RecordRequestHavingDuplicateBidID as noop
+func (me *Metrics) RecordRequestHavingDuplicateBidID() {
+}
+
+// RecordPodImpGenTime as a noop
+func (me *Metrics) RecordPodImpGenTime(labels PodLabels, startTime time.Time) {
+}
+
+// RecordPodCombGenTime as a noop
+func (me *Metrics) RecordPodCombGenTime(labels PodLabels, elapsedTime time.Duration) {
+}
+
+// RecordPodCompititveExclusionTime as a noop
+func (me *Metrics) RecordPodCompititveExclusionTime(labels PodLabels, elapsedTime time.Duration) {
+}
+
+// RecordAdapterVideoBidDuration as a noop
+func (me *Metrics) RecordAdapterVideoBidDuration(labels AdapterLabels, videoBidDuration int) {
+}
+
+// RecordAdapterVideoBidDuration as a noop
+func (me *Metrics) RecordRejectedBids(pubid, biddder, code string) {
+}
+
+// RecordBids as a noop
+func (me *Metrics) RecordBids(pubid, profileid, biddder, deal string) {
+}
+
+// RecordVastVersion as a noop
+func (me *Metrics) RecordVastVersion(biddder, vastVersion string) {
+}
+
+func (me *Metrics) RecordHttpCounter() {
+}
diff --git a/metrics/go_metrics_test.go b/metrics/go_metrics_test.go
index 1ab22ac1a..61e5ba8b9 100644
--- a/metrics/go_metrics_test.go
+++ b/metrics/go_metrics_test.go
@@ -395,29 +395,51 @@ func TestRecordDNSTime(t *testing.T) {
 }
 
 func TestRecordTLSHandshakeTime(t *testing.T) {
+	type testIn struct {
+		adapterName           openrtb_ext.BidderName
+		tLSHandshakeDuration  time.Duration
+		adapterMetricsEnabled bool
+	}
+
+	type testOut struct {
+		expectedDuration time.Duration
+	}
+
 	testCases := []struct {
-		description          string
-		tLSHandshakeDuration time.Duration
-		expectedDuration     time.Duration
+		description string
+		in          testIn
+		out         testOut
 	}{
 		{
-			description:          "Five second TLS handshake time",
-			tLSHandshakeDuration: time.Second * 5,
-			expectedDuration:     time.Second * 5,
+			description: "Five second TLS handshake time",
+			in: testIn{
+				adapterName:           openrtb_ext.BidderAppnexus,
+				tLSHandshakeDuration:  time.Second * 5,
+				adapterMetricsEnabled: true,
+			},
+			out: testOut{
+				expectedDuration: time.Second * 5,
+			},
 		},
 		{
-			description:          "Zero TLS handshake time",
-			tLSHandshakeDuration: time.Duration(0),
-			expectedDuration:     time.Duration(0),
+			description: "Zero TLS handshake time",
+			in: testIn{
+				adapterName:           openrtb_ext.BidderAppnexus,
+				tLSHandshakeDuration:  time.Duration(0),
+				adapterMetricsEnabled: true,
+			},
+			out: testOut{
+				expectedDuration: time.Duration(0),
+			},
 		},
 	}
 	for _, test := range testCases {
 		registry := metrics.NewRegistry()
 		m := NewMetrics(registry, []openrtb_ext.BidderName{openrtb_ext.BidderAppnexus}, config.DisabledMetrics{AccountAdapterDetails: true}, nil, nil)
 
-		m.RecordTLSHandshakeTime(test.tLSHandshakeDuration)
+		m.RecordTLSHandshakeTime(test.in.adapterName, test.in.tLSHandshakeDuration)
 
-		assert.Equal(t, test.expectedDuration.Nanoseconds(), m.TLSHandshakeTimer.Sum(), test.description)
+		assert.Equal(t, test.out.expectedDuration.Nanoseconds(), m.AdapterMetrics[openrtb_ext.BidderAppnexus].TLSHandshakeTimer.Sum(), test.description)
 	}
 }
 
@@ -889,6 +911,25 @@ func TestRecordSyncerSet(t *testing.T) {
 	assert.Equal(t, m.SyncerSetsMeter["foo"][SyncerSetUidCleared].Count(), int64(1))
 }
 
+func TestRecordRejectedBidsForBidders(t *testing.T) {
+	registry := metrics.NewRegistry()
+	m := NewMetrics(registry, []openrtb_ext.BidderName{openrtb_ext.BidderAppnexus, openrtb_ext.BidderRubicon, openrtb_ext.BidderPubmatic}, config.DisabledMetrics{}, nil, nil)
+
+	m.RecordFloorsRequestForAccount("1234")
+
+	m.RecordRejectedBidsForAccount("1234")
+	m.RecordRejectedBidsForBidder(openrtb_ext.BidderAppnexus)
+	m.RecordRejectedBidsForBidder(openrtb_ext.BidderAppnexus)
+
+	m.RecordRejectedBidsForBidder(openrtb_ext.BidderRubicon)
+
+	assert.Equal(t, m.accountMetrics["1234"].floorsRequestMeter.Count(), int64(1))
+	assert.Equal(t, m.accountMetrics["1234"].rejecteBidMeter.Count(), int64(1))
+	assert.Equal(t, m.FloorRejectedBidsMeter[openrtb_ext.BidderAppnexus].Count(), int64(2))
+	assert.Equal(t, m.FloorRejectedBidsMeter[openrtb_ext.BidderRubicon].Count(), int64(1))
+	assert.Equal(t, m.FloorRejectedBidsMeter[openrtb_ext.BidderPubmatic].Count(), int64(0))
+}
+
 func TestStoredResponses(t *testing.T) {
 	testCases := []struct {
 		description                           string
diff --git a/metrics/metrics.go b/metrics/metrics.go
index 214e7c1dd..664be4dd2 100644
--- a/metrics/metrics.go
+++ b/metrics/metrics.go
@@ -54,6 +54,15 @@ type ImpLabels struct {
 	NativeImps bool
 }
 
+// PodLabels defines metric labels describing algorithm type
+// and other labels as per scenario
+type PodLabels struct {
+	AlgorithmName    string // AlgorithmName which is used for generating impressions
+	NoOfImpressions  *int   // NoOfImpressions represents number of impressions generated
+	NoOfCombinations *int   // NoOfCombinations represents number of combinations generated
+	NoOfResponseBids *int   // NoOfResponseBids represents number of bids responded (including bids with similar duration)
+}
+
 // RequestLabels defines metric labels describing the result of a network request.
 type RequestLabels struct {
 	RequestStatus RequestStatus
@@ -429,7 +438,7 @@ type MetricsEngine interface {
 	RecordAdapterRequest(labels AdapterLabels)
 	RecordAdapterConnections(adapterName openrtb_ext.BidderName, connWasReused bool, connWaitTime time.Duration)
 	RecordDNSTime(dnsLookupTime time.Duration)
-	RecordTLSHandshakeTime(tlsHandshakeTime time.Duration)
+	RecordTLSHandshakeTime(adapterName openrtb_ext.BidderName, tlsHandshakeTime time.Duration)
 	RecordBidderServerResponseTime(bidderServerResponseTime time.Duration)
 	RecordAdapterPanic(labels AdapterLabels)
 	RecordAdapterBidReceived(labels AdapterLabels, bidType openrtb_ext.BidType, hasAdm bool)
@@ -439,6 +448,9 @@ type MetricsEngine interface {
 	RecordSyncerRequest(key string, status SyncerCookieSyncStatus)
 	RecordSetUid(status SetUidStatus)
 	RecordSyncerSet(key string, status SyncerSetUidStatus)
+	RecordRejectedBidsForBidder(bidder openrtb_ext.BidderName)
+	RecordRejectedBidsForAccount(pubId string)
+	RecordFloorsRequestForAccount(pubId string)
 	RecordStoredReqCacheResult(cacheResult CacheResult, inc int)
 	RecordStoredImpCacheResult(cacheResult CacheResult, inc int)
 	RecordAccountCacheResult(cacheResult CacheResult, inc int)
@@ -468,4 +480,52 @@ type MetricsEngine interface {
 	RecordAccountGDPRChannelEnabledWarning(account string)
 	RecordAccountCCPAChannelEnabledWarning(account string)
 	RecordAccountUpgradeStatus(account string)
+
+	// RecordAdapterDuplicateBidID captures the  bid.ID collisions when adaptor
+	// gives the bid response with multiple bids containing  same bid.ID
+	RecordAdapterDuplicateBidID(adaptor string, collisions int)
+
+	// RecordRequestHavingDuplicateBidID keeps track off how many request got bid.id collision
+	// detected
+	RecordRequestHavingDuplicateBidID()
+
+	// ad pod specific metrics
+
+	// RecordPodImpGenTime records number of impressions generated and time taken
+	// by underneath algorithm to generate them
+	// labels accept name of the algorithm and no of impressions generated
+	// startTime indicates the time at which algorithm started
+	// This function will take care of computing the elpased time
+	RecordPodImpGenTime(labels PodLabels, startTime time.Time)
+
+	// RecordPodCombGenTime records number of combinations generated and time taken
+	// by underneath algorithm to generate them
+	// labels accept name of the algorithm and no of combinations generated
+	// elapsedTime indicates the time taken by combination generator to compute all requested combinations
+	// This function will take care of computing the elpased time
+	RecordPodCombGenTime(labels PodLabels, elapsedTime time.Duration)
+
+	// RecordPodCompititveExclusionTime records time take by competitive exclusion
+	// to compute the final Ad pod Response.
+	// labels accept name of the algorithm and no of combinations evaluated, total bids
+	// elapsedTime indicates the time taken by competitive exclusion to form final ad pod response using combinations and exclusion algorithm
+	// This function will take care of computing the elpased time
+	RecordPodCompititveExclusionTime(labels PodLabels, elapsedTime time.Duration)
+
+	//RecordAdapterVideoBidDuration records actual ad duration returned by the bidder
+	RecordAdapterVideoBidDuration(labels AdapterLabels, videoBidDuration int)
+
+	//RecordDynamicFetchFailure records the dynamic fetch failure labeled by pubid and reason code
+	RecordDynamicFetchFailure(pubId, code string)
+
+	//RecordRejectedBids records the rejected bids labeled by pubid, bidder and reason code
+	RecordRejectedBids(pubid, bidder, code string)
+
+	//RecordBids records the bidder deal bids labeled by pubid, profile, bidder and deal
+	RecordBids(pubid, profileid, bidder, deal string)
+
+	//RecordVastVersion record the count of vast version labelled by bidder and vast version
+	RecordVastVersion(coreBidder, vastVersion string)
+
+	RecordHttpCounter()
 }
diff --git a/metrics/metrics_mock.go b/metrics/metrics_mock.go
index 0ce238c58..727f59cc4 100644
--- a/metrics/metrics_mock.go
+++ b/metrics/metrics_mock.go
@@ -67,8 +67,8 @@ func (me *MetricsEngineMock) RecordDNSTime(dnsLookupTime time.Duration) {
 	me.Called(dnsLookupTime)
 }
 
-func (me *MetricsEngineMock) RecordTLSHandshakeTime(tlsHandshakeTime time.Duration) {
-	me.Called(tlsHandshakeTime)
+func (me *MetricsEngineMock) RecordTLSHandshakeTime(bidderName openrtb_ext.BidderName, tlsHandshakeTime time.Duration) {
+	me.Called(bidderName, tlsHandshakeTime)
 }
 
 // RecordBidderServerResponseTime mock
@@ -116,6 +116,10 @@ func (me *MetricsEngineMock) RecordSyncerSet(key string, status SyncerSetUidStat
 	me.Called(key, status)
 }
 
+func (me *MetricsEngineMock) RecordRejectedBidsForBidder(bidder openrtb_ext.BidderName) {
+	me.Called(bidder)
+}
+
 // RecordStoredReqCacheResult mock
 func (me *MetricsEngineMock) RecordStoredReqCacheResult(cacheResult CacheResult, inc int) {
 	me.Called(cacheResult, inc)
@@ -165,6 +169,14 @@ func (me *MetricsEngineMock) RecordStoredResponse(pubId string) {
 	me.Called(pubId)
 }
 
+func (me *MetricsEngineMock) RecordRejectedBidsForAccount(pubId string) {
+	me.Called(pubId)
+}
+
+func (me *MetricsEngineMock) RecordFloorsRequestForAccount(pubId string) {
+	me.Called(pubId)
+}
+
 func (me *MetricsEngineMock) RecordAdsCertReq(success bool) {
 	me.Called(success)
 }
@@ -232,3 +244,14 @@ func (me *MetricsEngineMock) RecordAccountCCPAChannelEnabledWarning(account stri
 func (me *MetricsEngineMock) RecordAccountUpgradeStatus(account string) {
 	me.Called(account)
 }
+
+func (me *MetricsEngineMock) RecordRejectedBids(pubid, bidder, code string) {
+	me.Called(pubid, bidder, code)
+}
+
+func (me *MetricsEngineMock) RecordDynamicFetchFailure(pubId, code string) {
+	me.Called(pubId, code)
+}
+
+func (me *MetricsEngineMock) RecordHttpCounter() {
+}
diff --git a/metrics/metrics_mock_ow.go b/metrics/metrics_mock_ow.go
new file mode 100644
index 000000000..40e70c0d7
--- /dev/null
+++ b/metrics/metrics_mock_ow.go
@@ -0,0 +1,42 @@
+package metrics
+
+import "time"
+
+// RecordAdapterDuplicateBidID mock
+func (me *MetricsEngineMock) RecordAdapterDuplicateBidID(adaptor string, collisions int) {
+	me.Called(adaptor, collisions)
+}
+
+// RecordRequestHavingDuplicateBidID mock
+func (me *MetricsEngineMock) RecordRequestHavingDuplicateBidID() {
+	me.Called()
+}
+
+// RecordPodImpGenTime mock
+func (me *MetricsEngineMock) RecordPodImpGenTime(labels PodLabels, startTime time.Time) {
+	me.Called(labels, startTime)
+}
+
+// RecordPodCombGenTime mock
+func (me *MetricsEngineMock) RecordPodCombGenTime(labels PodLabels, elapsedTime time.Duration) {
+	me.Called(labels, elapsedTime)
+}
+
+// RecordPodCompititveExclusionTime mock
+func (me *MetricsEngineMock) RecordPodCompititveExclusionTime(labels PodLabels, elapsedTime time.Duration) {
+	me.Called(labels, elapsedTime)
+}
+
+// RecordAdapterVideoBidDuration mock
+func (me *MetricsEngineMock) RecordAdapterVideoBidDuration(labels AdapterLabels, videoBidDuration int) {
+	me.Called(labels, videoBidDuration)
+}
+
+func (me *MetricsEngineMock) RecordBids(pubid, profileid, biddder, deal string) {
+	me.Called(pubid, profileid, biddder, deal)
+}
+
+// RecordVastVersion mock
+func (me *MetricsEngineMock) RecordVastVersion(coreBidder, vastVersion string) {
+	me.Called(coreBidder, vastVersion)
+}
diff --git a/metrics/prometheus/prometheus.go b/metrics/prometheus/prometheus.go
index eb387789e..ee2fbdd1e 100644
--- a/metrics/prometheus/prometheus.go
+++ b/metrics/prometheus/prometheus.go
@@ -45,7 +45,6 @@ type Metrics struct {
 	storedVideoErrors            *prometheus.CounterVec
 	timeoutNotifications         *prometheus.CounterVec
 	dnsLookupTimer               prometheus.Histogram
-	tlsHandhakeTimer             prometheus.Histogram
 	privacyCCPA                  *prometheus.CounterVec
 	privacyCOPPA                 *prometheus.CounterVec
 	privacyLMT                   *prometheus.CounterVec
@@ -57,6 +56,8 @@ type Metrics struct {
 	adsCertSignTimer             prometheus.Histogram
 	bidderServerResponseTimer    prometheus.Histogram
 
+	requestsDuplicateBidIDCounter prometheus.Counter // total request having duplicate bid.id for given bidder
+
 	// Adapter Metrics
 	adapterBids                           *prometheus.CounterVec
 	adapterErrors                         *prometheus.CounterVec
@@ -74,10 +75,25 @@ type Metrics struct {
 	adapterBidResponseSecureMarkupError   *prometheus.CounterVec
 	adapterBidResponseSecureMarkupWarn    *prometheus.CounterVec
 
+	adapterDuplicateBidIDCounter *prometheus.CounterVec
+	adapterVideoBidDuration      *prometheus.HistogramVec
+	tlsHandhakeTimer             *prometheus.HistogramVec
+
 	// Syncer Metrics
 	syncerRequests *prometheus.CounterVec
 	syncerSets     *prometheus.CounterVec
 
+	// Rejected Bids
+	rejectedBids *prometheus.CounterVec
+	bids         *prometheus.CounterVec
+	vastVersion  *prometheus.CounterVec
+	//rejectedBids         *prometheus.CounterVec
+	accountRejectedBid   *prometheus.CounterVec
+	accountFloorsRequest *prometheus.CounterVec
+
+	//Dynamic Fetch Failure
+	dynamicFetchFailure *prometheus.CounterVec
+
 	// Account Metrics
 	accountRequests                       *prometheus.CounterVec
 	accountDebugRequests                  *prometheus.CounterVec
@@ -111,8 +127,23 @@ type Metrics struct {
 	moduleSuccessRejects  map[string]*prometheus.CounterVec
 	moduleExecutionErrors map[string]*prometheus.CounterVec
 	moduleTimeouts        map[string]*prometheus.CounterVec
+	// Ad Pod Metrics
+
+	// podImpGenTimer indicates time taken by impression generator
+	// algorithm to generate impressions for given ad pod request
+	podImpGenTimer *prometheus.HistogramVec
+
+	// podImpGenTimer indicates time taken by combination generator
+	// algorithm to generate combination based on bid response and ad pod request
+	podCombGenTimer *prometheus.HistogramVec
+
+	// podCompExclTimer indicates time taken by compititve exclusion
+	// algorithm to generate final pod response based on bid response and ad pod request
+	podCompExclTimer *prometheus.HistogramVec
 
 	metricsDisabled config.DisabledMetrics
+
+	httpCounter prometheus.Counter
 }
 
 const (
@@ -162,6 +193,14 @@ const (
 	requestFailed     = "failed"
 )
 
+// pod specific constants
+const (
+	podAlgorithm         = "algorithm"
+	podNoOfImpressions   = "no_of_impressions"
+	podTotalCombinations = "total_combinations"
+	podNoOfResponseBids  = "no_of_response_bids"
+)
+
 const (
 	sourceLabel   = "source"
 	sourceRequest = "request"
@@ -318,10 +357,15 @@ func NewMetrics(cfg config.PrometheusMetrics, disabledMetrics config.DisabledMet
 		"Seconds to resolve DNS",
 		standardTimeBuckets)
 
-	metrics.tlsHandhakeTimer = newHistogram(cfg, reg,
-		"tls_handshake_time",
-		"Seconds to perform TLS Handshake",
-		standardTimeBuckets)
+	// metrics.tlsHandhakeTimer = newHistogram(cfg, reg,
+	// 	"tls_handshake_time",
+	// 	"Seconds to perform TLS Handshake",
+	// 	standardTimeBuckets)
+
+	metrics.bids = newCounter(cfg, reg,
+		"bids",
+		"Count of no of bids by publisher id, profile, bidder and deal",
+		[]string{pubIDLabel, profileLabel, bidderLabel, dealLabel})
 
 	metrics.privacyCCPA = newCounter(cfg, reg,
 		"privacy_ccpa",
@@ -407,6 +451,12 @@ func NewMetrics(cfg config.PrometheusMetrics, disabledMetrics config.DisabledMet
 			"Seconds from when the connection was requested until it is either created or reused",
 			[]string{adapterLabel},
 			standardTimeBuckets)
+
+		metrics.tlsHandhakeTimer = newHistogramVec(cfg, reg,
+			"tls_handshake_time",
+			"Seconds to perform TLS Handshake",
+			[]string{adapterLabel},
+			standardTimeBuckets)
 	}
 
 	metrics.adapterBidResponseValidationSizeError = newCounter(cfg, reg,
@@ -497,6 +547,31 @@ func NewMetrics(cfg config.PrometheusMetrics, disabledMetrics config.DisabledMet
 		"Count of total requests to Prebid Server that have stored responses labled by account",
 		[]string{accountLabel})
 
+	metrics.accountRejectedBid = newCounter(cfg, reg,
+		"floors_account_rejected_bid_requests",
+		"Count of total requests to Prebid Server that have rejected bids due to floors enfocement labled by account",
+		[]string{accountLabel})
+
+	metrics.accountFloorsRequest = newCounter(cfg, reg,
+		"floors_account_requests",
+		"Count of total requests to Prebid Server that have non-zero imp.bidfloor labled by account",
+		[]string{accountLabel})
+
+	metrics.rejectedBids = newCounter(cfg, reg,
+		"rejected_bids",
+		"Count of rejected bids by publisher id, bidder and rejection reason code",
+		[]string{pubIDLabel, bidderLabel, codeLabel})
+
+	metrics.vastVersion = newCounter(cfg, reg,
+		"vast_version",
+		"Count of vast version by bidder and vast version",
+		[]string{adapterLabel, versionLabel})
+
+	metrics.dynamicFetchFailure = newCounter(cfg, reg,
+		"floors_account_fetch_err",
+		"Count of failures in case of dynamic fetch labeled by account",
+		[]string{codeLabel, accountLabel})
+
 	metrics.adsCertSignTimer = newHistogram(cfg, reg,
 		"ads_cert_sign_time",
 		"Seconds to generate an AdsCert header",
@@ -564,8 +639,47 @@ func NewMetrics(cfg config.PrometheusMetrics, disabledMetrics config.DisabledMet
 	metrics.Registerer = prometheus.WrapRegistererWithPrefix(metricsPrefix, reg)
 	metrics.Registerer.MustRegister(promCollector.NewGoCollector())
 
+	metrics.adapterDuplicateBidIDCounter = newCounter(cfg, reg,
+		"duplicate_bid_ids",
+		"Number of collisions observed for given adaptor",
+		[]string{adapterLabel})
+
+	metrics.requestsDuplicateBidIDCounter = newCounterWithoutLabels(cfg, reg,
+		"requests_having_duplicate_bid_ids",
+		"Count of number of request where bid collision is detected.")
+
+	// adpod specific metrics
+	metrics.podImpGenTimer = newHistogramVec(cfg, reg,
+		"impr_gen",
+		"Time taken by Ad Pod Impression Generator in seconds", []string{podAlgorithm, podNoOfImpressions},
+		// 200 µS, 250 µS, 275 µS, 300 µS
+		//[]float64{0.000200000, 0.000250000, 0.000275000, 0.000300000})
+		// 100 µS, 200 µS, 300 µS, 400 µS, 500 µS,  600 µS,
+		[]float64{0.000100000, 0.000200000, 0.000300000, 0.000400000, 0.000500000, 0.000600000})
+
+	metrics.podCombGenTimer = newHistogramVec(cfg, reg,
+		"comb_gen",
+		"Time taken by Ad Pod Combination Generator in seconds", []string{podAlgorithm, podTotalCombinations},
+		// 200 µS, 250 µS, 275 µS, 300 µS
+		//[]float64{0.000200000, 0.000250000, 0.000275000, 0.000300000})
+		[]float64{0.000100000, 0.000200000, 0.000300000, 0.000400000, 0.000500000, 0.000600000})
+
+	metrics.podCompExclTimer = newHistogramVec(cfg, reg,
+		"comp_excl",
+		"Time taken by Ad Pod Compititve Exclusion in seconds", []string{podAlgorithm, podNoOfResponseBids},
+		// 200 µS, 250 µS, 275 µS, 300 µS
+		//[]float64{0.000200000, 0.000250000, 0.000275000, 0.000300000})
+		[]float64{0.000100000, 0.000200000, 0.000300000, 0.000400000, 0.000500000, 0.000600000})
+
+	metrics.adapterVideoBidDuration = newHistogramVec(cfg, reg,
+		"adapter_vidbid_dur",
+		"Video Ad durations returned by the bidder", []string{adapterLabel},
+		[]float64{4, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 120})
+
 	preloadLabelValues(&metrics, syncerKeys, moduleStageNames)
 
+	metrics.httpCounter = newHttpCounter(cfg, reg)
+
 	return &metrics
 }
 
@@ -622,6 +736,7 @@ func createModulesMetrics(cfg config.PrometheusMetrics, registry *prometheus.Reg
 			fmt.Sprintf("modules_%s_timeouts", module),
 			"Count of module timeouts labeled by stage name.",
 			[]string{stageLabel})
+
 	}
 }
 
@@ -779,6 +894,22 @@ func (m *Metrics) RecordStoredResponse(pubId string) {
 	}
 }
 
+func (m *Metrics) RecordRejectedBidsForAccount(pubId string) {
+	if pubId != metrics.PublisherUnknown {
+		m.accountRejectedBid.With(prometheus.Labels{
+			accountLabel: pubId,
+		}).Inc()
+	}
+}
+
+func (m *Metrics) RecordFloorsRequestForAccount(pubId string) {
+	if pubId != metrics.PublisherUnknown {
+		m.accountFloorsRequest.With(prometheus.Labels{
+			accountLabel: pubId,
+		}).Inc()
+	}
+}
+
 func (m *Metrics) RecordImps(labels metrics.ImpLabels) {
 	m.impressions.With(prometheus.Labels{
 		isBannerLabel: strconv.FormatBool(labels.BannerImps),
@@ -869,6 +1000,23 @@ func (m *Metrics) RecordAdapterRequest(labels metrics.AdapterLabels) {
 	}
 }
 
+func (m *Metrics) RecordRejectedBidsForBidder(Adapter openrtb_ext.BidderName) {
+	if m.rejectedBids != nil {
+		m.rejectedBids.With(prometheus.Labels{
+			adapterLabel: string(Adapter),
+		}).Inc()
+	}
+}
+
+func (m *Metrics) RecordDynamicFetchFailure(pubId, code string) {
+	if pubId != metrics.PublisherUnknown {
+		m.dynamicFetchFailure.With(prometheus.Labels{
+			accountLabel: pubId,
+			codeLabel:    code,
+		}).Inc()
+	}
+}
+
 // Keeps track of created and reused connections to adapter bidders and the time from the
 // connection request, to the connection creation, or reuse from the pool across all engines
 func (m *Metrics) RecordAdapterConnections(adapterName openrtb_ext.BidderName, connWasReused bool, connWaitTime time.Duration) {
@@ -895,8 +1043,11 @@ func (m *Metrics) RecordDNSTime(dnsLookupTime time.Duration) {
 	m.dnsLookupTimer.Observe(dnsLookupTime.Seconds())
 }
 
-func (m *Metrics) RecordTLSHandshakeTime(tlsHandshakeTime time.Duration) {
-	m.tlsHandhakeTimer.Observe(tlsHandshakeTime.Seconds())
+func (m *Metrics) RecordTLSHandshakeTime(adapterName openrtb_ext.BidderName, tlsHandshakeTime time.Duration) {
+	// m.tlsHandhakeTimer.Observe(tlsHandshakeTime.Seconds())
+	m.tlsHandhakeTimer.With(prometheus.Labels{
+		adapterLabel: string(adapterName),
+	}).Observe(tlsHandshakeTime.Seconds())
 }
 
 func (m *Metrics) RecordBidderServerResponseTime(bidderServerResponseTime time.Duration) {
diff --git a/metrics/prometheus/prometheus_ow.go b/metrics/prometheus/prometheus_ow.go
new file mode 100644
index 000000000..ad80c8f5b
--- /dev/null
+++ b/metrics/prometheus/prometheus_ow.go
@@ -0,0 +1,122 @@
+package prometheusmetrics
+
+import (
+	"strconv"
+	"time"
+
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/metrics"
+	"github.com/prometheus/client_golang/prometheus"
+)
+
+const (
+	pubIDLabel   = "pubid"
+	bidderLabel  = "bidder"
+	codeLabel    = "code"
+	profileLabel = "profileid"
+	dealLabel    = "deal"
+)
+
+func newHttpCounter(cfg config.PrometheusMetrics, registry *prometheus.Registry) prometheus.Counter {
+	httpCounter := prometheus.NewCounter(prometheus.CounterOpts{
+		Name: "http_requests_total",
+		Help: "Number of http requests.",
+	})
+	registry.MustRegister(httpCounter)
+	return httpCounter
+}
+
+// RecordAdapterDuplicateBidID captures the  bid.ID collisions when adaptor
+// gives the bid response with multiple bids containing  same bid.ID
+// ensure collisions value is greater than 1. This function will not give any error
+// if collisions = 1 is passed
+func (m *Metrics) RecordAdapterDuplicateBidID(adaptor string, collisions int) {
+	m.adapterDuplicateBidIDCounter.With(prometheus.Labels{
+		adapterLabel: adaptor,
+	}).Add(float64(collisions))
+}
+
+// RecordRequestHavingDuplicateBidID keeps count of request when duplicate bid.id is
+// detected in partner's response
+func (m *Metrics) RecordRequestHavingDuplicateBidID() {
+	m.requestsDuplicateBidIDCounter.Inc()
+}
+
+// pod specific metrics
+
+// recordAlgoTime is common method which handles algorithm time performance
+func recordAlgoTime(timer *prometheus.HistogramVec, labels metrics.PodLabels, elapsedTime time.Duration) {
+
+	pmLabels := prometheus.Labels{
+		podAlgorithm: labels.AlgorithmName,
+	}
+
+	if labels.NoOfImpressions != nil {
+		pmLabels[podNoOfImpressions] = strconv.Itoa(*labels.NoOfImpressions)
+	}
+	if labels.NoOfCombinations != nil {
+		pmLabels[podTotalCombinations] = strconv.Itoa(*labels.NoOfCombinations)
+	}
+	if labels.NoOfResponseBids != nil {
+		pmLabels[podNoOfResponseBids] = strconv.Itoa(*labels.NoOfResponseBids)
+	}
+
+	timer.With(pmLabels).Observe(elapsedTime.Seconds())
+}
+
+// RecordPodImpGenTime records number of impressions generated and time taken
+// by underneath algorithm to generate them
+func (m *Metrics) RecordPodImpGenTime(labels metrics.PodLabels, start time.Time) {
+	elapsedTime := time.Since(start)
+	recordAlgoTime(m.podImpGenTimer, labels, elapsedTime)
+}
+
+// RecordPodCombGenTime records number of combinations generated and time taken
+// by underneath algorithm to generate them
+func (m *Metrics) RecordPodCombGenTime(labels metrics.PodLabels, elapsedTime time.Duration) {
+	recordAlgoTime(m.podCombGenTimer, labels, elapsedTime)
+}
+
+// RecordPodCompititveExclusionTime records number of combinations comsumed for forming
+// final ad pod response and time taken by underneath algorithm to generate them
+func (m *Metrics) RecordPodCompititveExclusionTime(labels metrics.PodLabels, elapsedTime time.Duration) {
+	recordAlgoTime(m.podCompExclTimer, labels, elapsedTime)
+}
+
+// RecordAdapterVideoBidDuration records actual ad duration (>0) returned by the bidder
+func (m *Metrics) RecordAdapterVideoBidDuration(labels metrics.AdapterLabels, videoBidDuration int) {
+	if videoBidDuration > 0 {
+		m.adapterVideoBidDuration.With(prometheus.Labels{adapterLabel: string(labels.Adapter)}).Observe(float64(videoBidDuration))
+	}
+}
+
+// RecordRejectedBids records rejected bids labeled by pubid, bidder and reason code
+func (m *Metrics) RecordRejectedBids(pubid, biddder, code string) {
+	m.rejectedBids.With(prometheus.Labels{
+		pubIDLabel:  pubid,
+		bidderLabel: biddder,
+		codeLabel:   code,
+	}).Inc()
+}
+
+// RecordBids records bids labeled by pubid, profileid, bidder and deal
+func (m *Metrics) RecordBids(pubid, profileid, biddder, deal string) {
+	m.bids.With(prometheus.Labels{
+		pubIDLabel:   pubid,
+		profileLabel: profileid,
+		bidderLabel:  biddder,
+		dealLabel:    deal,
+	}).Inc()
+}
+
+// RecordVastVersion record the count of vast version labelled by bidder and vast version
+func (m *Metrics) RecordVastVersion(coreBiddder, vastVersion string) {
+	m.vastVersion.With(prometheus.Labels{
+		adapterLabel: coreBiddder,
+		versionLabel: vastVersion,
+	}).Inc()
+}
+
+func (m *Metrics) RecordHttpCounter() {
+	m.httpCounter.Inc()
+}
diff --git a/metrics/prometheus/prometheus_ow_test.go b/metrics/prometheus/prometheus_ow_test.go
new file mode 100644
index 000000000..838a9c7c3
--- /dev/null
+++ b/metrics/prometheus/prometheus_ow_test.go
@@ -0,0 +1,129 @@
+package prometheusmetrics
+
+import (
+	"testing"
+
+	"github.com/prometheus/client_golang/prometheus"
+)
+
+func TestRecordRejectedBids(t *testing.T) {
+	type testIn struct {
+		pubid, bidder, code string
+	}
+	type testOut struct {
+		expCount int
+	}
+	testCases := []struct {
+		description string
+		in          testIn
+		out         testOut
+	}{
+		{
+			description: "record rejected bids",
+			in: testIn{
+				pubid:  "1010",
+				bidder: "bidder",
+				code:   "100",
+			},
+			out: testOut{
+				expCount: 1,
+			},
+		},
+	}
+	for _, test := range testCases {
+		pm := createMetricsForTesting()
+		pm.RecordRejectedBids(test.in.pubid, test.in.bidder, test.in.code)
+
+		assertCounterVecValue(t,
+			"",
+			"rejected_bids",
+			pm.rejectedBids,
+			float64(test.out.expCount),
+			prometheus.Labels{
+				pubIDLabel:  test.in.pubid,
+				bidderLabel: test.in.bidder,
+				codeLabel:   test.in.code,
+			})
+	}
+}
+
+func TestRecordBids(t *testing.T) {
+	type testIn struct {
+		pubid, profileid, bidder, deal string
+	}
+	type testOut struct {
+		expCount int
+	}
+	testCases := []struct {
+		description string
+		in          testIn
+		out         testOut
+	}{
+		{
+			description: "record bids",
+			in: testIn{
+				pubid:     "1010",
+				bidder:    "bidder",
+				profileid: "11",
+				deal:      "pubdeal",
+			},
+			out: testOut{
+				expCount: 1,
+			},
+		},
+	}
+	for _, test := range testCases {
+		pm := createMetricsForTesting()
+		pm.RecordBids(test.in.pubid, test.in.profileid, test.in.bidder, test.in.deal)
+
+		assertCounterVecValue(t,
+			"",
+			"bids",
+			pm.bids,
+			float64(test.out.expCount),
+			prometheus.Labels{
+				pubIDLabel:   test.in.pubid,
+				bidderLabel:  test.in.bidder,
+				profileLabel: test.in.profileid,
+				dealLabel:    test.in.deal,
+			})
+	}
+}
+
+func TestRecordVastVersion(t *testing.T) {
+	type testIn struct {
+		coreBidder, vastVersion string
+	}
+	type testOut struct {
+		expCount int
+	}
+	testCases := []struct {
+		description string
+		in          testIn
+		out         testOut
+	}{
+		{
+			description: "record vast version",
+			in: testIn{
+				coreBidder:  "bidder",
+				vastVersion: "2.0",
+			},
+			out: testOut{
+				expCount: 1,
+			},
+		},
+	}
+	for _, test := range testCases {
+		pm := createMetricsForTesting()
+		pm.RecordVastVersion(test.in.coreBidder, test.in.vastVersion)
+		assertCounterVecValue(t,
+			"",
+			"record vastVersion",
+			pm.vastVersion,
+			float64(test.out.expCount),
+			prometheus.Labels{
+				adapterLabel: test.in.coreBidder,
+				versionLabel: test.in.vastVersion,
+			})
+	}
+}
diff --git a/metrics/prometheus/prometheus_test.go b/metrics/prometheus/prometheus_test.go
index 32f7848cc..b0902e1dc 100644
--- a/metrics/prometheus/prometheus_test.go
+++ b/metrics/prometheus/prometheus_test.go
@@ -2,6 +2,7 @@ package prometheusmetrics
 
 import (
 	"fmt"
+	"strconv"
 	"testing"
 	"time"
 
@@ -1443,35 +1444,57 @@ func TestRecordDNSTime(t *testing.T) {
 }
 
 func TestRecordTLSHandshakeTime(t *testing.T) {
-	testCases := []struct {
-		description          string
+	type testIn struct {
+		adapterName          openrtb_ext.BidderName
 		tLSHandshakeDuration time.Duration
-		expectedDuration     float64
-		expectedCount        uint64
+	}
+
+	type testOut struct {
+		expectedDuration float64
+		expectedCount    uint64
+	}
+
+	testCases := []struct {
+		description string
+		in          testIn
+		out         testOut
 	}{
 		{
-			description:          "Five second DNS lookup time",
-			tLSHandshakeDuration: time.Second * 5,
-			expectedDuration:     5,
-			expectedCount:        1,
+			description: "Five second DNS lookup time",
+			in: testIn{
+				adapterName:          openrtb_ext.BidderAppnexus,
+				tLSHandshakeDuration: time.Second * 5,
+			},
+			out: testOut{
+				expectedDuration: 5,
+				expectedCount:    1,
+			},
 		},
 		{
-			description:          "Zero DNS lookup time",
-			tLSHandshakeDuration: 0,
-			expectedDuration:     0,
-			expectedCount:        1,
+			description: "Zero DNS lookup time",
+			in: testIn{
+				adapterName:          openrtb_ext.BidderAppnexus,
+				tLSHandshakeDuration: 0,
+			},
+			out: testOut{
+				expectedDuration: 0,
+				expectedCount:    1,
+			},
 		},
 	}
 	for i, test := range testCases {
 		pm := createMetricsForTesting()
-		pm.RecordTLSHandshakeTime(test.tLSHandshakeDuration)
+		assertDesciptions := []string{
+			fmt.Sprintf("[%d] Incorrect number of histogram entries. Desc: %s", i+1, test.description),
+			fmt.Sprintf("[%d] Incorrect number of histogram cumulative values. Desc: %s", i+1, test.description),
+		}
 
-		m := dto.Metric{}
-		pm.tlsHandhakeTimer.Write(&m)
-		histogram := *m.GetHistogram()
+		pm.RecordTLSHandshakeTime(test.in.adapterName, test.in.tLSHandshakeDuration)
 
-		assert.Equal(t, test.expectedCount, histogram.GetSampleCount(), "[%d] Incorrect number of histogram entries. Desc: %s\n", i, test.description)
-		assert.Equal(t, test.expectedDuration, histogram.GetSampleSum(), "[%d] Incorrect number of histogram cumulative values. Desc: %s\n", i, test.description)
+		// Assert TLS Handshake time
+		histogram := getHistogramFromHistogramVec(pm.tlsHandhakeTimer, adapterLabel, string(test.in.adapterName))
+		assert.Equal(t, test.out.expectedCount, histogram.GetSampleCount(), assertDesciptions[0])
+		assert.Equal(t, test.out.expectedDuration, histogram.GetSampleSum(), assertDesciptions[1])
 	}
 }
 
@@ -1634,6 +1657,7 @@ func TestDisabledMetrics(t *testing.T) {
 	assert.Nil(t, prometheusMetrics.adapterReusedConnections, "Counter Vector adapterReusedConnections should be nil")
 	assert.Nil(t, prometheusMetrics.adapterCreatedConnections, "Counter Vector adapterCreatedConnections should be nil")
 	assert.Nil(t, prometheusMetrics.adapterConnectionWaitTime, "Counter Vector adapterConnectionWaitTime should be nil")
+	assert.Nil(t, prometheusMetrics.tlsHandhakeTimer, "Counter Vector tlsHandhakeTimer should be nil")
 	assert.Nil(t, prometheusMetrics.adapterGDPRBlockedRequests, "Counter Vector adapterGDPRBlockedRequests should be nil")
 }
 
@@ -1715,6 +1739,187 @@ func TestRecordRequestPrivacy(t *testing.T) {
 		})
 }
 
+// TestRecordRequestDuplicateBidID checks RecordRequestDuplicateBidID
+func TestRecordRequestDuplicateBidID(t *testing.T) {
+	m := createMetricsForTesting()
+	m.RecordRequestHavingDuplicateBidID()
+	// verify total no of requests which detected collision
+	assertCounterValue(t, "request cnt having duplicate bid.id", "request cnt having duplicate bid.id", m.requestsDuplicateBidIDCounter, float64(1))
+}
+
+// TestRecordAdapterDuplicateBidID checks RecordAdapterDuplicateBidID
+func TestRecordAdapterDuplicateBidID(t *testing.T) {
+	type collisions struct {
+		simulate int // no of bids to be simulate with same bid.id
+		expect   int // no of collisions expected to be recorded by metrics engine for given bidder
+	}
+	type bidderCollisions = map[string]collisions
+	testCases := []struct {
+		scenario         string
+		bidderCollisions bidderCollisions // represents no of collisions detected for bid.id at bidder level for given request
+		expectCollisions int
+	}{
+		{scenario: "invalid collision value", bidderCollisions: map[string]collisions{"bidder-1": {simulate: -1, expect: 0}}},
+		{scenario: "no collision", bidderCollisions: map[string]collisions{"bidder-1": {simulate: 0, expect: 0}}},
+		{scenario: "one collision", bidderCollisions: map[string]collisions{"bidder-1": {simulate: 1, expect: 1}}},
+		{scenario: "multiple collisions", bidderCollisions: map[string]collisions{"bidder-1": {simulate: 2, expect: 2}}},
+		{scenario: "multiple bidders", bidderCollisions: map[string]collisions{"bidder-1": {simulate: 2, expect: 2}, "bidder-2": {simulate: 4, expect: 4}}},
+		{scenario: "multiple bidders with bidder-1 no collision", bidderCollisions: map[string]collisions{"bidder-1": {simulate: 0, expect: 0},
+			"bidder-2": {simulate: 4, expect: 4}}},
+	}
+
+	for _, testcase := range testCases {
+		m := createMetricsForTesting()
+		for bidder, collisions := range testcase.bidderCollisions {
+			for collision := 1; collision <= collisions.simulate; collision++ {
+				m.RecordAdapterDuplicateBidID(bidder, 1)
+			}
+			assertCounterVecValue(t, testcase.scenario, testcase.scenario, m.adapterDuplicateBidIDCounter, float64(collisions.expect), prometheus.Labels{
+				adapterLabel: bidder,
+			})
+		}
+	}
+}
+
+func TestRecordPodImpGenTime(t *testing.T) {
+	impressions := 4
+	testAlgorithmMetrics(t, impressions, func(m *Metrics) dto.Histogram {
+		m.RecordPodImpGenTime(metrics.PodLabels{AlgorithmName: "sample_imp_algo", NoOfImpressions: &impressions}, time.Now())
+		return getHistogramFromHistogramVec(m.podImpGenTimer, podNoOfImpressions, strconv.Itoa(impressions))
+	})
+}
+
+func TestRecordPodCombGenTime(t *testing.T) {
+	combinations := 5
+	testAlgorithmMetrics(t, combinations, func(m *Metrics) dto.Histogram {
+		m.RecordPodCombGenTime(metrics.PodLabels{AlgorithmName: "sample_comb_algo", NoOfCombinations: &combinations}, time.Since(time.Now()))
+		return getHistogramFromHistogramVec(m.podCombGenTimer, podTotalCombinations, strconv.Itoa(combinations))
+	})
+}
+
+func TestRecordPodCompetitiveExclusionTime(t *testing.T) {
+	totalBids := 8
+	testAlgorithmMetrics(t, totalBids, func(m *Metrics) dto.Histogram {
+		m.RecordPodCompititveExclusionTime(metrics.PodLabels{AlgorithmName: "sample_comt_excl_algo", NoOfResponseBids: &totalBids}, time.Since(time.Now()))
+		return getHistogramFromHistogramVec(m.podCompExclTimer, podNoOfResponseBids, strconv.Itoa(totalBids))
+	})
+}
+
+func TestRecordAdapterVideoBidDuration(t *testing.T) {
+
+	testCases := []struct {
+		description       string
+		bidderAdDurations map[string][]int
+		expectedSum       map[string]int
+		expectedCount     map[string]int
+		expectedBuckets   map[string]map[int]int // cumulative
+	}{
+		{
+			description: "single bidder multiple ad durations",
+			bidderAdDurations: map[string][]int{
+				"bidder_1": {5, 10, 11, 32},
+			},
+			expectedSum:   map[string]int{"bidder_1": 58},
+			expectedCount: map[string]int{"bidder_1": 4},
+			expectedBuckets: map[string]map[int]int{
+				"bidder_1": {5: 1, 10: 2, 15: 3, 35: 4}, // Upper bound : cumulative number
+			},
+		},
+		{
+			description: "multiple bidders multiple ad durations",
+			bidderAdDurations: map[string][]int{
+				"bidder_1": {5, 10, 11, 32, 39},
+				"bidder_2": {25, 30},
+			},
+			expectedSum:   map[string]int{"bidder_1": 97, "bidder_2": 55},
+			expectedCount: map[string]int{"bidder_1": 5, "bidder_2": 2},
+			expectedBuckets: map[string]map[int]int{
+				"bidder_1": {5: 1, 10: 2, 15: 3, 35: 4, 40: 5},
+				"bidder_2": {25: 1, 30: 2},
+			},
+		},
+		{
+			description: "bidder with 0 ad durations",
+			bidderAdDurations: map[string][]int{
+				"bidder_1": {5, 0, 0, 27},
+			},
+			expectedSum:   map[string]int{"bidder_1": 32},
+			expectedCount: map[string]int{"bidder_1": 2}, // must exclude 2 observations having 0 durations
+			expectedBuckets: map[string]map[int]int{
+				"bidder_1": {5: 1, 30: 2},
+			},
+		},
+		{
+			description: "bidder with similar durations",
+			bidderAdDurations: map[string][]int{
+				"bidder_1": {23, 23, 23},
+			},
+			expectedSum:   map[string]int{"bidder_1": 69},
+			expectedCount: map[string]int{"bidder_1": 3}, //
+			expectedBuckets: map[string]map[int]int{
+				"bidder_1": {25: 3},
+			},
+		},
+		{
+			description: "bidder with ad durations >= 60",
+			bidderAdDurations: map[string][]int{
+				"bidder_1": {33, 60, 93, 90, 90, 120},
+			},
+			expectedSum:   map[string]int{"bidder_1": 486},
+			expectedCount: map[string]int{"bidder_1": 6}, //
+			expectedBuckets: map[string]map[int]int{
+				"bidder_1": {35: 1, 60: 2, 120: 6},
+			},
+		},
+	}
+
+	for _, test := range testCases {
+		t.Run(test.description, func(t *testing.T) {
+			m := createMetricsForTesting()
+			for adapterName, adDurations := range test.bidderAdDurations {
+				for _, adDuration := range adDurations {
+					m.RecordAdapterVideoBidDuration(metrics.AdapterLabels{
+						Adapter: openrtb_ext.BidderName(adapterName),
+					}, adDuration)
+				}
+				result := getHistogramFromHistogramVec(m.adapterVideoBidDuration, adapterLabel, adapterName)
+				for bucketDuration, durationCnt := range test.expectedBuckets[adapterName] {
+					validBucket := false
+					for _, bucket := range result.GetBucket() {
+						if int(bucket.GetUpperBound()) == bucketDuration {
+							validBucket = true
+							assert.Equal(t, uint64(durationCnt), bucket.GetCumulativeCount())
+							break
+						}
+					}
+					if !validBucket {
+						assert.Fail(t, "Invalid expected bucket = "+strconv.Itoa(bucketDuration))
+					}
+				}
+				expectedCount := test.expectedCount[adapterName]
+				expectedSum := test.expectedSum[adapterName]
+				assertHistogram(t, "adapter_vidbid_dur", result, uint64(expectedCount), float64(expectedSum))
+			}
+		})
+	}
+}
+
+func testAlgorithmMetrics(t *testing.T, input int, f func(m *Metrics) dto.Histogram) {
+	// test input
+	adRequests := 2
+	m := createMetricsForTesting()
+	var result dto.Histogram
+	for req := 1; req <= adRequests; req++ {
+		result = f(m)
+	}
+
+	// assert observations
+	assert.Equal(t, uint64(adRequests), result.GetSampleCount(), "ad requests : count")
+	for _, bucket := range result.Bucket {
+		assert.Equal(t, uint64(adRequests), bucket.GetCumulativeCount(), "total observations")
+	}
+}
+
 func assertCounterValue(t *testing.T, description, name string, counter prometheus.Counter, expected float64) {
 	m := dto.Metric{}
 	counter.Write(&m)
@@ -2125,6 +2330,44 @@ func TestRecordAccountUpgradeStatusMetrics(t *testing.T) {
 
 			assertCounterValue(t, "", "Account Depreciation Summary Meter should be incremented", m.accountDeprecationSummary, test.expectedMetricCount)
 		})
+	}
+}
 
+func TestRecordDynamicFetchFailure(t *testing.T) {
+	type testIn struct {
+		pubid, code string
+	}
+	type testOut struct {
+		expCount int
+	}
+	testCases := []struct {
+		description string
+		in          testIn
+		out         testOut
+	}{
+		{
+			description: "record dynamic fetch failure",
+			in: testIn{
+				pubid: "5890",
+				code:  "1",
+			},
+			out: testOut{
+				expCount: 1,
+			},
+		},
+	}
+	for _, test := range testCases {
+		pm := createMetricsForTesting()
+		pm.RecordDynamicFetchFailure(test.in.pubid, test.in.code)
+
+		assertCounterVecValue(t,
+			"",
+			"",
+			pm.dynamicFetchFailure,
+			float64(test.out.expCount),
+			prometheus.Labels{
+				accountLabel: test.in.pubid,
+				codeLabel:    test.in.code,
+			})
 	}
 }
diff --git a/metrics/pubmatic_stats/stats.go b/metrics/pubmatic_stats/stats.go
new file mode 100644
index 000000000..c9a113178
--- /dev/null
+++ b/metrics/pubmatic_stats/stats.go
@@ -0,0 +1,11 @@
+package pubmaticstats
+
+// IncBidResponseByDealCountInPBS counts number of bids received from aliasBidder for
+// publisher, profile
+// if dealid is not present then value would be'nodeal'
+var IncBidResponseByDealCountInPBS = func(publisher, profile, aliasBidder, dealId string) {
+}
+
+// IncPartnerTimeoutInPBS counts partner timeouts fro given publisher, profile and aliasbidder
+var IncPartnerTimeoutInPBS = func(publisher, profile, aliasBidder string) {
+}
diff --git a/metrics/pubmatic_stats/stats_test.go b/metrics/pubmatic_stats/stats_test.go
new file mode 100644
index 000000000..cb3fe9182
--- /dev/null
+++ b/metrics/pubmatic_stats/stats_test.go
@@ -0,0 +1,11 @@
+package pubmaticstats
+
+import "testing"
+
+func TestIncBidResponseByDealCountInPBS(t *testing.T) {
+	IncBidResponseByDealCountInPBS("some_publisher_id", "some_profile_id", "some_alias_bidder", "some_dealid")
+}
+
+func TestIncPartnerTimeoutInPBS(t *testing.T) {
+	IncPartnerTimeoutInPBS("some_publisher_id", "some_profile_id", "some_alias_bidder")
+}
diff --git a/modules/builder.go b/modules/builder.go
index ffb814e64..61983e237 100644
--- a/modules/builder.go
+++ b/modules/builder.go
@@ -2,6 +2,7 @@ package modules
 
 import (
 	prebidOrtb2blocking "github.com/prebid/prebid-server/modules/prebid/ortb2blocking"
+	pubmaticOpenwrap "github.com/prebid/prebid-server/modules/pubmatic/openwrap"
 )
 
 // builders returns mapping between module name and its builder
@@ -11,5 +12,8 @@ func builders() ModuleBuilders {
 		"prebid": {
 			"ortb2blocking": prebidOrtb2blocking.Builder,
 		},
+		"pubmatic": {
+			"openwrap": pubmaticOpenwrap.Builder,
+		},
 	}
 }
diff --git a/modules/helpers.go b/modules/helpers.go
index c7fe9f73f..f91daeff8 100644
--- a/modules/helpers.go
+++ b/modules/helpers.go
@@ -27,6 +27,12 @@ func createModuleStageNamesCollection(modules map[string]interface{}) (map[strin
 			moduleStageNameCollector = addModuleStageName(moduleStageNameCollector, id, stageName)
 		}
 
+		if _, ok := hook.(hookstage.BeforeValidationRequest); ok {
+			added = true
+			stageName := hooks.StageBeforeValidationRequest.String()
+			moduleStageNameCollector = addModuleStageName(moduleStageNameCollector, id, stageName)
+		}
+
 		if _, ok := hook.(hookstage.ProcessedAuctionRequest); ok {
 			added = true
 			stageName := hooks.StageProcessedAuctionRequest.String()
diff --git a/modules/pubmatic/openwrap/abtest.go b/modules/pubmatic/openwrap/abtest.go
new file mode 100644
index 000000000..d9a6fcd73
--- /dev/null
+++ b/modules/pubmatic/openwrap/abtest.go
@@ -0,0 +1,119 @@
+package openwrap
+
+import (
+	"strconv"
+	"strings"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+// CheckABTestEnabled checks whether a given request is AB test enabled or not
+func CheckABTestEnabled(rctx models.RequestCtx) bool {
+	return models.GetVersionLevelPropertyFromPartnerConfig(rctx.PartnerConfigMap, models.AbTestEnabled) == "1"
+}
+
+// ABTestProcessing function checks if test config should be applied and change the partner config accordingly
+func ABTestProcessing(rctx models.RequestCtx) (map[int]map[string]string, bool) {
+	//test config logic
+	if CheckABTestEnabled(rctx) && ApplyTestConfig(rctx) {
+		return UpdateTestConfig(rctx), true
+	}
+	return nil, false
+}
+
+// ApplyTestConfig checks if test config should be applied
+func ApplyTestConfig(rctx models.RequestCtx) bool {
+	testGroupSize, err := strconv.Atoi(models.GetVersionLevelPropertyFromPartnerConfig(rctx.PartnerConfigMap, AppendTest(models.TestGroupSize)))
+	if err != nil || testGroupSize == 0 {
+		return false
+	}
+
+	randomNumber := GetRandomNumberIn1To100()
+	return randomNumber <= testGroupSize
+}
+
+// AppendTest appends "_test" string to given key
+func AppendTest(key string) string {
+	return key + test
+}
+
+// UpdateTestConfig returns the updated partnerconfig according to the test type
+func UpdateTestConfig(rctx models.RequestCtx) map[int]map[string]string {
+
+	//create copy of the map
+	newPartnerConfig := copyPartnerConfigMap(rctx.PartnerConfigMap)
+
+	//read test type
+	testType := models.GetVersionLevelPropertyFromPartnerConfig(rctx.PartnerConfigMap, AppendTest(models.TestType))
+
+	//change partnerconfig based on test type
+	switch testType {
+	case models.TestTypeAuctionTimeout:
+		replaceControlConfig(newPartnerConfig, models.VersionLevelConfigID, models.SSTimeoutKey)
+	case models.TestTypePartners:
+		//check the partner config map for test partners
+		for partnerID, config := range rctx.PartnerConfigMap {
+			if partnerID == models.VersionLevelConfigID {
+				continue
+			}
+
+			//if current partner is test enabled, update the config with test config
+			//otherwise if its a control partner, then remove it from final partner config map
+			if config[models.PartnerTestEnabledKey] == "1" {
+				for key := range config {
+					copyTestConfig(newPartnerConfig, partnerID, key)
+				}
+
+			} else {
+				delete(newPartnerConfig, partnerID)
+			}
+		}
+
+	case models.TestTypeClientVsServerPath: // TODO: can we deprecate this AB test type
+		for partnerID := range rctx.PartnerConfigMap {
+			if partnerID == models.VersionLevelConfigID {
+				continue
+			}
+
+			//update the "serverSideEnabled" value with test config
+			replaceControlConfig(newPartnerConfig, partnerID, models.SERVER_SIDE_FLAG)
+
+		}
+	default:
+	}
+
+	return newPartnerConfig
+}
+
+// copyPartnerConfigMap creates a copy of given partner config map
+func copyPartnerConfigMap(m map[int]map[string]string) map[int]map[string]string {
+	cp := make(map[int]map[string]string)
+	for pid, conf := range m {
+		config := make(map[string]string)
+		for key, val := range conf {
+			config[key] = val
+		}
+		cp[pid] = config
+	}
+	return cp
+}
+
+// replaceControlConfig replace control config with test config for a given key
+func replaceControlConfig(partnerConfig map[int]map[string]string, partnerID int, key string) {
+	if testValue := partnerConfig[partnerID][AppendTest(key)]; testValue != "" {
+		partnerConfig[partnerID][key] = testValue
+	}
+
+}
+
+// copyTestConfig checks if the given key is test config, if yes it copies it in control config
+func copyTestConfig(partnerConfig map[int]map[string]string, partnerID int, key string) {
+	//if the current key is test config
+	if strings.HasSuffix(key, test) {
+		if testValue := partnerConfig[partnerID][key]; testValue != "" {
+			//get control key for the given test key to copy data
+			controlKey := strings.TrimSuffix(key, test)
+			partnerConfig[partnerID][controlKey] = testValue
+		}
+	}
+}
diff --git a/modules/pubmatic/openwrap/adapters/bidder_alias.go b/modules/pubmatic/openwrap/adapters/bidder_alias.go
new file mode 100644
index 000000000..be8e39a05
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/bidder_alias.go
@@ -0,0 +1,32 @@
+package adapters
+
+import (
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+//ResolveOWBidder it resolves hardcoded bidder alias names
+
+func ResolveOWBidder(bidderName string) string {
+
+	var coreBidderName string
+
+	switch bidderName {
+
+	case models.BidderAdGenerationAlias:
+		coreBidderName = string(openrtb_ext.BidderAdgeneration)
+	case models.BidderDistrictmDMXAlias:
+		coreBidderName = string(openrtb_ext.BidderDmx)
+	case models.BidderPubMaticSecondaryAlias:
+		coreBidderName = string(openrtb_ext.BidderPubmatic)
+	case models.BidderDistrictmAlias:
+		coreBidderName = string(openrtb_ext.BidderAppnexus)
+	case models.BidderAndBeyondAlias:
+		coreBidderName = string(openrtb_ext.BidderAdkernel)
+	default:
+		coreBidderName = bidderName
+
+	}
+
+	return coreBidderName
+}
diff --git a/modules/pubmatic/openwrap/adapters/bidders.go b/modules/pubmatic/openwrap/adapters/bidders.go
new file mode 100644
index 000000000..598cb68d9
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/bidders.go
@@ -0,0 +1,561 @@
+package adapters
+
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"strings"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+// PrepareBidParamJSONForPartner preparing bid params json for partner
+func PrepareBidParamJSONForPartner(width *int64, height *int64, fieldMap map[string]interface{}, slotKey, adapterName, bidderCode string, impExt *models.ImpExtension) (json.RawMessage, error) {
+	params := BidderParameters{
+		AdapterName: adapterName,
+		BidderCode:  bidderCode,
+		ImpExt:      impExt,
+		FieldMap:    fieldMap,
+		Width:       width,
+		Height:      height,
+		SlotKey:     slotKey,
+	}
+
+	//get callback function and execute it
+	callback := getBuilder(params.AdapterName)
+	return callback(params)
+}
+
+// defaultBuilder for building json object for all other bidder
+func defaultBuilder(params BidderParameters) (json.RawMessage, error) {
+	//check if ResolveOWBidder is required or not
+	params.AdapterName = ResolveOWBidder(params.AdapterName)
+	return prepareBidParamJSONDefault(params)
+}
+
+// builderPubMatic for building json object for all other bidder
+func builderPubMatic(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+	jsonStr.WriteByte('{')
+
+	//UOE-5744: Adding custom changes for hybrid profiles
+	//publisherID
+	publisherID, _ := getString(params.FieldMap["publisherId"])
+	fmt.Fprintf(&jsonStr, `"publisherId":"%s"`, publisherID)
+
+	//adSlot
+	if adSlot, ok := getString(params.FieldMap["adSlot"]); ok {
+		fmt.Fprintf(&jsonStr, `,"adSlot":"%s"`, adSlot)
+	}
+
+	//pmzoneid
+	if pmzoneid, ok := getString(params.FieldMap["pmzoneid"]); ok {
+		fmt.Fprintf(&jsonStr, `,"pmzoneid":"%s"`, pmzoneid)
+	}
+
+	//dctr
+	if dctr, ok := getString(params.FieldMap["dctr"]); ok {
+		fmt.Fprintf(&jsonStr, `,"dctr":"%s"`, dctr)
+	}
+
+	//kadfloor
+	if kadfloor, ok := getString(params.FieldMap["kadfloor"]); ok {
+		fmt.Fprintf(&jsonStr, `,"kadfloor":"%s"`, kadfloor)
+	}
+
+	//wrapper object
+	if value, ok := params.FieldMap["wrapper"]; ok {
+		if wrapper, ok := value.(map[string]interface{}); ok {
+			fmt.Fprintf(&jsonStr, `,"wrapper":{`)
+
+			//profile
+			profile, _ := getInt(wrapper["profile"])
+			fmt.Fprintf(&jsonStr, `"profile":%d`, profile)
+
+			//version
+			version, _ := getInt(wrapper["version"])
+			fmt.Fprintf(&jsonStr, `,"version":%d`, version)
+
+			jsonStr.WriteByte('}')
+		}
+	}
+
+	//keywords
+	if value, ok := params.FieldMap["keywords"]; ok {
+		if keywords, err := json.Marshal(value); err == nil {
+			fmt.Fprintf(&jsonStr, `,"keywords":%s`, string(keywords))
+		}
+	}
+
+	//bidViewability Object
+	if value, ok := params.FieldMap["bidViewability"]; ok {
+		if bvsJson, err := json.Marshal(value); err == nil {
+			fmt.Fprintf(&jsonStr, `,"bidViewability":%s`, string(bvsJson))
+		}
+	}
+
+	jsonStr.WriteByte('}')
+
+	return jsonStr.Bytes(), nil
+}
+
+// builderAppNexus for building json object for AppNexus bidder
+func builderAppNexus(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+	jsonStr.WriteByte('{')
+
+	//incase if placementId not present then fallback to placement_id else log 0
+	placementID, ok := getInt(params.FieldMap["placementId"])
+	if !ok {
+		placementID, _ = getInt(params.FieldMap["placement_id"])
+	}
+	fmt.Fprintf(&jsonStr, `"placementId":%d`, placementID)
+
+	//reserve parameter
+	if reserve, ok := getFloat64(params.FieldMap["reserve"]); ok {
+		fmt.Fprintf(&jsonStr, `,"reserve":%.3f`, reserve)
+	}
+
+	//use_pmt_rule parameter
+	usePaymentRule, ok := getBool(params.FieldMap["usePaymentRule"])
+	if !ok {
+		usePaymentRule, ok = getBool(params.FieldMap["use_pmt_rule"])
+	}
+	if ok {
+		fmt.Fprintf(&jsonStr, `,"use_pmt_rule":%t`, usePaymentRule)
+	}
+
+	//anyone invcode and member
+	invCode, ok := getString(params.FieldMap["invCode"])
+	if !ok {
+		invCode, ok = getString(params.FieldMap["inv_code"])
+	}
+	if ok {
+		fmt.Fprintf(&jsonStr, `,"invCode":"%s"`, invCode)
+	} else {
+		if member, ok := getString(params.FieldMap["member"]); ok {
+			fmt.Fprintf(&jsonStr, `,"member":"%s"`, member)
+		}
+	}
+
+	//keywords
+	if val, ok := params.FieldMap["keywords"]; ok {
+		//UOE-5744: Adding custom changes for hybrid profiles
+		if keywords, _ := json.Marshal(val); len(keywords) > 0 {
+			fmt.Fprintf(&jsonStr, `,"keywords":%s`, string(keywords))
+		}
+	} else if keywords := getKeywordStringForPartner(params.ImpExt, params.BidderCode); keywords != "" {
+		fmt.Fprintf(&jsonStr, `,"keywords":%s`, keywords)
+	}
+
+	//generate_ad_pod_id
+	if generateAdPodID, ok := getBool(params.FieldMap["generate_ad_pod_id"]); ok {
+		fmt.Fprintf(&jsonStr, `,"generate_ad_pod_id":%t`, generateAdPodID)
+	}
+
+	//other parameters
+	for key, val := range params.FieldMap {
+		if ignoreAppnexusKeys[key] {
+			continue
+		}
+		if strVal, ok := getString(val); ok {
+			fmt.Fprintf(&jsonStr, `,"%s":"%s"`, key, strVal)
+		}
+	}
+
+	jsonStr.WriteByte('}')
+
+	return jsonStr.Bytes(), nil
+}
+
+// builderIndex for building json object for Index bidder
+func builderIndex(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+
+	siteID, ok := getString(params.FieldMap["siteID"])
+	if !ok {
+		//UOE-5744: Adding custom changes for hybrid profiles
+		if siteID, ok = getString(params.FieldMap["siteId"]); !ok {
+			return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "siteID")
+		}
+	}
+
+	width, height := params.Width, params.Height
+	if width == nil || height == nil {
+		//UOE-5744: Adding custom changes for hybrid profiles
+		size, ok := getIntArray(params.FieldMap["size"])
+		if len(size) != 2 || !ok {
+			return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "size")
+		}
+		w := int64(size[0])
+		h := int64(size[1])
+		width, height = &w, &h
+	}
+
+	fmt.Fprintf(&jsonStr, `{"siteId":"%s","size":[%d,%d]}`, siteID, *width, *height)
+	return jsonStr.Bytes(), nil
+}
+
+// builderPulsePoint for building json object for PulsePoint bidder
+func builderPulsePoint(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+
+	cp, _ := getInt(params.FieldMap["cp"])
+	ct, _ := getInt(params.FieldMap["ct"])
+	cf, _ := getString(params.FieldMap["cf"])
+	//[UOE-5744]: read adsize from fieldmap itself
+
+	if len(cf) == 0 {
+		cf = "0x0"
+		adSlot := strings.Split(params.SlotKey, "@")
+		if len(adSlot) == 2 && adSlot[0] != "" && adSlot[1] != "" {
+			cf = adSlot[1]
+		}
+	}
+
+	fmt.Fprintf(&jsonStr, `{"cp":%d,"ct":%d,"cf":"%s"}`, cp, ct, cf)
+	return jsonStr.Bytes(), nil
+}
+
+// builderRubicon for building json object for Rubicon bidder
+func builderRubicon(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+	jsonStr.WriteByte('{')
+
+	if accountID, ok := getInt(params.FieldMap["accountId"]); ok {
+		fmt.Fprintf(&jsonStr, `"accountId":%d,`, accountID)
+	}
+
+	if siteID, ok := getInt(params.FieldMap["siteId"]); ok {
+		fmt.Fprintf(&jsonStr, `"siteId":%d,`, siteID)
+	}
+
+	if zoneID, ok := getInt(params.FieldMap["zoneId"]); ok {
+		fmt.Fprintf(&jsonStr, `"zoneId":%d,`, zoneID)
+	}
+
+	if _, ok := params.FieldMap["video"]; ok {
+		if videoMap, ok := (params.FieldMap["video"]).(map[string]interface{}); ok {
+			jsonStr.WriteString(`"video":{`)
+
+			if width, ok := getInt(videoMap["playerWidth"]); ok {
+				fmt.Fprintf(&jsonStr, `"playerWidth":%d,`, width)
+			}
+
+			if height, ok := getInt(videoMap["playerHeight"]); ok {
+				fmt.Fprintf(&jsonStr, `"playerHeight":%d,`, height)
+			}
+
+			if sizeID, ok := getInt(videoMap["size_id"]); ok {
+				fmt.Fprintf(&jsonStr, `"size_id":%d,`, sizeID)
+			}
+
+			if lang, ok := getString(videoMap["language"]); ok {
+				fmt.Fprintf(&jsonStr, `"language":"%s",`, lang)
+			}
+
+			trimComma(&jsonStr)
+			jsonStr.WriteString(`},`)
+		}
+	}
+
+	trimComma(&jsonStr)
+	jsonStr.WriteByte('}')
+
+	return jsonStr.Bytes(), nil
+}
+
+// builderOpenx for building json object for Openx bidder
+func builderOpenx(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+	jsonStr.WriteByte('{')
+
+	if delDomain, ok := getString(params.FieldMap["delDomain"]); ok {
+		fmt.Fprintf(&jsonStr, `"delDomain":"%s",`, delDomain)
+	} else {
+	}
+
+	if unit, ok := getString(params.FieldMap["unit"]); ok {
+		fmt.Fprintf(&jsonStr, `"unit":"%s"`, unit)
+	} else {
+	}
+
+	trimComma(&jsonStr)
+	jsonStr.WriteByte('}')
+	return jsonStr.Bytes(), nil
+}
+
+// builderSovrn for building json object for Sovrn bidder
+func builderSovrn(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+	jsonStr.WriteByte('{')
+
+	if tagID, ok := getString(params.FieldMap["tagid"]); ok {
+		fmt.Fprintf(&jsonStr, `"tagid":"%s",`, tagID)
+	} else {
+	}
+
+	if bidFloor, ok := getFloat64(params.FieldMap["bidfloor"]); ok {
+		fmt.Fprintf(&jsonStr, `"bidfloor":%f`, bidFloor)
+	}
+
+	trimComma(&jsonStr)
+	jsonStr.WriteByte('}')
+
+	return jsonStr.Bytes(), nil
+}
+
+// builderImproveDigital for building json object for ImproveDigital bidder
+func builderImproveDigital(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+	jsonStr.WriteByte('{')
+
+	if placementID, ok := getInt(params.FieldMap["placementId"]); ok {
+		fmt.Fprintf(&jsonStr, `"placementId":%d`, placementID)
+	} else {
+		publisherID, ok1 := getInt(params.FieldMap["publisherId"])
+		placement, ok2 := getString(params.FieldMap["placementKey"])
+		if !ok1 || !ok2 {
+			return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "['placementId'] or ['publisherId', 'placementKey']")
+		}
+		fmt.Fprintf(&jsonStr, `"publisherId":%d,"placementKey":"%s"`, publisherID, placement)
+	}
+
+	width, height := params.Width, params.Height
+	////UOE-5744: Adding custom changes for hybrid profiles
+	if val, ok := params.FieldMap["size"]; ok {
+		if size, ok := val.(map[string]interface{}); ok {
+			w, ok1 := getInt(size["w"])
+			h, ok2 := getInt(size["h"])
+			if ok1 && ok2 {
+				_w := int64(w)
+				_h := int64(h)
+				width = &(_w)
+				height = &(_h)
+			}
+		}
+	}
+	if width != nil && height != nil {
+		fmt.Fprintf(&jsonStr, `,"size":{"w":%d,"h":%d}`, *width, *height)
+	}
+
+	jsonStr.WriteByte('}')
+	return jsonStr.Bytes(), nil
+}
+
+// builderBeachfront for building json object for Beachfront bidder
+func builderBeachfront(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+	jsonStr.WriteByte('{')
+
+	if appID, ok := getString(params.FieldMap["appId"]); !ok {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "appId")
+	} else {
+		fmt.Fprintf(&jsonStr, `"appId":"%s",`, appID)
+	}
+
+	if bidfloor, ok := getFloat64(params.FieldMap["bidfloor"]); !ok {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "bidfloor")
+	} else {
+		fmt.Fprintf(&jsonStr, `"bidfloor":%f`, bidfloor)
+	}
+
+	//As per beachfront bidder parameter documentation, by default the video response will be a nurl URL.
+	//OpenWrap platform currently only consumes 'adm' responses so setting hardcoded value 'adm' for videoResponseType.
+	jsonStr.WriteString(`,"videoResponseType":"adm"`)
+
+	jsonStr.WriteByte('}')
+	return jsonStr.Bytes(), nil
+}
+
+// builderSmaato for building json object for Smaato bidder
+func builderSmaato(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+	jsonStr.WriteByte('{')
+
+	if publisherID, ok := getString(params.FieldMap["publisherId"]); !ok {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "publisherId")
+	} else {
+		fmt.Fprintf(&jsonStr, `"publisherId":"%s",`, publisherID)
+	}
+
+	if adspaceID, ok := getString(params.FieldMap["adspaceId"]); !ok {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "adspaceId")
+	} else {
+		fmt.Fprintf(&jsonStr, `"adspaceId":"%s"`, adspaceID)
+	}
+
+	jsonStr.WriteByte('}')
+	return jsonStr.Bytes(), nil
+}
+
+// builderSmartAdServer for building json object for SmartAdServer bidder
+func builderSmartAdServer(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+	jsonStr.WriteByte('{')
+
+	if networkID, ok := getInt(params.FieldMap["networkId"]); !ok {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "networkId")
+	} else {
+		fmt.Fprintf(&jsonStr, `"networkId":%d`, networkID)
+	}
+
+	// siteId, pageId and formatId are dependent on each other and hence need to be sent only when all three are present
+	siteID, isSiteIDPresent := getInt(params.FieldMap["siteId"])
+	pageID, isPageIDPresent := getInt(params.FieldMap["pageId"])
+	formatID, isFormatIDPresent := getInt(params.FieldMap["formatId"])
+
+	if isSiteIDPresent && isPageIDPresent && isFormatIDPresent {
+		// all three are valid integers
+		fmt.Fprintf(&jsonStr, `,"siteId":%d,"pageId":%d,"formatId":%d`, siteID, pageID, formatID)
+	} else {
+	}
+
+	jsonStr.WriteByte('}')
+	return jsonStr.Bytes(), nil
+}
+
+// builderGumGum for building json object for GumGum bidder
+func builderGumGum(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+
+	if zone, ok := getString(params.FieldMap["zone"]); !ok {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "zone")
+	} else {
+		fmt.Fprintf(&jsonStr, `{"zone":"%s"}`, zone)
+	}
+
+	return jsonStr.Bytes(), nil
+}
+
+// builderPangle for building json object for Pangle bidder
+func builderPangle(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+
+	token, ok := getString(params.FieldMap["token"])
+	if !ok {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "token")
+	}
+
+	appID, appIDPresent := getString(params.FieldMap["appid"])
+	placementID, placementIDPresent := getString(params.FieldMap["placementid"])
+
+	if appIDPresent && !placementIDPresent {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "placementid")
+	} else if !appIDPresent && placementIDPresent {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "appid")
+	}
+
+	if appIDPresent && placementIDPresent {
+		fmt.Fprintf(&jsonStr, `{"token":"%s","placementid":"%s","appid":"%s"}`, token, placementID, appID)
+	} else {
+		fmt.Fprintf(&jsonStr, `{"token":"%s"}`, token)
+	}
+
+	return jsonStr.Bytes(), nil
+}
+
+// builderSonobi for building json object for Sonobi bidder
+func builderSonobi(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+
+	tagID, _ := getString(params.FieldMap["ad_unit"]) //checking with ad_unit value
+	if len(tagID) == 0 {
+		tagID, _ = getString(params.FieldMap["placement_id"]) //checking with placement_id
+	}
+
+	if len(tagID) == 0 {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "'ad_unit' or 'placement_id'")
+	}
+
+	fmt.Fprintf(&jsonStr, `{"TagID":"%s"}`, tagID)
+	return jsonStr.Bytes(), nil
+}
+
+// builderAdform for building json object for Adform bidder
+func builderAdform(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+
+	if mid, ok := getInt(params.FieldMap["mid"]); ok {
+		fmt.Fprintf(&jsonStr, `{"mid":%d}`, mid)
+	} else {
+		inv, invPresent := getInt(params.FieldMap["inv"])
+		mname, mnamePresent := getString(params.FieldMap["mname"])
+
+		if !(invPresent && mnamePresent) {
+			return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, "'mid' and 'inv'")
+		}
+
+		fmt.Fprintf(&jsonStr, `{"inv":%d,"mname":"%s"}`, inv, mname)
+	}
+
+	return jsonStr.Bytes(), nil
+}
+
+// builderCriteo for building json object for Criteo bidder
+func builderCriteo(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+
+	anyOf := []string{"zoneId", "networkId"} // not checking zoneid and networkid as client side uses only zoneId and networkId
+	for _, param := range anyOf {
+		if val, ok := getInt(params.FieldMap[param]); ok {
+			fmt.Fprintf(&jsonStr, `{"%s":%d}`, param, val)
+			break
+		}
+	}
+
+	if jsonStr.Len() == 0 {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, anyOf)
+	}
+
+	return jsonStr.Bytes(), nil
+}
+
+// builderOutbrain for building json object for Outbrain bidder
+func builderOutbrain(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+	publisherMap, ok := params.FieldMap["publisher"]
+	if !ok {
+		return nil, nil
+	}
+
+	publisher, ok := publisherMap.(map[string]interface{})
+	if !ok {
+		return nil, nil
+	}
+
+	id, ok := getString(publisher["id"])
+	if !ok {
+		return nil, nil
+	}
+
+	fmt.Fprintf(&jsonStr, `{"publisher":{"id":"%s"}}`, id)
+	return jsonStr.Bytes(), nil
+}
+
+func builderApacdex(params BidderParameters) (json.RawMessage, error) {
+	jsonStr := bytes.Buffer{}
+	jsonStr.WriteByte('{')
+	anyOf := []string{BidderParamApacdex_siteId, BidderParamApacdex_placementId}
+	for _, param := range anyOf {
+		if key, ok := getString(params.FieldMap[param]); ok {
+			fmt.Fprintf(&jsonStr, `"%s":"%s"`, param, key)
+			break
+		}
+	}
+	//  len=1 (no mandatory params present)
+	if jsonStr.Len() == 1 {
+		return nil, fmt.Errorf(errMandatoryParameterMissingFormat, params.AdapterName, anyOf)
+	}
+	if floorPrice, ok := getFloat64(params.FieldMap[BidderParamApacdex_floorPrice]); ok {
+		fmt.Fprintf(&jsonStr, `,"%s":%g`, BidderParamApacdex_floorPrice, floorPrice)
+	}
+	//geo object(hybrid param)
+	if value, ok := params.FieldMap[BidderParamApacdex_geo]; ok {
+		if geoJson, err := json.Marshal(value); err == nil {
+			fmt.Fprintf(&jsonStr, `,"%s":%s`, BidderParamApacdex_geo, string(geoJson))
+		}
+	}
+	jsonStr.WriteByte('}')
+	return jsonStr.Bytes(), nil
+}
diff --git a/modules/pubmatic/openwrap/adapters/builder.go b/modules/pubmatic/openwrap/adapters/builder.go
new file mode 100644
index 000000000..1ae822cc4
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/builder.go
@@ -0,0 +1,73 @@
+package adapters
+
+import (
+	"encoding/json"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/config"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// BidderParameters provides all properties requires for bidder to generate bidder json
+type BidderParameters struct {
+	//AdapterName, BidderCode should be passed in builder function
+	ReqID                   string
+	AdapterName, BidderCode string
+	ImpExt                  *models.ImpExtension
+
+	//bidder specific parameters
+	FieldMap      JSONObject
+	Width, Height *int64
+	SlotKey       string
+}
+
+// JSONObject generic JSON object
+type JSONObject = map[string]interface{}
+
+// builder callback type
+type builder func(params BidderParameters) (json.RawMessage, error)
+
+// bidderBuilderFactor
+var _bidderBuilderFactory map[string]builder
+
+// initBidderBuilderFactory initialise all hard coded bidder builder
+func initBidderBuilderFactory() {
+	_bidderBuilderFactory = map[string]builder{
+		string(openrtb_ext.BidderAdform):         builderAdform,
+		string(openrtb_ext.BidderAdf):            builderAdform,
+		string(openrtb_ext.BidderAppnexus):       builderAppNexus,
+		string(openrtb_ext.BidderBeachfront):     builderBeachfront,
+		string(openrtb_ext.BidderCriteo):         builderCriteo,
+		string(openrtb_ext.BidderGumGum):         builderGumGum,
+		string(openrtb_ext.BidderImprovedigital): builderImproveDigital,
+		string(openrtb_ext.BidderIx):             builderIndex,
+		string(openrtb_ext.BidderOpenx):          builderOpenx,
+		string(openrtb_ext.BidderOutbrain):       builderOutbrain,
+		string(openrtb_ext.BidderPangle):         builderPangle,
+		string(openrtb_ext.BidderPubmatic):       builderPubMatic, /*this only gets used incase of hybrid case*/
+		string(openrtb_ext.BidderPulsepoint):     builderPulsePoint,
+		string(openrtb_ext.BidderRubicon):        builderRubicon,
+		string(openrtb_ext.BidderSmaato):         builderSmaato,
+		string(openrtb_ext.BidderSmartAdserver):  builderSmartAdServer,
+		string(openrtb_ext.BidderSonobi):         builderSonobi,
+		string(openrtb_ext.BidderSovrn):          builderSovrn,
+		string(openrtb_ext.BidderApacdex):        builderApacdex,
+	}
+}
+
+// getBuilder will return core bidder hard coded builder, if not found then returns default builder
+func getBuilder(adapterName string) builder {
+	//resolve hardcoded bidder alias
+	adapterName = ResolveOWBidder(adapterName)
+
+	if callback, ok := _bidderBuilderFactory[adapterName]; ok {
+		return callback
+	}
+	return defaultBuilder
+}
+
+// InitBidders will initialise bidder alias, default bidder parameter json and builders for each bidder
+func InitBidders(cfg config.Config) error {
+	initBidderBuilderFactory()
+	return parseBidderParams(cfg)
+}
diff --git a/modules/pubmatic/openwrap/adapters/constant.go b/modules/pubmatic/openwrap/adapters/constant.go
new file mode 100644
index 000000000..9dee13569
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/constant.go
@@ -0,0 +1,30 @@
+package adapters
+
+const (
+	errMandatoryParameterMissingFormat     = `adapter:[%s] message:[missing_mandatory_param] key:[%v]`
+	errInvalidS2SPartnerFormat             = `adapter:[%s] message:[invalid_s2s_adapter] slotkey:[%s]`
+	errDefaultBidderParameterMissingFormat = `adapter:[%s] message:[default_bidder_missing_manadatory_param] param:[%s] applicable-key:[%s]`
+)
+
+var ignoreAppnexusKeys = map[string]bool{
+	"generate_ad_pod_id": true,
+	"invCode":            true,
+	"inv_code":           true,
+	"keywords":           true,
+	"member":             true,
+	"placementId":        true,
+	"placement_id":       true,
+	"private_sizes":      true,
+	"reserve":            true,
+	"usePaymentRule":     true,
+	"use_pmt_rule":       true,
+	"video":              true,
+}
+
+// Bidder Params
+const (
+	BidderParamApacdex_siteId      = "siteId"
+	BidderParamApacdex_placementId = "placementId"
+	BidderParamApacdex_geo         = "geo"
+	BidderParamApacdex_floorPrice  = "floorPrice"
+)
diff --git a/modules/pubmatic/openwrap/adapters/converter.go b/modules/pubmatic/openwrap/adapters/converter.go
new file mode 100644
index 000000000..3bc2ad067
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/converter.go
@@ -0,0 +1,38 @@
+package adapters
+
+import (
+	"encoding/json"
+)
+
+// convertExtToFieldMap converts bidder json parameter to object
+func convertExtToFieldMap(bidderName string, ext json.RawMessage) JSONObject {
+	fieldmap := JSONObject{}
+	if err := json.Unmarshal(ext, &fieldmap); err != nil {
+	}
+	return fieldmap
+}
+
+// FixBidderParams will fixes bidder parameter types for prebid auction endpoint(UOE-5744)
+func FixBidderParams(reqID, adapterName, bidderCode string, ext json.RawMessage) (json.RawMessage, error) {
+	/*
+		//check if fixing bidder parameters really required
+		if err := router.GetBidderParamValidator().Validate(openrtb_ext.BidderName(bidderCode), ext); err == nil {
+			//fixing bidder parameter datatype is not required
+			return ext, nil
+		}
+	*/
+
+	//convert jsonstring to jsonobj
+	fieldMap := convertExtToFieldMap(bidderCode, ext)
+
+	//get callback function and execute it
+	callback := getBuilder(adapterName)
+
+	//executing callback function
+	return callback(BidderParameters{
+		ReqID:       reqID,
+		AdapterName: adapterName, //actual partner name
+		BidderCode:  bidderCode,  //alias bidder name
+		FieldMap:    fieldMap,
+	})
+}
diff --git a/modules/pubmatic/openwrap/adapters/default_bidder.go b/modules/pubmatic/openwrap/adapters/default_bidder.go
new file mode 100644
index 000000000..a29e2ede2
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/default_bidder.go
@@ -0,0 +1,189 @@
+package adapters
+
+import (
+	"encoding/json"
+	"errors"
+	"fmt"
+
+	"strconv"
+	"strings"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+// Map containing []ParameterMapping for all partners (partner name)
+var adapterParams map[string]map[string]*ParameterMapping
+
+func prepareBidParamJSONDefault(params BidderParameters) (json.RawMessage, error) {
+	bidderParamMapping, present := adapterParams[params.AdapterName]
+	if !present {
+		return nil, fmt.Errorf(errInvalidS2SPartnerFormat, params.AdapterName, params.SlotKey)
+	}
+
+	bidderParams := make(map[string]interface{})
+	for _, mapping := range bidderParamMapping {
+		paramValue, present := params.FieldMap[mapping.KeyName]
+		if !present && mapping.DefaultValue != nil {
+			present = true
+			paramValue = mapping.DefaultValue
+		}
+
+		if !present && mapping.Required {
+			return nil, fmt.Errorf(errDefaultBidderParameterMissingFormat, params.AdapterName, mapping.BidderParamName, mapping.KeyName)
+		}
+
+		if present {
+			err := addBidParam(bidderParams, mapping.BidderParamName, mapping.Datatype, paramValue)
+			if err != nil && mapping.Required {
+				return nil, err
+			}
+		}
+	}
+
+	jsonBuf, err := json.Marshal(bidderParams)
+	if err != nil {
+		return nil, err
+	}
+
+	return jsonBuf, nil
+}
+
+func addBidParam(bidParams map[string]interface{}, name string, paramType string, value interface{}) error {
+	dataType := getDataType(paramType)
+
+	switch dataType {
+	case models.DataTypeInteger:
+		//DataTypeInteger
+		intVal, err := strconv.Atoi(fmt.Sprintf("%v", value))
+		if err != nil {
+			return err
+		}
+		bidParams[name] = intVal
+	case models.DataTypeFloat:
+		//DataTypeFloat
+		floatVal, err := strconv.ParseFloat(fmt.Sprintf("%v", value), 64)
+		if err != nil {
+			return err
+		}
+		bidParams[name] = toFixed(floatVal, FloatValuePrecision)
+	case models.DataTypeString:
+		//DataTypeString
+		val := fmt.Sprintf("%v", value)
+		if val == "" {
+			return errors.New("value is empty")
+		}
+		bidParams[name] = fmt.Sprintf("%v", value)
+	case models.DataTypeBoolean:
+		//DataTypeBoolean
+		boolVal, err := strconv.ParseBool(fmt.Sprintf("%v", value))
+		if err != nil {
+			return err
+		}
+		bidParams[name] = boolVal
+	case models.DataTypeArrayOfIntegers:
+		//Array of DataTypeInteger
+		switch v := value.(type) {
+		case string:
+			var arr []int
+			err := json.Unmarshal([]byte(value.(string)), &arr)
+			if err != nil {
+				return err
+			}
+			bidParams[name] = arr
+		case []int:
+			bidParams[name] = v
+		case []interface{}:
+			//Unmarshal's default type for array. Refer https://pkg.go.dev/encoding/json#Unmarshal
+			arr := make([]int, 0, len(v))
+			for _, elem := range v {
+				elemFloat, ok := elem.(float64) //Unmarshal's default type interface values
+				if !ok {
+					return fmt.Errorf("ErrTypeCastFailed %s float64 %v", name, elem)
+				}
+				arr = append(arr, int(elemFloat))
+			}
+
+			bidParams[name] = arr
+		default:
+			errMsg := fmt.Sprintf("unknown array type %T!\n", v)
+			return errors.New(errMsg)
+		}
+	case models.DataTypeArrayOfFloats:
+		//Array of DataTypeFloat
+		switch v := value.(type) {
+		case string:
+			var arr []float64
+			err := json.Unmarshal([]byte(value.(string)), &arr)
+			if err != nil {
+				return err
+			}
+			bidParams[name] = arr
+		case []float64:
+			bidParams[name] = v
+		case []interface{}:
+			//Unmarshal's default type for array. Refer https://pkg.go.dev/encoding/json#Unmarshal
+			arr := make([]float64, 0, len(v))
+			for _, elem := range v {
+				elemFloat, ok := elem.(float64) //Unmarshal's default type interface values
+				if !ok {
+					return fmt.Errorf("ErrTypeCastFailed %s float64 %v", name, elem)
+				}
+				arr = append(arr, elemFloat)
+			}
+
+			bidParams[name] = arr
+		default:
+			errMsg := fmt.Sprintf("unknown array type %T!\n", v)
+			return errors.New(errMsg)
+		}
+	case models.DataTypeArrayOfStrings:
+		//Array of DataTypeString
+		switch v := value.(type) {
+		case string:
+			var arr []string
+			stringValue := strings.Trim(value.(string), "[]")
+			arr = strings.Split(stringValue, ",")
+			bidParams[name] = arr
+		case []string:
+			bidParams[name] = v
+		case []interface{}:
+			arr := make([]string, 0, len(v))
+			for _, elem := range v {
+				elemStr, ok := elem.(string)
+				if !ok {
+					return fmt.Errorf("ErrTypeCastFailed %s float64 %v", name, elem)
+				}
+				arr = append(arr, elemStr)
+			}
+			bidParams[name] = arr
+		default:
+			errMsg := fmt.Sprintf("unknown array type %T!\n", v)
+			return errors.New(errMsg)
+		}
+	default:
+		bidParams[name] = fmt.Sprintf("%v", value)
+	}
+
+	return nil
+}
+
+func getDataType(paramType string) int {
+	switch paramType {
+	case "string":
+		return models.DataTypeString
+	case "number":
+		return models.DataTypeFloat
+	case "integer":
+		return models.DataTypeInteger
+	case "boolean":
+		return models.DataTypeBoolean
+	case "[]string":
+		return models.DataTypeArrayOfStrings
+	case "[]integer":
+		return models.DataTypeArrayOfIntegers
+	case "[]number":
+		return models.DataTypeArrayOfFloats
+	default:
+		return models.DataTypeUnknown
+	}
+}
diff --git a/modules/pubmatic/openwrap/adapters/default_bidder_parameter.go b/modules/pubmatic/openwrap/adapters/default_bidder_parameter.go
new file mode 100644
index 000000000..0799a7b9e
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/default_bidder_parameter.go
@@ -0,0 +1,210 @@
+package adapters
+
+import (
+	"encoding/json"
+	"errors"
+	"fmt"
+
+	"os"
+	"path/filepath"
+	"strings"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/config"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// BidderParamJSON defines type as per JSON schema files in static/bidder-param
+type BidderParamJSON struct {
+	Title        string                     `json:"title"`
+	Properties   map[string]BidderParameter `json:"properties"`
+	Required     []string                   `json:"required"`
+	OneOf        interface{}                `json:"oneOf"`
+	Not          interface{}                `json:"not"`
+	AnyOf        interface{}                `json:"anyOf"`
+	Dependencies interface{}                `json:"dependencies"`
+}
+
+// BidderParameter defines properties type as per JSON schema files in static/bidder-param
+type BidderParameter struct {
+	Type  interface{}    `json:"type"`
+	Items ArrayItemsType `json:"items"`
+}
+
+// ParameterMapping holds mapping information for bidder parameter
+type ParameterMapping struct {
+	BidderParamName string      `json:"bidderParameterName,omitempty"`
+	KeyName         string      `json:"keyName,omitempty"`
+	Datatype        string      `json:"type,omitempty"`
+	Required        bool        `json:"required,omitempty"`
+	DefaultValue    interface{} `json:"defaultValue,omitempty"`
+}
+
+// ArrayItemsType defines items type as per JSON schema files in static/bidder-param
+type ArrayItemsType struct {
+	Type string `json:"type"`
+}
+
+func parseBidderParams(cfg config.Config) error {
+	schemas, err := parseBidderSchemaDefinitions()
+	if err != nil {
+		return err
+	}
+
+	owParameterMappings := parseOpenWrapParameterMappings()
+	if owParameterMappings == nil {
+		return errors.New("BidderParamMapping is not defined in config")
+	}
+
+	adapterParams = make(map[string]map[string]*ParameterMapping)
+
+	for bidderName, jsonSchema := range schemas {
+
+		if jsonSchema.OneOf != nil || jsonSchema.AnyOf != nil || jsonSchema.Not != nil || jsonSchema.Dependencies != nil {
+			//JSON schema definition is complex and we rely on case block for this bidder
+			continue
+		}
+
+		parameters := make(map[string]*ParameterMapping)
+		for propertyName, propertyDef := range jsonSchema.Properties {
+			bidderParam := ParameterMapping{}
+			bidderParam.BidderParamName = propertyName
+			bidderParam.KeyName = propertyName
+			bidderParam.Datatype = getType(propertyDef)
+			bidderParam.Required = false
+
+			parameters[propertyName] = &bidderParam
+		}
+
+		owParameterOverrides := owParameterMappings[bidderName]
+		for propertyName, propertyDef := range owParameterOverrides {
+			if parameters[propertyName] != nil {
+				parameter := parameters[propertyName]
+				if propertyDef.BidderParamName != "" {
+					parameter.BidderParamName = propertyDef.BidderParamName
+				}
+				if propertyDef.KeyName != "" {
+					parameter.KeyName = propertyDef.KeyName
+				}
+				if propertyDef.Datatype != "" {
+					parameter.Datatype = propertyDef.Datatype
+				}
+				if propertyDef.DefaultValue != nil {
+					parameter.DefaultValue = propertyDef.DefaultValue
+				}
+				parameter.Required = propertyDef.Required
+			} else {
+			}
+		}
+
+		for _, propertyName := range jsonSchema.Required {
+			if parameters[propertyName] != nil {
+				parameters[propertyName].Required = true
+			} else {
+			}
+		}
+
+		adapterParams[bidderName] = parameters
+	}
+
+	return nil
+}
+
+func getType(param BidderParameter) string {
+	tp := ""
+	switch param.Type.(type) {
+	case string:
+		tp = param.Type.(string)
+	case []string:
+		v := param.Type.([]string)
+		tp = v[0]
+		for _, typ := range v {
+			if typ == "string" {
+				tp = "string"
+			}
+		}
+	}
+	if tp == "array" {
+		tp = fmt.Sprintf("[]%s", param.Items.Type)
+	}
+	return tp
+}
+
+func parseBidderSchemaDefinitions() (map[string]*BidderParamJSON, error) {
+	schemas := make(map[string]*BidderParamJSON)
+
+	schemaDirectory := getBidderParamsDirectory()
+	if schemaDirectory == "" {
+		return schemas, errors.New("error failed to parse bidder params files")
+	}
+
+	fileInfos, err := os.ReadDir(schemaDirectory)
+	if err != nil {
+		return schemas, errors.New("error failed to parse bidder params files" + err.Error())
+	}
+
+	bidderMap := openrtb_ext.BuildBidderMap()
+
+	for _, fileInfo := range fileInfos {
+		bidderName := strings.TrimSuffix(fileInfo.Name(), ".json")
+		if _, isValid := bidderMap[bidderName]; !isValid {
+			continue
+		}
+		_, err := filepath.Abs(filepath.Join(schemaDirectory, fileInfo.Name()))
+		if err != nil {
+			continue
+		}
+		fileBytes, err := os.ReadFile(fmt.Sprintf("%s/%s", schemaDirectory, fileInfo.Name()))
+		if err != nil {
+			continue
+		}
+
+		var bidderParamJSON BidderParamJSON
+		err = json.Unmarshal(fileBytes, &bidderParamJSON)
+		if err != nil {
+			continue
+		}
+
+		schemas[bidderName] = &bidderParamJSON
+	}
+
+	if len(schemas) == 0 {
+		return schemas, errors.New("Error failed to parse bidder params files")
+	}
+
+	return schemas, nil
+}
+
+func getBidderParamsDirectory() string {
+	schemaDirectory := "./static/bidder-params"
+	if isDirectoryExists(schemaDirectory) {
+		return schemaDirectory
+	}
+
+	return ""
+}
+
+func parseOpenWrapParameterMappings() map[string]map[string]*ParameterMapping {
+	return map[string]map[string]*ParameterMapping{
+		"dmx": {
+			"tagid": {
+				KeyName: "dmxid",
+			},
+		},
+		"vrtcal": {
+			"just_an_unused_vrtcal_param": {
+				KeyName:      "dummyParam",
+				DefaultValue: "1",
+			},
+		},
+		"grid": {
+			"uid": {
+				Required: true,
+			},
+		},
+		"adkernel": {
+			"zoneId": {
+				Datatype: "integer",
+			},
+		},
+	}
+}
diff --git a/modules/pubmatic/openwrap/adapters/pubmatic.go b/modules/pubmatic/openwrap/adapters/pubmatic.go
new file mode 100644
index 000000000..5f9bc4514
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/pubmatic.go
@@ -0,0 +1 @@
+package adapters
diff --git a/modules/pubmatic/openwrap/adapters/tests/hybrid_bidders.json b/modules/pubmatic/openwrap/adapters/tests/hybrid_bidders.json
new file mode 100644
index 000000000..02f3ba27a
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/tests/hybrid_bidders.json
@@ -0,0 +1,352 @@
+[
+    {
+        "name": "pubmatic_client_json",
+        "args": {
+            "adapterName": "pubmatic",
+            "requestJSON": {
+                "wiid": "147dc5a6-cef1-4733-b7f4-fd4447bf9393-difid",
+                "publisherId": "5890",
+                "adSlot": "/43743431/DMDemo@728x90:0",
+                "kadfloor": "1.0",
+                "wrapper": {
+                    "profile": 8671,
+                    "version": 4
+                }
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "adSlot": "/43743431/DMDemo@728x90:0",
+                "publisherId": "5890",
+                "kadfloor": "1.0",
+                "wrapper": {
+                    "profile": 8671,
+                    "version": 4
+                }
+            }
+        }
+    },
+    {
+        "name": "appnexus_client_json",
+        "args": {
+            "adapterName": "appnexus",
+            "requestJSON": {
+                "placementId": "9880618"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "placementId": 9880618
+            }
+        }
+    },
+    {
+        "name": "districtm_client_json",
+        "args": {
+            "adapterName": "districtm",
+            "requestJSON": {
+                "placementId": "9880618"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "placementId": 9880618
+            }
+        }
+    },
+    {
+        "name": "ix_client_json",
+        "args": {
+            "adapterName": "ix",
+            "requestJSON": {
+                "siteId": "171906",
+                "id": "123",
+                "size": [
+                    160,
+                    600
+                ]
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "siteId": "171906",
+                "size": [
+                    160,
+                    600
+                ]
+            }
+        }
+    },
+    {
+        "name": "pulsepoint_client_json",
+        "args": {
+            "adapterName": "pulsepoint",
+            "requestJSON": {
+                "ct": "1300",
+                "cp": "521732",
+                "cf": "160x600"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "cp": 521732,
+                "ct": 1300,
+                "cf": "160x600"
+            }
+        }
+    },
+    {
+        "name": "rubicon_client_json",
+        "args": {
+            "adapterName": "rubicon",
+            "requestJSON": {
+                "zoneId": "498816",
+                "siteId": "70608",
+                "video": {
+                    "playerHeight": "360",
+                    "size_id": "201",
+                    "playerWidth": "640",
+                    "language": "en"
+                },
+                "accountId": "97531"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "accountId": 97531,
+                "siteId": 70608,
+                "zoneId": 498816,
+                "video": {
+                    "playerWidth": 640,
+                    "playerHeight": 360,
+                    "size_id": 201,
+                    "language": "en"
+                }
+            }
+        }
+    },
+    {
+        "name": "openx_client_json",
+        "args": {
+            "adapterName": "openx",
+            "requestJSON": {
+                "unit": "539439964",
+                "delDomain": "se-demo-d.openx.net"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "delDomain": "se-demo-d.openx.net",
+                "unit": "539439964"
+            }
+        }
+    },
+    {
+        "name": "sovrn_client_json",
+        "args": {
+            "adapterName": "sovrn",
+            "requestJSON": {
+                "tagid": "14",
+                "bidfloor": 1.2
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "tagid": "14",
+                "bidfloor": 1.200000
+            }
+        }
+    },
+    {
+        "name": "improvedigital_client_json",
+        "args": {
+            "adapterName": "improvedigital",
+            "requestJSON": {
+                "placementId": "1234567",
+                "publisherId": "5890",
+                "size": {
+                    "w": 720,
+                    "h": 120
+                }
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "placementId": 1234567,
+                "size": {
+                    "w": 720,
+                    "h": 120
+                }
+            }
+        }
+    },
+    {
+        "name": "beachfront_client_json",
+        "args": {
+            "adapterName": "beachfront",
+            "requestJSON": {
+                "appId": "11bc5dd5-7421-4dd8-c926-40fa653bec83",
+                "bidfloor": "0.01"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "appId": "11bc5dd5-7421-4dd8-c926-40fa653bec83",
+                "bidfloor": 0.01,
+                "videoResponseType": "adm"
+            }
+        }
+    },
+    {
+        "name": "smaato_client_json",
+        "args": {
+            "adapterName": "smaato",
+            "requestJSON": {
+                "app": {
+                    "geo": {
+                        "lon": -88.80000305175781,
+                        "lat": 33.29999923706055
+                    },
+                    "ifa": "56700000-9cf0-22bd-b23e-46b96e40003a"
+                },
+                "adspaceId": "130563103",
+                "publisherId": "1100042525"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "adspaceId": "130563103",
+                "publisherId": "1100042525"
+            }
+        }
+    },
+    {
+        "name": "smartadserver_client_json",
+        "args": {
+            "adapterName": "smartadserver",
+            "requestJSON": {
+                "formatId": "84313",
+                "siteId": "317777",
+                "pageId": "1232599",
+                "domain": "http://ssb-us.smartadserver.com",
+                "networkId": "458"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "formatId": 84313,
+                "networkId": 458,
+                "pageId": 1232599,
+                "siteId": 317777
+            }
+        }
+    },
+    {
+        "name": "gumgum_client_json",
+        "args": {
+            "adapterName": "gumgum",
+            "requestJSON": {
+                "inSlot": "9",
+                "inScreen": "ggumtest",
+                "zone": "APAC1234"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "zone": "APAC1234"
+            }
+        }
+    },
+    {
+        "name": "pangle_client_json",
+        "args": {
+            "adapterName": "pangle",
+            "requestJSON": {
+                "placementid": "912340000",
+                "appid": "5123400",
+                "token": "sample_token"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "appid": "5123400",
+                "placementid": "912340000",
+                "token": "sample_token"
+            }
+        }
+    },
+    {
+        "name": "sonobi_client_json",
+        "args": {
+            "adapterName": "sonobi",
+            "requestJSON": {
+                "ad_unit": "/43743431/DMDemo",
+                "placement_id": "1a2b3c4d5e6f1a2b3c4d",
+                "hfa": "123"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "TagID": "/43743431/DMDemo"
+            }
+        }
+    },
+    {
+        "name": "adf_client_json",
+        "args": {
+            "adapterName": "adf",
+            "requestJSON": {
+                "inv": 1234,
+                "priceType": "gross",
+                "mid": 12345,
+                "mname": "Leaderboard",
+                "adxDomain": "adx.adform.net"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "mid": 12345
+            }
+        }
+    },
+    {
+        "name": "criteo_client_json",
+        "args": {
+            "adapterName": "criteo",
+            "requestJSON": {
+                "zoneId": "1023914"
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "zoneId": 1023914
+            }
+        }
+    },
+    {
+        "name": "apacdex_client_json",
+        "args": {
+            "adapterName": "apacdex",
+            "requestJSON": {
+                "siteId": "test123",
+                "floorPrice": 0.9333,
+                "geo": {
+                    "lat": 17.98928,
+                    "lon": 99.7741712,
+                    "accuracy": 20
+                }
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "siteId": "test123",
+                "floorPrice": 0.9333,
+                "geo": {
+                    "lat": 17.98928,
+                    "lon": 99.7741712,
+                    "accuracy": 20
+                }
+            }
+        }
+    }
+]
\ No newline at end of file
diff --git a/modules/pubmatic/openwrap/adapters/tests/s2s_bidders.json b/modules/pubmatic/openwrap/adapters/tests/s2s_bidders.json
new file mode 100644
index 000000000..183c84913
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/tests/s2s_bidders.json
@@ -0,0 +1,18 @@
+[
+    {
+        "name": "visx_client_json",
+        "args" : {
+            "adapterName": "visx",
+            "requestJSON": {
+                "uid": 123,
+                "size": [160, 600]
+            }
+        },
+        "want": {
+            "expectedJSON": {
+                "uid": 123,
+                "size": [160,600]
+            }
+        }
+    }
+]
\ No newline at end of file
diff --git a/modules/pubmatic/openwrap/adapters/util.go b/modules/pubmatic/openwrap/adapters/util.go
new file mode 100644
index 000000000..9b493d5ba
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/util.go
@@ -0,0 +1,177 @@
+package adapters
+
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"math"
+	"os"
+	"strconv"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+const FloatValuePrecision = 2
+
+func getKeywordStringForPartner(impExt *models.ImpExtension, partner string) string {
+	if impExt != nil && impExt.Bidder != nil {
+		bidder := impExt.Bidder[partner]
+		if nil != bidder && len(bidder.KeyWords) > 0 {
+			if byts, err := json.Marshal(bidder.KeyWords); err == nil {
+				return string(byts)
+			}
+		}
+	}
+	return ""
+}
+
+func toFixed(num float64, precision int) float64 {
+	output := math.Pow(10, float64(precision))
+	return float64(round(num*output)) / output
+}
+
+func round(num float64) int {
+	return int(num + math.Copysign(0.5, num))
+}
+
+func trimComma(buf *bytes.Buffer) {
+	b := buf.Bytes()
+	if len(b) > 0 && b[len(b)-1] == ',' {
+		b[len(b)-1] = ' '
+	}
+}
+
+func isDirectoryExists(location string) bool {
+	if _, err := os.Stat(location); err == nil {
+		// path to schemaDirectory exists
+		return true
+	}
+	return false
+}
+
+// ----------- datatype utilities ----------
+func getInt(val interface{}) (int, bool) {
+	if val == nil {
+		return 0, false
+	}
+
+	var result int
+	switch v := val.(type) {
+	case int:
+		result = v
+	case string:
+		iVal, err := strconv.Atoi(v)
+		if err != nil {
+			return 0, false
+		}
+		result = iVal
+	case float64:
+		result = int(v)
+	case float32:
+		result = int(v)
+	default:
+		iVal, err := strconv.Atoi(fmt.Sprint(v))
+		if err != nil {
+			return 0, false
+		}
+		result = iVal
+	}
+	return result, true
+}
+
+func getFloat64(val interface{}) (float64, bool) {
+	if val == nil {
+		return 0, false
+	}
+
+	var result float64
+	switch v := val.(type) {
+	case float64:
+		result = v
+	case string:
+		fVal, err := strconv.ParseFloat(v, 64)
+		if err != nil {
+			return 0, false
+		}
+		result = fVal
+	case int:
+		result = float64(v)
+	default:
+		fVal, err := strconv.ParseFloat(fmt.Sprint(v), 64)
+		if err != nil {
+			return 0, false
+		}
+		result = fVal
+	}
+	return result, true
+}
+
+func getString(val interface{}) (string, bool) {
+	if val == nil {
+		return "", false
+	}
+
+	var result string
+	switch v := val.(type) {
+	case string:
+		result = v
+	case int:
+		result = strconv.Itoa(v)
+	case map[string]interface{}:
+		val, err := json.Marshal(v)
+		if err != nil {
+			return "", false
+		}
+		result = string(val)
+	default:
+		result = fmt.Sprint(val)
+	}
+
+	return result, true
+}
+
+func getBool(val interface{}) (bool, bool) {
+	if val == nil {
+		return false, false
+	}
+
+	var result bool
+	switch v := val.(type) {
+	case bool:
+		result = v
+	case string:
+		bVal, err := strconv.ParseBool(v)
+		if err != nil {
+			return false, false
+		}
+		result = bVal
+	default:
+		bVal, err := strconv.ParseBool(fmt.Sprint(v))
+		if err != nil {
+			return false, false
+		}
+		result = bVal
+	}
+
+	return result, true
+}
+
+func getIntArray(val interface{}) ([]int, bool) {
+	if val == nil {
+		return nil, false
+	}
+
+	valArray, ok := val.([]interface{})
+	if !ok {
+		return nil, false
+	}
+
+	result := make([]int, 0)
+	for _, x := range valArray {
+		if val, ok := getInt(x); ok {
+			result = append(result, val)
+		}
+	}
+
+	return result, true
+}
diff --git a/modules/pubmatic/openwrap/adapters/vastbidder.go b/modules/pubmatic/openwrap/adapters/vastbidder.go
new file mode 100644
index 000000000..dfbd11bb5
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapters/vastbidder.go
@@ -0,0 +1,83 @@
+package adapters
+
+import (
+	"encoding/json"
+	"strconv"
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func PrepareVASTBidderParamJSON(request *openrtb2.BidRequest, imp *openrtb2.Imp,
+	pubVASTTags models.PublisherVASTTags,
+	matchedSlotKeys []string, slotMap map[string]models.SlotMapping,
+	adpod *models.AdPod) json.RawMessage {
+
+	if nil == imp.Video {
+		return nil
+	}
+
+	bidderExt := openrtb_ext.ExtImpVASTBidder{}
+	bidderExt.Tags = make([]*openrtb_ext.ExtImpVASTBidderTag, len(matchedSlotKeys))
+	var tagIndex int = 0
+	for _, slotKey := range matchedSlotKeys {
+		vastTagID := getVASTTagID(slotKey)
+		if 0 == vastTagID {
+			continue
+		}
+
+		vastTag, ok := pubVASTTags[vastTagID]
+		if false == ok {
+			continue
+		}
+
+		slotMappingObj, ok := slotMap[strings.ToLower(slotKey)]
+		if !ok {
+			continue
+		}
+
+		mapping := slotMappingObj.SlotMappings
+
+		//adding mapping parameters as it is in ext.bidder
+		params := mapping
+		/*
+			params := make(map[string]interface{})
+			// Copy from the original map of for slot key to the target map
+			for key, value := range mapping {
+				params[key] = value
+			}
+		*/
+
+		//prepare bidder ext json here
+		bidderExt.Tags[tagIndex] = &openrtb_ext.ExtImpVASTBidderTag{
+			//TagID:    strconv.Itoa(vastTag.ID),
+			TagID:    slotKey,
+			URL:      vastTag.URL,
+			Duration: vastTag.Duration,
+			Price:    vastTag.Price,
+			Params:   params,
+		}
+		tagIndex++
+	}
+
+	if tagIndex > 0 {
+		//If any vast tags found then create impression ext for vast bidder.
+		bidderExt.Tags = bidderExt.Tags[:tagIndex]
+		bidParamBuf, _ := json.Marshal(bidderExt)
+		return bidParamBuf
+	}
+	return nil
+}
+
+// getVASTTagID returns VASTTag ID details from slot key
+func getVASTTagID(key string) int {
+	index := strings.LastIndex(key, "@")
+	if -1 == index {
+		return 0
+	}
+	id, _ := strconv.Atoi(key[index+1:])
+	return id
+}
diff --git a/modules/pubmatic/openwrap/adapterthrottle.go b/modules/pubmatic/openwrap/adapterthrottle.go
new file mode 100644
index 000000000..41bebb1c9
--- /dev/null
+++ b/modules/pubmatic/openwrap/adapterthrottle.go
@@ -0,0 +1,52 @@
+package openwrap
+
+import (
+	"math/rand"
+	"strconv"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+// GetAdapterThrottleMap creates map of adapter and bool value which tells whether the adapter should be throtled or not
+func GetAdapterThrottleMap(partnerConfigMap map[int]map[string]string) (map[string]struct{}, bool) {
+	adapterThrottleMap := make(map[string]struct{})
+	allPartnersThrottledFlag := true
+	for _, partnerConfig := range partnerConfigMap {
+		if partnerConfig[models.SERVER_SIDE_FLAG] != "1" {
+			continue
+		}
+		if ThrottleAdapter(partnerConfig) {
+			adapterThrottleMap[partnerConfig[models.BidderCode]] = struct{}{}
+		} else if allPartnersThrottledFlag {
+			allPartnersThrottledFlag = false
+		}
+	}
+
+	return adapterThrottleMap, allPartnersThrottledFlag
+}
+
+// ThrottleAdapter this function returns bool value for whether a adapter should be throttled or not
+func ThrottleAdapter(partnerConfig map[string]string) bool {
+	if partnerConfig[models.THROTTLE] == "100" || partnerConfig[models.THROTTLE] == "" {
+		return false
+	}
+
+	if partnerConfig[models.THROTTLE] == "0" {
+		return true
+	}
+
+	//else check throttle value based on random no
+	throttle, _ := strconv.ParseFloat(partnerConfig[models.THROTTLE], 64)
+	throttle = 100 - throttle
+
+	randomNumberBelow100 := GetRandomNumberBelow100()
+	return !(float64(randomNumberBelow100) >= throttle)
+}
+
+var GetRandomNumberBelow100 = func() int {
+	return rand.Intn(99)
+}
+
+var GetRandomNumberIn1To100 = func() int {
+	return rand.Intn(100) + 1
+}
diff --git a/modules/pubmatic/openwrap/adunitconfig/app.go b/modules/pubmatic/openwrap/adunitconfig/app.go
new file mode 100644
index 000000000..3b329b278
--- /dev/null
+++ b/modules/pubmatic/openwrap/adunitconfig/app.go
@@ -0,0 +1,108 @@
+package adunitconfig
+
+import (
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+func ReplaceAppObjectFromAdUnitConfig(rCtx models.RequestCtx, app *openrtb2.App) {
+	if app == nil {
+		return
+	}
+
+	var adUnitCfg *adunitconfig.AdConfig
+	for _, impCtx := range rCtx.ImpBidCtx {
+		if impCtx.BannerAdUnitCtx.AppliedSlotAdUnitConfig != nil {
+			adUnitCfg = impCtx.BannerAdUnitCtx.AppliedSlotAdUnitConfig
+			break
+		}
+		if impCtx.VideoAdUnitCtx.AppliedSlotAdUnitConfig != nil {
+			adUnitCfg = impCtx.VideoAdUnitCtx.AppliedSlotAdUnitConfig
+			break
+		}
+	}
+
+	if adUnitCfg == nil || adUnitCfg.App == nil {
+		return
+	}
+
+	if app.ID == "" {
+		app.ID = adUnitCfg.App.ID
+	}
+
+	if app.Name == "" {
+		app.Name = adUnitCfg.App.Name
+	}
+
+	if app.Bundle == "" {
+		app.Bundle = adUnitCfg.App.Bundle
+	}
+
+	if app.Domain == "" {
+		app.Domain = adUnitCfg.App.Domain
+	}
+
+	if app.StoreURL == "" {
+		app.StoreURL = adUnitCfg.App.StoreURL
+	}
+
+	if len(app.Cat) == 0 {
+		app.Cat = adUnitCfg.App.Cat
+	}
+
+	if len(app.SectionCat) == 0 {
+		app.SectionCat = adUnitCfg.App.SectionCat
+	}
+
+	if len(app.PageCat) == 0 {
+		app.PageCat = adUnitCfg.App.PageCat
+	}
+
+	if app.Ver == "" {
+		app.Ver = adUnitCfg.App.Ver
+	}
+
+	if app.PrivacyPolicy == 0 {
+		app.PrivacyPolicy = adUnitCfg.App.PrivacyPolicy
+	}
+
+	if app.Paid == 0 {
+		app.Paid = adUnitCfg.App.Paid
+	}
+
+	if app.Content == nil {
+		app.Content = adUnitCfg.App.Content
+	}
+
+	if app.Keywords == "" {
+		app.Keywords = adUnitCfg.App.Keywords
+	}
+
+	if app.Ext == nil {
+		app.Ext = adUnitCfg.App.Ext
+	}
+
+	if adUnitCfg.App.Publisher != nil {
+		if app.Publisher == nil {
+			app.Publisher = &openrtb2.Publisher{}
+		}
+
+		if app.Publisher.Name == "" {
+			app.Publisher.Name = adUnitCfg.App.Publisher.Name
+		}
+
+		if len(app.Publisher.Cat) == 0 {
+			app.Publisher.Cat = adUnitCfg.App.Publisher.Cat
+		}
+
+		if app.Publisher.Domain == "" {
+			app.Publisher.Domain = adUnitCfg.App.Publisher.Domain
+		}
+
+		if app.Publisher.Ext == nil {
+			app.Publisher.Ext = adUnitCfg.App.Publisher.Ext
+		}
+	}
+
+}
diff --git a/modules/pubmatic/openwrap/adunitconfig/banner.go b/modules/pubmatic/openwrap/adunitconfig/banner.go
new file mode 100644
index 000000000..fef365120
--- /dev/null
+++ b/modules/pubmatic/openwrap/adunitconfig/banner.go
@@ -0,0 +1,54 @@
+package adunitconfig
+
+import (
+	"runtime/debug"
+
+	"github.com/golang/glog"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+func UpdateBannerObjectWithAdunitConfig(rCtx models.RequestCtx, imp openrtb2.Imp, div string) (adUnitCtx models.AdUnitCtx) {
+	defer func() {
+		if r := recover(); r != nil {
+			glog.Error(string(debug.Stack()))
+		}
+	}()
+
+	if rCtx.AdUnitConfig == nil || len(rCtx.AdUnitConfig.Config) == 0 {
+		return
+	}
+
+	defaultAdUnitConfig, ok := rCtx.AdUnitConfig.Config[models.AdunitConfigDefaultKey]
+	if ok && defaultAdUnitConfig != nil {
+		if defaultAdUnitConfig.Banner != nil && defaultAdUnitConfig.Banner.Enabled != nil && !*defaultAdUnitConfig.Banner.Enabled {
+			f := false
+			adUnitCtx.AppliedSlotAdUnitConfig = &adunitconfig.AdConfig{Banner: &adunitconfig.Banner{Enabled: &f}}
+			return
+		}
+	}
+
+	var height, width int64
+	if imp.Banner != nil {
+		if imp.Banner.H != nil {
+			height = *imp.Banner.H
+		}
+		if imp.Banner.W != nil {
+			width = *imp.Banner.W
+		}
+	}
+
+	adUnitCtx.SelectedSlotAdUnitConfig, adUnitCtx.MatchedSlot, adUnitCtx.IsRegex, adUnitCtx.MatchedRegex = selectSlot(rCtx, height, width, imp.TagID, div, rCtx.Source)
+	if adUnitCtx.SelectedSlotAdUnitConfig != nil && adUnitCtx.SelectedSlotAdUnitConfig.Banner != nil {
+		if adUnitCtx.SelectedSlotAdUnitConfig.Banner.Enabled != nil && !*adUnitCtx.SelectedSlotAdUnitConfig.Banner.Enabled {
+			f := false
+			adUnitCtx.AppliedSlotAdUnitConfig = &adunitconfig.AdConfig{Banner: &adunitconfig.Banner{Enabled: &f}}
+			return
+		}
+	}
+
+	adUnitCtx.AppliedSlotAdUnitConfig = getFinalSlotAdUnitConfig(adUnitCtx.SelectedSlotAdUnitConfig, defaultAdUnitConfig)
+
+	return
+}
diff --git a/modules/pubmatic/openwrap/adunitconfig/common.go b/modules/pubmatic/openwrap/adunitconfig/common.go
new file mode 100644
index 000000000..1354dc201
--- /dev/null
+++ b/modules/pubmatic/openwrap/adunitconfig/common.go
@@ -0,0 +1,60 @@
+package adunitconfig
+
+import (
+	"encoding/json"
+	"strings"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/bidderparams"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+func selectSlot(rCtx models.RequestCtx, h, w int64, tagid, div, source string) (slotAdUnitConfig *adunitconfig.AdConfig, slotName string, isRegex bool, matchedRegex string) {
+	slotName = bidderparams.GenerateSlotName(h, w, rCtx.AdUnitConfig.ConfigPattern, tagid, div, rCtx.Source)
+
+	if slotAdUnitConfig, ok := rCtx.AdUnitConfig.Config[strings.ToLower(slotName)]; ok {
+		return slotAdUnitConfig, slotName, false, ""
+	} else if rCtx.AdUnitConfig.Regex {
+		if matchedRegex = getRegexMatch(rCtx, strings.ToLower(slotName)); matchedRegex != "" {
+			return rCtx.AdUnitConfig.Config[matchedRegex], slotName, true, matchedRegex
+		}
+	}
+
+	return nil, "", false, ""
+}
+
+/*GetClientConfigForMediaType function fetches the client config data from the ad unit config JSON for the given media type*/
+func GetClientConfigForMediaType(rctx models.RequestCtx, impID string, mediaType string) json.RawMessage {
+	if rctx.AdUnitConfig == nil || rctx.AdUnitConfig.Config == nil {
+		return nil
+	}
+
+	impData, ok := rctx.ImpBidCtx[impID]
+	if !ok {
+		return nil
+	}
+
+	if mediaType == models.AdunitConfigSlotBannerKey {
+		if impData.BannerAdUnitCtx.AppliedSlotAdUnitConfig != nil &&
+			impData.BannerAdUnitCtx.AppliedSlotAdUnitConfig.Banner != nil &&
+			impData.BannerAdUnitCtx.AppliedSlotAdUnitConfig.Banner.Config != nil {
+			if impData.BannerAdUnitCtx.AppliedSlotAdUnitConfig.Banner.Enabled != nil &&
+				*impData.BannerAdUnitCtx.AppliedSlotAdUnitConfig.Banner.Enabled == false {
+				return nil
+			}
+			return impData.BannerAdUnitCtx.AppliedSlotAdUnitConfig.Banner.Config.ClientConfig
+		}
+	} else if mediaType == models.AdunitConfigSlotVideoKey {
+		if impData.VideoAdUnitCtx.AppliedSlotAdUnitConfig != nil &&
+			impData.VideoAdUnitCtx.AppliedSlotAdUnitConfig.Video != nil &&
+			impData.VideoAdUnitCtx.AppliedSlotAdUnitConfig.Video.Config != nil {
+			if impData.VideoAdUnitCtx.AppliedSlotAdUnitConfig.Video.Enabled != nil &&
+				*impData.VideoAdUnitCtx.AppliedSlotAdUnitConfig.Video.Enabled == false {
+				return nil
+			}
+			return impData.VideoAdUnitCtx.AppliedSlotAdUnitConfig.Video.Config.ClientConfig
+		}
+	}
+
+	return nil
+}
diff --git a/modules/pubmatic/openwrap/adunitconfig/device.go b/modules/pubmatic/openwrap/adunitconfig/device.go
new file mode 100644
index 000000000..57b3517a5
--- /dev/null
+++ b/modules/pubmatic/openwrap/adunitconfig/device.go
@@ -0,0 +1,36 @@
+package adunitconfig
+
+import (
+	"github.com/prebid/openrtb/v19/adcom1"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+func ReplaceDeviceTypeFromAdUnitConfig(rCtx models.RequestCtx, device *openrtb2.Device) {
+	if device != nil || device.DeviceType != 0 {
+		return
+	}
+
+	var adUnitCfg *adunitconfig.AdConfig
+	for _, impCtx := range rCtx.ImpBidCtx {
+		if impCtx.BannerAdUnitCtx.AppliedSlotAdUnitConfig != nil {
+			adUnitCfg = impCtx.BannerAdUnitCtx.AppliedSlotAdUnitConfig
+			break
+		}
+		if impCtx.VideoAdUnitCtx.AppliedSlotAdUnitConfig != nil {
+			adUnitCfg = impCtx.VideoAdUnitCtx.AppliedSlotAdUnitConfig
+			break
+		}
+	}
+
+	if adUnitCfg == nil || adUnitCfg.Device == nil {
+		return
+	}
+
+	if device == nil {
+		device = &openrtb2.Device{}
+	}
+
+	device.DeviceType = adcom1.DeviceType(adUnitCfg.Device.DeviceType)
+}
diff --git a/modules/pubmatic/openwrap/adunitconfig/floors.go b/modules/pubmatic/openwrap/adunitconfig/floors.go
new file mode 100644
index 000000000..3bd8ebe99
--- /dev/null
+++ b/modules/pubmatic/openwrap/adunitconfig/floors.go
@@ -0,0 +1,30 @@
+package adunitconfig
+
+import (
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+func UpdateFloorsExtObjectFromAdUnitConfig(rCtx models.RequestCtx, requestExt *models.RequestExt) {
+	if requestExt.Prebid.Floors != nil {
+		return
+	}
+
+	var adUnitCfg *adunitconfig.AdConfig
+	for _, impCtx := range rCtx.ImpBidCtx {
+		if impCtx.BannerAdUnitCtx.AppliedSlotAdUnitConfig != nil {
+			adUnitCfg = impCtx.BannerAdUnitCtx.AppliedSlotAdUnitConfig
+			break
+		}
+		if impCtx.VideoAdUnitCtx.AppliedSlotAdUnitConfig != nil {
+			adUnitCfg = impCtx.VideoAdUnitCtx.AppliedSlotAdUnitConfig
+			break
+		}
+	}
+
+	if adUnitCfg == nil || adUnitCfg.Floors == nil {
+		return
+	}
+
+	requestExt.Prebid.Floors = adUnitCfg.Floors
+}
diff --git a/modules/pubmatic/openwrap/adunitconfig/regex.go b/modules/pubmatic/openwrap/adunitconfig/regex.go
new file mode 100644
index 000000000..617e51747
--- /dev/null
+++ b/modules/pubmatic/openwrap/adunitconfig/regex.go
@@ -0,0 +1,24 @@
+package adunitconfig
+
+import (
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+func getRegexMatch(rctx models.RequestCtx, slotName string) string {
+	for expression := range rctx.AdUnitConfig.Config {
+		if expression != models.AdunitConfigDefaultKey {
+			//Populating and Validating
+			re, err := Compile(expression)
+			if err != nil {
+				// TODO: add debug messages
+				// errs = append(errs, err)
+				continue
+			}
+
+			if re.MatchString(slotName) {
+				return expression
+			}
+		}
+	}
+	return ""
+}
diff --git a/modules/pubmatic/openwrap/adunitconfig/regex_cache.go b/modules/pubmatic/openwrap/adunitconfig/regex_cache.go
new file mode 100644
index 000000000..bae9be486
--- /dev/null
+++ b/modules/pubmatic/openwrap/adunitconfig/regex_cache.go
@@ -0,0 +1,64 @@
+package adunitconfig
+
+import (
+	"regexp"
+	"sync"
+)
+
+// Check https://pkg.go.dev/github.com/umisama/go-regexpcache#section-readme for Regex-Caching
+var (
+	regexMapContainer regexMap
+)
+
+// Compile parses a regular expression.
+// This compatible with regexp.Compile but this uses a cache.
+func Compile(str string) (*regexp.Regexp, error) {
+	return regexMapContainer.Get(str)
+}
+
+// Match checks whether a textual regular expression matches a string.
+// This compatible with regexp.MatchString but this uses a cache.
+func MatchString(pattern string, s string) (matched bool, err error) {
+	re, err := Compile(pattern)
+	if err != nil {
+		return false, err
+	}
+	return re.MatchString(s), nil
+}
+
+type regexMap struct {
+	regexps map[string]*regexp.Regexp
+	mu      *sync.RWMutex
+}
+
+func newContainer() regexMap {
+	return regexMap{
+		regexps: make(map[string]*regexp.Regexp),
+		mu:      &sync.RWMutex{},
+	}
+}
+
+func (s *regexMap) Get(str string) (*regexp.Regexp, error) {
+	s.mu.RLock()
+	defer s.mu.RUnlock()
+
+	re, ok := s.regexps[str]
+	if ok {
+		return re, nil
+	}
+
+	var err error
+
+	re, err = regexp.Compile(str)
+
+	if err != nil {
+		return nil, err
+	}
+	s.regexps[str] = re
+
+	return re, nil
+}
+
+func init() {
+	regexMapContainer = newContainer()
+}
diff --git a/modules/pubmatic/openwrap/adunitconfig/regex_cache_test.go b/modules/pubmatic/openwrap/adunitconfig/regex_cache_test.go
new file mode 100644
index 000000000..6e1ba94a9
--- /dev/null
+++ b/modules/pubmatic/openwrap/adunitconfig/regex_cache_test.go
@@ -0,0 +1,51 @@
+package adunitconfig
+
+import (
+	"regexp"
+	"testing"
+)
+
+func TestContainer(t *testing.T) {
+	cases := []struct {
+		name         string
+		exp          string
+		str          string
+		expect_err   bool
+		expect_match bool
+	}{
+		{"test1", "^[hc]at", "cat", false, true},
+		{"test2", "^[hc]at", "hat", false, true},
+		{"test3", "^[hc]at", "hot", false, false},
+		{"test4", `^^^[ddd!!\1\1\1\1`, "hot", true, true},
+	}
+
+	cont := newContainer()
+	for _, c := range cases {
+		re, err := cont.Get(c.exp)
+		if (err != nil) != c.expect_err {
+			t.Error("expect error, but got", err.Error())
+		}
+		if c.expect_err {
+			continue
+		}
+		match := re.MatchString(c.str)
+		if match != c.expect_match {
+			t.Error("expect ", c.expect_match, ", but got ", match, "for test ", c.name)
+		}
+	}
+
+}
+
+func BenchmarkRegexpPackageCompile(b *testing.B) {
+	for i := 0; i < b.N; i++ {
+		re, _ := regexp.Compile(`^[hc]at`)
+		re.MatchString("cat")
+	}
+}
+
+func BenchmarkRegexpCachePackageCompile(b *testing.B) {
+	for i := 0; i < b.N; i++ {
+		re, _ := Compile(`^[hc]at`)
+		re.MatchString("cat")
+	}
+}
diff --git a/modules/pubmatic/openwrap/adunitconfig/utils.go b/modules/pubmatic/openwrap/adunitconfig/utils.go
new file mode 100644
index 000000000..3593388cb
--- /dev/null
+++ b/modules/pubmatic/openwrap/adunitconfig/utils.go
@@ -0,0 +1,98 @@
+package adunitconfig
+
+import (
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/bidderparams"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+// TODO use this
+func GetMatchedSlotName(rCtx models.RequestCtx, imp openrtb2.Imp, impExt models.ImpExtension) (slotAdUnitConfig *adunitconfig.AdConfig, isRegex bool) {
+	div := ""
+	height := imp.Video.H
+	width := imp.Video.W
+	tagID := imp.TagID
+
+	if impExt.Wrapper != nil {
+		div = impExt.Wrapper.Div
+	}
+
+	slotName := bidderparams.GenerateSlotName(height, width, rCtx.AdUnitConfig.ConfigPattern, tagID, div, rCtx.Source)
+
+	var ok bool
+	slotAdUnitConfig, ok = rCtx.AdUnitConfig.Config[slotName]
+	if ok {
+		return
+	}
+
+	// for slot, adUnitConfig := range rCtx.AdUnitConfig.Config {
+
+	// }
+
+	return
+}
+
+func getDefaultAllowedConnectionTypes(adUnitConfigMap *adunitconfig.AdUnitConfig) []int {
+	if adUnitConfigMap == nil {
+		return nil
+	}
+
+	if v, ok := adUnitConfigMap.Config[models.AdunitConfigDefaultKey]; ok && v.Video != nil && v.Video.Config != nil && len(v.Video.Config.CompanionType) != 0 {
+		return v.Video.Config.ConnectionType
+	}
+
+	return nil
+}
+
+func checkValuePresentInArray(intArray []int, value int) bool {
+	for _, eachVal := range intArray {
+		if eachVal == value {
+			return true
+		}
+	}
+	return false
+}
+
+// update slotConfig with final AdUnit config to apply with
+func getFinalSlotAdUnitConfig(slotConfig, defaultConfig *adunitconfig.AdConfig) *adunitconfig.AdConfig {
+	// nothing available
+	if slotConfig == nil && defaultConfig == nil {
+		return nil
+	}
+
+	// only default available
+	if slotConfig == nil {
+		return defaultConfig
+	}
+
+	// only slot available
+	if defaultConfig == nil {
+		return slotConfig
+	}
+
+	// both available, merge both with priority to slot
+
+	if (slotConfig.BidFloor == nil || *slotConfig.BidFloor == 0.0) && defaultConfig.BidFloor != nil {
+		slotConfig.BidFloor = defaultConfig.BidFloor
+
+		slotConfig.BidFloorCur = func() *string { s := "USD"; return &s }()
+		if defaultConfig.BidFloorCur != nil {
+			slotConfig.BidFloorCur = defaultConfig.BidFloorCur
+		}
+	}
+
+	if slotConfig.Banner == nil {
+		slotConfig.Banner = defaultConfig.Banner
+	}
+
+	if slotConfig.Video == nil {
+		slotConfig.Video = defaultConfig.Video
+	}
+
+	if slotConfig.Floors == nil {
+		slotConfig.Floors = defaultConfig.Floors
+	}
+
+	return slotConfig
+}
diff --git a/modules/pubmatic/openwrap/adunitconfig/video.go b/modules/pubmatic/openwrap/adunitconfig/video.go
new file mode 100644
index 000000000..c9fcc49f8
--- /dev/null
+++ b/modules/pubmatic/openwrap/adunitconfig/video.go
@@ -0,0 +1,79 @@
+package adunitconfig
+
+import (
+	"runtime/debug"
+
+	"github.com/golang/glog"
+	"github.com/prebid/openrtb/v19/adcom1"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+func UpdateVideoObjectWithAdunitConfig(rCtx models.RequestCtx, imp openrtb2.Imp, div string, connectionType *adcom1.ConnectionType) (adUnitCtx models.AdUnitCtx) {
+	defer func() {
+		if r := recover(); r != nil {
+			glog.Error(string(debug.Stack()))
+		}
+	}()
+
+	if rCtx.AdUnitConfig == nil || len(rCtx.AdUnitConfig.Config) == 0 {
+		return
+	}
+
+	defaultAdUnitConfig, ok := rCtx.AdUnitConfig.Config[models.AdunitConfigDefaultKey]
+	if ok && defaultAdUnitConfig != nil {
+		adUnitCtx.UsingDefaultConfig = true
+
+		if defaultAdUnitConfig.Video != nil && defaultAdUnitConfig.Video.Enabled != nil && !*defaultAdUnitConfig.Video.Enabled {
+			f := false
+			adUnitCtx.AppliedSlotAdUnitConfig = &adunitconfig.AdConfig{Video: &adunitconfig.Video{Enabled: &f}}
+			return
+		}
+	}
+
+	var height, width int64
+	if imp.Video != nil {
+		height = imp.Video.H
+		width = imp.Video.W
+	}
+
+	adUnitCtx.SelectedSlotAdUnitConfig, adUnitCtx.MatchedSlot, adUnitCtx.IsRegex, adUnitCtx.MatchedRegex = selectSlot(rCtx, height, width, imp.TagID, div, rCtx.Source)
+	if adUnitCtx.SelectedSlotAdUnitConfig != nil && adUnitCtx.SelectedSlotAdUnitConfig.Video != nil {
+		adUnitCtx.UsingDefaultConfig = false
+		if adUnitCtx.SelectedSlotAdUnitConfig.Video.Enabled != nil && !*adUnitCtx.SelectedSlotAdUnitConfig.Video.Enabled {
+			f := false
+			adUnitCtx.AppliedSlotAdUnitConfig = &adunitconfig.AdConfig{Video: &adunitconfig.Video{Enabled: &f}}
+			return
+		}
+	}
+
+	adUnitCtx.AppliedSlotAdUnitConfig = getFinalSlotAdUnitConfig(adUnitCtx.SelectedSlotAdUnitConfig, defaultAdUnitConfig)
+	if adUnitCtx.AppliedSlotAdUnitConfig == nil {
+		return
+	}
+
+	adUnitCtx.AllowedConnectionTypes = getDefaultAllowedConnectionTypes(rCtx.AdUnitConfig)
+
+	// updateAllowedConnectionTypes := !adUnitCtx.UsingDefaultConfig
+	// if adUnitCtx.AppliedSlotAdUnitConfig != nil && adUnitCtx.AppliedSlotAdUnitConfig.Video != nil &&
+	// 	adUnitCtx.AppliedSlotAdUnitConfig.Video.Config != nil && len(adUnitCtx.AppliedSlotAdUnitConfig.Video.Config.ConnectionType) != 0 {
+	// 	updateAllowedConnectionTypes = updateAllowedConnectionTypes && true
+	// }
+
+	// // disable video if connection type is not present in allowed connection types from config
+	// if connectionType != nil {
+	// 	//check connection type in slot config
+	// 	if updateAllowedConnectionTypes {
+	// 		adUnitCtx.AllowedConnectionTypes = configObjInVideoConfig.ConnectionType
+	// 	}
+
+	// 	if allowedConnectionTypes != nil && !checkValuePresentInArray(allowedConnectionTypes, int(*connectionType)) {
+	// 		f := false
+	// 		adUnitCtx.AppliedSlotAdUnitConfig = &adunitconfig.AdConfig{Video: &adunitconfig.Video{Enabled: &f}}
+	// 		return
+	// 	}
+	// }
+
+	return
+}
diff --git a/modules/pubmatic/openwrap/auctionresponsehook.go b/modules/pubmatic/openwrap/auctionresponsehook.go
new file mode 100644
index 000000000..59f1f37ee
--- /dev/null
+++ b/modules/pubmatic/openwrap/auctionresponsehook.go
@@ -0,0 +1,335 @@
+package openwrap
+
+import (
+	"context"
+	"encoding/json"
+	"strconv"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/hooks/hookanalytics"
+	"github.com/prebid/prebid-server/hooks/hookstage"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/adunitconfig"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/tracker"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func (m OpenWrap) handleAuctionResponseHook(
+	ctx context.Context,
+	moduleCtx hookstage.ModuleInvocationContext,
+	payload hookstage.AuctionResponsePayload,
+) (hookstage.HookResult[hookstage.AuctionResponsePayload], error) {
+	result := hookstage.HookResult[hookstage.AuctionResponsePayload]{}
+	result.ChangeSet = hookstage.ChangeSet[hookstage.AuctionResponsePayload]{}
+
+	// absence of rctx at this hook means the first hook failed!. Do nothing
+	if len(moduleCtx.ModuleContext) == 0 {
+		result.DebugMessages = append(result.DebugMessages, "error: module-ctx not found in handleBeforeValidationHook()")
+		return result, nil
+	}
+	rctx, ok := moduleCtx.ModuleContext["rctx"].(models.RequestCtx)
+	if !ok {
+		result.DebugMessages = append(result.DebugMessages, "error: request-ctx not found in handleBeforeValidationHook()")
+		return result, nil
+	}
+	defer func() {
+		moduleCtx.ModuleContext["rctx"] = rctx
+	}()
+
+	// cache rctx for analytics
+	result.AnalyticsTags = hookanalytics.Analytics{
+		Activities: []hookanalytics.Activity{
+			{
+				Name: "openwrap_request_ctx",
+				Results: []hookanalytics.Result{
+					{
+						Values: map[string]interface{}{
+							"request-ctx": &rctx,
+						},
+					},
+				},
+			},
+		},
+	}
+
+	// if payload.BidResponse.NBR != nil {
+	// 	return result, nil
+	// }
+
+	winningBids := make(map[string]models.OwBid, 0)
+	for _, seatBid := range payload.BidResponse.SeatBid {
+		for _, bid := range seatBid.Bid {
+			impCtx, ok := rctx.ImpBidCtx[bid.ImpID]
+			if !ok {
+				result.Errors = append(result.Errors, "invalid impCtx.ID for bid"+bid.ImpID)
+				continue
+			}
+
+			partnerID := 0
+			if bidderMeta, ok := impCtx.Bidders[seatBid.Seat]; ok {
+				partnerID = bidderMeta.PartnerID
+			}
+
+			revShare := models.GetRevenueShare(rctx.PartnerConfigMap[partnerID])
+			price := bid.Price
+
+			bidExt := &models.BidExt{}
+			if len(bid.Ext) != 0 { //NYC_TODO: most of the fields should be filled even if unmarshal fails
+				err := json.Unmarshal(bid.Ext, bidExt)
+				if err != nil {
+					result.Errors = append(result.Errors, "failed to unmarshal bid.ext for "+bid.ID)
+					// continue
+				}
+
+				// NYC_TODO: fix this in PBS-Core or ExecuteAllProcessedBidResponsesStage
+				if bidExt.Prebid != nil && bidExt.Prebid.Video != nil && bidExt.Prebid.Video.Duration == 0 &&
+					bidExt.Prebid.Video.PrimaryCategory == "" && bidExt.Prebid.Video.VASTTagID == "" {
+					bidExt.Prebid.Video = nil
+				}
+
+				if v, ok := rctx.PartnerConfigMap[models.VersionLevelConfigID]["refreshInterval"]; ok {
+					n, err := strconv.Atoi(v)
+					if err == nil {
+						bidExt.RefreshInterval = n
+					}
+				}
+
+				if bidExt.Prebid != nil {
+					bidExt.CreativeType = string(bidExt.Prebid.Type)
+				}
+				if bidExt.CreativeType == "" {
+					bidExt.CreativeType = models.GetAdFormat(bid.AdM)
+				}
+
+				if payload.BidResponse.Cur != "USD" {
+					price = bidExt.OriginalBidCPMUSD
+				}
+
+				bidExt.NetECPM = models.GetNetEcpm(price, revShare)
+
+				if impCtx.Video != nil && impCtx.Type == "video" && bidExt.CreativeType == "video" {
+					if bidExt.Video == nil {
+						bidExt.Video = &models.ExtBidVideo{}
+					}
+					if impCtx.Video.MaxDuration != 0 {
+						bidExt.Video.MaxDuration = impCtx.Video.MaxDuration
+					}
+					if impCtx.Video.MinDuration != 0 {
+						bidExt.Video.MinDuration = impCtx.Video.MinDuration
+					}
+					if impCtx.Video.Skip != nil {
+						bidExt.Video.Skip = impCtx.Video.Skip
+					}
+					if impCtx.Video.SkipAfter != 0 {
+						bidExt.Video.SkipAfter = impCtx.Video.SkipAfter
+					}
+					if impCtx.Video.SkipMin != 0 {
+						bidExt.Video.SkipMin = impCtx.Video.SkipMin
+					}
+					bidExt.Video.BAttr = impCtx.Video.BAttr
+					bidExt.Video.PlaybackMethod = impCtx.Video.PlaybackMethod
+					if rctx.ClientConfigFlag == 1 {
+						bidExt.Video.ClientConfig = adunitconfig.GetClientConfigForMediaType(rctx, bid.ImpID, "video")
+					}
+				} else if impCtx.Banner && bidExt.CreativeType == "banner" && rctx.ClientConfigFlag == 1 {
+					cc := adunitconfig.GetClientConfigForMediaType(rctx, bid.ImpID, "banner")
+					if len(cc) != 0 {
+						if bidExt.Banner == nil {
+							bidExt.Banner = &models.ExtBidBanner{}
+						}
+						bidExt.Banner.ClientConfig = cc
+					}
+				}
+			}
+
+			bidDealTierSatisfied := false
+			if bidExt.Prebid != nil {
+				bidDealTierSatisfied = bidExt.Prebid.DealTierSatisfied
+			}
+
+			owbid := models.OwBid{
+				ID:                   bid.ID,
+				NetEcpm:              bidExt.NetECPM,
+				BidDealTierSatisfied: bidDealTierSatisfied,
+			}
+			wbid, ok := winningBids[bid.ImpID]
+			if !ok || isNewWinningBid(owbid, wbid, rctx.SupportDeals) {
+				winningBids[bid.ImpID] = owbid
+			}
+
+			// cache for bid details for logger and tracker
+			if impCtx.BidCtx == nil {
+				impCtx.BidCtx = make(map[string]models.BidCtx)
+			}
+			impCtx.BidCtx[bid.ID] = models.BidCtx{
+				BidExt: *bidExt,
+			}
+			rctx.ImpBidCtx[bid.ImpID] = impCtx
+		}
+	}
+
+	rctx.WinningBids = winningBids
+
+	droppedBids, warnings := addPWTTargetingForBid(rctx, payload.BidResponse)
+	if len(droppedBids) != 0 {
+		rctx.DroppedBids = droppedBids
+	}
+	if len(warnings) != 0 {
+		result.Warnings = append(result.Warnings, warnings...)
+	}
+
+	rctx.NoSeatBids = m.addDefaultBids(rctx, payload.BidResponse)
+
+	rctx.Trackers = tracker.CreateTrackers(rctx, payload.BidResponse)
+
+	responseExt := openrtb_ext.ExtBidResponse{}
+	// TODO use concrete structure
+	if len(payload.BidResponse.Ext) != 0 {
+		if err := json.Unmarshal(payload.BidResponse.Ext, &responseExt); err != nil {
+			result.Errors = append(result.Errors, "failed to unmarshal response.ext err: "+err.Error())
+		}
+	}
+
+	for k, v := range responseExt.ResponseTimeMillis {
+		rctx.BidderResponseTimeMillis[k.String()] = v
+	}
+
+	// TODO: PBS-Core should pass the hostcookie for module to usersync.ParseCookieFromRequest()
+	if matchedImpression := getMatchedImpression(rctx); matchedImpression != nil {
+		responseExt.OwMatchedImpression = matchedImpression
+	}
+
+	if rctx.SendAllBids {
+		responseExt.OwSendAllBids = 1
+	}
+
+	if rctx.LogInfoFlag == 1 {
+		responseExt.OwLogInfo = &openrtb_ext.OwLogInfo{
+			// Logger:  openwrap.GetLogAuctionObjectAsURL(ao, true, true), updated done later
+			Tracker: tracker.GetTrackerInfo(rctx),
+		}
+	}
+
+	var err error
+	rctx.ResponseExt, err = json.Marshal(responseExt)
+	if err != nil {
+		result.Errors = append(result.Errors, "failed to marshal response.ext err: "+err.Error())
+	}
+
+	if rctx.Debug {
+		rCtxBytes, _ := json.Marshal(rctx)
+		result.DebugMessages = append(result.DebugMessages, string(rCtxBytes))
+	}
+
+	result.ChangeSet.AddMutation(func(ap hookstage.AuctionResponsePayload) (hookstage.AuctionResponsePayload, error) {
+		rctx := moduleCtx.ModuleContext["rctx"].(models.RequestCtx)
+		var err error
+		ap.BidResponse, err = m.updateORTBV25Response(rctx, ap.BidResponse)
+		if err != nil {
+			return ap, err
+		}
+
+		ap.BidResponse, err = tracker.InjectTrackers(rctx, ap.BidResponse)
+		if err != nil {
+			return ap, err
+		}
+
+		ap.BidResponse, err = m.applyDefaultBids(rctx, ap.BidResponse)
+
+		ap.BidResponse.Ext = rctx.ResponseExt
+		return ap, err
+	}, hookstage.MutationUpdate, "response-body-with-sshb-format")
+
+	// TODO: move debug here
+	// result.ChangeSet.AddMutation(func(ap hookstage.AuctionResponsePayload) (hookstage.AuctionResponsePayload, error) {
+	// }, hookstage.MutationUpdate, "response-body-with-sshb-format")
+
+	return result, nil
+}
+
+func (m *OpenWrap) updateORTBV25Response(rctx models.RequestCtx, bidResponse *openrtb2.BidResponse) (*openrtb2.BidResponse, error) {
+	if len(bidResponse.SeatBid) == 0 {
+		return bidResponse, nil
+	}
+
+	// remove non-winning bids if sendallbids=1
+	if !rctx.SendAllBids {
+		for i := range bidResponse.SeatBid {
+			filteredBid := make([]openrtb2.Bid, 0, len(bidResponse.SeatBid[i].Bid))
+			for _, bid := range bidResponse.SeatBid[i].Bid {
+				if b, ok := rctx.WinningBids[bid.ImpID]; ok && b.ID == bid.ID {
+					filteredBid = append(filteredBid, bid)
+				}
+			}
+			bidResponse.SeatBid[i].Bid = filteredBid
+		}
+	}
+
+	// remove seats with empty bids (will add nobids later)
+	filteredSeatBid := make([]openrtb2.SeatBid, 0, len(bidResponse.SeatBid))
+	for _, seatBid := range bidResponse.SeatBid {
+		if len(seatBid.Bid) > 0 {
+			filteredSeatBid = append(filteredSeatBid, seatBid)
+		}
+	}
+	bidResponse.SeatBid = filteredSeatBid
+
+	// keep pubmatic 1st to handle automation failure.
+	if len(bidResponse.SeatBid) != 0 {
+		if bidResponse.SeatBid[0].Seat != "pubmatic" {
+			for i := 0; i < len(bidResponse.SeatBid); i++ {
+				if bidResponse.SeatBid[i].Seat == "pubmatic" {
+					temp := bidResponse.SeatBid[0]
+					bidResponse.SeatBid[0] = bidResponse.SeatBid[i]
+					bidResponse.SeatBid[i] = temp
+				}
+			}
+		}
+	}
+
+	// update bid ext and other details
+	for i, seatBid := range bidResponse.SeatBid {
+		for j, bid := range seatBid.Bid {
+			impCtx, ok := rctx.ImpBidCtx[bid.ImpID]
+			if !ok {
+				continue
+			}
+
+			bidCtx, ok := impCtx.BidCtx[bid.ID]
+			if !ok {
+				continue
+			}
+
+			bidResponse.SeatBid[i].Bid[j].Ext, _ = json.Marshal(bidCtx.BidExt)
+		}
+	}
+
+	return bidResponse, nil
+}
+
+// isNewWinningBid calculates if the new bid (nbid) will win against the current winning bid (wbid) given preferDeals.
+func isNewWinningBid(bid, wbid models.OwBid, preferDeals bool) bool {
+	if preferDeals {
+		//only wbid has deal
+		if wbid.BidDealTierSatisfied && !bid.BidDealTierSatisfied {
+			return false
+		}
+		//only bid has deal
+		if !wbid.BidDealTierSatisfied && bid.BidDealTierSatisfied {
+			return true
+		}
+	}
+	//both have deal or both do not have deal
+	return bid.NetEcpm > wbid.NetEcpm
+}
+
+func getPlatformName(platform string) string {
+	if platform == models.PLATFORM_APP {
+		return models.PlatformAppTargetingKey
+	}
+	return platform
+}
+
+func getIntPtr(i int) *int {
+	return &i
+}
diff --git a/modules/pubmatic/openwrap/beforevalidationhook.go b/modules/pubmatic/openwrap/beforevalidationhook.go
new file mode 100644
index 000000000..aaaef5925
--- /dev/null
+++ b/modules/pubmatic/openwrap/beforevalidationhook.go
@@ -0,0 +1,771 @@
+package openwrap
+
+import (
+	"context"
+	"encoding/json"
+	"errors"
+	"fmt"
+	"net/url"
+	"strconv"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/hooks/hookstage"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/adapters"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/adunitconfig"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/bidderparams"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/nbr"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	"github.com/prebid/prebid-server/util/boolutil"
+)
+
+func (m OpenWrap) handleBeforeValidationHook(
+	ctx context.Context,
+	moduleCtx hookstage.ModuleInvocationContext,
+	payload hookstage.BeforeValidationRequestPayload,
+) (hookstage.HookResult[hookstage.BeforeValidationRequestPayload], error) {
+	result := hookstage.HookResult[hookstage.BeforeValidationRequestPayload]{
+		Reject: true,
+	}
+
+	if len(moduleCtx.ModuleContext) == 0 {
+		result.DebugMessages = append(result.DebugMessages, "error: module-ctx not found in handleBeforeValidationHook()")
+		return result, nil
+	}
+	rCtx, ok := moduleCtx.ModuleContext["rctx"].(models.RequestCtx)
+	if !ok {
+		result.DebugMessages = append(result.DebugMessages, "error: request-ctx not found in handleBeforeValidationHook()")
+		return result, nil
+	}
+	defer func() {
+		moduleCtx.ModuleContext["rctx"] = rCtx
+	}()
+
+	pubID, err := getPubID(*payload.BidRequest)
+	if err != nil {
+		result.NbrCode = nbr.InvalidPublisherID
+		result.Errors = append(result.Errors, "ErrInvalidPublisherID")
+		return result, fmt.Errorf("invalid publisher id : %v", err)
+	}
+	rCtx.PubID = pubID
+
+	requestExt, err := models.GetRequestExt(payload.BidRequest.Ext)
+	if err != nil {
+		result.NbrCode = nbr.InvalidRequest
+		err = errors.New("failed to get request ext: " + err.Error())
+		result.Errors = append(result.Errors, err.Error())
+		return result, err
+	}
+
+	// TODO: verify preference of request.test vs queryParam test
+	if payload.BidRequest.Test != 0 {
+		rCtx.IsTestRequest = payload.BidRequest.Test
+	}
+
+	partnerConfigMap, err := m.getProfileData(rCtx, *payload.BidRequest)
+	if err != nil || len(partnerConfigMap) == 0 {
+		// TODO: seperate DB fetch errors as internal errors
+		result.NbrCode = nbr.InvalidProfileConfiguration
+		err = errors.New("failed to get profile data: " + err.Error())
+		result.Errors = append(result.Errors, err.Error())
+		return result, err
+	}
+
+	rCtx.PartnerConfigMap = partnerConfigMap // keep a copy at module level as well
+	rCtx.Platform, _ = rCtx.GetVersionLevelKey(models.PLATFORM_KEY)
+	rCtx.PageURL = getPageURL(payload.BidRequest)
+	rCtx.DevicePlatform = GetDevicePlatform(rCtx.UA, payload.BidRequest, rCtx.Platform)
+	rCtx.SendAllBids = isSendAllBids(rCtx)
+	rCtx.Source, rCtx.Origin = getSourceAndOrigin(payload.BidRequest)
+	rCtx.TMax = m.setTimeout(rCtx)
+
+	if newPartnerConfigMap, ok := ABTestProcessing(rCtx); ok {
+		rCtx.ABTestConfigApplied = 1
+		rCtx.PartnerConfigMap = newPartnerConfigMap
+		result.Warnings = append(result.Warnings, "update the rCtx.PartnerConfigMap with ABTest data")
+	}
+
+	var allPartnersThrottledFlag bool
+	rCtx.AdapterThrottleMap, allPartnersThrottledFlag = GetAdapterThrottleMap(rCtx.PartnerConfigMap)
+	if allPartnersThrottledFlag {
+		result.NbrCode = nbr.AllPartnerThrottled
+		result.Errors = append(result.Errors, "All adapters throttled")
+		rCtx.ImpBidCtx = getDefaultImpBidCtx(*payload.BidRequest) // for wrapper logger sz
+		return result, err
+	}
+
+	priceGranularity, err := computePriceGranularity(rCtx)
+	if err != nil {
+		result.NbrCode = nbr.InvalidPriceGranularityConfig
+		err = errors.New("failed to price granularity details: " + err.Error())
+		result.Errors = append(result.Errors, err.Error())
+		rCtx.ImpBidCtx = getDefaultImpBidCtx(*payload.BidRequest) // for wrapper logger sz
+		return result, err
+	}
+
+	rCtx.AdUnitConfig = m.cache.GetAdunitConfigFromCache(payload.BidRequest, rCtx.PubID, rCtx.ProfileID, rCtx.DisplayID)
+
+	requestExt.Prebid.Debug = rCtx.Debug
+	// requestExt.Prebid.SupportDeals = rCtx.SupportDeals && rCtx.IsCTVRequest // TODO: verify usecase of Prefered deals vs Support details
+	requestExt.Prebid.AlternateBidderCodes, rCtx.MarketPlaceBidders = getMarketplaceBidders(requestExt.Prebid.AlternateBidderCodes, partnerConfigMap)
+	requestExt.Prebid.Targeting = &openrtb_ext.ExtRequestTargeting{
+		PriceGranularity:  &priceGranularity,
+		IncludeBidderKeys: boolutil.BoolPtr(true),
+		IncludeWinners:    boolutil.BoolPtr(true),
+	}
+
+	disabledSlots := 0
+	serviceSideBidderPresent := false
+
+	aliasgvlids := make(map[string]uint16)
+	for i := 0; i < len(payload.BidRequest.Imp); i++ {
+		var adpodExt *models.AdPod
+		imp := payload.BidRequest.Imp[i]
+
+		if imp.TagID == "" {
+			result.NbrCode = nbr.InvalidImpressionTagID
+			err = errors.New("tagid missing for imp: " + imp.ID)
+			result.Errors = append(result.Errors, err.Error())
+			return result, err
+		}
+
+		if len(requestExt.Prebid.Macros) == 0 && imp.Video != nil {
+			// provide custom macros for video event trackers
+			requestExt.Prebid.Macros = getVASTEventMacros(rCtx)
+		}
+
+		impExt := &models.ImpExtension{}
+		if len(imp.Ext) != 0 {
+			err := json.Unmarshal(imp.Ext, impExt)
+			if err != nil {
+				result.NbrCode = nbr.InternalError
+				err = errors.New("failed to parse imp.ext: " + imp.ID)
+				result.Errors = append(result.Errors, err.Error())
+				return result, err
+			}
+		}
+
+		div := ""
+		if impExt.Wrapper != nil {
+			div = impExt.Wrapper.Div
+		}
+
+		incomingSlots := getIncomingSlots(imp)
+
+		var videoAdUnitCtx, bannerAdUnitCtx models.AdUnitCtx
+		if rCtx.AdUnitConfig != nil {
+			videoAdUnitCtx = adunitconfig.UpdateVideoObjectWithAdunitConfig(rCtx, imp, div, payload.BidRequest.Device.ConnectionType)
+			bannerAdUnitCtx = adunitconfig.UpdateBannerObjectWithAdunitConfig(rCtx, imp, div)
+		}
+
+		if !isSlotEnabled(videoAdUnitCtx, bannerAdUnitCtx) {
+			disabledSlots++
+
+			rCtx.ImpBidCtx[imp.ID] = models.ImpCtx{ // for wrapper logger sz
+				IncomingSlots: incomingSlots,
+			}
+			continue
+		}
+
+		slotType := "banner"
+		if imp.Video != nil {
+			slotType = "video"
+		}
+
+		bidderMeta := make(map[string]models.PartnerData)
+		nonMapped := make(map[string]struct{})
+		for _, partnerConfig := range rCtx.PartnerConfigMap {
+			if partnerConfig[models.SERVER_SIDE_FLAG] != "1" {
+				continue
+			}
+
+			partneridstr, ok := partnerConfig[models.PARTNER_ID]
+			if !ok {
+				continue
+			}
+			partnerID, err := strconv.Atoi(partneridstr)
+			if err != nil || partnerID == models.VersionLevelConfigID {
+				continue
+			}
+
+			// bidderCode is in context with pubmatic. Ex. it could be appnexus-1, appnexus-2, etc.
+			bidderCode := partnerConfig[models.BidderCode]
+			// prebidBidderCode is equivalent of PBS-Core's bidderCode
+			prebidBidderCode := partnerConfig[models.PREBID_PARTNER_NAME]
+			//
+			rCtx.PrebidBidderCode[prebidBidderCode] = bidderCode
+
+			if _, ok := rCtx.AdapterThrottleMap[bidderCode]; ok {
+				result.Warnings = append(result.Warnings, "Dropping throttled adapter from auction: "+bidderCode)
+				continue
+			}
+
+			var isRegex bool
+			var slot, kgpv string
+			var bidderParams json.RawMessage
+			switch prebidBidderCode {
+			case string(openrtb_ext.BidderPubmatic), models.BidderPubMaticSecondaryAlias:
+				slot, kgpv, isRegex, bidderParams, err = bidderparams.PreparePubMaticParamsV25(rCtx, m.cache, *payload.BidRequest, imp, *impExt, partnerID)
+			case models.BidderVASTBidder:
+				slot, bidderParams, err = bidderparams.PrepareVASTBidderParams(rCtx, m.cache, *payload.BidRequest, imp, *impExt, partnerID, adpodExt)
+			default:
+				slot, kgpv, isRegex, bidderParams, err = bidderparams.PrepareAdapterParamsV25(rCtx, m.cache, *payload.BidRequest, imp, *impExt, partnerID)
+			}
+
+			if err != nil || len(bidderParams) == 0 {
+				result.Errors = append(result.Errors, fmt.Sprintf("no bidder params found for imp:%s partner: %s", imp.ID, prebidBidderCode))
+				nonMapped[bidderCode] = struct{}{}
+				continue
+			}
+
+			bidderMeta[bidderCode] = models.PartnerData{
+				PartnerID:        partnerID,
+				PrebidBidderCode: prebidBidderCode,
+				MatchedSlot:      slot, // KGPSV
+				Params:           bidderParams,
+				KGP:              rCtx.PartnerConfigMap[partnerID][models.KEY_GEN_PATTERN], // acutual slot
+				KGPV:             kgpv,                                                     // regex pattern, use this field for pubmatic default unmapped slot as well using isRegex
+				IsRegex:          isRegex,                                                  // regex pattern
+			}
+
+			if alias, ok := partnerConfig[models.IsAlias]; ok && alias == "1" {
+				if prebidPartnerName, ok := partnerConfig[models.PREBID_PARTNER_NAME]; ok {
+					rCtx.Aliases[bidderCode] = adapters.ResolveOWBidder(prebidPartnerName)
+				}
+			}
+			if alias, ok := IsAlias(bidderCode); ok {
+				rCtx.Aliases[bidderCode] = alias
+			}
+
+			if partnerConfig[models.PREBID_PARTNER_NAME] == models.BidderVASTBidder {
+				updateAliasGVLIds(aliasgvlids, bidderCode, partnerConfig)
+			}
+
+			serviceSideBidderPresent = true
+		} // for(rctx.PartnerConfigMap
+
+		// update the imp.ext with bidder params for this
+		if impExt.Prebid.Bidder == nil {
+			impExt.Prebid.Bidder = make(map[string]json.RawMessage)
+		}
+		for bidder, meta := range bidderMeta {
+			impExt.Prebid.Bidder[bidder] = meta.Params
+		}
+
+		// reuse the existing impExt instead of allocating a new one
+		reward := impExt.Reward
+
+		if reward != nil {
+			impExt.Prebid.IsRewardedInventory = reward
+		}
+
+		impExt.Wrapper = nil
+		impExt.Reward = nil
+		impExt.Bidder = nil
+		newImpExt, err := json.Marshal(impExt)
+		if err != nil {
+			result.Errors = append(result.Errors, fmt.Sprintf("failed to update bidder params for impression %s", imp.ID))
+		}
+
+		// cache the details for further processing
+		if _, ok := rCtx.ImpBidCtx[imp.ID]; !ok {
+			rCtx.ImpBidCtx[imp.ID] = models.ImpCtx{
+				TagID:             imp.TagID,
+				Div:               div,
+				IsRewardInventory: reward,
+				Type:              slotType,
+				Banner:            imp.Banner != nil,
+				Video:             imp.Video,
+				IncomingSlots:     incomingSlots,
+				Bidders:           make(map[string]models.PartnerData),
+				BidCtx:            make(map[string]models.BidCtx),
+				NewExt:            json.RawMessage(newImpExt),
+			}
+		}
+
+		impCtx := rCtx.ImpBidCtx[imp.ID]
+		impCtx.Bidders = bidderMeta
+		impCtx.NonMapped = nonMapped
+		impCtx.VideoAdUnitCtx = videoAdUnitCtx
+		impCtx.BannerAdUnitCtx = bannerAdUnitCtx
+		rCtx.ImpBidCtx[imp.ID] = impCtx
+	} // for(imp
+
+	if disabledSlots == len(payload.BidRequest.Imp) {
+		result.NbrCode = nbr.AllSlotsDisabled
+		err = errors.New("All slots disabled: " + err.Error())
+		result.Errors = append(result.Errors, err.Error())
+		return result, nil
+	}
+
+	if !serviceSideBidderPresent {
+		result.NbrCode = nbr.ServerSidePartnerNotConfigured
+		err = errors.New("server side partner not found: " + err.Error())
+		result.Errors = append(result.Errors, err.Error())
+		return result, nil
+	}
+
+	if cto := setContentTransparencyObject(rCtx, requestExt); cto != nil {
+		requestExt.Prebid.Transparency = cto
+	}
+
+	adunitconfig.UpdateFloorsExtObjectFromAdUnitConfig(rCtx, &requestExt)
+	setPriceFloorFetchURL(&requestExt, rCtx.PartnerConfigMap)
+
+	if len(rCtx.Aliases) != 0 && requestExt.Prebid.Aliases == nil {
+		requestExt.Prebid.Aliases = make(map[string]string)
+	}
+	for k, v := range rCtx.Aliases {
+		requestExt.Prebid.Aliases[k] = v
+	}
+
+	requestExt.Prebid.AliasGVLIDs = aliasgvlids
+	if _, ok := rCtx.AdapterThrottleMap[string(openrtb_ext.BidderPubmatic)]; !ok {
+		requestExt.Prebid.BidderParams, _ = updateRequestExtBidderParamsPubmatic(requestExt.Prebid.BidderParams, rCtx.Cookies, rCtx.LoggerImpressionID, string(openrtb_ext.BidderPubmatic))
+	}
+
+	if _, ok := requestExt.Prebid.Aliases[string(models.BidderPubMaticSecondaryAlias)]; ok {
+		if _, ok := rCtx.AdapterThrottleMap[string(models.BidderPubMaticSecondaryAlias)]; !ok {
+			requestExt.Prebid.BidderParams, _ = updateRequestExtBidderParamsPubmatic(requestExt.Prebid.BidderParams, rCtx.Cookies, rCtx.LoggerImpressionID, string(models.BidderPubMaticSecondaryAlias))
+		}
+	}
+
+	// similar to impExt, reuse the existing requestExt to avoid additional memory requests
+	requestExt.Wrapper = nil
+	requestExt.Bidder = nil
+	rCtx.NewReqExt, err = json.Marshal(requestExt)
+	if err != nil {
+		result.Errors = append(result.Errors, "failed to update request.ext "+err.Error())
+	}
+
+	if rCtx.Debug {
+		newImp, _ := json.Marshal(rCtx.ImpBidCtx)
+		result.DebugMessages = append(result.DebugMessages, "new imp: "+string(newImp))
+		result.DebugMessages = append(result.DebugMessages, "new request.ext: "+string(rCtx.NewReqExt))
+	}
+
+	result.ChangeSet.AddMutation(func(ep hookstage.BeforeValidationRequestPayload) (hookstage.BeforeValidationRequestPayload, error) {
+		rctx := moduleCtx.ModuleContext["rctx"].(models.RequestCtx)
+		var err error
+		ep.BidRequest, err = m.applyProfileChanges(rctx, ep.BidRequest)
+		return ep, err
+	}, hookstage.MutationUpdate, "request-body-with-profile-data")
+
+	result.Reject = false
+	return result, nil
+}
+
+// applyProfileChanges copies and updates BidRequest with required values from http header and partnetConfigMap
+func (m *OpenWrap) applyProfileChanges(rctx models.RequestCtx, bidRequest *openrtb2.BidRequest) (*openrtb2.BidRequest, error) {
+	if rctx.IsTestRequest > 0 {
+		bidRequest.Test = 1
+	}
+
+	if cur, ok := rctx.PartnerConfigMap[models.VersionLevelConfigID][models.AdServerCurrency]; ok {
+		bidRequest.Cur = []string{cur}
+	}
+
+	if bidRequest.TMax == 0 {
+		bidRequest.TMax = rctx.TMax
+	}
+
+	if bidRequest.Source == nil {
+		bidRequest.Source = &openrtb2.Source{}
+	}
+	bidRequest.Source.TID = bidRequest.ID
+
+	for i := 0; i < len(bidRequest.Imp); i++ {
+		// TODO: move this to PBS-Core
+		if bidRequest.Imp[i].BidFloor == 0 {
+			bidRequest.Imp[i].BidFloorCur = ""
+		} else if bidRequest.Imp[i].BidFloorCur == "" {
+			bidRequest.Imp[i].BidFloorCur = "USD"
+		}
+
+		m.applyBannerAdUnitConfig(rctx, &bidRequest.Imp[i])
+		m.applyVideoAdUnitConfig(rctx, &bidRequest.Imp[i])
+		bidRequest.Imp[i].Ext = rctx.ImpBidCtx[bidRequest.Imp[i].ID].NewExt
+	}
+
+	if rctx.Platform == models.PLATFORM_APP || rctx.Platform == models.PLATFORM_VIDEO {
+		sChainObj := getSChainObj(rctx.PartnerConfigMap)
+		if sChainObj != nil {
+			setSchainInSourceObject(bidRequest.Source, sChainObj)
+		}
+	}
+
+	adunitconfig.ReplaceAppObjectFromAdUnitConfig(rctx, bidRequest.App)
+	adunitconfig.ReplaceDeviceTypeFromAdUnitConfig(rctx, bidRequest.Device)
+
+	bidRequest.Device.IP = rctx.IP
+	bidRequest.Device.Language = getValidLanguage(bidRequest.Device.Language)
+	validateDevice(bidRequest.Device)
+
+	if bidRequest.User == nil {
+		bidRequest.User = &openrtb2.User{}
+	}
+	if bidRequest.User.CustomData == "" && rctx.KADUSERCookie != nil {
+		bidRequest.User.CustomData = rctx.KADUSERCookie.Value
+	}
+	for i := 0; i < len(bidRequest.WLang); i++ {
+		bidRequest.WLang[i] = getValidLanguage(bidRequest.WLang[i])
+	}
+
+	if bidRequest.Site != nil && bidRequest.Site.Content != nil {
+		bidRequest.Site.Content.Language = getValidLanguage(bidRequest.Site.Content.Language)
+	} else if bidRequest.App != nil && bidRequest.App.Content != nil {
+		bidRequest.App.Content.Language = getValidLanguage(bidRequest.App.Content.Language)
+	}
+
+	bidRequest.Ext = rctx.NewReqExt
+	return bidRequest, nil
+}
+
+func (m *OpenWrap) applyVideoAdUnitConfig(rCtx models.RequestCtx, imp *openrtb2.Imp) {
+	if imp.Video == nil {
+		return
+	}
+
+	adUnitCfg := rCtx.ImpBidCtx[imp.ID].VideoAdUnitCtx.AppliedSlotAdUnitConfig
+	if adUnitCfg == nil {
+		return
+	}
+
+	if imp.BidFloor == 0 && adUnitCfg.BidFloor != nil {
+		imp.BidFloor = *adUnitCfg.BidFloor
+	}
+
+	if len(imp.BidFloorCur) == 0 && adUnitCfg.BidFloorCur != nil {
+		imp.BidFloorCur = *adUnitCfg.BidFloorCur
+	}
+
+	if adUnitCfg.Exp != nil {
+		imp.Exp = int64(*adUnitCfg.Exp)
+	}
+
+	if adUnitCfg.Video == nil {
+		return
+	}
+
+	//check if video is disabled, if yes then remove video from imp object
+	if adUnitCfg.Video.Enabled != nil && !*adUnitCfg.Video.Enabled {
+		imp.Video = nil
+		return
+	}
+
+	if adUnitCfg.Video.Config == nil {
+		return
+	}
+
+	configObjInVideoConfig := adUnitCfg.Video.Config
+
+	if len(imp.Video.MIMEs) == 0 {
+		imp.Video.MIMEs = configObjInVideoConfig.MIMEs
+	}
+
+	if imp.Video.MinDuration == 0 {
+		imp.Video.MinDuration = configObjInVideoConfig.MinDuration
+	}
+
+	if imp.Video.MaxDuration == 0 {
+		imp.Video.MaxDuration = configObjInVideoConfig.MaxDuration
+	}
+
+	if imp.Video.Skip == nil {
+		imp.Video.Skip = configObjInVideoConfig.Skip
+	}
+
+	if imp.Video.SkipMin == 0 {
+		imp.Video.SkipMin = configObjInVideoConfig.SkipMin
+	}
+
+	if imp.Video.SkipAfter == 0 {
+		imp.Video.SkipAfter = configObjInVideoConfig.SkipAfter
+	}
+
+	if len(imp.Video.BAttr) == 0 {
+		imp.Video.BAttr = configObjInVideoConfig.BAttr
+	}
+
+	if imp.Video.MinBitRate == 0 {
+		imp.Video.MinBitRate = configObjInVideoConfig.MinBitRate
+	}
+
+	if imp.Video.MaxBitRate == 0 {
+		imp.Video.MaxBitRate = configObjInVideoConfig.MaxBitRate
+	}
+
+	if imp.Video.MaxExtended == 0 {
+		imp.Video.MaxExtended = configObjInVideoConfig.MaxExtended
+	}
+
+	if imp.Video.StartDelay == nil {
+		imp.Video.StartDelay = configObjInVideoConfig.StartDelay
+	}
+
+	if imp.Video.Placement == 0 {
+		imp.Video.Placement = configObjInVideoConfig.Placement
+	}
+
+	if imp.Video.Linearity == 0 {
+		imp.Video.Linearity = configObjInVideoConfig.Linearity
+	}
+
+	if imp.Video.Protocol == 0 {
+		imp.Video.Protocol = configObjInVideoConfig.Protocol
+	}
+
+	if len(imp.Video.Protocols) == 0 {
+		imp.Video.Protocols = configObjInVideoConfig.Protocols
+	}
+
+	if imp.Video.W == 0 {
+		imp.Video.W = configObjInVideoConfig.W
+	}
+
+	if imp.Video.H == 0 {
+		imp.Video.H = configObjInVideoConfig.H
+	}
+
+	if imp.Video.Sequence == 0 {
+		imp.Video.Sequence = configObjInVideoConfig.Sequence
+	}
+
+	if imp.Video.BoxingAllowed == 0 {
+		imp.Video.BoxingAllowed = configObjInVideoConfig.BoxingAllowed
+	}
+
+	if len(imp.Video.PlaybackMethod) == 0 {
+		imp.Video.PlaybackMethod = configObjInVideoConfig.PlaybackMethod
+	}
+
+	if imp.Video.PlaybackEnd == 0 {
+		imp.Video.PlaybackEnd = configObjInVideoConfig.PlaybackEnd
+	}
+
+	if imp.Video.Delivery == nil {
+		imp.Video.Delivery = configObjInVideoConfig.Delivery
+	}
+
+	if imp.Video.Pos == nil {
+		imp.Video.Pos = configObjInVideoConfig.Pos
+	}
+
+	if len(imp.Video.API) == 0 {
+		imp.Video.API = configObjInVideoConfig.API
+	}
+
+	if len(imp.Video.CompanionType) == 0 {
+		imp.Video.CompanionType = configObjInVideoConfig.CompanionType
+	}
+
+	if imp.Video.CompanionAd == nil {
+		imp.Video.CompanionAd = configObjInVideoConfig.CompanionAd
+	}
+}
+
+func (m *OpenWrap) applyBannerAdUnitConfig(rCtx models.RequestCtx, imp *openrtb2.Imp) {
+	if imp.Banner == nil {
+		return
+	}
+
+	adUnitCfg := rCtx.ImpBidCtx[imp.ID].BannerAdUnitCtx.AppliedSlotAdUnitConfig
+	if adUnitCfg == nil {
+		return
+	}
+
+	if imp.BidFloor == 0 && adUnitCfg.BidFloor != nil {
+		imp.BidFloor = *adUnitCfg.BidFloor
+	}
+
+	if len(imp.BidFloorCur) == 0 && adUnitCfg.BidFloorCur != nil {
+		imp.BidFloorCur = *adUnitCfg.BidFloorCur
+	}
+
+	if adUnitCfg.Exp != nil {
+		imp.Exp = int64(*adUnitCfg.Exp)
+	}
+
+	if adUnitCfg.Banner == nil {
+		return
+	}
+
+	if adUnitCfg.Banner.Enabled != nil && !*adUnitCfg.Banner.Enabled {
+		imp.Banner = nil
+		return
+	}
+}
+
+func getDomainFromUrl(pageUrl string) string {
+	u, err := url.Parse(pageUrl)
+	if err != nil {
+		return ""
+	}
+
+	return u.Host
+}
+
+// always perfer rCtx.LoggerImpressionID received in request. Create a new once if it is not availble.
+// func getLoggerID(reqExt models.ExtRequestWrapper) string {
+// 	if reqExt.Wrapper.LoggerImpressionID != "" {
+// 		return reqExt.Wrapper.LoggerImpressionID
+// 	}
+// 	return uuid.NewV4().String()
+// }
+
+// NYC: make this generic. Do we need this?. PBS now has auto_gen_source_tid generator. We can make it to wiid for pubmatic adapter in pubmatic.go
+func updateRequestExtBidderParamsPubmatic(bidderParams json.RawMessage, cookie, loggerID, bidderCode string) (json.RawMessage, error) {
+	bidderParamsMap := make(map[string]map[string]interface{})
+	_ = json.Unmarshal(bidderParams, &bidderParamsMap) // ignore error, incoming might be nil for now but we still have data to put
+
+	bidderParamsMap[bidderCode] = map[string]interface{}{
+		models.WrapperLoggerImpID: loggerID,
+	}
+
+	if len(cookie) != 0 {
+		bidderParamsMap[bidderCode][models.COOKIE] = cookie
+	}
+
+	return json.Marshal(bidderParamsMap)
+}
+
+func getPageURL(bidRequest *openrtb2.BidRequest) string {
+	if bidRequest.App != nil && bidRequest.App.StoreURL != "" {
+		return bidRequest.App.StoreURL
+	} else if bidRequest.Site != nil && bidRequest.Site.Page != "" {
+		return bidRequest.Site.Page
+	}
+	return ""
+}
+
+// getVASTEventMacros populates macros with PubMatic specific macros
+// These marcros is used in replacing with actual values of Macros in case of Video Event tracke URLs
+// If this function fails to determine value of any macro then it continues with next macro setup
+// returns true when at least one macro is added to map
+func getVASTEventMacros(rctx models.RequestCtx) map[string]string {
+	macros := map[string]string{
+		string(models.MacroProfileID):           fmt.Sprintf("%d", rctx.ProfileID),
+		string(models.MacroProfileVersionID):    fmt.Sprintf("%d", rctx.DisplayID),
+		string(models.MacroUnixTimeStamp):       fmt.Sprintf("%d", rctx.StartTime),
+		string(models.MacroPlatform):            fmt.Sprintf("%d", rctx.DevicePlatform),
+		string(models.MacroWrapperImpressionID): rctx.LoggerImpressionID,
+	}
+
+	if rctx.SSAI != "" {
+		macros[string(models.MacroSSAI)] = rctx.SSAI
+	}
+
+	return macros
+}
+
+func updateAliasGVLIds(aliasgvlids map[string]uint16, bidderCode string, partnerConfig map[string]string) {
+	if vendorID, ok := partnerConfig[models.VENDORID]; ok && vendorID != "" {
+		vid, err := strconv.ParseUint(vendorID, 10, 64)
+		if err != nil {
+			return
+		}
+
+		if vid == 0 {
+			return
+		}
+		aliasgvlids[bidderCode] = uint16(vid)
+	}
+}
+
+// setTimeout - This utility returns timeout applicable for a profile
+func (m OpenWrap) setTimeout(rCtx models.RequestCtx) int64 {
+	var auctionTimeout int64
+
+	//check for ssTimeout in the partner config
+	ssTimeout := models.GetVersionLevelPropertyFromPartnerConfig(rCtx.PartnerConfigMap, models.SSTimeoutKey)
+	if ssTimeout != "" {
+		ssTimeoutDB, err := strconv.Atoi(ssTimeout)
+		if err == nil {
+			auctionTimeout = int64(ssTimeoutDB)
+		}
+	}
+
+	// found tmax value in request or db
+	if auctionTimeout != 0 {
+		if auctionTimeout < m.cfg.Timeout.MinTimeout {
+			return m.cfg.Timeout.MinTimeout
+		} else if auctionTimeout > m.cfg.Timeout.MaxTimeout {
+			return m.cfg.Timeout.MaxTimeout
+		}
+		return auctionTimeout
+	}
+
+	//Below piece of code is applicable for older profiles where ssTimeout is not set
+	//Here we will check the partner timeout and select max timeout considering timeout range
+	auctionTimeout = m.cfg.Timeout.MinTimeout
+	for _, partnerConfig := range rCtx.PartnerConfigMap {
+		partnerTO, _ := strconv.Atoi(partnerConfig[models.TIMEOUT])
+		if int64(partnerTO) > m.cfg.Timeout.MaxTimeout {
+			auctionTimeout = m.cfg.Timeout.MaxTimeout
+			break
+		}
+		if int64(partnerTO) >= m.cfg.Timeout.MinTimeout {
+			if auctionTimeout < int64(partnerTO) {
+				auctionTimeout = int64(partnerTO)
+			}
+		}
+	}
+	return auctionTimeout
+}
+
+// isSendAllBids returns true in below cases:
+// if ssauction flag is set 0 in the request
+// if ssauction flag is not set and platform is dislay, then by default send all bids
+// if ssauction flag is not set and platform is in-app, then check if profile setting sendAllBids is set to 1
+func isSendAllBids(rctx models.RequestCtx) bool {
+
+	//if ssauction is set to 0 in the request
+	if rctx.SSAuction == 0 {
+		return true
+	} else if rctx.SSAuction == -1 && rctx.Platform == models.PLATFORM_APP {
+		// if platform is in-app, then check if profile setting sendAllBids is set to 1
+		if models.GetVersionLevelPropertyFromPartnerConfig(rctx.PartnerConfigMap, models.SendAllBidsKey) == "1" {
+			return true
+		}
+	}
+	return false
+}
+
+func getValidLanguage(language string) string {
+	if len(language) > 2 {
+		lang := language[0:2]
+		if models.ValidCode(lang) {
+			return lang
+		}
+	}
+	return language
+}
+
+func isSlotEnabled(videoAdUnitCtx, bannerAdUnitCtx models.AdUnitCtx) bool {
+	videoEnabled := true
+	if videoAdUnitCtx.AppliedSlotAdUnitConfig != nil && videoAdUnitCtx.AppliedSlotAdUnitConfig.Video != nil &&
+		videoAdUnitCtx.AppliedSlotAdUnitConfig.Video.Enabled != nil && !*videoAdUnitCtx.AppliedSlotAdUnitConfig.Video.Enabled {
+		videoEnabled = false
+	}
+
+	bannerEnabled := true
+	if bannerAdUnitCtx.AppliedSlotAdUnitConfig != nil && bannerAdUnitCtx.AppliedSlotAdUnitConfig.Banner != nil &&
+		bannerAdUnitCtx.AppliedSlotAdUnitConfig.Banner.Enabled != nil && !*bannerAdUnitCtx.AppliedSlotAdUnitConfig.Banner.Enabled {
+		bannerEnabled = false
+	}
+
+	return videoEnabled || bannerEnabled
+}
+
+func getPubID(bidRequest openrtb2.BidRequest) (int, error) {
+	var pubID int
+	var err error
+
+	if bidRequest.Site != nil && bidRequest.Site.Publisher != nil {
+		pubID, err = strconv.Atoi(bidRequest.Site.Publisher.ID)
+	} else if bidRequest.App != nil && bidRequest.App.Publisher != nil {
+		pubID, err = strconv.Atoi(bidRequest.App.Publisher.ID)
+	}
+
+	return pubID, err
+}
diff --git a/modules/pubmatic/openwrap/bidderparams/common.go b/modules/pubmatic/openwrap/bidderparams/common.go
new file mode 100644
index 000000000..50c1428f3
--- /dev/null
+++ b/modules/pubmatic/openwrap/bidderparams/common.go
@@ -0,0 +1,215 @@
+package bidderparams
+
+import (
+	"fmt"
+	"regexp"
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/cache"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+var ignoreKeys = map[string]bool{
+	models.PARTNER_ACCOUNT_NAME: true,
+	models.ADAPTER_NAME:         true,
+	models.ADAPTER_ID:           true,
+	models.TIMEOUT:              true,
+	models.KEY_GEN_PATTERN:      true,
+	models.PREBID_PARTNER_NAME:  true,
+	models.PROTOCOL:             true,
+	models.SERVER_SIDE_FLAG:     true,
+	models.LEVEL:                true,
+	models.PARTNER_ID:           true,
+	models.REVSHARE:             true,
+	models.THROTTLE:             true,
+	models.BidderCode:           true,
+	models.IsAlias:              true,
+}
+
+func getSlotMeta(rctx models.RequestCtx, cache cache.Cache, bidRequest openrtb2.BidRequest, imp openrtb2.Imp, impExt models.ImpExtension, partnerID int) ([]string, map[string]models.SlotMapping, models.SlotMappingInfo, [][2]int64) {
+	var slotMap map[string]models.SlotMapping
+	var slotMappingInfo models.SlotMappingInfo
+
+	//don't read mappings from cache in case of test=2
+	if rctx.IsTestRequest == 0 {
+		slotMap = cache.GetMappingsFromCacheV25(rctx, partnerID)
+		if slotMap == nil {
+			return nil, nil, models.SlotMappingInfo{}, nil
+		}
+		slotMappingInfo = cache.GetSlotToHashValueMapFromCacheV25(rctx, partnerID)
+		if len(slotMappingInfo.OrderedSlotList) == 0 {
+			return nil, nil, models.SlotMappingInfo{}, nil
+		}
+	}
+
+	var hw [][2]int64
+	if imp.Banner != nil {
+		if imp.Banner.W != nil && imp.Banner.H != nil {
+			hw = append(hw, [2]int64{*imp.Banner.H, *imp.Banner.W})
+		}
+
+		for _, format := range imp.Banner.Format {
+			hw = append(hw, [2]int64{format.H, format.W})
+		}
+	}
+
+	if imp.Video != nil {
+		hw = append(hw, [2]int64{0, 0})
+	}
+
+	if imp.Native != nil {
+		hw = append(hw, [2]int64{1, 1})
+	}
+
+	kgp := rctx.PartnerConfigMap[partnerID][models.KEY_GEN_PATTERN]
+
+	var div string
+	if impExt.Wrapper != nil {
+		div = impExt.Wrapper.Div
+	}
+
+	var slots []string
+	for _, format := range hw {
+		// TODO fix the param sequence. make it consistent. HxW
+		slot := GenerateSlotName(format[0], format[1], kgp, imp.TagID, div, rctx.Source)
+		if slot != "" {
+			slots = append(slots, slot)
+			// NYC_TODO: break at i=0 for pubmatic?
+		}
+	}
+
+	// NYC_TODO wh is returned temporarily
+	return slots, slotMap, slotMappingInfo, hw
+}
+
+// Harcode would be the optimal. We could make it configurable like _AU_@_W_x_H_:%s@%dx%d entries in pbs.yaml
+// mysql> SELECT DISTINCT key_gen_pattern FROM wrapper_mapping_template;
+// +----------------------+
+// | key_gen_pattern      |
+// +----------------------+
+// | _AU_@_W_x_H_         |
+// | _DIV_@_W_x_H_        |
+// | _W_x_H_@_W_x_H_      |
+// | _DIV_                |
+// | _AU_@_DIV_@_W_x_H_   |
+// | _AU_@_SRC_@_VASTTAG_ |
+// +----------------------+
+// 6 rows in set (0.21 sec)
+func GenerateSlotName(h, w int64, kgp, tagid, div, src string) string {
+	// func (H, W, Div), no need to validate, will always be non-nil
+	switch kgp {
+	case "_AU_": // adunitconfig
+		return tagid
+	case "_DIV_":
+		return div
+	case "_AU_@_W_x_H_":
+		return fmt.Sprintf("%s@%dx%d", tagid, w, h)
+	case "_DIV_@_W_x_H_":
+		return fmt.Sprintf("%s@%dx%d", div, w, h)
+	case "_W_x_H_@_W_x_H_":
+		return fmt.Sprintf("%dx%d@%dx%d", w, h, w, h)
+	case "_AU_@_DIV_@_W_x_H_":
+		return fmt.Sprintf("%s@%s@%dx%d", tagid, div, w, h)
+	case "_AU_@_SRC_@_VASTTAG_":
+		return fmt.Sprintf("%s@%s@s_VASTTAG_", tagid, src) //TODO check where/how _VASTTAG_ is updated
+	default:
+		// TODO: check if we need to fallback to old generic flow (below)
+		// Add this cases in a map and read it from yaml file
+	}
+	return ""
+}
+
+/*
+formSlotForDefaultMapping: In this method, we are removing wxh from the kgp because
+pubmatic adapter sets wxh that we send in imp.ext.pubmatic.adslot as primary size while calling translator.
+In case of default mappings, since all sizes are unmapped, we don't want to treat any size as primary
+thats why we are removing size from kgp
+*/
+func getDefaultMappingKGP(keyGenPattern string) string {
+	if strings.Contains(keyGenPattern, "@_W_x_H_") {
+		return strings.ReplaceAll(keyGenPattern, "@_W_x_H_", "")
+	}
+	return keyGenPattern
+}
+
+// getSlotMappings will returns slotMapping from map based on slotKey
+func getSlotMappings(matchedSlot, matchedPattern string, slotMap map[string]models.SlotMapping) map[string]interface{} {
+	slotKey := matchedSlot
+	if matchedPattern != "" {
+		slotKey = matchedPattern
+	}
+
+	if slotMappingObj, ok := slotMap[strings.ToLower(slotKey)]; ok {
+		return slotMappingObj.SlotMappings
+	}
+
+	return nil
+}
+
+func GetMatchingSlot(rctx models.RequestCtx, cache cache.Cache, slot string, slotMap map[string]models.SlotMapping, slotMappingInfo models.SlotMappingInfo, isRegexKGP bool, partnerID int) (string, string) {
+	if _, ok := slotMap[strings.ToLower(slot)]; ok {
+		return slot, ""
+	}
+
+	if isRegexKGP {
+		if matchedSlot, regexPattern := GetRegexMatchingSlot(rctx, cache, slot, slotMap, slotMappingInfo, partnerID); matchedSlot != "" {
+			return matchedSlot, regexPattern
+		}
+	}
+
+	return "", ""
+}
+
+const pubSlotRegex = "psregex_%d_%d_%d_%d_%s" // slot and its matching regex info at publisher, profile, display version and adapter level
+
+// TODO: handle this db injection correctly
+func GetRegexMatchingSlot(rctx models.RequestCtx, cache cache.Cache, slot string, slotMap map[string]models.SlotMapping, slotMappingInfo models.SlotMappingInfo, partnerID int) (string, string) {
+	type regexSlotEntry struct {
+		SlotName     string
+		RegexPattern string
+	}
+
+	// Ex. "psregex_5890_56777_1_8_/43743431/DMDemo1@@728x90"
+	cacheKey := fmt.Sprintf(pubSlotRegex, rctx.PubID, rctx.ProfileID, rctx.DisplayID, partnerID, slot)
+	if v, ok := cache.Get(cacheKey); ok {
+		if rse, ok := v.(regexSlotEntry); ok {
+			return rse.SlotName, rse.RegexPattern
+		}
+	}
+
+	//Flags passed to regexp.Compile
+	regexFlags := "(?i)" // case in-sensitive match
+
+	// if matching regex is not found in cache, run checks for the regex patterns in DB
+	for _, slotname := range slotMappingInfo.OrderedSlotList {
+		slotnameMatched := false
+		dbSlotNameParts := strings.Split(slotname, "@")
+		requestSlotKeyParts := strings.Split(slot, "@")
+		if len(dbSlotNameParts) == len(requestSlotKeyParts) {
+			for i, dbPart := range dbSlotNameParts {
+				re, err := regexp.Compile(regexFlags + dbPart)
+				if err != nil {
+					// If an invalid regex pattern is encountered, check further entries intead of returning immediately
+					break
+				}
+				matchingPart := re.FindString(requestSlotKeyParts[i])
+				if matchingPart == "" && requestSlotKeyParts[i] != "" {
+					// request slot key did not match the Regex pattern
+					// check the next regex pattern from the DB
+					break
+				}
+				if i == len(dbSlotNameParts)-1 {
+					slotnameMatched = true
+				}
+			}
+		}
+
+		if slotnameMatched {
+			cache.Set(cacheKey, regexSlotEntry{SlotName: slot, RegexPattern: slotname})
+			return slot, slotname
+		}
+	}
+
+	return "", ""
+}
diff --git a/modules/pubmatic/openwrap/bidderparams/others.go b/modules/pubmatic/openwrap/bidderparams/others.go
new file mode 100644
index 000000000..0a0cefbeb
--- /dev/null
+++ b/modules/pubmatic/openwrap/bidderparams/others.go
@@ -0,0 +1,58 @@
+package bidderparams
+
+import (
+	"errors"
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/adapters"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/cache"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+func PrepareAdapterParamsV25(rctx models.RequestCtx, cache cache.Cache, bidRequest openrtb2.BidRequest, imp openrtb2.Imp, impExt models.ImpExtension, partnerID int) (string, string, bool, []byte, error) {
+	partnerConfig, ok := rctx.PartnerConfigMap[partnerID]
+	if !ok {
+		return "", "", false, nil, errors.New("ErrBidderParamsValidationError")
+	}
+
+	var isRegexSlot bool
+	var matchedSlot, matchedPattern string
+
+	isRegexKGP := rctx.PartnerConfigMap[partnerID][models.KEY_GEN_PATTERN] == models.REGEX_KGP
+	slots, slotMap, slotMappingInfo, hw := getSlotMeta(rctx, cache, bidRequest, imp, impExt, partnerID)
+
+	for i, slot := range slots {
+		matchedSlot, matchedPattern = GetMatchingSlot(rctx, cache, slot, slotMap, slotMappingInfo, isRegexKGP, partnerID)
+		if matchedSlot == "" {
+			continue
+		}
+
+		slotMappingObj, ok := slotMap[strings.ToLower(matchedSlot)]
+		if !ok {
+			slotMappingObj = slotMap[strings.ToLower(matchedPattern)]
+			isRegexSlot = true
+		}
+
+		bidderParams := make(map[string]interface{}, len(slotMappingObj.SlotMappings))
+		for k, v := range slotMappingObj.SlotMappings {
+			bidderParams[k] = v
+		}
+
+		for key, value := range partnerConfig {
+			if !ignoreKeys[key] {
+				bidderParams[key] = value
+			}
+		}
+
+		h := hw[i][0]
+		w := hw[i][1]
+		params, err := adapters.PrepareBidParamJSONForPartner(&w, &h, bidderParams, slot, partnerConfig[models.PREBID_PARTNER_NAME], partnerConfig[models.BidderCode], &impExt)
+		if err != nil || params == nil {
+			continue
+		}
+		return matchedSlot, matchedPattern, isRegexSlot, params, nil
+	}
+
+	return "", "", false, nil, nil
+}
diff --git a/modules/pubmatic/openwrap/bidderparams/pubmatic.go b/modules/pubmatic/openwrap/bidderparams/pubmatic.go
new file mode 100644
index 000000000..f19a1ea92
--- /dev/null
+++ b/modules/pubmatic/openwrap/bidderparams/pubmatic.go
@@ -0,0 +1,128 @@
+package bidderparams
+
+import (
+	"encoding/json"
+	"fmt"
+	"strconv"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/cache"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func PreparePubMaticParamsV25(rctx models.RequestCtx, cache cache.Cache, bidRequest openrtb2.BidRequest, imp openrtb2.Imp, impExt models.ImpExtension, partnerID int) (string, string, bool, []byte, error) {
+	wrapExt := fmt.Sprintf(`{"%s":%d,"%s":%d}`, models.SS_PM_VERSION_ID, rctx.DisplayID, models.SS_PM_PROFILE_ID, rctx.ProfileID)
+	extImpPubMatic := openrtb_ext.ExtImpPubmatic{
+		PublisherId: strconv.Itoa(rctx.PubID),
+		WrapExt:     json.RawMessage(wrapExt),
+		Keywords:    getImpExtPubMaticKeyWords(impExt, rctx.PartnerConfigMap[partnerID][models.BidderCode]),
+		DealTier:    getDealTier(impExt, rctx.PartnerConfigMap[partnerID][models.BidderCode]),
+	}
+
+	slots, slotMap, slotMappingInfo, _ := getSlotMeta(rctx, cache, bidRequest, imp, impExt, partnerID)
+
+	if rctx.IsTestRequest > 0 {
+		extImpPubMatic.AdSlot = slots[0]
+		params, err := json.Marshal(extImpPubMatic)
+		return extImpPubMatic.AdSlot, "", false, params, err
+	}
+
+	hash := ""
+	var err error
+	var matchedSlot, matchedPattern string
+	isRegexSlot := false
+
+	kgp := rctx.PartnerConfigMap[partnerID][models.KEY_GEN_PATTERN]
+	isRegexKGP := kgp == models.REGEX_KGP
+
+	// simple+regex key match
+	for _, slot := range slots {
+		matchedSlot, matchedPattern = GetMatchingSlot(rctx, cache, slot, slotMap, slotMappingInfo, isRegexKGP, partnerID)
+		if matchedSlot != "" {
+			extImpPubMatic.AdSlot = matchedSlot
+
+			if matchedPattern != "" {
+				isRegexSlot = true
+				// imp.TagID = hash
+				// TODO: handle kgpv case sensitivity in hashvaluemap
+				if slotMappingInfo.HashValueMap != nil {
+					if v, ok := slotMappingInfo.HashValueMap[matchedPattern]; ok {
+						extImpPubMatic.AdSlot = v
+						imp.TagID = hash // TODO, make imp pointer. But do other bidders accept hash as TagID?
+					}
+				}
+			}
+
+			break
+		}
+	}
+
+	if paramMap := getSlotMappings(matchedSlot, matchedPattern, slotMap); paramMap != nil {
+		if matchedPattern == "" {
+			// use alternate names defined in DB for this slot if selection is non-regex
+			// use owSlotName to addres case insensitive slotname.
+			// Ex: slot="/43743431/DMDEMO@300x250" and owSlotName="/43743431/DMDemo@300x250"
+			if v, ok := paramMap[models.KEY_OW_SLOT_NAME]; ok {
+				if owSlotName, ok := v.(string); ok {
+					extImpPubMatic.AdSlot = owSlotName
+				}
+			}
+		}
+
+		// Update slot key for PubMatic secondary flow
+		if v, ok := paramMap[models.KEY_SLOT_NAME]; ok {
+			if secondarySlotName, ok := v.(string); ok {
+				extImpPubMatic.AdSlot = secondarySlotName
+			}
+		}
+	}
+
+	// last resort: send slotname w/o size to translator
+	if extImpPubMatic.AdSlot == "" {
+		var div string
+		if impExt.Wrapper != nil {
+			div = impExt.Wrapper.Div
+		}
+		unmappedKPG := getDefaultMappingKGP(kgp)
+		extImpPubMatic.AdSlot = GenerateSlotName(0, 0, unmappedKPG, imp.TagID, div, rctx.Source)
+		if len(slots) != 0 { // reuse this field for wt and wl in combination with isRegex
+			matchedPattern = slots[0]
+		}
+	}
+
+	params, err := json.Marshal(extImpPubMatic)
+	return matchedSlot, matchedPattern, isRegexSlot, params, err
+}
+
+func getDealTier(impExt models.ImpExtension, bidderCode string) *openrtb_ext.DealTier {
+	if len(impExt.Bidder) != 0 {
+		if bidderExt, ok := impExt.Bidder[bidderCode]; ok && bidderExt != nil && bidderExt.DealTier != nil {
+			return bidderExt.DealTier
+		}
+	}
+	return nil
+}
+
+func getImpExtPubMaticKeyWords(impExt models.ImpExtension, bidderCode string) []*openrtb_ext.ExtImpPubmaticKeyVal {
+	if len(impExt.Bidder) != 0 {
+		if bidderExt, ok := impExt.Bidder[bidderCode]; ok && bidderExt != nil && len(bidderExt.KeyWords) != 0 {
+			keywords := make([]*openrtb_ext.ExtImpPubmaticKeyVal, 0)
+			for _, keyVal := range bidderExt.KeyWords {
+				//ignore key values pair with no values
+				if len(keyVal.Values) == 0 {
+					continue
+				}
+				keyValPair := openrtb_ext.ExtImpPubmaticKeyVal{
+					Key:    keyVal.Key,
+					Values: keyVal.Values,
+				}
+				keywords = append(keywords, &keyValPair)
+			}
+			if len(keywords) != 0 {
+				return keywords
+			}
+		}
+	}
+	return nil
+}
diff --git a/modules/pubmatic/openwrap/bidderparams/vast.go b/modules/pubmatic/openwrap/bidderparams/vast.go
new file mode 100644
index 000000000..ef5cf9d72
--- /dev/null
+++ b/modules/pubmatic/openwrap/bidderparams/vast.go
@@ -0,0 +1,182 @@
+package bidderparams
+
+import (
+	"encoding/json"
+	"errors"
+	"fmt"
+	"strconv"
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/adapters"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/cache"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+func PrepareVASTBidderParams(rctx models.RequestCtx, cache cache.Cache, bidRequest openrtb2.BidRequest, imp openrtb2.Imp, impExt models.ImpExtension, partnerID int, adpodExt *models.AdPod) (string, json.RawMessage, error) {
+	if imp.Video == nil {
+		return "", nil, nil
+	}
+
+	slots, slotMap, _, _ := getSlotMeta(rctx, cache, bidRequest, imp, impExt, partnerID)
+	if len(slots) == 0 {
+		return "", nil, nil
+	}
+
+	pubVASTTags := cache.GetPublisherVASTTagsFromCache(rctx.PubID)
+	if len(pubVASTTags) == 0 {
+		return "", nil, nil
+	}
+
+	matchedSlotKeys, err := getVASTBidderSlotKeys(&imp, slots[0], slotMap, pubVASTTags, adpodExt)
+	if len(matchedSlotKeys) == 0 {
+		return "", nil, err
+	}
+
+	// NYC_TODO:
+	//setting flagmap
+	// bidderWrapper := &BidderWrapper{VASTagFlags: make(map[string]bool)}
+	// for _, key := range matchedSlotKeys {
+	// 	bidderWrapper.VASTagFlags[key] = false
+	// }
+	// impWrapper.Bidder[bidderCode] = bidderWrapper
+
+	bidParams := adapters.PrepareVASTBidderParamJSON(&bidRequest, &imp, pubVASTTags, matchedSlotKeys, slotMap, adpodExt)
+
+	/*
+		Sample Values
+			//slotkey:/15671365/DMDemo1@com.pubmatic.openbid.app@
+			//slotKeys:[/15671365/DMDemo1@com.pubmatic.openbid.app@101]
+			//slotMap:map[/15671365/DMDemo1@com.pubmatic.openbid.app@101:map[param1:6005 param2:test param3:example]]
+			//Ext:{"tags":[{"tagid":"101","url":"sample_url_1","dur":15,"price":"15","params":{"param1":"6005","param2":"test","param3":"example"}}]}
+	*/
+	return slots[0], bidParams, nil
+}
+
+// getVASTBidderSlotKeys returns all slot keys which are matching to vast tag slot key
+func getVASTBidderSlotKeys(imp *openrtb2.Imp,
+	slotKey string,
+	slotMap map[string]models.SlotMapping,
+	pubVASTTags models.PublisherVASTTags,
+	adpodExt *models.AdPod) ([]string, error) {
+
+	//TODO: Optimize this function
+	var (
+		result, defaultMapping []string
+		validationErr          error
+		isValidationError      bool
+	)
+
+	for _, sm := range slotMap {
+		//formCaseInsensitiveVASTSlotKey forms slotKey for case in-sensitive comparison.
+		//It converts AdUnit part of slot key to lower case for comparison.
+		//Currently it only supports slot-keys of the format <AdUnit>@<bundle-id>@<VAST ID>
+		//This function needs to be enhanced to support different slot-key formats.
+		key := formCaseInsensitiveVASTSlotKey(sm.SlotName)
+		tempSlotKey := formCaseInsensitiveVASTSlotKey(slotKey)
+		isDefaultMappingSelected := false
+
+		index := strings.Index(key, "@@")
+		if -1 != index {
+			//prefix check only for `/15671365/MG_VideoAdUnit@`
+			if false == strings.HasPrefix(tempSlotKey, key[:index+1]) {
+				continue
+			}
+
+			//getting slot key `/15671365/MG_VideoAdUnit@@`
+			tempSlotKey = key[:index+2]
+			isDefaultMappingSelected = true
+		} else if false == strings.HasPrefix(key, tempSlotKey) {
+			continue
+		}
+
+		//get vast tag id and slotkey
+		vastTagID, _ := strconv.Atoi(key[len(tempSlotKey):])
+		if 0 == vastTagID {
+			continue
+		}
+
+		//check pubvasttag details
+		vastTag, ok := pubVASTTags[vastTagID]
+		if false == ok {
+			continue
+		}
+
+		//validate vast tag details
+		if err := validateVASTTag(vastTag, imp.Video.MinDuration, imp.Video.MaxDuration, adpodExt); nil != err {
+			isValidationError = true
+			continue
+		}
+
+		if isDefaultMappingSelected {
+			defaultMapping = append(defaultMapping, sm.SlotName)
+		} else {
+			result = append(result, sm.SlotName)
+		}
+	}
+
+	if len(result) == 0 && len(defaultMapping) == 0 && isValidationError {
+		validationErr = errors.New("ErrInvalidVastTag")
+	}
+
+	if len(result) == 0 {
+		return defaultMapping, validationErr
+	}
+
+	return result, validationErr
+}
+
+// formCaseInsensitiveVASTSlotKey forms slotKey for case in-sensitive comparison.
+// It converts AdUnit part of slot key to lower case for comparison.
+// Currently it only supports slot-keys of the format <AdUnit>@<bundle-id>@<VAST ID>
+// This function needs to be enhanced to support different slot-key formats.
+func formCaseInsensitiveVASTSlotKey(key string) string {
+	index := strings.Index(key, "@")
+	caseInsensitiveSlotKey := key
+	if index != -1 {
+		caseInsensitiveSlotKey = strings.ToLower(key[:index]) + key[index:]
+	}
+	return caseInsensitiveSlotKey
+}
+
+func validateVASTTag(
+	vastTag *models.VASTTag,
+	videoMinDuration, videoMaxDuration int64,
+	adpod *models.AdPod) error {
+
+	if nil == vastTag {
+		return fmt.Errorf("Empty vast tag")
+	}
+
+	//TODO: adding checks for Duration and URL
+	if len(vastTag.URL) == 0 {
+		return fmt.Errorf("VAST tag mandatory parameter 'url' missing: %v", vastTag.ID)
+	}
+
+	if vastTag.Duration <= 0 {
+		return fmt.Errorf("VAST tag mandatory parameter 'duration' missing: %v", vastTag.ID)
+	}
+
+	if vastTag.Duration > int(videoMaxDuration) {
+		return fmt.Errorf("VAST tag 'duration' validation failed 'tag.duration > video.maxduration' vastTagID:%v, tag.duration:%v, video.maxduration:%v", vastTag.ID, vastTag.Duration, videoMaxDuration)
+	}
+
+	if nil == adpod {
+		//non-adpod request
+		if vastTag.Duration < int(videoMinDuration) {
+			return fmt.Errorf("VAST tag 'duration' validation failed 'tag.duration < video.minduration' vastTagID:%v, tag.duration:%v, video.minduration:%v", vastTag.ID, vastTag.Duration, videoMinDuration)
+		}
+
+	} else {
+		//adpod request
+		if nil != adpod.MinDuration && vastTag.Duration < *adpod.MinDuration {
+			return fmt.Errorf("VAST tag 'duration' validation failed 'tag.duration < adpod.minduration' vastTagID:%v, tag.duration:%v, adpod.minduration:%v", vastTag.ID, vastTag.Duration, *adpod.MinDuration)
+		}
+
+		if nil != adpod.MaxDuration && vastTag.Duration > *adpod.MaxDuration {
+			return fmt.Errorf("VAST tag 'duration' validation failed 'tag.duration > adpod.maxduration' vastTagID:%v, tag.duration:%v, adpod.maxduration:%v", vastTag.ID, vastTag.Duration, *adpod.MaxDuration)
+		}
+	}
+
+	return nil
+}
diff --git a/modules/pubmatic/openwrap/bidders.go b/modules/pubmatic/openwrap/bidders.go
new file mode 100644
index 000000000..88b46411f
--- /dev/null
+++ b/modules/pubmatic/openwrap/bidders.go
@@ -0,0 +1,20 @@
+package openwrap
+
+import (
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+var alias = map[string]string{
+	models.BidderAdGenerationAlias:      string(openrtb_ext.BidderAdgeneration),
+	models.BidderDistrictmDMXAlias:      string(openrtb_ext.BidderDmx),
+	models.BidderPubMaticSecondaryAlias: string(openrtb_ext.BidderPubmatic),
+	models.BidderDistrictmAlias:         string(openrtb_ext.BidderAppnexus),
+	models.BidderAndBeyondAlias:         string(openrtb_ext.BidderAdkernel),
+}
+
+// IsAlias will return copy of exisiting alias
+func IsAlias(bidder string) (string, bool) {
+	v, ok := alias[bidder]
+	return v, ok
+}
diff --git a/modules/pubmatic/openwrap/cache.go b/modules/pubmatic/openwrap/cache.go
new file mode 100644
index 000000000..83a8f4c97
--- /dev/null
+++ b/modules/pubmatic/openwrap/cache.go
@@ -0,0 +1,24 @@
+package openwrap
+
+import (
+	"strconv"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func getTestModePartnerConfigMap(pubid, profileid, displayversion int, platform string) map[int]map[string]string {
+	return map[int]map[string]string{
+		1: {
+			models.PARTNER_ID:          models.PUBMATIC_PARTNER_ID_STRING,
+			models.PREBID_PARTNER_NAME: string(openrtb_ext.BidderPubmatic),
+			models.BidderCode:          string(openrtb_ext.BidderPubmatic),
+			models.SERVER_SIDE_FLAG:    models.PUBMATIC_SS_FLAG,
+			models.KEY_GEN_PATTERN:     models.ADUNIT_SIZE_KGP,
+		},
+		-1: {
+			models.PLATFORM_KEY:     platform,
+			models.DisplayVersionID: strconv.Itoa(displayversion),
+		},
+	}
+}
diff --git a/modules/pubmatic/openwrap/cache/cache.go b/modules/pubmatic/openwrap/cache/cache.go
new file mode 100644
index 000000000..9a8b19bd0
--- /dev/null
+++ b/modules/pubmatic/openwrap/cache/cache.go
@@ -0,0 +1,21 @@
+package cache
+
+import (
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+type Cache interface {
+	GetPartnerConfigMap(pubid, profileid, displayversion int) (map[int]map[string]string, error)
+	GetAdunitConfigFromCache(request *openrtb2.BidRequest, pubID int, profileID, displayVersion int) *adunitconfig.AdUnitConfig
+	GetMappingsFromCacheV25(rctx models.RequestCtx, partnerID int) map[string]models.SlotMapping
+	GetSlotToHashValueMapFromCacheV25(rctx models.RequestCtx, partnerID int) models.SlotMappingInfo
+	GetPublisherVASTTagsFromCache(pubID int) models.PublisherVASTTags
+
+	GetFSCDisabledPublishers() (map[int]struct{}, error)
+	GetFSCThresholdPerDSP() (map[int]int, error)
+
+	Set(key string, value interface{})
+	Get(key string) (interface{}, bool)
+}
diff --git a/modules/pubmatic/openwrap/cache/gocache/adunit_config.go b/modules/pubmatic/openwrap/cache/gocache/adunit_config.go
new file mode 100644
index 000000000..eeabe6b8f
--- /dev/null
+++ b/modules/pubmatic/openwrap/cache/gocache/adunit_config.go
@@ -0,0 +1,40 @@
+package gocache
+
+import (
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+func (c *cache) populateCacheWithAdunitConfig(pubID int, profileID, displayVersion int) {
+	adunitConfig, err := c.db.GetAdunitConfig(profileID, displayVersion)
+	if err != nil {
+		return
+	}
+
+	caseFoldConfigMap := make(map[string]*adunitconfig.AdConfig, len(adunitConfig.Config))
+	for k, v := range adunitConfig.Config {
+		caseFoldConfigMap[strings.ToLower(k)] = v
+	}
+	adunitConfig.Config = caseFoldConfigMap
+
+	cacheKey := key(PubAdunitConfig, pubID, profileID, displayVersion)
+	c.cache.Set(cacheKey, adunitConfig, getSeconds(c.cfg.CacheDefaultExpiry))
+}
+
+// GetAdunitConfigFromCache this function gets adunit config from cache for a given request
+func (c *cache) GetAdunitConfigFromCache(request *openrtb2.BidRequest, pubID int, profileID, displayVersion int) *adunitconfig.AdUnitConfig {
+	if request.Test == 2 {
+		return nil
+	}
+
+	cacheKey := key(PubAdunitConfig, pubID, profileID, displayVersion)
+	if obj, ok := c.cache.Get(cacheKey); ok {
+		if v, ok := obj.(*adunitconfig.AdUnitConfig); ok {
+			return v
+		}
+	}
+
+	return nil
+}
diff --git a/modules/pubmatic/openwrap/cache/gocache/fsc.go b/modules/pubmatic/openwrap/cache/gocache/fsc.go
new file mode 100644
index 000000000..26598e9e3
--- /dev/null
+++ b/modules/pubmatic/openwrap/cache/gocache/fsc.go
@@ -0,0 +1,23 @@
+package gocache
+
+// Populates Cache with Fsc-Disabled Publishers
+func (dbcache *cache) GetFSCDisabledPublishers() (map[int]struct{}, error) {
+	disabledPublishersMap, err := dbcache.db.GetFSCDisabledPublishers()
+	if err != nil {
+		return disabledPublishersMap, err
+	}
+	// Not setting into cache as fsc maintains it own map
+	// mcache.Set(constant.FscPublisher, disabledPublishersMap)
+	return disabledPublishersMap, nil
+}
+
+// Populates cache with Fsc-Dsp Threshold Percentages
+func (dbcache *cache) GetFSCThresholdPerDSP() (map[int]int, error) {
+	dspThresholdsMap, err := dbcache.db.GetFSCThresholdPerDSP()
+	if err != nil {
+		return dspThresholdsMap, err
+	}
+	// Not setting into cache as fsc maintains it own map
+	// mcache.Set(constant.FscPublisher, dspThresholdsMap)
+	return dspThresholdsMap, nil
+}
diff --git a/modules/pubmatic/openwrap/cache/gocache/gocache.go b/modules/pubmatic/openwrap/cache/gocache/gocache.go
new file mode 100644
index 000000000..043eeceb2
--- /dev/null
+++ b/modules/pubmatic/openwrap/cache/gocache/gocache.go
@@ -0,0 +1,62 @@
+package gocache
+
+import (
+	"fmt"
+	"sync"
+	"time"
+
+	gocache "github.com/patrickmn/go-cache"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/config"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/database"
+)
+
+const (
+	PUB_SLOT_INFO  = "pslot_%d_%d_%d_%d" // publisher slot mapping at publisher, profile, display version and adapter level
+	PUB_HB_PARTNER = "hbplist_%d_%d_%d"  // header bidding partner list at publishr,profile, display version level
+	//HB_PARTNER_CFG = "hbpcfg_%d"         // header bidding partner configuration at partner level
+	//PubAadunitConfig - this key for storing adunit config at pub, profile and version level
+	PubAdunitConfig = "aucfg_%d_%d_%d"
+	PubSlotHashInfo = "pshash_%d_%d_%d_%d" // slot and its hash info at publisher, profile, display version and adapter level
+	PubSlotNameHash = "pslotnamehash_%d"   //publisher slotname hash mapping cache key
+	PubVASTTags     = "pvasttags_%d"       //publisher level vasttags
+)
+
+func key(format string, v ...interface{}) string {
+	return fmt.Sprintf(format, v...)
+}
+
+// NYC_TODO: refactor this to inject any kind of cache,replace cache with freecache library
+// any db or cache should be injectable
+type cache struct {
+	sync.Map
+	cache *gocache.Cache
+	cfg   config.Cache
+	db    database.Database
+}
+
+var c *cache
+var cOnce sync.Once
+
+func New(goCache *gocache.Cache, database database.Database, cfg config.Cache) *cache {
+	cOnce.Do(
+		func() {
+			c = &cache{
+				cache: goCache,
+				db:    database,
+				cfg:   cfg,
+			}
+		})
+	return c
+}
+
+func getSeconds(duration int) time.Duration {
+	return time.Duration(duration) * time.Second
+}
+
+func (c *cache) Set(key string, value interface{}) {
+	c.cache.Set(key, value, getSeconds(c.cfg.CacheDefaultExpiry))
+}
+
+func (c *cache) Get(key string) (interface{}, bool) {
+	return c.cache.Get(key)
+}
diff --git a/modules/pubmatic/openwrap/cache/gocache/partner_config.go b/modules/pubmatic/openwrap/cache/gocache/partner_config.go
new file mode 100644
index 000000000..fead1b273
--- /dev/null
+++ b/modules/pubmatic/openwrap/cache/gocache/partner_config.go
@@ -0,0 +1,26 @@
+package gocache
+
+// NYC_TODO: Return DB level errors for module logging
+func (c *cache) GetPartnerConfigMap(pubid, profileid, displayversion int) (map[int]map[string]string, error) {
+	if mapNameHash, ok := c.cache.Get(key(PubSlotNameHash, pubid)); !ok || mapNameHash == nil {
+		c.populateCacheWithPubSlotNameHash(pubid)
+	}
+
+	if vastTags, ok := c.cache.Get(key(PubVASTTags, pubid)); !ok || vastTags == nil {
+		c.populatePublisherVASTTags(pubid)
+	}
+
+	cacheKey := key(PUB_HB_PARTNER, pubid, profileid, displayversion)
+	if obj, ok := c.cache.Get(cacheKey); ok {
+		return obj.(map[int]map[string]string), nil
+	}
+
+	partnerConfigMap, err := c.db.GetActivePartnerConfigurations(pubid, profileid, displayversion)
+	if len(partnerConfigMap) != 0 {
+		c.cache.Set(cacheKey, partnerConfigMap, getSeconds(c.cfg.CacheDefaultExpiry))
+
+		c.populateCacheWithWrapperSlotMappings(pubid, partnerConfigMap, profileid, displayversion)
+		c.populateCacheWithAdunitConfig(pubid, profileid, displayversion)
+	}
+	return partnerConfigMap, err
+}
diff --git a/modules/pubmatic/openwrap/cache/gocache/slot_mappings.go b/modules/pubmatic/openwrap/cache/gocache/slot_mappings.go
new file mode 100644
index 000000000..446bd5be8
--- /dev/null
+++ b/modules/pubmatic/openwrap/cache/gocache/slot_mappings.go
@@ -0,0 +1,107 @@
+package gocache
+
+import (
+	"encoding/json"
+	"sort"
+	"strconv"
+	"strings"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// PopulateCacheWithPubSlotNameHash will put the slot names and hashes for a publisher in cache
+func (c *cache) populateCacheWithPubSlotNameHash(pubid int) {
+	cacheKey := key(PubSlotNameHash, pubid)
+	if _, ok := c.cache.Get(cacheKey); ok {
+		return
+	}
+
+	publisherSlotNameHashMap := c.db.GetPublisherSlotNameHash(pubid)
+	if publisherSlotNameHashMap != nil {
+		c.cache.Set(cacheKey, publisherSlotNameHashMap, getSeconds(c.cfg.CacheDefaultExpiry))
+	}
+}
+
+// PopulateCacheWithWrapperSlotMappings will get the SlotMappings from database and put them in cache.
+func (c *cache) populateCacheWithWrapperSlotMappings(pubid int, partnerConfigMap map[int]map[string]string, profileId, displayVersion int) {
+	partnerSlotMappingMap := c.db.GetWrapperSlotMappings(partnerConfigMap, profileId, displayVersion)
+
+	//put a version level dummy entry in cache denoting mappings are present for this version
+	cacheKey := key(PUB_SLOT_INFO, pubid, profileId, displayVersion, 0)
+	c.cache.Set(cacheKey, make(map[string]models.SlotMapping, 0), getSeconds(c.cfg.CacheDefaultExpiry))
+
+	if len(partnerSlotMappingMap) == 0 {
+		for _, partnerConf := range partnerConfigMap {
+			partnerID, _ := strconv.Atoi(partnerConf[models.PARTNER_ID])
+			cacheKey = key(PUB_SLOT_INFO, pubid, profileId, displayVersion, partnerID)
+			c.cache.Set(cacheKey, make(map[string]models.SlotMapping, 0), getSeconds(c.cfg.CacheDefaultExpiry))
+		}
+		return
+	}
+
+	var nameHashMap map[string]string
+	obj, ok := c.cache.Get(key(PubSlotNameHash, pubid))
+	if ok && obj != nil {
+		nameHashMap = obj.(map[string]string)
+	}
+
+	for partnerID, slotMappingList := range partnerSlotMappingMap {
+		slotNameToMappingMap := make(map[string]models.SlotMapping, len(slotMappingList))
+		slotNameToHashValueMap := make(map[string]string, len(slotMappingList))
+		slotNameOrderedList := make([]string, 0)
+		sort.Slice(slotMappingList, func(i, j int) bool {
+			return slotMappingList[i].OrderID < slotMappingList[j].OrderID
+		})
+		for _, slotMapping := range slotMappingList {
+			slotMapping.Hash = nameHashMap[slotMapping.SlotName]
+
+			var mappingJSONObj map[string]interface{}
+			if err := json.Unmarshal([]byte(slotMapping.MappingJson), &mappingJSONObj); err != nil {
+				continue
+			}
+
+			cfgMap := partnerConfigMap[partnerID]
+			bidderCode := cfgMap[models.BidderCode]
+			if bidderCode == string(openrtb_ext.BidderPubmatic) || bidderCode == string(openrtb_ext.BidderGroupm) {
+				//Adding slotName from DB in fieldMap for PubMatic, as slotName from DB should be sent to PubMatic instead of slotName from request
+				//This is required for case in-sensitive mapping
+				mappingJSONObj[models.KEY_OW_SLOT_NAME] = slotMapping.SlotName
+			}
+
+			slotMapping.SlotMappings = mappingJSONObj
+			slotNameToMappingMap[strings.ToLower(slotMapping.SlotName)] = slotMapping
+			slotNameToHashValueMap[slotMapping.SlotName] = slotMapping.Hash
+			slotNameOrderedList = append(slotNameOrderedList, slotMapping.SlotName)
+		}
+		cacheKey = key(PUB_SLOT_INFO, pubid, profileId, displayVersion, partnerID)
+		c.cache.Set(cacheKey, slotNameToMappingMap, getSeconds(c.cfg.CacheDefaultExpiry))
+
+		slotMappingInfoObj := models.SlotMappingInfo{
+			OrderedSlotList: slotNameOrderedList,
+			HashValueMap:    slotNameToHashValueMap,
+		}
+		cacheKey = key(PubSlotHashInfo, pubid, profileId, displayVersion, partnerID)
+		c.cache.Set(cacheKey, slotMappingInfoObj, getSeconds(c.cfg.CacheDefaultExpiry))
+	}
+}
+
+// GetMappingsFromCacheV25 will return mapping of each partner in partnerConf map
+func (c *cache) GetMappingsFromCacheV25(rctx models.RequestCtx, partnerID int) map[string]models.SlotMapping {
+	cacheKey := key(PUB_SLOT_INFO, rctx.PubID, rctx.ProfileID, rctx.DisplayID, partnerID)
+	if value, ok := c.cache.Get(cacheKey); ok {
+		return value.(map[string]models.SlotMapping)
+	}
+
+	return nil
+}
+
+/*GetSlotToHashValueMapFromCacheV25 returns SlotMappingInfo object from cache that contains and ordered list of slot names by order_id field and a map of slot names to their hash values*/
+func (c *cache) GetSlotToHashValueMapFromCacheV25(rctx models.RequestCtx, partnerID int) models.SlotMappingInfo {
+	cacheKey := key(PubSlotHashInfo, rctx.PubID, rctx.ProfileID, rctx.DisplayID, partnerID)
+	if value, ok := c.cache.Get(cacheKey); ok {
+		return value.(models.SlotMappingInfo)
+	}
+
+	return models.SlotMappingInfo{}
+}
diff --git a/modules/pubmatic/openwrap/cache/gocache/sync.go b/modules/pubmatic/openwrap/cache/gocache/sync.go
new file mode 100644
index 000000000..3d8eae8b3
--- /dev/null
+++ b/modules/pubmatic/openwrap/cache/gocache/sync.go
@@ -0,0 +1,20 @@
+package gocache
+
+// LockAndLoad calls DB only once for same requests
+func (c *cache) LockAndLoad(key string, dbFunc func()) {
+	waitCh := make(chan struct{})
+	lockCh, present := c.LoadOrStore(key, waitCh)
+	if !present {
+		// fetch db data and save in cache
+		dbFunc()
+
+		// delete and let other requests take the lock (ideally only 1 per hour per pod)
+		c.Delete(key)
+
+		// unblock waiting requests
+		close(waitCh)
+	}
+
+	// requests that did not get lock will wait here until the one that reterives the data closes the channel
+	<-lockCh.(chan struct{})
+}
diff --git a/modules/pubmatic/openwrap/cache/gocache/vast_tags.go b/modules/pubmatic/openwrap/cache/gocache/vast_tags.go
new file mode 100644
index 000000000..899346041
--- /dev/null
+++ b/modules/pubmatic/openwrap/cache/gocache/vast_tags.go
@@ -0,0 +1,35 @@
+package gocache
+
+import (
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+// PopulatePublisherVASTTags will put publisher level VAST Tag details into cache
+func (c *cache) populatePublisherVASTTags(pubid int) {
+	cacheKey := key(PubVASTTags, pubid)
+	if _, ok := c.cache.Get(cacheKey); ok {
+		return
+	}
+
+	//get publisher level vast tag details from DB
+	publisherVASTTags, err := c.db.GetPublisherVASTTags(pubid)
+	if err != nil {
+		return
+	}
+
+	if publisherVASTTags == nil {
+		publisherVASTTags = models.PublisherVASTTags{}
+	}
+
+	c.cache.Set(cacheKey, publisherVASTTags, getSeconds(c.cfg.VASTTagCacheExpiry))
+}
+
+// GetPublisherVASTTagsFromCache read publisher level vast tag details from cache
+func (c *cache) GetPublisherVASTTagsFromCache(pubID int) models.PublisherVASTTags {
+	cacheKey := key(PubVASTTags, pubID)
+	if value, ok := c.cache.Get(cacheKey); ok && value != nil {
+		return value.(models.PublisherVASTTags)
+	}
+	//if found then return actual value or else return empty
+	return models.PublisherVASTTags{}
+}
diff --git a/modules/pubmatic/openwrap/cache/mock/mock.go b/modules/pubmatic/openwrap/cache/mock/mock.go
new file mode 100644
index 000000000..9ab990370
--- /dev/null
+++ b/modules/pubmatic/openwrap/cache/mock/mock.go
@@ -0,0 +1,165 @@
+// Code generated by MockGen. DO NOT EDIT.
+// Source: github.com/pm-nilesh-chate/prebid-server/modules/pubmatic/openwrap/cache (interfaces: Cache)
+
+// Package mock_cache is a generated GoMock package.
+package mock_cache
+
+import (
+	reflect "reflect"
+
+	gomock "github.com/golang/mock/gomock"
+	openrtb2 "github.com/prebid/openrtb/v19/openrtb2"
+	models "github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	adunitconfig "github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+// MockCache is a mock of Cache interface.
+type MockCache struct {
+	ctrl     *gomock.Controller
+	recorder *MockCacheMockRecorder
+}
+
+// MockCacheMockRecorder is the mock recorder for MockCache.
+type MockCacheMockRecorder struct {
+	mock *MockCache
+}
+
+// NewMockCache creates a new mock instance.
+func NewMockCache(ctrl *gomock.Controller) *MockCache {
+	mock := &MockCache{ctrl: ctrl}
+	mock.recorder = &MockCacheMockRecorder{mock}
+	return mock
+}
+
+// EXPECT returns an object that allows the caller to indicate expected use.
+func (m *MockCache) EXPECT() *MockCacheMockRecorder {
+	return m.recorder
+}
+
+// Get mocks base method.
+func (m *MockCache) Get(arg0 string) (interface{}, bool) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "Get", arg0)
+	ret0, _ := ret[0].(interface{})
+	ret1, _ := ret[1].(bool)
+	return ret0, ret1
+}
+
+// Get indicates an expected call of Get.
+func (mr *MockCacheMockRecorder) Get(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCache)(nil).Get), arg0)
+}
+
+// GetAdunitConfigFromCache mocks base method.
+func (m *MockCache) GetAdunitConfigFromCache(arg0 *openrtb2.BidRequest, arg1, arg2, arg3 int) *adunitconfig.AdUnitConfig {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetAdunitConfigFromCache", arg0, arg1, arg2, arg3)
+	ret0, _ := ret[0].(*adunitconfig.AdUnitConfig)
+	return ret0
+}
+
+// GetAdunitConfigFromCache indicates an expected call of GetAdunitConfigFromCache.
+func (mr *MockCacheMockRecorder) GetAdunitConfigFromCache(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAdunitConfigFromCache", reflect.TypeOf((*MockCache)(nil).GetAdunitConfigFromCache), arg0, arg1, arg2, arg3)
+}
+
+// GetFSCDisabledPublishers mocks base method.
+func (m *MockCache) GetFSCDisabledPublishers() (map[int]struct{}, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetFSCDisabledPublishers")
+	ret0, _ := ret[0].(map[int]struct{})
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// GetFSCDisabledPublishers indicates an expected call of GetFSCDisabledPublishers.
+func (mr *MockCacheMockRecorder) GetFSCDisabledPublishers() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFSCDisabledPublishers", reflect.TypeOf((*MockCache)(nil).GetFSCDisabledPublishers))
+}
+
+// GetFSCThresholdPerDSP mocks base method.
+func (m *MockCache) GetFSCThresholdPerDSP() (map[int]int, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetFSCThresholdPerDSP")
+	ret0, _ := ret[0].(map[int]int)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// GetFSCThresholdPerDSP indicates an expected call of GetFSCThresholdPerDSP.
+func (mr *MockCacheMockRecorder) GetFSCThresholdPerDSP() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFSCThresholdPerDSP", reflect.TypeOf((*MockCache)(nil).GetFSCThresholdPerDSP))
+}
+
+// GetMappingsFromCacheV25 mocks base method.
+func (m *MockCache) GetMappingsFromCacheV25(arg0 models.RequestCtx, arg1 int) map[string]models.SlotMapping {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetMappingsFromCacheV25", arg0, arg1)
+	ret0, _ := ret[0].(map[string]models.SlotMapping)
+	return ret0
+}
+
+// GetMappingsFromCacheV25 indicates an expected call of GetMappingsFromCacheV25.
+func (mr *MockCacheMockRecorder) GetMappingsFromCacheV25(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMappingsFromCacheV25", reflect.TypeOf((*MockCache)(nil).GetMappingsFromCacheV25), arg0, arg1)
+}
+
+// GetPartnerConfigMap mocks base method.
+func (m *MockCache) GetPartnerConfigMap(arg0, arg1, arg2 int) (map[int]map[string]string, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetPartnerConfigMap", arg0, arg1, arg2)
+	ret0, _ := ret[0].(map[int]map[string]string)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// GetPartnerConfigMap indicates an expected call of GetPartnerConfigMap.
+func (mr *MockCacheMockRecorder) GetPartnerConfigMap(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPartnerConfigMap", reflect.TypeOf((*MockCache)(nil).GetPartnerConfigMap), arg0, arg1, arg2)
+}
+
+// GetPublisherVASTTagsFromCache mocks base method.
+func (m *MockCache) GetPublisherVASTTagsFromCache(arg0 int) map[int]*models.VASTTag {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetPublisherVASTTagsFromCache", arg0)
+	ret0, _ := ret[0].(map[int]*models.VASTTag)
+	return ret0
+}
+
+// GetPublisherVASTTagsFromCache indicates an expected call of GetPublisherVASTTagsFromCache.
+func (mr *MockCacheMockRecorder) GetPublisherVASTTagsFromCache(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPublisherVASTTagsFromCache", reflect.TypeOf((*MockCache)(nil).GetPublisherVASTTagsFromCache), arg0)
+}
+
+// GetSlotToHashValueMapFromCacheV25 mocks base method.
+func (m *MockCache) GetSlotToHashValueMapFromCacheV25(arg0 models.RequestCtx, arg1 int) models.SlotMappingInfo {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetSlotToHashValueMapFromCacheV25", arg0, arg1)
+	ret0, _ := ret[0].(models.SlotMappingInfo)
+	return ret0
+}
+
+// GetSlotToHashValueMapFromCacheV25 indicates an expected call of GetSlotToHashValueMapFromCacheV25.
+func (mr *MockCacheMockRecorder) GetSlotToHashValueMapFromCacheV25(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSlotToHashValueMapFromCacheV25", reflect.TypeOf((*MockCache)(nil).GetSlotToHashValueMapFromCacheV25), arg0, arg1)
+}
+
+// Set mocks base method.
+func (m *MockCache) Set(arg0 string, arg1 interface{}) {
+	m.ctrl.T.Helper()
+	m.ctrl.Call(m, "Set", arg0, arg1)
+}
+
+// Set indicates an expected call of Set.
+func (mr *MockCacheMockRecorder) Set(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCache)(nil).Set), arg0, arg1)
+}
diff --git a/modules/pubmatic/openwrap/config/config.go b/modules/pubmatic/openwrap/config/config.go
new file mode 100755
index 000000000..c2f0082db
--- /dev/null
+++ b/modules/pubmatic/openwrap/config/config.go
@@ -0,0 +1,86 @@
+package config
+
+import "time"
+
+// Config contains the values read from the config file at boot time
+type Config struct {
+	Server    Server
+	Database  Database
+	Cache     Cache
+	Timeout   Timeout
+	Tracker   Tracker
+	PixelView PixelView
+	Features  FeatureToggle
+	Log       Log
+}
+
+type Server struct {
+	HostName string
+}
+
+type Database struct {
+	Host string
+	Port int
+
+	Database string
+	User     string
+	Pass     string
+
+	IdleConnection, MaxConnection, ConnMaxLifeTime, MaxDbContextTimeout int
+
+	Queries Queries
+}
+
+/*
+GetParterConfig query to get all partners and related configurations for a given pub,profile,version
+
+Data is ordered by partnerId,keyname and entityId so that version level partner params will override the account level partner parasm in the code logic
+*/
+type Queries struct {
+	GetParterConfig                   string
+	DisplayVersionInnerQuery          string
+	LiveVersionInnerQuery             string
+	GetWrapperSlotMappingsQuery       string
+	GetWrapperLiveVersionSlotMappings string
+	GetPMSlotToMappings               string
+	GetAdunitConfigQuery              string
+	GetAdunitConfigForLiveVersion     string
+	GetSlotNameHash                   string
+	GetPublisherVASTTagsQuery         string
+	GetAllFscDisabledPublishersQuery  string
+	GetAllDspFscPcntQuery             string
+}
+
+type Cache struct {
+	CacheConTimeout int // Connection timeout for cache
+
+	CacheDefaultExpiry int // in seconds
+	VASTTagCacheExpiry int // in seconds
+}
+
+type Timeout struct {
+	MaxTimeout int64
+	MinTimeout int64
+}
+
+type Tracker struct {
+	Endpoint                  string
+	VideoErrorTrackerEndpoint string
+}
+
+type PixelView struct {
+	OMScript string //js script path for conditional tracker call fire
+}
+
+type FeatureToggle struct {
+}
+
+type Log struct { //Log Details
+	LogPath            string
+	LogLevel           int
+	MaxLogSize         uint64
+	MaxLogFiles        int
+	LogRotationTime    time.Duration
+	DebugLogUpdateTime time.Duration
+	DebugAuthKey       string
+}
diff --git a/modules/pubmatic/openwrap/contenttransperencyobject.go b/modules/pubmatic/openwrap/contenttransperencyobject.go
new file mode 100644
index 000000000..6fcab45d2
--- /dev/null
+++ b/modules/pubmatic/openwrap/contenttransperencyobject.go
@@ -0,0 +1,59 @@
+package openwrap
+
+import (
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// setContentObjectTransparencyObject from request or AdUnit Object
+// setContentObjectTransparencyObject from request or AdUnit Object
+func setContentTransparencyObject(rctx models.RequestCtx, reqExt models.RequestExt) (prebidTransparency *openrtb_ext.TransparencyExt) {
+	if reqExt.Prebid.Transparency != nil {
+		return
+	}
+
+	for _, impCtx := range rctx.ImpBidCtx {
+		var transparency *adunitconfig.Transparency
+
+		if impCtx.BannerAdUnitCtx.AppliedSlotAdUnitConfig != nil && impCtx.BannerAdUnitCtx.AppliedSlotAdUnitConfig.Transparency != nil {
+			transparency = impCtx.BannerAdUnitCtx.AppliedSlotAdUnitConfig.Transparency
+		} else if impCtx.VideoAdUnitCtx.AppliedSlotAdUnitConfig != nil && impCtx.VideoAdUnitCtx.AppliedSlotAdUnitConfig.Transparency != nil {
+			transparency = impCtx.VideoAdUnitCtx.AppliedSlotAdUnitConfig.Transparency
+		}
+
+		if transparency == nil || len(transparency.Content.Mappings) == 0 {
+			continue
+		}
+
+		content := make(map[string]openrtb_ext.TransparencyRule)
+
+		for _, partnerConfig := range rctx.PartnerConfigMap {
+			bidder := partnerConfig[models.BidderCode]
+
+			_, ok := rctx.AdapterThrottleMap[bidder]
+			if ok || partnerConfig[models.SERVER_SIDE_FLAG] != "1" {
+				continue
+			}
+
+			for _, rule := range getRules(rctx.Source, bidder) {
+				if transparencyRule, ok := transparency.Content.Mappings[rule]; ok {
+					content[bidder] = transparencyRule
+					break
+				}
+			}
+		}
+
+		if len(content) > 0 {
+			return &openrtb_ext.TransparencyExt{
+				Content: content,
+			}
+		}
+	}
+
+	return nil
+}
+
+func getRules(source, bidder string) []string {
+	return []string{source + "|" + bidder, "*|" + bidder, source + "|*", "*|*"}
+}
diff --git a/modules/pubmatic/openwrap/database/database.go b/modules/pubmatic/openwrap/database/database.go
new file mode 100644
index 000000000..fde8d7925
--- /dev/null
+++ b/modules/pubmatic/openwrap/database/database.go
@@ -0,0 +1,18 @@
+package database
+
+import (
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+type Database interface {
+	GetAdunitConfig(profileID, displayVersionID int) (*adunitconfig.AdUnitConfig, error)
+	GetActivePartnerConfigurations(pubId, profileId, displayVersion int) (map[int]map[string]string, error)
+	GetPubmaticSlotMappings(pubId int) map[string]models.SlotMapping
+	GetPublisherSlotNameHash(pubID int) map[string]string
+	GetWrapperSlotMappings(partnerConfigMap map[int]map[string]string, profileId, displayVersion int) map[int][]models.SlotMapping
+	GetPublisherVASTTags(pubID int) (models.PublisherVASTTags, error)
+	GetMappings(slotKey string, slotMap map[string]models.SlotMapping) (map[string]interface{}, error)
+	GetFSCDisabledPublishers() (map[int]struct{}, error)
+	GetFSCThresholdPerDSP() (map[int]int, error)
+}
diff --git a/modules/pubmatic/openwrap/database/mock/mock.go b/modules/pubmatic/openwrap/database/mock/mock.go
new file mode 100644
index 000000000..21c0676ba
--- /dev/null
+++ b/modules/pubmatic/openwrap/database/mock/mock.go
@@ -0,0 +1,168 @@
+// Code generated by MockGen. DO NOT EDIT.
+// Source: github.com/pm-nilesh-chate/prebid-server/modules/pubmatic/openwrap/database (interfaces: Database)
+
+// Package mock_database is a generated GoMock package.
+package mock_database
+
+import (
+	reflect "reflect"
+
+	gomock "github.com/golang/mock/gomock"
+	models "github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	adunitconfig "github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+// MockDatabase is a mock of Database interface.
+type MockDatabase struct {
+	ctrl     *gomock.Controller
+	recorder *MockDatabaseMockRecorder
+}
+
+// MockDatabaseMockRecorder is the mock recorder for MockDatabase.
+type MockDatabaseMockRecorder struct {
+	mock *MockDatabase
+}
+
+// NewMockDatabase creates a new mock instance.
+func NewMockDatabase(ctrl *gomock.Controller) *MockDatabase {
+	mock := &MockDatabase{ctrl: ctrl}
+	mock.recorder = &MockDatabaseMockRecorder{mock}
+	return mock
+}
+
+// EXPECT returns an object that allows the caller to indicate expected use.
+func (m *MockDatabase) EXPECT() *MockDatabaseMockRecorder {
+	return m.recorder
+}
+
+// GetActivePartnerConfigurations mocks base method.
+func (m *MockDatabase) GetActivePartnerConfigurations(arg0, arg1, arg2 int) (map[int]map[string]string, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetActivePartnerConfigurations", arg0, arg1, arg2)
+	ret0, _ := ret[0].(map[int]map[string]string)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// GetActivePartnerConfigurations indicates an expected call of GetActivePartnerConfigurations.
+func (mr *MockDatabaseMockRecorder) GetActivePartnerConfigurations(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActivePartnerConfigurations", reflect.TypeOf((*MockDatabase)(nil).GetActivePartnerConfigurations), arg0, arg1, arg2)
+}
+
+// GetAdunitConfig mocks base method.
+func (m *MockDatabase) GetAdunitConfig(arg0, arg1 int) (*adunitconfig.AdUnitConfig, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetAdunitConfig", arg0, arg1)
+	ret0, _ := ret[0].(*adunitconfig.AdUnitConfig)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// GetAdunitConfig indicates an expected call of GetAdunitConfig.
+func (mr *MockDatabaseMockRecorder) GetAdunitConfig(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAdunitConfig", reflect.TypeOf((*MockDatabase)(nil).GetAdunitConfig), arg0, arg1)
+}
+
+// GetFSCDisabledPublishers mocks base method.
+func (m *MockDatabase) GetFSCDisabledPublishers() (map[int]struct{}, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetFSCDisabledPublishers")
+	ret0, _ := ret[0].(map[int]struct{})
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// GetFSCDisabledPublishers indicates an expected call of GetFSCDisabledPublishers.
+func (mr *MockDatabaseMockRecorder) GetFSCDisabledPublishers() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFSCDisabledPublishers", reflect.TypeOf((*MockDatabase)(nil).GetFSCDisabledPublishers))
+}
+
+// GetFSCThresholdPerDSP mocks base method.
+func (m *MockDatabase) GetFSCThresholdPerDSP() (map[int]int, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetFSCThresholdPerDSP")
+	ret0, _ := ret[0].(map[int]int)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// GetFSCThresholdPerDSP indicates an expected call of GetFSCThresholdPerDSP.
+func (mr *MockDatabaseMockRecorder) GetFSCThresholdPerDSP() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFSCThresholdPerDSP", reflect.TypeOf((*MockDatabase)(nil).GetFSCThresholdPerDSP))
+}
+
+// GetMappings mocks base method.
+func (m *MockDatabase) GetMappings(arg0 string, arg1 map[string]models.SlotMapping) (map[string]interface{}, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetMappings", arg0, arg1)
+	ret0, _ := ret[0].(map[string]interface{})
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// GetMappings indicates an expected call of GetMappings.
+func (mr *MockDatabaseMockRecorder) GetMappings(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMappings", reflect.TypeOf((*MockDatabase)(nil).GetMappings), arg0, arg1)
+}
+
+// GetPublisherSlotNameHash mocks base method.
+func (m *MockDatabase) GetPublisherSlotNameHash(arg0 int) map[string]string {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetPublisherSlotNameHash", arg0)
+	ret0, _ := ret[0].(map[string]string)
+	return ret0
+}
+
+// GetPublisherSlotNameHash indicates an expected call of GetPublisherSlotNameHash.
+func (mr *MockDatabaseMockRecorder) GetPublisherSlotNameHash(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPublisherSlotNameHash", reflect.TypeOf((*MockDatabase)(nil).GetPublisherSlotNameHash), arg0)
+}
+
+// GetPublisherVASTTags mocks base method.
+func (m *MockDatabase) GetPublisherVASTTags(arg0 int) (map[int]*models.VASTTag, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetPublisherVASTTags", arg0)
+	ret0, _ := ret[0].(map[int]*models.VASTTag)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// GetPublisherVASTTags indicates an expected call of GetPublisherVASTTags.
+func (mr *MockDatabaseMockRecorder) GetPublisherVASTTags(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPublisherVASTTags", reflect.TypeOf((*MockDatabase)(nil).GetPublisherVASTTags), arg0)
+}
+
+// GetPubmaticSlotMappings mocks base method.
+func (m *MockDatabase) GetPubmaticSlotMappings(arg0 int) map[string]models.SlotMapping {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetPubmaticSlotMappings", arg0)
+	ret0, _ := ret[0].(map[string]models.SlotMapping)
+	return ret0
+}
+
+// GetPubmaticSlotMappings indicates an expected call of GetPubmaticSlotMappings.
+func (mr *MockDatabaseMockRecorder) GetPubmaticSlotMappings(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPubmaticSlotMappings", reflect.TypeOf((*MockDatabase)(nil).GetPubmaticSlotMappings), arg0)
+}
+
+// GetWrapperSlotMappings mocks base method.
+func (m *MockDatabase) GetWrapperSlotMappings(arg0 map[int]map[string]string, arg1, arg2 int) map[int][]models.SlotMapping {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "GetWrapperSlotMappings", arg0, arg1, arg2)
+	ret0, _ := ret[0].(map[int][]models.SlotMapping)
+	return ret0
+}
+
+// GetWrapperSlotMappings indicates an expected call of GetWrapperSlotMappings.
+func (mr *MockDatabaseMockRecorder) GetWrapperSlotMappings(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWrapperSlotMappings", reflect.TypeOf((*MockDatabase)(nil).GetWrapperSlotMappings), arg0, arg1, arg2)
+}
diff --git a/modules/pubmatic/openwrap/database/mock_driver/mock.go b/modules/pubmatic/openwrap/database/mock_driver/mock.go
new file mode 100644
index 000000000..c5c653194
--- /dev/null
+++ b/modules/pubmatic/openwrap/database/mock_driver/mock.go
@@ -0,0 +1,208 @@
+// Code generated by MockGen. DO NOT EDIT.
+// Source: database/sql/driver (interfaces: Driver,Connector,Conn,DriverContext)
+
+// Package mock_driver is a generated GoMock package.
+package mock_driver
+
+import (
+	context "context"
+	driver "database/sql/driver"
+	reflect "reflect"
+
+	gomock "github.com/golang/mock/gomock"
+)
+
+// MockDriver is a mock of Driver interface.
+type MockDriver struct {
+	ctrl     *gomock.Controller
+	recorder *MockDriverMockRecorder
+}
+
+// MockDriverMockRecorder is the mock recorder for MockDriver.
+type MockDriverMockRecorder struct {
+	mock *MockDriver
+}
+
+// NewMockDriver creates a new mock instance.
+func NewMockDriver(ctrl *gomock.Controller) *MockDriver {
+	mock := &MockDriver{ctrl: ctrl}
+	mock.recorder = &MockDriverMockRecorder{mock}
+	return mock
+}
+
+// EXPECT returns an object that allows the caller to indicate expected use.
+func (m *MockDriver) EXPECT() *MockDriverMockRecorder {
+	return m.recorder
+}
+
+// Open mocks base method.
+func (m *MockDriver) Open(arg0 string) (driver.Conn, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "Open", arg0)
+	ret0, _ := ret[0].(driver.Conn)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// Open indicates an expected call of Open.
+func (mr *MockDriverMockRecorder) Open(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockDriver)(nil).Open), arg0)
+}
+
+// MockConnector is a mock of Connector interface.
+type MockConnector struct {
+	ctrl     *gomock.Controller
+	recorder *MockConnectorMockRecorder
+}
+
+// MockConnectorMockRecorder is the mock recorder for MockConnector.
+type MockConnectorMockRecorder struct {
+	mock *MockConnector
+}
+
+// NewMockConnector creates a new mock instance.
+func NewMockConnector(ctrl *gomock.Controller) *MockConnector {
+	mock := &MockConnector{ctrl: ctrl}
+	mock.recorder = &MockConnectorMockRecorder{mock}
+	return mock
+}
+
+// EXPECT returns an object that allows the caller to indicate expected use.
+func (m *MockConnector) EXPECT() *MockConnectorMockRecorder {
+	return m.recorder
+}
+
+// Connect mocks base method.
+func (m *MockConnector) Connect(arg0 context.Context) (driver.Conn, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "Connect", arg0)
+	ret0, _ := ret[0].(driver.Conn)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// Connect indicates an expected call of Connect.
+func (mr *MockConnectorMockRecorder) Connect(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockConnector)(nil).Connect), arg0)
+}
+
+// Driver mocks base method.
+func (m *MockConnector) Driver() driver.Driver {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "Driver")
+	ret0, _ := ret[0].(driver.Driver)
+	return ret0
+}
+
+// Driver indicates an expected call of Driver.
+func (mr *MockConnectorMockRecorder) Driver() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Driver", reflect.TypeOf((*MockConnector)(nil).Driver))
+}
+
+// MockConn is a mock of Conn interface.
+type MockConn struct {
+	ctrl     *gomock.Controller
+	recorder *MockConnMockRecorder
+}
+
+// MockConnMockRecorder is the mock recorder for MockConn.
+type MockConnMockRecorder struct {
+	mock *MockConn
+}
+
+// NewMockConn creates a new mock instance.
+func NewMockConn(ctrl *gomock.Controller) *MockConn {
+	mock := &MockConn{ctrl: ctrl}
+	mock.recorder = &MockConnMockRecorder{mock}
+	return mock
+}
+
+// EXPECT returns an object that allows the caller to indicate expected use.
+func (m *MockConn) EXPECT() *MockConnMockRecorder {
+	return m.recorder
+}
+
+// Begin mocks base method.
+func (m *MockConn) Begin() (driver.Tx, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "Begin")
+	ret0, _ := ret[0].(driver.Tx)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// Begin indicates an expected call of Begin.
+func (mr *MockConnMockRecorder) Begin() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockConn)(nil).Begin))
+}
+
+// Close mocks base method.
+func (m *MockConn) Close() error {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "Close")
+	ret0, _ := ret[0].(error)
+	return ret0
+}
+
+// Close indicates an expected call of Close.
+func (mr *MockConnMockRecorder) Close() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockConn)(nil).Close))
+}
+
+// Prepare mocks base method.
+func (m *MockConn) Prepare(arg0 string) (driver.Stmt, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "Prepare", arg0)
+	ret0, _ := ret[0].(driver.Stmt)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// Prepare indicates an expected call of Prepare.
+func (mr *MockConnMockRecorder) Prepare(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockConn)(nil).Prepare), arg0)
+}
+
+// MockDriverContext is a mock of DriverContext interface.
+type MockDriverContext struct {
+	ctrl     *gomock.Controller
+	recorder *MockDriverContextMockRecorder
+}
+
+// MockDriverContextMockRecorder is the mock recorder for MockDriverContext.
+type MockDriverContextMockRecorder struct {
+	mock *MockDriverContext
+}
+
+// NewMockDriverContext creates a new mock instance.
+func NewMockDriverContext(ctrl *gomock.Controller) *MockDriverContext {
+	mock := &MockDriverContext{ctrl: ctrl}
+	mock.recorder = &MockDriverContextMockRecorder{mock}
+	return mock
+}
+
+// EXPECT returns an object that allows the caller to indicate expected use.
+func (m *MockDriverContext) EXPECT() *MockDriverContextMockRecorder {
+	return m.recorder
+}
+
+// OpenConnector mocks base method.
+func (m *MockDriverContext) OpenConnector(arg0 string) (driver.Connector, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "OpenConnector", arg0)
+	ret0, _ := ret[0].(driver.Connector)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// OpenConnector indicates an expected call of OpenConnector.
+func (mr *MockDriverContextMockRecorder) OpenConnector(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenConnector", reflect.TypeOf((*MockDriverContext)(nil).OpenConnector), arg0)
+}
diff --git a/modules/pubmatic/openwrap/database/mysql/adunit_config.go b/modules/pubmatic/openwrap/database/mysql/adunit_config.go
new file mode 100644
index 000000000..52124ecda
--- /dev/null
+++ b/modules/pubmatic/openwrap/database/mysql/adunit_config.go
@@ -0,0 +1,46 @@
+package mysql
+
+import (
+	"encoding/json"
+	"fmt"
+	"strconv"
+	"strings"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+// GetAdunitConfig - Method to get adunit config for a given profile and display version from giym DB
+func (db *mySqlDB) GetAdunitConfig(profileID, displayVersionID int) (*adunitconfig.AdUnitConfig, error) {
+	var adunitConfigJSON string
+	adunitConfig := new(adunitconfig.AdUnitConfig)
+	adunitConfigQuery := ""
+	if displayVersionID == 0 {
+		adunitConfigQuery = db.cfg.Queries.GetAdunitConfigForLiveVersion
+	} else {
+		adunitConfigQuery = db.cfg.Queries.GetAdunitConfigQuery
+	}
+	adunitConfigQuery = strings.Replace(adunitConfigQuery, profileIdKey, strconv.Itoa(profileID), -1)
+	adunitConfigQuery = strings.Replace(adunitConfigQuery, displayVersionKey, strconv.Itoa(displayVersionID), -1)
+	err := db.conn.QueryRow(adunitConfigQuery).Scan(&adunitConfigJSON)
+	if err != nil {
+		err = fmt.Errorf("[QUERY_FAILED] Name:[%v] Error:[%v]", "GetAdunitConfig", err.Error())
+		return nil, err
+	}
+
+	err = json.Unmarshal([]byte(adunitConfigJSON), &adunitConfig)
+	if err != nil {
+		return nil, err
+	}
+
+	for k, v := range adunitConfig.Config {
+		adunitConfig.Config[strings.ToLower(k)] = v
+		// shall we delete the orignal key-val?
+	}
+
+	if adunitConfig.ConfigPattern == "" {
+		//Default configPattern value is "_AU_" if not present in db config
+		adunitConfig.ConfigPattern = models.MACRO_AD_UNIT_ID
+	}
+	return adunitConfig, err
+}
diff --git a/modules/pubmatic/openwrap/database/mysql/adunit_config_test.go b/modules/pubmatic/openwrap/database/mysql/adunit_config_test.go
new file mode 100644
index 000000000..442a62f4d
--- /dev/null
+++ b/modules/pubmatic/openwrap/database/mysql/adunit_config_test.go
@@ -0,0 +1,175 @@
+package mysql
+
+import (
+	"database/sql"
+	"testing"
+
+	"github.com/DATA-DOG/go-sqlmock"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/config"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+	"github.com/prebid/prebid-server/util/ptrutil"
+	"github.com/stretchr/testify/assert"
+)
+
+func Test_mySqlDB_GetAdunitConfig(t *testing.T) {
+	type fields struct {
+		conn *sql.DB
+		cfg  config.Database
+	}
+	type args struct {
+		profileID        int
+		displayVersionID int
+	}
+	tests := []struct {
+		name    string
+		fields  fields
+		args    args
+		want    *adunitconfig.AdUnitConfig
+		wantErr bool
+		setup   func() *sql.DB
+	}{
+		{
+			name:    "empty query in config file",
+			want:    nil,
+			wantErr: true,
+			setup: func() *sql.DB {
+				db, _, err := sqlmock.New()
+				if err != nil {
+					t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
+				}
+				return db
+			},
+		},
+		{
+			name: "query with display version id 0",
+			fields: fields{
+				cfg: config.Database{
+					Queries: config.Queries{
+						GetAdunitConfigForLiveVersion: `SELECT cf.config_json AS adunitConfig FROM wrapper_media_config cf JOIN wrapper_version wv ON cf.version_id = wv.id AND cf.is_active=1 AND wv.profile_id = #PROFILE_ID JOIN wrapper_status ws ON wv.id = ws.version_id and ws.status IN ('LIVE','LIVE_PENDING')`,
+					},
+				},
+			},
+			args: args{
+				profileID:        5890,
+				displayVersionID: 0,
+			},
+			want: &adunitconfig.AdUnitConfig{
+				ConfigPattern: "_AU_",
+				Config: map[string]*adunitconfig.AdConfig{
+					"default": {BidFloor: ptrutil.ToPtr(2.0)},
+				},
+			},
+			wantErr: false,
+			setup: func() *sql.DB {
+				db, mock, err := sqlmock.New()
+				if err != nil {
+					t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
+				}
+				rows := sqlmock.NewRows([]string{"adunitConfig"}).AddRow(`{"config":{"default":{"bidfloor":2}}}`)
+				mock.ExpectQuery(`SELECT cf\.config_json AS adunitConfig FROM wrapper_media_config cf JOIN wrapper_version wv ON cf\.version_id = wv\.id AND cf\.is_active=1 AND wv\.profile_id = 5890 JOIN wrapper_status ws ON wv\.id = ws\.version_id and ws\.status IN \('LIVE','LIVE_PENDING'\)`).WillReturnRows(rows)
+				return db
+			},
+		},
+		{
+			name: "query with non-zero display version id",
+			fields: fields{
+				cfg: config.Database{
+					Queries: config.Queries{
+						GetAdunitConfigQuery: `SELECT cf.config_json AS adunitConfig FROM wrapper_media_config cf JOIN wrapper_version wv ON cf.version_id = wv.id AND cf.is_active=1 AND wv.profile_id = #PROFILE_ID AND wv.display_version = #DISPLAY_VERSION`,
+					},
+				},
+			},
+			args: args{
+				profileID:        5890,
+				displayVersionID: 1,
+			},
+			want: &adunitconfig.AdUnitConfig{
+				ConfigPattern: "_AU_",
+				Config: map[string]*adunitconfig.AdConfig{
+					"default": {BidFloor: ptrutil.ToPtr(3.1)},
+				},
+			},
+			wantErr: false,
+			setup: func() *sql.DB {
+				db, mock, err := sqlmock.New()
+				if err != nil {
+					t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
+				}
+				rows := sqlmock.NewRows([]string{"adunitConfig"}).AddRow(`{"config":{"default":{"bidfloor":3.1}}}`)
+				mock.ExpectQuery(`SELECT cf\.config_json AS adunitConfig FROM wrapper_media_config cf JOIN wrapper_version wv ON cf\.version_id = wv\.id AND cf\.is_active=1 AND wv\.profile_id = 5890 AND wv\.display_version = 1`).WillReturnRows(rows)
+				return db
+			},
+		},
+		{
+			name: "invalid adunitconfig json",
+			fields: fields{
+				cfg: config.Database{
+					Queries: config.Queries{
+						GetAdunitConfigForLiveVersion: `SELECT cf.config_json AS adunitConfig FROM wrapper_media_config cf JOIN wrapper_version wv ON cf.version_id = wv.id AND cf.is_active=1 AND wv.profile_id = #PROFILE_ID JOIN wrapper_status ws ON wv.id = ws.version_id and ws.status IN ('LIVE','LIVE_PENDING')`,
+					},
+				},
+			},
+			args: args{
+				profileID:        5890,
+				displayVersionID: 0,
+			},
+			want:    nil,
+			wantErr: true,
+			setup: func() *sql.DB {
+				db, mock, err := sqlmock.New()
+				if err != nil {
+					t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
+				}
+				rows := sqlmock.NewRows([]string{"adunitConfig"}).AddRow(`{`)
+				mock.ExpectQuery(`SELECT cf\.config_json AS adunitConfig FROM wrapper_media_config cf JOIN wrapper_version wv ON cf\.version_id = wv\.id AND cf\.is_active=1 AND wv\.profile_id = 5890 JOIN wrapper_status ws ON wv\.id = ws\.version_id and ws\.status IN \('LIVE','LIVE_PENDING'\)`).WillReturnRows(rows)
+				return db
+			},
+		},
+		{
+			name: "non-default config pattern in adunitconfig",
+			fields: fields{
+				cfg: config.Database{
+					Queries: config.Queries{
+						GetAdunitConfigQuery: `SELECT cf.config_json AS adunitConfig FROM wrapper_media_config cf JOIN wrapper_version wv ON cf.version_id = wv.id AND cf.is_active=1 AND wv.profile_id = #PROFILE_ID AND wv.display_version = #DISPLAY_VERSION`,
+					},
+				},
+			},
+			args: args{
+				profileID:        5890,
+				displayVersionID: 1,
+			},
+			want: &adunitconfig.AdUnitConfig{
+				ConfigPattern: "_DIV_",
+				Config: map[string]*adunitconfig.AdConfig{
+					"default": {BidFloor: ptrutil.ToPtr(3.1)},
+				},
+			},
+			wantErr: false,
+			setup: func() *sql.DB {
+				db, mock, err := sqlmock.New()
+				if err != nil {
+					t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
+				}
+				rows := sqlmock.NewRows([]string{"adunitConfig"}).AddRow(`{"configPattern": "_DIV_", "config":{"default":{"bidfloor":3.1}}}`)
+				mock.ExpectQuery(`SELECT cf\.config_json AS adunitConfig FROM wrapper_media_config cf JOIN wrapper_version wv ON cf\.version_id = wv\.id AND cf\.is_active=1 AND wv\.profile_id = 5890 AND wv\.display_version = 1`).WillReturnRows(rows)
+				return db
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			db := &mySqlDB{
+				conn: tt.setup(),
+				cfg:  tt.fields.cfg,
+			}
+			defer db.conn.Close()
+
+			got, err := db.GetAdunitConfig(tt.args.profileID, tt.args.displayVersionID)
+			if (err != nil) != tt.wantErr {
+				t.Errorf("mySqlDB.GetAdunitConfig() error = %v, wantErr %v", err, tt.wantErr)
+				return
+			}
+			assert.Equal(t, tt.want, got)
+		})
+	}
+}
diff --git a/modules/pubmatic/openwrap/database/mysql/fsc.go b/modules/pubmatic/openwrap/database/mysql/fsc.go
new file mode 100644
index 000000000..a620886a1
--- /dev/null
+++ b/modules/pubmatic/openwrap/database/mysql/fsc.go
@@ -0,0 +1,52 @@
+package mysql
+
+import (
+	"fmt"
+	"strconv"
+
+	"github.com/golang/glog"
+)
+
+func (db *mySqlDB) GetFSCDisabledPublishers() (map[int]struct{}, error) {
+	rows, err := db.conn.Query(db.cfg.Queries.GetAllFscDisabledPublishersQuery)
+	if err != nil {
+		err = fmt.Errorf("[QUERY_FAILED] Name:[%v] Error:[%v]", "GetFSCDisabledPublishers", err.Error())
+		return map[int]struct{}{}, err
+	}
+	defer rows.Close()
+	fscDisabledPublishers := make(map[int]struct{})
+	for rows.Next() {
+		var pubid int
+		if err := rows.Scan(&pubid); err != nil {
+			continue
+		}
+		fscDisabledPublishers[pubid] = struct{}{}
+	}
+	return fscDisabledPublishers, nil
+}
+
+func (db *mySqlDB) GetFSCThresholdPerDSP() (map[int]int, error) {
+	rows, err := db.conn.Query(db.cfg.Queries.GetAllDspFscPcntQuery)
+	if err != nil {
+		err = fmt.Errorf("[QUERY_FAILED] Name:[%v] Error:[%v]", "GetFSCThresholdPerDSP", err.Error())
+		return map[int]int{}, err
+	}
+	defer rows.Close()
+	fscDspThresholds := make(map[int]int)
+	for rows.Next() {
+		var dspId int
+		var fscThreshold string
+		if err := rows.Scan(&dspId, &fscThreshold); err != nil {
+			glog.Error("Error in getting dsp-thresholds details from DB:", err.Error())
+			continue
+		}
+		// convert threshold string to int
+		pcnt, err := strconv.Atoi(fscThreshold)
+		if err != nil {
+			glog.Errorf("Invalid fsc_pcnt value for dspId:%d, threshold:%v", dspId, fscThreshold)
+			continue
+		}
+		fscDspThresholds[dspId] = pcnt
+	}
+	return fscDspThresholds, nil
+}
diff --git a/modules/pubmatic/openwrap/database/mysql/mysql.go b/modules/pubmatic/openwrap/database/mysql/mysql.go
new file mode 100644
index 000000000..d8d32d325
--- /dev/null
+++ b/modules/pubmatic/openwrap/database/mysql/mysql.go
@@ -0,0 +1,24 @@
+package mysql
+
+import (
+	"database/sql"
+	"sync"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/config"
+)
+
+type mySqlDB struct {
+	conn *sql.DB
+	cfg  config.Database
+}
+
+var db *mySqlDB
+var dbOnce sync.Once
+
+func New(conn *sql.DB, cfg config.Database) *mySqlDB {
+	dbOnce.Do(
+		func() {
+			db = &mySqlDB{conn: conn, cfg: cfg}
+		})
+	return db
+}
diff --git a/modules/pubmatic/openwrap/database/mysql/partner_config.go b/modules/pubmatic/openwrap/database/mysql/partner_config.go
new file mode 100644
index 000000000..3391c2c3e
--- /dev/null
+++ b/modules/pubmatic/openwrap/database/mysql/partner_config.go
@@ -0,0 +1,93 @@
+package mysql
+
+import (
+	"context"
+	"database/sql"
+	"fmt"
+	"strconv"
+	"time"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+// return the list of active server side header bidding partners
+// with their configurations at publisher-profile-version level
+func (db *mySqlDB) GetActivePartnerConfigurations(pubId, profileId int, displayVersion int) (map[int]map[string]string, error) {
+	versionID, displayVersionID, err := db.getVersionID(profileId, displayVersion, pubId)
+	if err != nil {
+		return nil, err
+	}
+
+	partnerConfigMap, err := db.getActivePartnerConfigurations(pubId, profileId, versionID)
+	if err == nil && partnerConfigMap[-1] != nil {
+		partnerConfigMap[-1][models.DisplayVersionID] = strconv.Itoa(displayVersionID)
+	}
+	return partnerConfigMap, err
+}
+
+func (db *mySqlDB) getActivePartnerConfigurations(pubId, profileId int, versionID int) (map[int]map[string]string, error) {
+	getActivePartnersQuery := fmt.Sprintf(db.cfg.Queries.GetParterConfig, db.cfg.MaxDbContextTimeout, versionID, versionID, versionID)
+
+	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(time.Millisecond*time.Duration(db.cfg.MaxDbContextTimeout)))
+	defer cancel()
+	rows, err := db.conn.QueryContext(ctx, getActivePartnersQuery)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	partnerConfigMap := make(map[int]map[string]string, 0)
+	for rows.Next() {
+		var partnerID int
+		var keyName string
+		var value string
+		var prebidPartnerName, bidderCode string
+		var entityTypeID, testConfig, isAlias int
+		if err := rows.Scan(&partnerID, &prebidPartnerName, &bidderCode, &isAlias, &entityTypeID, &testConfig, &keyName, &value); err != nil {
+			continue
+		}
+
+		_, ok := partnerConfigMap[partnerID]
+		//below logic will take care of overriding account level partner keys with version level partner keys
+		//if key name is same for a given partnerID (Ref ticket: UOE-5647)
+		if !ok {
+			partnerConfigMap[partnerID] = map[string]string{models.PARTNER_ID: strconv.Itoa(partnerID)}
+		}
+
+		if testConfig == 1 {
+			keyName = keyName + "_test"
+			partnerConfigMap[partnerID][models.PartnerTestEnabledKey] = "1"
+		}
+
+		partnerConfigMap[partnerID][keyName] = value
+
+		if _, ok := partnerConfigMap[partnerID][models.PREBID_PARTNER_NAME]; !ok && prebidPartnerName != "-" {
+			partnerConfigMap[partnerID][models.PREBID_PARTNER_NAME] = prebidPartnerName
+			partnerConfigMap[partnerID][models.BidderCode] = bidderCode
+			partnerConfigMap[partnerID][models.IsAlias] = strconv.Itoa(isAlias)
+		}
+	}
+
+	// NYC_TODO: ignore close error
+	if err = rows.Err(); err != nil {
+
+	}
+	return partnerConfigMap, nil
+}
+
+func (db *mySqlDB) getVersionID(profileID, displayVersionID, pubID int) (int, int, error) {
+	var versionID, displayVersionIDFromDB int
+	var row *sql.Row
+
+	if displayVersionID == 0 {
+		row = db.conn.QueryRow(db.cfg.Queries.LiveVersionInnerQuery, profileID, pubID)
+	} else {
+		row = db.conn.QueryRow(db.cfg.Queries.DisplayVersionInnerQuery, profileID, displayVersionID, pubID)
+	}
+
+	err := row.Scan(&versionID, &displayVersionIDFromDB)
+	if err != nil {
+		return versionID, displayVersionIDFromDB, err
+	}
+	return versionID, displayVersionIDFromDB, nil
+}
diff --git a/modules/pubmatic/openwrap/database/mysql/queries.go b/modules/pubmatic/openwrap/database/mysql/queries.go
new file mode 100644
index 000000000..0f59dd745
--- /dev/null
+++ b/modules/pubmatic/openwrap/database/mysql/queries.go
@@ -0,0 +1,9 @@
+package mysql
+
+const (
+	partnerIdKey      = "#PARTNER_IDS"
+	profileIdKey      = "#PROFILE_ID"
+	pubIdKey          = "#PUB_ID"
+	displayVersionKey = "#DISPLAY_VERSION"
+	versionIdKey      = "#VERSION_ID"
+)
diff --git a/modules/pubmatic/openwrap/database/mysql/slot_mapping.go b/modules/pubmatic/openwrap/database/mysql/slot_mapping.go
new file mode 100644
index 000000000..bc7612dd9
--- /dev/null
+++ b/modules/pubmatic/openwrap/database/mysql/slot_mapping.go
@@ -0,0 +1,144 @@
+package mysql
+
+import (
+	"encoding/json"
+	"errors"
+	"fmt"
+	"strconv"
+	"strings"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+// Return the list of Pubmatic slot mappings
+func (db *mySqlDB) GetPubmaticSlotMappings(pubId int) map[string]models.SlotMapping {
+	pmSlotMappings := make(map[string]models.SlotMapping, 0)
+	rows, err := db.conn.Query(db.cfg.Queries.GetPMSlotToMappings,
+		pubId, models.MAX_SLOT_COUNT)
+	if nil != err {
+		return pmSlotMappings
+	}
+
+	defer rows.Close()
+	for rows.Next() {
+		slotInfo := models.SlotInfo{}
+		slotMapping := models.SlotMapping{}
+
+		err := rows.Scan(&slotInfo.SlotName, &slotInfo.AdSize, &slotInfo.SiteId,
+			&slotInfo.AdTagId, &slotInfo.GId, &slotInfo.Floor)
+		if nil != err {
+			//continue
+		}
+		slotMapping.PartnerId = models.PUBMATIC_PARTNER_ID //hardcoding partnerId for pubmatic
+		slotMapping.AdapterId = models.PUBMATIC_ADAPTER_ID //hardcoding adapterId for pubmatic
+		slotMapping.SlotName = slotInfo.SlotName           //+ "@" + slotInfo.AdSize
+		//adtag, site, floor hardcoded as this code is to be removed once pmapi moves to wrapper workflow
+		slotMapping.MappingJson =
+			"{\"adtag\":\"" + strconv.Itoa(slotInfo.AdTagId) + "\"," +
+				"\"site\":\"" + strconv.Itoa(slotInfo.SiteId) + "\"," +
+				"\"floor\":\"" + strconv.FormatFloat(slotInfo.Floor, 'f', 2, 64) + "\"," +
+				"\"gaid\":\"" + strconv.Itoa(slotInfo.GId) + "\"}"
+		var mappingJsonObj map[string]interface{}
+		if err := json.Unmarshal([]byte(slotMapping.MappingJson), &mappingJsonObj); err != nil {
+			continue
+		}
+
+		//Adding slotName from DB in fieldMap for PubMatic, as slotName from DB should be sent to PubMatic instead of slotName from request
+		//This is required for case in-sensitive mapping
+		mappingJsonObj[models.KEY_OW_SLOT_NAME] = slotMapping.SlotName
+
+		slotMapping.SlotMappings = mappingJsonObj
+		pmSlotMappings[strings.ToLower(slotMapping.SlotName)] = slotMapping
+	}
+	return pmSlotMappings
+}
+
+// GetPublisherSlotNameHash Returns a map of all slot names and hashes for a publisher
+func (db *mySqlDB) GetPublisherSlotNameHash(pubID int) map[string]string {
+	nameHashMap := make(map[string]string)
+
+	query := formSlotNameHashQuery(pubID)
+	rows, err := db.conn.Query(query)
+	if err != nil {
+		return nameHashMap
+	}
+	defer rows.Close()
+
+	for rows.Next() {
+		var name, hash string
+		if err = rows.Scan(&name, &hash); err != nil {
+			continue
+		}
+		nameHashMap[name] = hash
+	}
+
+	//vastTagHookPublisherSlotName(nameHashMap, pubID)
+	return nameHashMap
+}
+
+// Return the list of wrapper slot mappings
+func (db *mySqlDB) GetWrapperSlotMappings(partnerConfigMap map[int]map[string]string, profileId, displayVersion int) map[int][]models.SlotMapping {
+	partnerSlotMappingMap := make(map[int][]models.SlotMapping)
+
+	var query string
+	query = formWrapperSlotMappingQuery(profileId, displayVersion, partnerConfigMap)
+	rows, err := db.conn.Query(query)
+	if err != nil {
+		return partnerSlotMappingMap
+	}
+	defer rows.Close()
+
+	for rows.Next() {
+		var slotMapping = models.SlotMapping{}
+		err := rows.Scan(&slotMapping.PartnerId, &slotMapping.AdapterId, &slotMapping.VersionId, &slotMapping.SlotName, &slotMapping.MappingJson, &slotMapping.OrderID)
+		if nil != err {
+			continue
+		}
+
+		slotMappingList, found := partnerSlotMappingMap[int(slotMapping.PartnerId)]
+		if found {
+			slotMappingList = append(slotMappingList, slotMapping)
+			partnerSlotMappingMap[int(slotMapping.PartnerId)] = slotMappingList
+		} else {
+			newSlotMappingList := make([]models.SlotMapping, 0)
+			newSlotMappingList = append(newSlotMappingList, slotMapping)
+			partnerSlotMappingMap[int(slotMapping.PartnerId)] = newSlotMappingList
+		}
+
+	}
+	//vastTagHookPartnerSlotMapping(partnerSlotMappingMap, profileId, displayVersion)
+	return partnerSlotMappingMap
+}
+
+// GetMappings will returns slotMapping from map based on slotKey
+func (db *mySqlDB) GetMappings(slotKey string, slotMap map[string]models.SlotMapping) (map[string]interface{}, error) {
+	slotMappingObj, present := slotMap[strings.ToLower(slotKey)]
+	if !present {
+		return nil, errors.New("No mapping found for slot:" + slotKey)
+	}
+	fieldMap := slotMappingObj.SlotMappings
+	return fieldMap, nil
+}
+
+func formWrapperSlotMappingQuery(profileID, displayVersion int, partnerConfigMap map[int]map[string]string) string {
+	var query string
+	var partnerIDStr string
+	for partnerID := range partnerConfigMap {
+		partnerIDStr = partnerIDStr + strconv.Itoa(partnerID) + ","
+	}
+	partnerIDStr = strings.TrimSuffix(partnerIDStr, ",")
+
+	if displayVersion != 0 {
+		query = strings.Replace(db.cfg.Queries.GetWrapperSlotMappingsQuery, profileIdKey, strconv.Itoa(profileID), -1)
+		query = strings.Replace(query, displayVersionKey, strconv.Itoa(displayVersion), -1)
+		query = strings.Replace(query, partnerIdKey, partnerIDStr, -1)
+	} else {
+		query = strings.Replace(db.cfg.Queries.GetWrapperLiveVersionSlotMappings, profileIdKey, strconv.Itoa(profileID), -1)
+		query = strings.Replace(query, partnerIdKey, partnerIDStr, -1)
+	}
+	return query
+}
+
+func formSlotNameHashQuery(pubID int) (query string) {
+	return fmt.Sprint(db.cfg.Queries.GetSlotNameHash, pubID)
+}
diff --git a/modules/pubmatic/openwrap/database/mysql/vasttags.go b/modules/pubmatic/openwrap/database/mysql/vasttags.go
new file mode 100644
index 000000000..c74960730
--- /dev/null
+++ b/modules/pubmatic/openwrap/database/mysql/vasttags.go
@@ -0,0 +1,37 @@
+package mysql
+
+import (
+	"fmt"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+// GetPublisherVASTTags - Method to get vast tags associated with publisher id from giym DB
+func (db *mySqlDB) GetPublisherVASTTags(pubID int) (models.PublisherVASTTags, error) {
+
+	/*
+		//TOOD:VIRAL Remove Hook once UI/API changes are in place
+		if out := vastTagHookPublisherVASTTags(rtbReqId, pubID); nil != out {
+			return out, nil
+		}
+	*/
+
+	getActiveVASTTagsQuery := fmt.Sprintf(db.cfg.Queries.GetPublisherVASTTagsQuery, pubID)
+
+	rows, err := db.conn.Query(getActiveVASTTagsQuery)
+	if err != nil {
+		err = fmt.Errorf("[QUERY_FAILED] Name:[%v] Error:[%v]", "GetPublisherVASTTags", err.Error())
+		return nil, err
+	}
+	defer rows.Close()
+
+	vasttags := models.PublisherVASTTags{}
+	for rows.Next() {
+		var vastTag models.VASTTag
+		if err := rows.Scan(&vastTag.ID, &vastTag.PartnerID, &vastTag.URL, &vastTag.Duration, &vastTag.Price); err != nil {
+			continue
+		}
+		vasttags[vastTag.ID] = &vastTag
+	}
+	return vasttags, nil
+}
diff --git a/modules/pubmatic/openwrap/defaultbids.go b/modules/pubmatic/openwrap/defaultbids.go
new file mode 100644
index 000000000..792314abd
--- /dev/null
+++ b/modules/pubmatic/openwrap/defaultbids.go
@@ -0,0 +1,156 @@
+package openwrap
+
+import (
+	"encoding/json"
+	"strconv"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/adunitconfig"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+func (m *OpenWrap) addDefaultBids(rctx models.RequestCtx, bidResponse *openrtb2.BidResponse) map[string]map[string][]openrtb2.Bid {
+	// responded bidders per impression
+	seatBids := make(map[string]map[string]struct{}, len(bidResponse.SeatBid))
+	for _, seatBid := range bidResponse.SeatBid {
+		for _, bid := range seatBid.Bid {
+			if seatBids[bid.ImpID] == nil {
+				seatBids[bid.ImpID] = make(map[string]struct{})
+			}
+			seatBids[bid.ImpID][seatBid.Seat] = struct{}{}
+		}
+	}
+
+	// consider responded but dropped bids to avoid false nobid entries
+	for seat, bids := range rctx.DroppedBids {
+		for _, bid := range bids {
+			if seatBids[bid.ImpID] == nil {
+				seatBids[bid.ImpID] = make(map[string]struct{})
+			}
+			seatBids[bid.ImpID][seat] = struct{}{}
+		}
+	}
+
+	// bids per bidders per impression that did not respond
+	noSeatBids := make(map[string]map[string][]openrtb2.Bid, 0)
+	for impID, impCtx := range rctx.ImpBidCtx {
+		for bidder := range impCtx.Bidders {
+			noBid := false
+			if bidders, ok := seatBids[impID]; ok {
+				if _, ok := bidders[bidder]; !ok {
+					noBid = true
+				}
+			} else {
+				noBid = true
+			}
+
+			if noBid {
+				if noSeatBids[impID] == nil {
+					noSeatBids[impID] = make(map[string][]openrtb2.Bid)
+				}
+
+				noSeatBids[impID][bidder] = append(noSeatBids[impID][bidder], openrtb2.Bid{
+					ID:    impID,
+					ImpID: impID,
+					Ext:   newNoBidExt(rctx, impID),
+				})
+			}
+		}
+	}
+
+	// add nobids for throttled adapter to all the impressions (how do we set profile with custom list of bidders at impression level?)
+	for bidder := range rctx.AdapterThrottleMap {
+		for impID := range rctx.ImpBidCtx { // ImpBidCtx is used only for list of impID, it does not have data of throttled adapters
+			if noSeatBids[impID] == nil {
+				noSeatBids[impID] = make(map[string][]openrtb2.Bid)
+			}
+
+			noSeatBids[impID][bidder] = []openrtb2.Bid{
+				{
+					ID:    impID,
+					ImpID: impID,
+					Ext:   newNoBidExt(rctx, impID),
+				},
+			}
+		}
+	}
+
+	// add nobids for non-mapped bidders
+	for impID, impCtx := range rctx.ImpBidCtx {
+		for bidder := range impCtx.NonMapped {
+			if noSeatBids[impID] == nil {
+				noSeatBids[impID] = make(map[string][]openrtb2.Bid)
+			}
+
+			noSeatBids[impID][bidder] = []openrtb2.Bid{
+				{
+					ID:    impID,
+					ImpID: impID,
+					Ext:   newNoBidExt(rctx, impID),
+				},
+			}
+		}
+	}
+
+	return noSeatBids
+}
+
+func newNoBidExt(rctx models.RequestCtx, impID string) json.RawMessage {
+	bidExt := models.BidExt{
+		NetECPM: 0,
+	}
+	if rctx.ClientConfigFlag == 1 {
+		if cc := adunitconfig.GetClientConfigForMediaType(rctx, impID, "banner"); cc != nil {
+			bidExt.Banner = &models.ExtBidBanner{
+				ClientConfig: cc,
+			}
+		}
+
+		if cc := adunitconfig.GetClientConfigForMediaType(rctx, impID, "video"); cc != nil {
+			bidExt.Video = &models.ExtBidVideo{
+				ClientConfig: cc,
+			}
+		}
+	}
+
+	if v, ok := rctx.PartnerConfigMap[models.VersionLevelConfigID]["refreshInterval"]; ok {
+		n, err := strconv.Atoi(v)
+		if err == nil {
+			bidExt.RefreshInterval = n
+		}
+	}
+
+	newBidExt, err := json.Marshal(bidExt)
+	if err != nil {
+		return nil
+	}
+
+	return json.RawMessage(newBidExt)
+}
+
+func (m *OpenWrap) applyDefaultBids(rctx models.RequestCtx, bidResponse *openrtb2.BidResponse) (*openrtb2.BidResponse, error) {
+	// update nobids in final response
+	for i, seatBid := range bidResponse.SeatBid {
+		for impID, noSeatBid := range rctx.NoSeatBids {
+			for seat, bids := range noSeatBid {
+				if seatBid.Seat == seat {
+					bidResponse.SeatBid[i].Bid = append(bidResponse.SeatBid[i].Bid, bids...)
+					delete(noSeatBid, seat)
+					rctx.NoSeatBids[impID] = noSeatBid
+				}
+			}
+		}
+	}
+
+	// no-seat case
+	for _, noSeatBid := range rctx.NoSeatBids {
+		for seat, bids := range noSeatBid {
+			bidResponse.SeatBid = append(bidResponse.SeatBid, openrtb2.SeatBid{
+				Bid:  bids,
+				Seat: seat,
+			})
+		}
+	}
+
+	return bidResponse, nil
+}
diff --git a/modules/pubmatic/openwrap/device.go b/modules/pubmatic/openwrap/device.go
new file mode 100644
index 000000000..3249d9a04
--- /dev/null
+++ b/modules/pubmatic/openwrap/device.go
@@ -0,0 +1,48 @@
+package openwrap
+
+import (
+	"encoding/json"
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func validateDevice(device *openrtb2.Device) {
+	//unmarshal device ext
+	var deviceExt models.ExtDevice
+	err := json.Unmarshal(device.Ext, &deviceExt)
+	if err != nil {
+		return
+	}
+
+	if deviceExt.ExtDevice != nil {
+		deviceExt.IFAType = strings.TrimSpace(deviceExt.IFAType)
+		deviceExt.SessionID = strings.TrimSpace(deviceExt.SessionID)
+
+		//refactor below condition
+		if deviceExt.IFAType != "" {
+			if device.IFA != "" {
+				if _, ok := models.DeviceIFATypeID[strings.ToLower(deviceExt.IFAType)]; !ok {
+					deviceExt.IFAType = ""
+				}
+			} else if deviceExt.SessionID != "" {
+				device.IFA = deviceExt.SessionID
+				deviceExt.IFAType = models.DeviceIFATypeSESSIONID
+			} else {
+				deviceExt.IFAType = ""
+			}
+		} else if deviceExt.SessionID != "" {
+			device.IFA = deviceExt.SessionID
+			deviceExt.IFAType = models.DeviceIFATypeSESSIONID
+		}
+	} else if deviceExt.SessionID != "" {
+		deviceExt.ExtDevice = &openrtb_ext.ExtDevice{
+			IFAType: models.DeviceIFATypeSESSIONID,
+		}
+		device.IFA = deviceExt.SessionID
+	}
+
+	device.Ext, _ = json.Marshal(deviceExt)
+}
diff --git a/modules/pubmatic/openwrap/endpoints/legacy/openrtb/v25/v25.go b/modules/pubmatic/openwrap/endpoints/legacy/openrtb/v25/v25.go
new file mode 100644
index 000000000..5118119c5
--- /dev/null
+++ b/modules/pubmatic/openwrap/endpoints/legacy/openrtb/v25/v25.go
@@ -0,0 +1 @@
+package v25
diff --git a/modules/pubmatic/openwrap/endpoints/legacy/openrtb/v25/video.go b/modules/pubmatic/openwrap/endpoints/legacy/openrtb/v25/video.go
new file mode 100644
index 000000000..2ff96423a
--- /dev/null
+++ b/modules/pubmatic/openwrap/endpoints/legacy/openrtb/v25/video.go
@@ -0,0 +1,716 @@
+package v25
+
+import (
+	"encoding/json"
+	"errors"
+	"math/rand"
+	"net/url"
+	"strconv"
+	"strings"
+
+	"github.com/gofrs/uuid"
+	"github.com/prebid/openrtb/v19/adcom1"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/hooks/hookstage"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func ConvertVideoToAuctionRequest(payload hookstage.EntrypointPayload, result *hookstage.HookResult[hookstage.EntrypointPayload]) (models.RequestExtWrapper, error) {
+	values := payload.Request.URL.Query()
+
+	pubID := values.Get(models.PUBID_KEY)
+	profileID := values.Get(models.PROFILEID_KEY)
+
+	owRedirectURLStr := values.Get(models.OWRedirectURLKey)
+	// mimeTypesStr := values.Get(models.MimeTypes)
+	gdprFlag := values.Get(models.GDPRFlag)
+	ccpa := values.Get(models.CCPAUSPrivacyKey)
+	eids := values.Get(models.OWUserEids)
+	consentString := values.Get(models.ConsentString)
+	appReq := values.Get(models.AppRequest)
+	responseFormat := values.Get(models.ResponseFormatKey)
+
+	if owRedirectURLStr == "" && responseFormat != models.ResponseFormatJSON {
+		return models.RequestExtWrapper{}, errors.New(models.OWRedirectURLKey + " missing in request")
+	}
+
+	redirectURL, err := url.Parse(owRedirectURLStr)
+	if err != nil {
+		return models.RequestExtWrapper{}, errors.New(models.OWRedirectURLKey + "url parsing failed")
+	}
+	redirectQueryParams := redirectURL.Query()
+	// Replace macro values in DFP URL - NYC TODO: Do we still need to trim the macro prefix?
+	for k := range values {
+		if strings.HasPrefix(k, models.MacroPrefix) {
+			paramName := strings.TrimPrefix(k, models.MacroPrefix)
+			redirectQueryParams.Set(paramName, values.Get(k))
+		}
+	}
+
+	bidRequest := openrtb2.BidRequest{
+		Imp: []openrtb2.Imp{
+			{
+				Video: &openrtb2.Video{
+					MIMEs:          GetStringArr(GetValueFromRequest(values, redirectQueryParams, models.MimeORTBParam)),
+					MaxDuration:    GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.MaxDurationORTBParam))),
+					MinDuration:    GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.MinDurationORTBParam))),
+					Protocols:      models.GetProtocol(GetIntArr(GetValueFromRequest(values, redirectQueryParams, models.ProtocolsORTBParam))),
+					Skip:           GetCustomAtoI8(GetString(GetValueFromRequest(values, redirectQueryParams, models.SkipORTBParam))),
+					SkipMin:        GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.SkipMinORTBParam))),
+					SkipAfter:      GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.SkipAfterORTBParam))),
+					BAttr:          models.GetCreativeAttributes(GetIntArr(GetValueFromRequest(values, redirectQueryParams, models.BAttrORTBParam))),
+					MaxExtended:    GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.MaxExtendedORTBParam))),
+					MinBitRate:     GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.MinBitrateORTBParam))),
+					MaxBitRate:     GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.MaxBitrateORTBParam))),
+					PlaybackMethod: models.GetPlaybackMethod(GetIntArr(GetValueFromRequest(values, redirectQueryParams, models.PlaybackMethodORTBParam))),
+					Delivery:       models.GetDeliveryMethod(GetIntArr(GetValueFromRequest(values, redirectQueryParams, models.DeliveryORTBParam))),
+					API:            models.GetAPIFramework((GetIntArr(GetValueFromRequest(values, redirectQueryParams, models.APIORTBParam)))),
+				},
+			},
+		},
+	}
+
+	if sequence := GetCustomAtoI8(GetString(GetValueFromRequest(values, redirectQueryParams, models.SequenceORTBParam))); sequence != nil {
+		bidRequest.Imp[0].Video.Sequence = *sequence
+	}
+	if boxingAllowed := GetCustomAtoI8(GetString(GetValueFromRequest(values, redirectQueryParams, models.BoxingAllowedORTBParam))); boxingAllowed != nil {
+		bidRequest.Imp[0].Video.BoxingAllowed = *boxingAllowed
+	}
+	if prctl := GetCustomAtoI8(GetString(GetValueFromRequest(values, redirectQueryParams, models.ProtocolORTBParam))); prctl != nil {
+		bidRequest.Imp[0].Video.Protocol = adcom1.MediaCreativeSubtype(*prctl)
+	}
+	if strtDelay := GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.StartDelayORTBParam))); strtDelay != 0 {
+		st := adcom1.StartDelay(strtDelay)
+		bidRequest.Imp[0].Video.StartDelay = &st
+	}
+	if placementValue := GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.PlacementORTBParam))); placementValue != 0 {
+		bidRequest.Imp[0].Video.Placement = adcom1.VideoPlacementSubtype(placementValue)
+	}
+	if linearityValue := GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.LinearityORTBParam))); linearityValue != 0 {
+		bidRequest.Imp[0].Video.Linearity = adcom1.LinearityMode(linearityValue)
+	}
+	if pos := GetCustomAtoI8(GetString(GetValueFromRequest(values, redirectQueryParams, models.PosORTBParam))); pos != nil {
+		pos := adcom1.PlacementPosition(*pos)
+		bidRequest.Imp[0].Video.Pos = &pos
+	}
+
+	size := GetString(GetValueFromRequest(values, redirectQueryParams, models.SizeORTBParam))
+	if size != "" && strings.Split(size, "x") != nil {
+		sizeValues := strings.Split(size, "x")
+		bidRequest.Imp[0].Video.W, _ = strconv.ParseInt(sizeValues[0], 10, 64)
+		bidRequest.Imp[0].Video.H, _ = strconv.ParseInt(sizeValues[1], 10, 64)
+	}
+
+	slot := redirectQueryParams.Get(models.InventoryUnitKey)
+	if slot == "" && responseFormat == models.ResponseFormatJSON {
+		slot = values.Get(models.InventoryUnitMacroKey)
+	}
+
+	validationFailed := false
+	if slot == "" {
+		validationFailed = true
+	}
+
+	// TODO NYC: do we need this??
+	// if mimeTypesStr == "" {
+	// 	validationFailed = true
+	// } else {
+	// 	mimeStrArr := strings.Split(values.Get(models.OWMimeTypes), models.MimesSeparator)
+	// 	if len(mimeStrArr) == 0 {
+	// 		validationFailed = true
+	// 	} else {
+	// 		for _, mime := range mimeStrArr {
+	// 			if models.MimeIDToValueMap[mime] == "" {
+	// 				validationFailed = true
+	// 				break
+	// 			}
+	// 		}
+	// 	}
+	// }
+
+	// if gdprFlag != "" && gdprFlag != "0" && gdprFlag != "1" {
+	// 	validationFailed = true
+	// }
+
+	// if ccpa != "" && len(ccpa) != 4 {
+	// 	validationFailed = true
+	// }
+
+	// request is for Mobile App, perform necessary validations
+	if appReq == "1" && (models.CheckIfValidQueryParamFlag(values, models.DeviceLMT) || models.CheckIfValidQueryParamFlag(values, models.DeviceDNT)) {
+		validationFailed = true
+	}
+
+	if validationFailed {
+		return models.RequestExtWrapper{}, errors.New("validation failure")
+	}
+
+	if uuid, err := uuid.NewV4(); err == nil {
+		bidRequest.ID = uuid.String()
+	}
+
+	if uuid, err := uuid.NewV4(); err == nil {
+		bidRequest.Imp[0].ID = uuid.String()
+	}
+	bidRequest.Imp[0].TagID = slot
+	bidRequest.Imp[0].BidFloor, _ = models.Atof(values.Get(models.FloorValue), 4)
+	bidRequest.Imp[0].BidFloorCur = values.Get(models.FloorCurrency)
+
+	content := &openrtb2.Content{
+		Genre: GetString(GetValueFromRequest(values, redirectQueryParams, models.ContentGenreORTBParam)),
+		Title: GetString(GetValueFromRequest(values, redirectQueryParams, models.ContentTitleORTBParam)),
+	}
+	if content.Genre == "" && content.Title == "" {
+		content = nil
+	}
+
+	if appReq == "1" {
+		bidRequest.App = &openrtb2.App{
+			ID:       GetString(GetValueFromRequest(values, redirectQueryParams, models.AppIDORTBParam)),
+			Name:     GetString(GetValueFromRequest(values, redirectQueryParams, models.AppNameORTBParam)),
+			Bundle:   GetString(GetValueFromRequest(values, redirectQueryParams, models.AppBundleORTBParam)),
+			StoreURL: GetString(GetValueFromRequest(values, redirectQueryParams, models.AppStoreURLORTBParam)),
+			Domain:   GetString(GetValueFromRequest(values, redirectQueryParams, models.AppDomainORTBParam)),
+			Keywords: GetString(GetValueFromRequest(values, redirectQueryParams, models.OwAppKeywords)),
+			Cat:      GetStringArr(GetValueFromRequest(values, redirectQueryParams, models.AppCatORTBParam)),
+			Publisher: &openrtb2.Publisher{
+				ID: pubID,
+			},
+			Content: content,
+		}
+		bidRequest.Device = &openrtb2.Device{
+			Lmt:      GetCustomAtoI8(GetString(GetValueFromRequest(values, redirectQueryParams, models.DeviceLMTORTBParam))),
+			DNT:      GetCustomAtoI8(GetString(GetValueFromRequest(values, redirectQueryParams, models.DeviceDNTORTBParam))),
+			IFA:      GetString(GetValueFromRequest(values, redirectQueryParams, models.DeviceIfaORTBParam)),
+			DIDSHA1:  GetString(GetValueFromRequest(values, redirectQueryParams, models.DeviceDidsha1ORTBParam)),
+			DIDMD5:   GetString(GetValueFromRequest(values, redirectQueryParams, models.DeviceDidmd5ORTBParam)),
+			DPIDSHA1: GetString(GetValueFromRequest(values, redirectQueryParams, models.DeviceDpidsha1ORTBParam)),
+			DPIDMD5:  GetString(GetValueFromRequest(values, redirectQueryParams, models.DeviceDpidmd5ORTBParam)),
+			MACSHA1:  GetString(GetValueFromRequest(values, redirectQueryParams, models.DeviceMacsha1ORTBParam)),
+			MACMD5:   GetString(GetValueFromRequest(values, redirectQueryParams, models.DeviceMacmd5ORTBParam)),
+			Geo: &openrtb2.Geo{
+				Lat:       GetCustomStrToFloat(GetString(GetValueFromRequest(values, redirectQueryParams, models.GeoLatORTBParam))),
+				Lon:       GetCustomStrToFloat(GetString(GetValueFromRequest(values, redirectQueryParams, models.GeoLonORTBParam))),
+				Country:   GetString(GetValueFromRequest(values, redirectQueryParams, models.GeoCountryORTBParam)),
+				City:      GetString(GetValueFromRequest(values, redirectQueryParams, models.GeoCityORTBParam)),
+				Metro:     GetString(GetValueFromRequest(values, redirectQueryParams, models.GeoMetroORTBParam)),
+				ZIP:       GetString(GetValueFromRequest(values, redirectQueryParams, models.GeoZipORTBParam)),
+				UTCOffset: GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.GeoUTOffsetORTBParam))),
+			},
+		}
+
+		paid := GetCustomAtoI8(GetString(GetValueFromRequest(values, redirectQueryParams, models.AppPaidORTBParam)))
+		if paid != nil {
+			bidRequest.App.Paid = *paid
+		}
+
+		js := GetCustomAtoI8(GetString(GetValueFromRequest(values, redirectQueryParams, models.DeviceJSORTBParam)))
+		if js != nil {
+			bidRequest.Device.JS = *js
+		}
+
+		if locationTypeValue := GetCustomAtoI8(GetString(GetValueFromRequest(values, redirectQueryParams, models.GeoTypeORTBParam))); locationTypeValue != nil {
+			bidRequest.Device.Geo.Type = adcom1.LocationType(*locationTypeValue)
+		}
+
+		var deviceExt models.ExtDevice
+
+		if session_id := GetValueFromRequest(values, redirectQueryParams, models.DeviceExtSessionID); session_id != nil {
+			deviceExt.SessionID = GetString(session_id)
+		}
+
+		if ifaType := GetValueFromRequest(values, redirectQueryParams, models.DeviceExtIfaType); ifaType != nil {
+			deviceExt.ExtDevice = &openrtb_ext.ExtDevice{
+				IFAType: GetString(ifaType),
+			}
+		}
+		bidRequest.Device.Ext, _ = json.Marshal(deviceExt)
+	} else {
+		url := redirectQueryParams.Get(models.URLKey)
+		if url == "" {
+			url = redirectQueryParams.Get(models.DescriptionURLKey)
+		}
+		if url == "" {
+			url = payload.Request.Header.Get(models.PAGE_URL_HEADER)
+		}
+
+		bidRequest.Site = &openrtb2.Site{
+			Publisher: &openrtb2.Publisher{
+				ID: pubID,
+			},
+			Content: content,
+			Page:    url,
+		}
+	}
+
+	bidderParams := GetString(GetValueFromRequest(values, redirectQueryParams, models.BidderParams))
+	impPrebidExt := GetString(GetValueFromRequest(values, redirectQueryParams, models.ImpPrebidExt))
+	updatedImpExt := false
+	impExt := "{"
+	if bidderParams != "" {
+		impExt += "bidder" + bidderParams
+		updatedImpExt = true
+	}
+	if impPrebidExt != "" {
+		if updatedImpExt {
+			impExt += ","
+		}
+		impExt += "prebid" + impPrebidExt
+		updatedImpExt = true
+	}
+	impExt += "}"
+	bidRequest.Imp[0].Ext = json.RawMessage(impExt)
+
+	if validationFailed {
+		return models.RequestExtWrapper{}, errors.New("validation failed")
+	}
+
+	if gdprFlag != "" || ccpa != "" {
+		bidRequest.Regs = &openrtb2.Regs{}
+		regsExt := openrtb_ext.ExtRegs{}
+
+		if gdprFlag != "" {
+			gdprInt, _ := strconv.ParseInt(gdprFlag, 10, 8)
+			gdprInt8 := int8(gdprInt)
+			regsExt.GDPR = &gdprInt8
+		}
+
+		if ccpa != "" {
+			regsExt.USPrivacy = ccpa
+		}
+
+		bidRequest.Regs.Ext, _ = json.Marshal(regsExt)
+	}
+
+	bidRequest.User = &openrtb2.User{
+		ID:     GetString(GetValueFromRequest(values, redirectQueryParams, models.UserIDORTBParam)),
+		Gender: GetString(GetValueFromRequest(values, redirectQueryParams, models.UserGenderORTBParam)),
+		Yob:    GetCustomAtoI64(GetString(GetValueFromRequest(values, redirectQueryParams, models.UserYobORTBParam))),
+	}
+
+	if consentString != "" || eids != "" {
+		userExt := openrtb_ext.ExtUser{
+			Consent: consentString,
+		}
+
+		var eidList []openrtb2.EID
+		if err := json.Unmarshal([]byte(eids), &eidList); err == nil {
+			userExt.Eids = eidList
+		}
+
+		bidRequest.User.Ext, _ = json.Marshal(userExt)
+	}
+
+	sourceExt := models.ExtSource{}
+	if omidpv := GetString(GetValueFromRequest(values, redirectQueryParams, models.SourceOmidpvORTBParam)); omidpv != "" {
+		sourceExt.OMIDPV = omidpv
+	}
+	if omidpn := GetString(GetValueFromRequest(values, redirectQueryParams, models.SourceOmidpnORTBParam)); omidpn != "" {
+		sourceExt.OMIDPN = omidpn
+	}
+	bidRequest.Source = &openrtb2.Source{}
+	bidRequest.Source.Ext, _ = json.Marshal(sourceExt)
+
+	profileId, _ := strconv.Atoi(profileID)
+	displayVersion := 0
+	if val := getValueForKeyFromParams(models.VERSION_KEY, appReq, values, redirectQueryParams); val != "" {
+		displayVersion, _ = strconv.Atoi(val)
+	}
+
+	contentTransparency := values.Get(models.ContentTransparency)
+	var transparency map[string]openrtb_ext.TransparencyRule
+	if contentTransparency != "" {
+		_ = json.Unmarshal([]byte(contentTransparency), &transparency)
+	}
+
+	requestExtWrapper := models.RequestExtWrapper{
+		ProfileId:        profileId,
+		VersionId:        displayVersion,
+		SumryDisableFlag: 1,
+		SSAuctionFlag:    1,
+	}
+	requestExt := models.RequestExt{
+		Wrapper: &requestExtWrapper,
+		ExtRequest: openrtb_ext.ExtRequest{
+			Prebid: openrtb_ext.ExtRequestPrebid{
+				Debug: getValueForKeyFromParams(models.DEBUG_KEY, appReq, values, redirectQueryParams) == "1",
+				Transparency: &openrtb_ext.TransparencyExt{
+					Content: transparency,
+				},
+			},
+		},
+	}
+	bidRequest.Ext, _ = json.Marshal(requestExt)
+
+	// Replace macro values in DFP URL
+	for k := range values {
+		if strings.HasPrefix(k, models.MacroPrefix) {
+			paramName := strings.TrimPrefix(k, models.MacroPrefix)
+			redirectQueryParams.Set(paramName, values.Get(k))
+		}
+	}
+	DFPControllerValue := rand.Int()
+	redirectQueryParams.Set(models.Correlator, strconv.Itoa(DFPControllerValue))
+	redirectURL.RawQuery = redirectQueryParams.Encode()
+	owRedirectURLStr = redirectURL.String()
+	//Update Original HTTP Request with updated value of 'owredirect'
+	values.Set(models.OWRedirectURLKey, owRedirectURLStr)
+	rawQuery := values.Encode()
+
+	body, err := json.Marshal(bidRequest)
+	if err != nil {
+		return requestExtWrapper, err
+	}
+
+	result.ChangeSet.AddMutation(func(ep hookstage.EntrypointPayload) (hookstage.EntrypointPayload, error) {
+		ep.Request.URL.RawQuery = rawQuery
+		// ep.Request.Body = ioutil.NopCloser(bytes.NewBuffer(body))
+		ep.Body = body
+		return ep, nil
+	}, hookstage.MutationUpdate, "entrypoint-update-amp-redirect-url")
+
+	return requestExtWrapper, nil
+}
+
+// GetValueFromRequest contains logic to get value for parameter identified by 'key'
+func GetValueFromRequest(requestQueryParams, redirectQueryParams url.Values, key string) interface{} {
+	values := requestQueryParams
+	switch key {
+	case models.MimeORTBParam:
+		// DFP currently does not have a parameter defined for Mime types
+		if values.Get(models.OWMimeTypes) != "" {
+			mimeStrArr := strings.Split(values.Get(models.OWMimeTypes), models.MimesSeparator)
+			mimeValueArr := make([]string, 0)
+			for _, mime := range mimeStrArr {
+				if models.MimeIDToValueMap[mime] != "" {
+					mimeValueArr = append(mimeValueArr, models.MimeIDToValueMap[mime])
+				}
+			}
+			return mimeValueArr
+		}
+	case models.OwAppKeywords:
+		if values.Get(models.OwAppKeywords) != "" {
+			return values.Get(models.OwAppKeywords)
+		}
+	case models.MaxDurationORTBParam:
+		return getValue(models.MaxDurationORTBParam, values, redirectQueryParams, models.DFPMaxAdDuration, models.OWMaxAdDuration)
+	case models.MinDurationORTBParam:
+		return getValue(models.MinDurationORTBParam, values, redirectQueryParams, models.DFPMinAdDuration, models.OWMinAdDuration)
+	case models.StartDelayORTBParam:
+		if values.Get(models.OWStartDelay) != "" {
+			return values.Get(models.OWStartDelay)
+		} else if redirectQueryParams.Get(models.DFPVPos) != "" {
+			posStr := redirectQueryParams.Get(models.DFPVPos)
+			return models.VideoPositionToStartDelayMap[posStr]
+		}
+	case models.PlaybackMethodORTBParam:
+		var pbStr string
+		if values.Get(models.OWPlaybackMethod) != "" {
+			pbStr = values.Get(models.OWPlaybackMethod)
+		} else if redirectQueryParams.Get(models.DFPVpmute) != "" || redirectQueryParams.Get(models.DFPVpa) != "" {
+			if redirectQueryParams.Get(models.DFPVpmute) == "1" && redirectQueryParams.Get(models.DFPVpa) == "0" {
+				pbStr = "2,6"
+			} else if redirectQueryParams.Get(models.DFPVpmute) == "0" && redirectQueryParams.Get(models.DFPVpa) == "1" {
+				pbStr = "1,2"
+			} else if redirectQueryParams.Get(models.DFPVpmute) == "1" && redirectQueryParams.Get(models.DFPVpa) == "1" {
+				pbStr = "2"
+			}
+		}
+		if pbStr != "" {
+			pbIntArr := make([]int, 0)
+			for _, pb := range strings.Split(pbStr, ",") {
+				pbInt, _ := strconv.Atoi(pb)
+				pbIntArr = append(pbIntArr, pbInt)
+			}
+			return pbIntArr
+		}
+	case models.APIORTBParam:
+		return getValueInArray(models.APIORTBParam, values, redirectQueryParams, "", models.OWAPI)
+	case models.DeliveryORTBParam:
+		return getValueInArray(models.DeliveryORTBParam, values, redirectQueryParams, "", models.OWDelivery)
+	case models.ProtocolsORTBParam:
+		return getValueInArray(models.ProtocolsORTBParam, values, redirectQueryParams, "", models.OWProtocols)
+	case models.BAttrORTBParam:
+		return getValueInArray(models.BAttrORTBParam, values, redirectQueryParams, "", models.OWBAttr)
+	case models.LinearityORTBParam:
+		if values.Get(models.OWLinearity) != "" {
+			return values.Get(models.OWLinearity)
+		} else if redirectQueryParams.Get(models.DFPVAdType) != "" {
+			adtypeStr := redirectQueryParams.Get(models.DFPVAdType)
+			return models.LinearityMap[adtypeStr]
+		}
+	case models.PlacementORTBParam:
+		return getValue(models.PlacementORTBParam, values, redirectQueryParams, "", models.OWPlacement)
+	case models.MinBitrateORTBParam:
+		return getValue(models.MinBitrateORTBParam, values, redirectQueryParams, "", models.OWMinBitrate)
+	case models.MaxBitrateORTBParam:
+		return getValue(models.MaxBitrateORTBParam, values, redirectQueryParams, "", models.OWMaxBitrate)
+	case models.SkipORTBParam:
+		return getValue(models.SkipORTBParam, values, redirectQueryParams, "", models.OWSkippable)
+	case models.SkipMinORTBParam:
+		return getValue(models.SkipMinORTBParam, values, redirectQueryParams, "", models.OWSkipMin)
+	case models.SkipAfterORTBParam:
+		return getValue(models.SkipAfterORTBParam, values, redirectQueryParams, "", models.OWSkipAfter)
+	case models.SequenceORTBParam:
+		return getValue(models.SequenceORTBParam, values, redirectQueryParams, "", models.OWSequence)
+	case models.BoxingAllowedORTBParam:
+		return getValue(models.BoxingAllowedORTBParam, values, redirectQueryParams, "", models.OWBoxingAllowed)
+	case models.MaxExtendedORTBParam:
+		return getValue(models.MaxExtendedORTBParam, values, redirectQueryParams, "", models.OWMaxExtended)
+	case models.ProtocolORTBParam:
+		return getValue(models.ProtocolORTBParam, values, redirectQueryParams, "", models.OWProtocol)
+	case models.PosORTBParam:
+		return getValue(models.PosORTBParam, values, redirectQueryParams, "", models.OWPos)
+	case models.AppIDORTBParam:
+		return getValue(models.AppIDORTBParam, values, redirectQueryParams, "", models.OWAppId)
+	case models.AppNameORTBParam:
+		return getValue(models.AppNameORTBParam, values, redirectQueryParams, "", models.OWAppName)
+	case models.AppBundleORTBParam:
+		return getValue(models.AppBundleORTBParam, values, redirectQueryParams, "", models.OWAppBundle)
+	case models.AppDomainORTBParam:
+		return getValue(models.AppDomainORTBParam, values, redirectQueryParams, "", models.OWAppDomain)
+	case models.AppStoreURLORTBParam:
+		return getValue(models.AppStoreURLORTBParam, values, redirectQueryParams, "", models.OWAppStoreURL)
+	case models.AppCatORTBParam:
+		if values.Get(models.OWAppCat) != "" {
+			catStrArr := strings.Split(values.Get(models.OWAppCat), models.Comma)
+			return catStrArr
+		}
+	case models.AppPaidORTBParam:
+		return getValue(models.AppPaidORTBParam, values, redirectQueryParams, "", models.OWAppPaid)
+	case models.DeviceUAORTBParam:
+		return getValue(models.DeviceUAORTBParam, values, redirectQueryParams, "", models.OWDeviceUA)
+	case models.DeviceIPORTBParam:
+		return getValue(models.DeviceIPORTBParam, values, redirectQueryParams, "", models.OWDeviceIP)
+	case models.DeviceLMTORTBParam:
+		return getValue(models.DeviceLMTORTBParam, values, redirectQueryParams, "", models.OWDeviceLMT)
+	case models.DeviceDNTORTBParam:
+		return getValue(models.DeviceDNTORTBParam, values, redirectQueryParams, "", models.OWDeviceDNT)
+	case models.DeviceJSORTBParam:
+		return getValue(models.DeviceJSORTBParam, values, redirectQueryParams, "", models.OWDeviceJS)
+	case models.GeoLatORTBParam:
+		return getValue(models.GeoLatORTBParam, values, redirectQueryParams, "", models.OWGeoLat)
+	case models.GeoLonORTBParam:
+		return getValue(models.GeoLonORTBParam, values, redirectQueryParams, "", models.OWGeoLon)
+	case models.GeoTypeORTBParam:
+		return getValue(models.GeoTypeORTBParam, values, redirectQueryParams, "", models.OWGeoType)
+	case models.GeoCountryORTBParam:
+		return getValue(models.GeoCountryORTBParam, values, redirectQueryParams, "", models.OWGeoCountry)
+	case models.GeoCityORTBParam:
+		return getValue(models.GeoCityORTBParam, values, redirectQueryParams, "", models.OWGeoCity)
+	case models.GeoMetroORTBParam:
+		return getValue(models.GeoMetroORTBParam, values, redirectQueryParams, "", models.OWGeoMetro)
+	case models.GeoZipORTBParam:
+		return getValue(models.GeoZipORTBParam, values, redirectQueryParams, "", models.OWGeoZip)
+	case models.GeoUTOffsetORTBParam:
+		return getValue(models.GeoUTOffsetORTBParam, values, redirectQueryParams, "", models.OWUTOffset)
+	case models.DeviceIfaORTBParam:
+		return getValue(models.DeviceIfaORTBParam, values, redirectQueryParams, "", models.OWDeviceIfa)
+	case models.DeviceDidsha1ORTBParam:
+		return getValue(models.DeviceDidsha1ORTBParam, values, redirectQueryParams, "", models.OWDeviceDidsha1)
+	case models.DeviceDidmd5ORTBParam:
+		return getValue(models.DeviceDidmd5ORTBParam, values, redirectQueryParams, "", models.OWDeviceDidmd5)
+	case models.DeviceDpidsha1ORTBParam:
+		return getValue(models.DeviceDpidsha1ORTBParam, values, redirectQueryParams, "", models.OWDeviceDpidsha1)
+	case models.DeviceDpidmd5ORTBParam:
+		return getValue(models.DeviceDpidmd5ORTBParam, values, redirectQueryParams, "", models.OWDeviceDpidmd5)
+	case models.DeviceMacsha1ORTBParam:
+		return getValue(models.DeviceMacsha1ORTBParam, values, redirectQueryParams, "", models.OWDeviceMacsha1)
+	case models.DeviceMacmd5ORTBParam:
+		return getValue(models.DeviceMacmd5ORTBParam, values, redirectQueryParams, "", models.OWDeviceMacmd5)
+	case models.UserIDORTBParam:
+		return getValue(models.UserIDORTBParam, values, redirectQueryParams, "", models.OWUserID)
+	case models.SizeORTBParam:
+		if values.Get(models.OWSize) != "" {
+			return values.Get(models.OWSize)
+		} else if redirectQueryParams.Get(models.DFPSize) != "" {
+			// If multiple sizes are passed in DFP parameter, we will consider only the first
+			DFPSizeStr := strings.Split(redirectQueryParams.Get(models.DFPSize), models.MultipleSizeSeparator)
+			return DFPSizeStr[0]
+		}
+	case models.ContentGenreORTBParam:
+		return getValue(models.ContentGenreORTBParam, values, redirectQueryParams, "", models.OWContentGenre)
+	case models.ContentTitleORTBParam:
+		return getValue(models.ContentTitleORTBParam, values, redirectQueryParams, "", models.OWContentTitle)
+	case models.UserGenderORTBParam:
+		return getValue(models.UserGenderORTBParam, values, redirectQueryParams, "", models.OWUserGender)
+	case models.UserYobORTBParam:
+		return getValue(models.UserYobORTBParam, values, redirectQueryParams, "", models.OWUserYob)
+	case models.SourceOmidpvORTBParam:
+		return getValue(models.SourceOmidpvORTBParam, values, redirectQueryParams, "", models.OWSourceOmidPv)
+	case models.SourceOmidpnORTBParam:
+		return getValue(models.SourceOmidpnORTBParam, values, redirectQueryParams, "", models.OWSourceOmidPn)
+	case models.BidderParams:
+		return getValue(models.BidderParams, values, redirectQueryParams, "", models.OWBidderParams)
+	case models.DeviceExtSessionID:
+		if _, ok := values[models.OWDeviceExtSessionID]; ok {
+			return values.Get(models.OWDeviceExtSessionID)
+		}
+	case models.DeviceExtIfaType:
+		if _, ok := values[models.OWDeviceExtIfaType]; ok {
+			return values.Get(models.OWDeviceExtIfaType)
+		}
+	case models.FloorValue:
+		if _, ok := values[models.FloorValue]; ok {
+			return values.Get(models.FloorValue)
+		}
+	case models.FloorCurrency:
+		if _, ok := values[models.FloorCurrency]; ok {
+			return values.Get(models.FloorCurrency)
+		}
+	case models.ImpPrebidExt:
+		return getValue(models.ImpPrebidExt, values, redirectQueryParams, "", models.OWImpPrebidExt)
+	}
+	return nil
+
+}
+
+func getValue(oRTBParamName string, values url.Values, redirectQueryParams url.Values, DFPParamName string, OWParamName string) interface{} {
+	paramArr := models.ORTBToDFPOWMap[oRTBParamName]
+	if paramArr == nil {
+		return nil
+	}
+
+	if values.Get(OWParamName) != "" {
+		return values.Get(OWParamName)
+	} else if paramArr[1] != "" && DFPParamName != "" && redirectQueryParams.Get(DFPParamName) != "" {
+		return redirectQueryParams.Get(DFPParamName)
+	}
+
+	return nil
+}
+
+func getValueInArray(oRTBParamName string, values url.Values, redirectQueryParams url.Values, DFPParamName string, OWParamName string) interface{} {
+	valStr := GetString(getValue(oRTBParamName, values, redirectQueryParams, DFPParamName, OWParamName))
+	if valStr != "" {
+		valIntArr := make([]int, 0)
+		for _, val := range strings.Split(valStr, ",") {
+			valInt, _ := strconv.Atoi(val)
+			valIntArr = append(valIntArr, valInt)
+		}
+		return valIntArr
+	}
+	return nil
+}
+
+func GetString(val interface{}) string {
+	var result string
+	if val != nil {
+		result, ok := val.(string)
+		if ok {
+			return result
+		}
+	}
+	return result
+}
+
+func GetStringArr(val interface{}) []string {
+	var result []string
+	if val != nil {
+		result, ok := val.([]string)
+		if ok {
+			return result
+		}
+	}
+	return result
+}
+
+func GetIntArr(val interface{}) []int {
+	var result []int
+	if val != nil {
+		result, ok := val.([]int)
+		if ok {
+			return result
+		}
+	}
+	return result
+}
+
+func GetInt(val interface{}) int {
+	var result int
+	if val != nil {
+		result, ok := val.(int)
+		if ok {
+			return result
+		}
+	}
+	return result
+}
+
+func GetCustomAtoI8(s string) *int8 {
+	if s == "" {
+		return nil
+	}
+	i, ok := strconv.Atoi(s)
+	if ok == nil {
+		i8 := int8(i)
+		return &i8
+	}
+	return nil
+}
+
+func GetCustomAtoI64(s string) int64 {
+	if s == "" {
+		return 0
+	}
+	i, ok := strconv.ParseInt(s, 10, 64)
+	if ok == nil {
+		return i
+	}
+	return 0
+}
+
+func GetCustomStrToFloat(s string) float64 {
+	if s == "" {
+		return 0
+	}
+	f, ok := strconv.ParseFloat(s, 64)
+	if ok == nil {
+		return f
+	}
+	return 0
+}
+
+// getValueForKeyFromParams returns value for a key from the request params, if not present in request params
+// then it checks url/description_url in the redirect URL
+func getValueForKeyFromParams(key string, appReq string, requestParams, redirectURLParams url.Values) string {
+	var value string
+
+	//first check from request query params
+	if val := requestParams.Get(key); val != "" {
+		return val
+	}
+
+	//else check it in url/description_url in redirect url query params
+	urlStr := getURLfromRedirectURL(redirectURLParams, appReq)
+
+	if urlStr != "" {
+		if urlObj, urlErr := url.Parse(urlStr); urlErr == nil {
+			URLQueryParams := urlObj.Query()
+			if val := URLQueryParams.Get(key); val != "" {
+				return val
+			}
+		}
+	}
+	return value
+
+}
+
+// getURLfromRedirectURL return 'url' from redirectURL and if url is not present it returns desc URL for web request
+func getURLfromRedirectURL(redirectQueryParams url.Values, appReq string) string {
+	var URL string
+
+	//check for 'url' query param
+	if urlStr := redirectQueryParams.Get(models.URLKey); urlStr != "" {
+		return urlStr
+	}
+
+	//if 'url' is not present, check for 'description_url' key
+	if appReq != "1" {
+		if descURL := redirectQueryParams.Get(models.DescriptionURLKey); descURL != "" {
+			return descURL
+		}
+	}
+	return URL
+}
diff --git a/modules/pubmatic/openwrap/entrypointhook.go b/modules/pubmatic/openwrap/entrypointhook.go
new file mode 100644
index 000000000..4029232fd
--- /dev/null
+++ b/modules/pubmatic/openwrap/entrypointhook.go
@@ -0,0 +1,106 @@
+package openwrap
+
+import (
+	"context"
+	"time"
+
+	"github.com/prebid/prebid-server/hooks/hookexecution"
+	"github.com/prebid/prebid-server/hooks/hookstage"
+	v25 "github.com/prebid/prebid-server/modules/pubmatic/openwrap/endpoints/legacy/openrtb/v25"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/nbr"
+	uuid "github.com/satori/go.uuid"
+)
+
+const (
+	OpenWrapAuction  = "/pbs/openrtb2/auction"
+	OpenWrapV25      = "/openrtb/2.5"
+	OpenWrapV25Video = "/openrtb/2.5/video"
+	OpenWrapAmp      = "/openrtb/amp"
+)
+
+func (m OpenWrap) handleEntrypointHook(
+	_ context.Context,
+	miCtx hookstage.ModuleInvocationContext,
+	payload hookstage.EntrypointPayload,
+) (hookstage.HookResult[hookstage.EntrypointPayload], error) {
+	result := hookstage.HookResult[hookstage.EntrypointPayload]{}
+	queryParams := payload.Request.URL.Query()
+	if queryParams.Get("sshb") != "1" {
+		return result, nil
+	}
+
+	var err error
+	var requestExtWrapper models.RequestExtWrapper
+	switch payload.Request.URL.Path {
+	case hookexecution.EndpointAuction:
+		if !models.IsHybrid(payload.Body) { // new hybrid api should not execute module
+			return result, nil
+		}
+		requestExtWrapper, err = models.GetRequestExtWrapper(payload.Body)
+	case OpenWrapAuction: // legacy hybrid api should not execute module
+		return result, nil
+	case OpenWrapV25:
+		requestExtWrapper, err = models.GetRequestExtWrapper(payload.Body, "ext", "wrapper")
+	case OpenWrapV25Video:
+		requestExtWrapper, err = v25.ConvertVideoToAuctionRequest(payload, &result)
+	case OpenWrapAmp:
+		// requestExtWrapper, err = models.GetQueryParamRequestExtWrapper(payload.Body)
+	}
+
+	// init default for all modules
+	result.Reject = true
+
+	if err != nil {
+		result.NbrCode = nbr.InvalidRequest
+		result.Errors = append(result.Errors, "InvalidRequest")
+		return result, err
+	}
+
+	if requestExtWrapper.ProfileId == 0 {
+		result.NbrCode = nbr.InvalidProfileID
+		result.Errors = append(result.Errors, "ErrMissingProfileID")
+		return result, err
+	}
+
+	rCtx := models.RequestCtx{
+		StartTime:                 time.Now().Unix(),
+		Debug:                     queryParams.Get(models.Debug) == "1",
+		UA:                        payload.Request.Header.Get("User-Agent"),
+		ProfileID:                 requestExtWrapper.ProfileId,
+		DisplayID:                 requestExtWrapper.VersionId,
+		LogInfoFlag:               requestExtWrapper.LogInfoFlag,
+		SupportDeals:              requestExtWrapper.SupportDeals,
+		ABTestConfig:              requestExtWrapper.ABTestConfig,
+		SSAuction:                 requestExtWrapper.SSAuctionFlag,
+		SummaryDisable:            requestExtWrapper.SumryDisableFlag,
+		LoggerImpressionID:        requestExtWrapper.LoggerImpressionID,
+		ClientConfigFlag:          requestExtWrapper.ClientConfigFlag,
+		SSAI:                      requestExtWrapper.SSAI,
+		IP:                        models.GetIP(payload.Request),
+		IsCTVRequest:              models.IsCTVAPIRequest(payload.Request.URL.Path),
+		TrackerEndpoint:           m.cfg.Tracker.Endpoint,
+		VideoErrorTrackerEndpoint: m.cfg.Tracker.VideoErrorTrackerEndpoint,
+		Aliases:                   make(map[string]string),
+		ImpBidCtx:                 make(map[string]models.ImpCtx),
+		PrebidBidderCode:          make(map[string]string),
+		BidderResponseTimeMillis:  make(map[string]int),
+	}
+
+	// only http.ErrNoCookie is returned, we can ignore it
+	rCtx.UidCookie, _ = payload.Request.Cookie(models.UidCookieName)
+	rCtx.KADUSERCookie, _ = payload.Request.Cookie(models.KADUSERCOOKIE)
+	if originCookie, _ := payload.Request.Cookie("origin"); originCookie != nil {
+		rCtx.OriginCookie = originCookie.Value
+	}
+
+	if rCtx.LoggerImpressionID == "" {
+		rCtx.LoggerImpressionID = uuid.NewV4().String()
+	}
+
+	result.ModuleContext = make(hookstage.ModuleContext)
+	result.ModuleContext["rctx"] = rCtx
+
+	result.Reject = false
+	return result, nil
+}
diff --git a/modules/pubmatic/openwrap/entrypointhook_test.go b/modules/pubmatic/openwrap/entrypointhook_test.go
new file mode 100644
index 000000000..b8e6c34eb
--- /dev/null
+++ b/modules/pubmatic/openwrap/entrypointhook_test.go
@@ -0,0 +1,217 @@
+package openwrap
+
+import (
+	"context"
+	"net/http"
+	"testing"
+
+	"github.com/prebid/prebid-server/hooks/hookstage"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/cache"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/config"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/nbr"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestOpenWrap_handleEntrypointHook(t *testing.T) {
+	type fields struct {
+		cfg   config.Config
+		cache cache.Cache
+	}
+	type args struct {
+		in0     context.Context
+		miCtx   hookstage.ModuleInvocationContext
+		payload hookstage.EntrypointPayload
+	}
+	tests := []struct {
+		name    string
+		fields  fields
+		args    args
+		want    hookstage.HookResult[hookstage.EntrypointPayload]
+		wantErr error
+	}{
+		{
+			name: "sshb absent",
+			args: args{
+				in0:   context.Background(),
+				miCtx: hookstage.ModuleInvocationContext{},
+				payload: hookstage.EntrypointPayload{
+					Request: func() *http.Request {
+						r, err := http.NewRequest("POST", "http://localhost/openrtb/2.5?debug=1", nil)
+						if err != nil {
+							panic(err)
+						}
+						r.Header.Add("User-Agent", "go-test")
+						r.Header.Add("SOURCE_IP", "127.0.0.1")
+						r.Header.Add("Cookie", `KADUSERCOOKIE=7D75D25F-FAC9-443D-B2D1-B17FEE11E027; DPSync3=1684886400%3A248%7C1685491200%3A245_226_201; KRTBCOOKIE_80=16514-CAESEMih0bN7ISRdZT8xX8LXzEw&KRTB&22987-CAESEMih0bN7ISRdZT8xX8LXzEw&KRTB&23025-CAESEMih0bN7ISRdZT8xX8LXzEw&KRTB&23386-CAESEMih0bN7ISRdZT8xX8LXzEw; KRTBCOOKIE_377=6810-59dc50c9-d658-44ce-b442-5a1f344d97c0&KRTB&22918-59dc50c9-d658-44ce-b442-5a1f344d97c0&KRTB&23031-59dc50c9-d658-44ce-b442-5a1f344d97c0; uids=eyJ0ZW1wVUlEcyI6eyIzM2Fjcm9zcyI6eyJ1aWQiOiIxMTkxNzkxMDk5Nzc2NjEiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OTo0My4zODg4Nzk5NVoifSwiYWRmIjp7InVpZCI6IjgwNDQ2MDgzMzM3Nzg4MzkwNzgiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMS4wMzMwNTQ3MjdaIn0sImFka2VybmVsIjp7InVpZCI6IkE5MTYzNTAwNzE0OTkyOTMyOTkwIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MDkuMzczMzg1NjYyWiJ9LCJhZGtlcm5lbEFkbiI6eyJ1aWQiOiJBOTE2MzUwMDcxNDk5MjkzMjk5MCIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEzLjQzNDkyNTg5NloifSwiYWRtaXhlciI6eyJ1aWQiOiIzNjZhMTdiMTJmMjI0ZDMwOGYzZTNiOGRhOGMzYzhhMCIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA5LjU5MjkxNDgwMVoifSwiYWRueHMiOnsidWlkIjoiNDE5Mjg5ODUzMDE0NTExOTMiLCJleHBpcmVzIjoiMjAyMy0wMS0xOFQwOTo1MzowOC44MjU0NDI2NzZaIn0sImFqYSI6eyJ1aWQiOiJzMnN1aWQ2RGVmMFl0bjJveGQ1aG9zS1AxVmV3IiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTMuMjM5MTc2MDU0WiJ9LCJlcGxhbm5pbmciOnsidWlkIjoiQUoxRjBTOE5qdTdTQ0xWOSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEwLjkyOTk2MDQ3M1oifSwiZ2Ftb3NoaSI6eyJ1aWQiOiJndXNyXzM1NmFmOWIxZDhjNjQyYjQ4MmNiYWQyYjdhMjg4MTYxIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTAuNTI0MTU3MjI1WiJ9LCJncmlkIjp7InVpZCI6IjRmYzM2MjUwLWQ4NTItNDU5Yy04NzcyLTczNTZkZTE3YWI5NyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjE0LjY5NjMxNjIyN1oifSwiZ3JvdXBtIjp7InVpZCI6IjdENzVEMjVGLUZBQzktNDQzRC1CMkQxLUIxN0ZFRTExRTAyNyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjM5LjIyNjIxMjUzMloifSwiaXgiOnsidWlkIjoiWW9ORlNENlc5QkphOEh6eEdtcXlCUUFBXHUwMDI2Mjk3IiwiZXhwaXJlcyI6IjIwMjMtMDUtMzFUMDc6NTM6MzguNTU1ODI3MzU0WiJ9LCJqaXhpZSI6eyJ1aWQiOiI3MzY3MTI1MC1lODgyLTExZWMtYjUzOC0xM2FjYjdhZjBkZTQiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMi4xOTEwOTk3MzJaIn0sImxvZ2ljYWQiOnsidWlkIjoiQVZ4OVROQS11c25pa3M4QURzTHpWa3JvaDg4QUFBR0JUREh0UUEiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OTowOS40NTUxNDk2MTZaIn0sIm1lZGlhbmV0Ijp7InVpZCI6IjI5Nzg0MjM0OTI4OTU0MTAwMDBWMTAiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMy42NzIyMTUxMjhaIn0sIm1naWQiOnsidWlkIjoibTU5Z1hyN0xlX1htIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTcuMDk3MDAxNDcxWiJ9LCJuYW5vaW50ZXJhY3RpdmUiOnsidWlkIjoiNmFlYzhjMTAzNzlkY2I3ODQxMmJjODBiNmRkOWM5NzMxNzNhYjdkNzEyZTQzMWE1YTVlYTcwMzRlNTZhNThhMCIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjE2LjcxNDgwNzUwNVoifSwib25ldGFnIjp7InVpZCI6IjdPelZoVzFOeC1LOGFVak1HMG52NXVNYm5YNEFHUXZQbnVHcHFrZ3k0ckEiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OTowOS4xNDE3NDEyNjJaIn0sIm9wZW54Ijp7InVpZCI6IjVkZWNlNjIyLTBhMjMtMGRhYi0zYTI0LTVhNzcwMTBlNDU4MiIsImV4cGlyZXMiOiIyMDIzLTA1LTMxVDA3OjUyOjQ3LjE0MDQxNzM2M1oifSwicHVibWF0aWMiOnsidWlkIjoiN0Q3NUQyNUYtRkFDOS00NDNELUIyRDEtQjE3RkVFMTFFMDI3IiwiZXhwaXJlcyI6IjIwMjItMTAtMzFUMDk6MTQ6MjUuNzM3MjU2ODk5WiJ9LCJyaWNoYXVkaWVuY2UiOnsidWlkIjoiY2I2YzYzMjAtMzNlMi00Nzc0LWIxNjAtMXp6MTY1NDg0MDc0OSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA5LjUyNTA3NDE4WiJ9LCJzbWFydHlhZHMiOnsidWlkIjoiMTJhZjE1ZTQ0ZjAwZDA3NjMwZTc0YzQ5MTU0Y2JmYmE0Zjg0N2U4ZDRhMTU0YzhjM2Q1MWY1OGNmNzJhNDYyNyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEwLjgyNTAzMTg4NFoifSwic21pbGV3YW50ZWQiOnsidWlkIjoiZGQ5YzNmZTE4N2VmOWIwOWNhYTViNzExNDA0YzI4MzAiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxNC4yNTU2MDkzNjNaIn0sInN5bmFjb3JtZWRpYSI6eyJ1aWQiOiJHRFBSIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MDkuOTc5NTgzNDM4WiJ9LCJ0cmlwbGVsaWZ0Ijp7InVpZCI6IjcwMjE5NzUwNTQ4MDg4NjUxOTQ2MyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA4Ljk4OTY3MzU3NFoifSwidmFsdWVpbXByZXNzaW9uIjp7InVpZCI6IjlkMDgxNTVmLWQ5ZmUtNGI1OC04OThlLWUyYzU2MjgyYWIzZSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA5LjA2NzgzOTE2NFoifSwidmlzeCI6eyJ1aWQiOiIyN2UwYWMzYy1iNDZlLTQxYjMtOTkyYy1mOGQyNzE0OTQ5NWUiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMi45ODk1MjM1NzNaIn0sInlpZWxkbGFiIjp7InVpZCI6IjY5NzE0ZDlmLWZiMDAtNGE1Zi04MTljLTRiZTE5MTM2YTMyNSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjExLjMwMzAyNjYxNVoifSwieWllbGRtbyI6eyJ1aWQiOiJnOTZjMmY3MTlmMTU1MWIzMWY2MyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEwLjExMDUyODYwOVoifSwieWllbGRvbmUiOnsidWlkIjoiMmE0MmZiZDMtMmM3MC00ZWI5LWIxYmQtMDQ2OTY2NTBkOTQ4IiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTAuMzE4MzMzOTM5WiJ9LCJ6ZXJvY2xpY2tmcmF1ZCI6eyJ1aWQiOiJiOTk5NThmZS0yYTg3LTJkYTQtOWNjNC05NjFmZDExM2JlY2UiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxNS43MTk1OTQ1NjZaIn19LCJiZGF5IjoiMjAyMi0wNS0xN1QwNjo0ODozOC4wMTc5ODgyMDZaIn0=; KRTBCOOKIE_153=1923-LZw-Ny-bMjI2m2Q8IpsrNnnIYzw2yjdnLJsrdYse&KRTB&19420-LZw-Ny-bMjI2m2Q8IpsrNnnIYzw2yjdnLJsrdYse&KRTB&22979-LZw-Ny-bMjI2m2Q8IpsrNnnIYzw2yjdnLJsrdYse&KRTB&23462-LZw-Ny-bMjI2m2Q8IpsrNnnIYzw2yjdnLJsrdYse; KRTBCOOKIE_57=22776-41928985301451193&KRTB&23339-41928985301451193; KRTBCOOKIE_27=16735-uid:3cab6283-4546-4500-a7b6-40ef605fe745&KRTB&16736-uid:3cab6283-4546-4500-a7b6-40ef605fe745&KRTB&23019-uid:3cab6283-4546-4500-a7b6-40ef605fe745&KRTB&23114-uid:3cab6283-4546-4500-a7b6-40ef605fe745; KRTBCOOKIE_18=22947-1978557989514665832; KRTBCOOKIE_466=16530-4fc36250-d852-459c-8772-7356de17ab97; KRTBCOOKIE_391=22924-8044608333778839078&KRTB&23263-8044608333778839078&KRTB&23481-8044608333778839078; KRTBCOOKIE_1310=23431-b81c3g7dr67i&KRTB&23446-b81c3g7dr67i&KRTB&23465-b81c3g7dr67i; KRTBCOOKIE_1290=23368-vkf3yv9lbbl; KRTBCOOKIE_22=14911-4554572065121110164&KRTB&23150-4554572065121110164; KRTBCOOKIE_860=16335-YGAqDU1zUTdjyAFxCoe3kctlNPo&KRTB&23334-YGAqDU1zUTdjyAFxCoe3kctlNPo&KRTB&23417-YGAqDU1zUTdjyAFxCoe3kctlNPo&KRTB&23426-YGAqDU1zUTdjyAFxCoe3kctlNPo; KRTBCOOKIE_904=16787-KwJwE7NkCZClNJRysN2iYg; KRTBCOOKIE_1159=23138-5545f53f3d6e4ec199d8ed627ff026f3&KRTB&23328-5545f53f3d6e4ec199d8ed627ff026f3&KRTB&23427-5545f53f3d6e4ec199d8ed627ff026f3&KRTB&23445-5545f53f3d6e4ec199d8ed627ff026f3; KRTBCOOKIE_32=11175-AQEI_1QecY2ESAIjEW6KAQEBAQE&KRTB&22713-AQEI_1QecY2ESAIjEW6KAQEBAQE&KRTB&22715-AQEI_1QecY2ESAIjEW6KAQEBAQE; SyncRTB3=1685577600%3A35%7C1685491200%3A107_21_71_56_204_247_165_231_233_179_22_209_54_254_238_96_99_220_7_214_13_3_8_234_176_46_5%7C1684886400%3A2_223_15%7C1689465600%3A69%7C1685145600%3A63; KRTBCOOKIE_107=1471-uid:EK38R0PM1NQR0H5&KRTB&23421-uid:EK38R0PM1NQR0H5; KRTBCOOKIE_594=17105-RX-447a6332-530e-456a-97f4-3f0fd1ed48c9-004&KRTB&17107-RX-447a6332-530e-456a-97f4-3f0fd1ed48c9-004; SPugT=1684310122; chkChromeAb67Sec=133; KRTBCOOKIE_699=22727-AAFy2k7FBosAAEasbJoXnw; PugT=1684310473; origin=go-test`)
+						return r
+					}(),
+					Body: []byte(`{"ext":{"wrapper":{"profileid":5890,"versionid":1}}}`),
+				},
+			},
+			want: hookstage.HookResult[hookstage.EntrypointPayload]{},
+		},
+		{
+			name: "valid /openrtb/2.5 request",
+			fields: fields{
+				cfg: config.Config{
+					Tracker: config.Tracker{
+						Endpoint:                  "t.pubmatic.com",
+						VideoErrorTrackerEndpoint: "t.pubmatic.com/error",
+					},
+				},
+				cache: nil,
+			},
+			args: args{
+				in0:   context.Background(),
+				miCtx: hookstage.ModuleInvocationContext{},
+				payload: hookstage.EntrypointPayload{
+					Request: func() *http.Request {
+						r, err := http.NewRequest("POST", "http://localhost/openrtb/2.5?debug=1&sshb=1", nil)
+						if err != nil {
+							panic(err)
+						}
+						r.Header.Add("User-Agent", "go-test")
+						r.Header.Add("SOURCE_IP", "127.0.0.1")
+						r.Header.Add("Cookie", `KADUSERCOOKIE=7D75D25F-FAC9-443D-B2D1-B17FEE11E027; DPSync3=1684886400%3A248%7C1685491200%3A245_226_201; KRTBCOOKIE_80=16514-CAESEMih0bN7ISRdZT8xX8LXzEw&KRTB&22987-CAESEMih0bN7ISRdZT8xX8LXzEw&KRTB&23025-CAESEMih0bN7ISRdZT8xX8LXzEw&KRTB&23386-CAESEMih0bN7ISRdZT8xX8LXzEw; KRTBCOOKIE_377=6810-59dc50c9-d658-44ce-b442-5a1f344d97c0&KRTB&22918-59dc50c9-d658-44ce-b442-5a1f344d97c0&KRTB&23031-59dc50c9-d658-44ce-b442-5a1f344d97c0; uids=eyJ0ZW1wVUlEcyI6eyIzM2Fjcm9zcyI6eyJ1aWQiOiIxMTkxNzkxMDk5Nzc2NjEiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OTo0My4zODg4Nzk5NVoifSwiYWRmIjp7InVpZCI6IjgwNDQ2MDgzMzM3Nzg4MzkwNzgiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMS4wMzMwNTQ3MjdaIn0sImFka2VybmVsIjp7InVpZCI6IkE5MTYzNTAwNzE0OTkyOTMyOTkwIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MDkuMzczMzg1NjYyWiJ9LCJhZGtlcm5lbEFkbiI6eyJ1aWQiOiJBOTE2MzUwMDcxNDk5MjkzMjk5MCIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEzLjQzNDkyNTg5NloifSwiYWRtaXhlciI6eyJ1aWQiOiIzNjZhMTdiMTJmMjI0ZDMwOGYzZTNiOGRhOGMzYzhhMCIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA5LjU5MjkxNDgwMVoifSwiYWRueHMiOnsidWlkIjoiNDE5Mjg5ODUzMDE0NTExOTMiLCJleHBpcmVzIjoiMjAyMy0wMS0xOFQwOTo1MzowOC44MjU0NDI2NzZaIn0sImFqYSI6eyJ1aWQiOiJzMnN1aWQ2RGVmMFl0bjJveGQ1aG9zS1AxVmV3IiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTMuMjM5MTc2MDU0WiJ9LCJlcGxhbm5pbmciOnsidWlkIjoiQUoxRjBTOE5qdTdTQ0xWOSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEwLjkyOTk2MDQ3M1oifSwiZ2Ftb3NoaSI6eyJ1aWQiOiJndXNyXzM1NmFmOWIxZDhjNjQyYjQ4MmNiYWQyYjdhMjg4MTYxIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTAuNTI0MTU3MjI1WiJ9LCJncmlkIjp7InVpZCI6IjRmYzM2MjUwLWQ4NTItNDU5Yy04NzcyLTczNTZkZTE3YWI5NyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjE0LjY5NjMxNjIyN1oifSwiZ3JvdXBtIjp7InVpZCI6IjdENzVEMjVGLUZBQzktNDQzRC1CMkQxLUIxN0ZFRTExRTAyNyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjM5LjIyNjIxMjUzMloifSwiaXgiOnsidWlkIjoiWW9ORlNENlc5QkphOEh6eEdtcXlCUUFBXHUwMDI2Mjk3IiwiZXhwaXJlcyI6IjIwMjMtMDUtMzFUMDc6NTM6MzguNTU1ODI3MzU0WiJ9LCJqaXhpZSI6eyJ1aWQiOiI3MzY3MTI1MC1lODgyLTExZWMtYjUzOC0xM2FjYjdhZjBkZTQiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMi4xOTEwOTk3MzJaIn0sImxvZ2ljYWQiOnsidWlkIjoiQVZ4OVROQS11c25pa3M4QURzTHpWa3JvaDg4QUFBR0JUREh0UUEiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OTowOS40NTUxNDk2MTZaIn0sIm1lZGlhbmV0Ijp7InVpZCI6IjI5Nzg0MjM0OTI4OTU0MTAwMDBWMTAiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMy42NzIyMTUxMjhaIn0sIm1naWQiOnsidWlkIjoibTU5Z1hyN0xlX1htIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTcuMDk3MDAxNDcxWiJ9LCJuYW5vaW50ZXJhY3RpdmUiOnsidWlkIjoiNmFlYzhjMTAzNzlkY2I3ODQxMmJjODBiNmRkOWM5NzMxNzNhYjdkNzEyZTQzMWE1YTVlYTcwMzRlNTZhNThhMCIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjE2LjcxNDgwNzUwNVoifSwib25ldGFnIjp7InVpZCI6IjdPelZoVzFOeC1LOGFVak1HMG52NXVNYm5YNEFHUXZQbnVHcHFrZ3k0ckEiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OTowOS4xNDE3NDEyNjJaIn0sIm9wZW54Ijp7InVpZCI6IjVkZWNlNjIyLTBhMjMtMGRhYi0zYTI0LTVhNzcwMTBlNDU4MiIsImV4cGlyZXMiOiIyMDIzLTA1LTMxVDA3OjUyOjQ3LjE0MDQxNzM2M1oifSwicHVibWF0aWMiOnsidWlkIjoiN0Q3NUQyNUYtRkFDOS00NDNELUIyRDEtQjE3RkVFMTFFMDI3IiwiZXhwaXJlcyI6IjIwMjItMTAtMzFUMDk6MTQ6MjUuNzM3MjU2ODk5WiJ9LCJyaWNoYXVkaWVuY2UiOnsidWlkIjoiY2I2YzYzMjAtMzNlMi00Nzc0LWIxNjAtMXp6MTY1NDg0MDc0OSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA5LjUyNTA3NDE4WiJ9LCJzbWFydHlhZHMiOnsidWlkIjoiMTJhZjE1ZTQ0ZjAwZDA3NjMwZTc0YzQ5MTU0Y2JmYmE0Zjg0N2U4ZDRhMTU0YzhjM2Q1MWY1OGNmNzJhNDYyNyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEwLjgyNTAzMTg4NFoifSwic21pbGV3YW50ZWQiOnsidWlkIjoiZGQ5YzNmZTE4N2VmOWIwOWNhYTViNzExNDA0YzI4MzAiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxNC4yNTU2MDkzNjNaIn0sInN5bmFjb3JtZWRpYSI6eyJ1aWQiOiJHRFBSIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MDkuOTc5NTgzNDM4WiJ9LCJ0cmlwbGVsaWZ0Ijp7InVpZCI6IjcwMjE5NzUwNTQ4MDg4NjUxOTQ2MyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA4Ljk4OTY3MzU3NFoifSwidmFsdWVpbXByZXNzaW9uIjp7InVpZCI6IjlkMDgxNTVmLWQ5ZmUtNGI1OC04OThlLWUyYzU2MjgyYWIzZSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA5LjA2NzgzOTE2NFoifSwidmlzeCI6eyJ1aWQiOiIyN2UwYWMzYy1iNDZlLTQxYjMtOTkyYy1mOGQyNzE0OTQ5NWUiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMi45ODk1MjM1NzNaIn0sInlpZWxkbGFiIjp7InVpZCI6IjY5NzE0ZDlmLWZiMDAtNGE1Zi04MTljLTRiZTE5MTM2YTMyNSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjExLjMwMzAyNjYxNVoifSwieWllbGRtbyI6eyJ1aWQiOiJnOTZjMmY3MTlmMTU1MWIzMWY2MyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEwLjExMDUyODYwOVoifSwieWllbGRvbmUiOnsidWlkIjoiMmE0MmZiZDMtMmM3MC00ZWI5LWIxYmQtMDQ2OTY2NTBkOTQ4IiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTAuMzE4MzMzOTM5WiJ9LCJ6ZXJvY2xpY2tmcmF1ZCI6eyJ1aWQiOiJiOTk5NThmZS0yYTg3LTJkYTQtOWNjNC05NjFmZDExM2JlY2UiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxNS43MTk1OTQ1NjZaIn19LCJiZGF5IjoiMjAyMi0wNS0xN1QwNjo0ODozOC4wMTc5ODgyMDZaIn0=; KRTBCOOKIE_153=1923-LZw-Ny-bMjI2m2Q8IpsrNnnIYzw2yjdnLJsrdYse&KRTB&19420-LZw-Ny-bMjI2m2Q8IpsrNnnIYzw2yjdnLJsrdYse&KRTB&22979-LZw-Ny-bMjI2m2Q8IpsrNnnIYzw2yjdnLJsrdYse&KRTB&23462-LZw-Ny-bMjI2m2Q8IpsrNnnIYzw2yjdnLJsrdYse; KRTBCOOKIE_57=22776-41928985301451193&KRTB&23339-41928985301451193; KRTBCOOKIE_27=16735-uid:3cab6283-4546-4500-a7b6-40ef605fe745&KRTB&16736-uid:3cab6283-4546-4500-a7b6-40ef605fe745&KRTB&23019-uid:3cab6283-4546-4500-a7b6-40ef605fe745&KRTB&23114-uid:3cab6283-4546-4500-a7b6-40ef605fe745; KRTBCOOKIE_18=22947-1978557989514665832; KRTBCOOKIE_466=16530-4fc36250-d852-459c-8772-7356de17ab97; KRTBCOOKIE_391=22924-8044608333778839078&KRTB&23263-8044608333778839078&KRTB&23481-8044608333778839078; KRTBCOOKIE_1310=23431-b81c3g7dr67i&KRTB&23446-b81c3g7dr67i&KRTB&23465-b81c3g7dr67i; KRTBCOOKIE_1290=23368-vkf3yv9lbbl; KRTBCOOKIE_22=14911-4554572065121110164&KRTB&23150-4554572065121110164; KRTBCOOKIE_860=16335-YGAqDU1zUTdjyAFxCoe3kctlNPo&KRTB&23334-YGAqDU1zUTdjyAFxCoe3kctlNPo&KRTB&23417-YGAqDU1zUTdjyAFxCoe3kctlNPo&KRTB&23426-YGAqDU1zUTdjyAFxCoe3kctlNPo; KRTBCOOKIE_904=16787-KwJwE7NkCZClNJRysN2iYg; KRTBCOOKIE_1159=23138-5545f53f3d6e4ec199d8ed627ff026f3&KRTB&23328-5545f53f3d6e4ec199d8ed627ff026f3&KRTB&23427-5545f53f3d6e4ec199d8ed627ff026f3&KRTB&23445-5545f53f3d6e4ec199d8ed627ff026f3; KRTBCOOKIE_32=11175-AQEI_1QecY2ESAIjEW6KAQEBAQE&KRTB&22713-AQEI_1QecY2ESAIjEW6KAQEBAQE&KRTB&22715-AQEI_1QecY2ESAIjEW6KAQEBAQE; SyncRTB3=1685577600%3A35%7C1685491200%3A107_21_71_56_204_247_165_231_233_179_22_209_54_254_238_96_99_220_7_214_13_3_8_234_176_46_5%7C1684886400%3A2_223_15%7C1689465600%3A69%7C1685145600%3A63; KRTBCOOKIE_107=1471-uid:EK38R0PM1NQR0H5&KRTB&23421-uid:EK38R0PM1NQR0H5; KRTBCOOKIE_594=17105-RX-447a6332-530e-456a-97f4-3f0fd1ed48c9-004&KRTB&17107-RX-447a6332-530e-456a-97f4-3f0fd1ed48c9-004; SPugT=1684310122; chkChromeAb67Sec=133; KRTBCOOKIE_699=22727-AAFy2k7FBosAAEasbJoXnw; PugT=1684310473; origin=go-test`)
+						return r
+					}(),
+					Body: []byte(`{"ext":{"wrapper":{"profileid":5890,"versionid":1}}}`),
+				},
+			},
+			want: hookstage.HookResult[hookstage.EntrypointPayload]{
+				ModuleContext: hookstage.ModuleContext{
+					"rctx": models.RequestCtx{
+						ProfileID:                 5890,
+						DisplayID:                 1,
+						SSAuction:                 -1,
+						Debug:                     true,
+						UA:                        "go-test",
+						IP:                        "127.0.0.1",
+						IsCTVRequest:              false,
+						TrackerEndpoint:           "t.pubmatic.com",
+						VideoErrorTrackerEndpoint: "t.pubmatic.com/error",
+						UidCookie: &http.Cookie{
+							Name:  "uids",
+							Value: `eyJ0ZW1wVUlEcyI6eyIzM2Fjcm9zcyI6eyJ1aWQiOiIxMTkxNzkxMDk5Nzc2NjEiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OTo0My4zODg4Nzk5NVoifSwiYWRmIjp7InVpZCI6IjgwNDQ2MDgzMzM3Nzg4MzkwNzgiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMS4wMzMwNTQ3MjdaIn0sImFka2VybmVsIjp7InVpZCI6IkE5MTYzNTAwNzE0OTkyOTMyOTkwIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MDkuMzczMzg1NjYyWiJ9LCJhZGtlcm5lbEFkbiI6eyJ1aWQiOiJBOTE2MzUwMDcxNDk5MjkzMjk5MCIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEzLjQzNDkyNTg5NloifSwiYWRtaXhlciI6eyJ1aWQiOiIzNjZhMTdiMTJmMjI0ZDMwOGYzZTNiOGRhOGMzYzhhMCIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA5LjU5MjkxNDgwMVoifSwiYWRueHMiOnsidWlkIjoiNDE5Mjg5ODUzMDE0NTExOTMiLCJleHBpcmVzIjoiMjAyMy0wMS0xOFQwOTo1MzowOC44MjU0NDI2NzZaIn0sImFqYSI6eyJ1aWQiOiJzMnN1aWQ2RGVmMFl0bjJveGQ1aG9zS1AxVmV3IiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTMuMjM5MTc2MDU0WiJ9LCJlcGxhbm5pbmciOnsidWlkIjoiQUoxRjBTOE5qdTdTQ0xWOSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEwLjkyOTk2MDQ3M1oifSwiZ2Ftb3NoaSI6eyJ1aWQiOiJndXNyXzM1NmFmOWIxZDhjNjQyYjQ4MmNiYWQyYjdhMjg4MTYxIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTAuNTI0MTU3MjI1WiJ9LCJncmlkIjp7InVpZCI6IjRmYzM2MjUwLWQ4NTItNDU5Yy04NzcyLTczNTZkZTE3YWI5NyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjE0LjY5NjMxNjIyN1oifSwiZ3JvdXBtIjp7InVpZCI6IjdENzVEMjVGLUZBQzktNDQzRC1CMkQxLUIxN0ZFRTExRTAyNyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjM5LjIyNjIxMjUzMloifSwiaXgiOnsidWlkIjoiWW9ORlNENlc5QkphOEh6eEdtcXlCUUFBXHUwMDI2Mjk3IiwiZXhwaXJlcyI6IjIwMjMtMDUtMzFUMDc6NTM6MzguNTU1ODI3MzU0WiJ9LCJqaXhpZSI6eyJ1aWQiOiI3MzY3MTI1MC1lODgyLTExZWMtYjUzOC0xM2FjYjdhZjBkZTQiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMi4xOTEwOTk3MzJaIn0sImxvZ2ljYWQiOnsidWlkIjoiQVZ4OVROQS11c25pa3M4QURzTHpWa3JvaDg4QUFBR0JUREh0UUEiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OTowOS40NTUxNDk2MTZaIn0sIm1lZGlhbmV0Ijp7InVpZCI6IjI5Nzg0MjM0OTI4OTU0MTAwMDBWMTAiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMy42NzIyMTUxMjhaIn0sIm1naWQiOnsidWlkIjoibTU5Z1hyN0xlX1htIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTcuMDk3MDAxNDcxWiJ9LCJuYW5vaW50ZXJhY3RpdmUiOnsidWlkIjoiNmFlYzhjMTAzNzlkY2I3ODQxMmJjODBiNmRkOWM5NzMxNzNhYjdkNzEyZTQzMWE1YTVlYTcwMzRlNTZhNThhMCIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjE2LjcxNDgwNzUwNVoifSwib25ldGFnIjp7InVpZCI6IjdPelZoVzFOeC1LOGFVak1HMG52NXVNYm5YNEFHUXZQbnVHcHFrZ3k0ckEiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OTowOS4xNDE3NDEyNjJaIn0sIm9wZW54Ijp7InVpZCI6IjVkZWNlNjIyLTBhMjMtMGRhYi0zYTI0LTVhNzcwMTBlNDU4MiIsImV4cGlyZXMiOiIyMDIzLTA1LTMxVDA3OjUyOjQ3LjE0MDQxNzM2M1oifSwicHVibWF0aWMiOnsidWlkIjoiN0Q3NUQyNUYtRkFDOS00NDNELUIyRDEtQjE3RkVFMTFFMDI3IiwiZXhwaXJlcyI6IjIwMjItMTAtMzFUMDk6MTQ6MjUuNzM3MjU2ODk5WiJ9LCJyaWNoYXVkaWVuY2UiOnsidWlkIjoiY2I2YzYzMjAtMzNlMi00Nzc0LWIxNjAtMXp6MTY1NDg0MDc0OSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA5LjUyNTA3NDE4WiJ9LCJzbWFydHlhZHMiOnsidWlkIjoiMTJhZjE1ZTQ0ZjAwZDA3NjMwZTc0YzQ5MTU0Y2JmYmE0Zjg0N2U4ZDRhMTU0YzhjM2Q1MWY1OGNmNzJhNDYyNyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEwLjgyNTAzMTg4NFoifSwic21pbGV3YW50ZWQiOnsidWlkIjoiZGQ5YzNmZTE4N2VmOWIwOWNhYTViNzExNDA0YzI4MzAiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxNC4yNTU2MDkzNjNaIn0sInN5bmFjb3JtZWRpYSI6eyJ1aWQiOiJHRFBSIiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MDkuOTc5NTgzNDM4WiJ9LCJ0cmlwbGVsaWZ0Ijp7InVpZCI6IjcwMjE5NzUwNTQ4MDg4NjUxOTQ2MyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA4Ljk4OTY3MzU3NFoifSwidmFsdWVpbXByZXNzaW9uIjp7InVpZCI6IjlkMDgxNTVmLWQ5ZmUtNGI1OC04OThlLWUyYzU2MjgyYWIzZSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjA5LjA2NzgzOTE2NFoifSwidmlzeCI6eyJ1aWQiOiIyN2UwYWMzYy1iNDZlLTQxYjMtOTkyYy1mOGQyNzE0OTQ5NWUiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxMi45ODk1MjM1NzNaIn0sInlpZWxkbGFiIjp7InVpZCI6IjY5NzE0ZDlmLWZiMDAtNGE1Zi04MTljLTRiZTE5MTM2YTMyNSIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjExLjMwMzAyNjYxNVoifSwieWllbGRtbyI6eyJ1aWQiOiJnOTZjMmY3MTlmMTU1MWIzMWY2MyIsImV4cGlyZXMiOiIyMDIyLTA2LTI0VDA1OjU5OjEwLjExMDUyODYwOVoifSwieWllbGRvbmUiOnsidWlkIjoiMmE0MmZiZDMtMmM3MC00ZWI5LWIxYmQtMDQ2OTY2NTBkOTQ4IiwiZXhwaXJlcyI6IjIwMjItMDYtMjRUMDU6NTk6MTAuMzE4MzMzOTM5WiJ9LCJ6ZXJvY2xpY2tmcmF1ZCI6eyJ1aWQiOiJiOTk5NThmZS0yYTg3LTJkYTQtOWNjNC05NjFmZDExM2JlY2UiLCJleHBpcmVzIjoiMjAyMi0wNi0yNFQwNTo1OToxNS43MTk1OTQ1NjZaIn19LCJiZGF5IjoiMjAyMi0wNS0xN1QwNjo0ODozOC4wMTc5ODgyMDZaIn0=`,
+						},
+						KADUSERCookie: &http.Cookie{
+							Name:  "KADUSERCOOKIE",
+							Value: `7D75D25F-FAC9-443D-B2D1-B17FEE11E027`,
+						},
+						OriginCookie:             "go-test",
+						Aliases:                  make(map[string]string),
+						ImpBidCtx:                make(map[string]models.ImpCtx),
+						PrebidBidderCode:         make(map[string]string),
+						BidderResponseTimeMillis: make(map[string]int),
+					},
+				},
+			},
+			wantErr: nil,
+		},
+		{
+			name: "valid /openrtb/2.5 request with wiid set and no cookies",
+			fields: fields{
+				cfg: config.Config{
+					Tracker: config.Tracker{
+						Endpoint:                  "t.pubmatic.com",
+						VideoErrorTrackerEndpoint: "t.pubmatic.com/error",
+					},
+				},
+				cache: nil,
+			},
+			args: args{
+				in0:   context.Background(),
+				miCtx: hookstage.ModuleInvocationContext{},
+				payload: hookstage.EntrypointPayload{
+					Request: func() *http.Request {
+						r, err := http.NewRequest("POST", "http://localhost/openrtb/2.5?debug=1&sshb=1", nil)
+						if err != nil {
+							panic(err)
+						}
+						r.Header.Add("User-Agent", "go-test")
+						r.Header.Add("SOURCE_IP", "127.0.0.1")
+						return r
+					}(),
+					Body: []byte(`{"ext":{"wrapper":{"profileid":5890,"versionid":1,"wiid":"4df09505-d0b2-4d70-94d9-dc41e8e777f7"}}}`),
+				},
+			},
+			want: hookstage.HookResult[hookstage.EntrypointPayload]{
+				ModuleContext: hookstage.ModuleContext{
+					"rctx": models.RequestCtx{
+						ProfileID:                 5890,
+						DisplayID:                 1,
+						SSAuction:                 -1,
+						Debug:                     true,
+						UA:                        "go-test",
+						IP:                        "127.0.0.1",
+						IsCTVRequest:              false,
+						TrackerEndpoint:           "t.pubmatic.com",
+						VideoErrorTrackerEndpoint: "t.pubmatic.com/error",
+						LoggerImpressionID:        "4df09505-d0b2-4d70-94d9-dc41e8e777f7",
+						Aliases:                   make(map[string]string),
+						ImpBidCtx:                 make(map[string]models.ImpCtx),
+						PrebidBidderCode:          make(map[string]string),
+						BidderResponseTimeMillis:  make(map[string]int),
+					},
+				},
+			},
+			wantErr: nil,
+		},
+		{
+			name: "/openrtb/2.5 request without profileid",
+			fields: fields{
+				cfg:   config.Config{},
+				cache: nil,
+			},
+			args: args{
+				in0:   context.Background(),
+				miCtx: hookstage.ModuleInvocationContext{},
+				payload: hookstage.EntrypointPayload{
+					Request: func() *http.Request {
+						r, err := http.NewRequest("POST", "http://localhost/openrtb/2.5?&sshb=1", nil)
+						if err != nil {
+							panic(err)
+						}
+						return r
+					}(),
+					Body: []byte(`{"ext":{"wrapper":{"profileids":5890,"versionid":1}}}`),
+				},
+			},
+			want: hookstage.HookResult[hookstage.EntrypointPayload]{
+				Reject:  true,
+				NbrCode: nbr.InvalidProfileID,
+				Errors:  []string{"ErrMissingProfileID"},
+			},
+			wantErr: nil,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			m := OpenWrap{
+				cfg:   tt.fields.cfg,
+				cache: tt.fields.cache,
+			}
+			got, err := m.handleEntrypointHook(tt.args.in0, tt.args.miCtx, tt.args.payload)
+			assert.Equal(t, err, tt.wantErr)
+
+			if tt.want.ModuleContext != nil {
+				// validate runtime values individually and reset them
+				gotRctx := got.ModuleContext["rctx"].(models.RequestCtx)
+
+				assert.NotEmpty(t, gotRctx.StartTime)
+				gotRctx.StartTime = 0
+
+				wantRctx := tt.want.ModuleContext["rctx"].(models.RequestCtx)
+				if wantRctx.LoggerImpressionID == "" {
+					assert.Len(t, gotRctx.LoggerImpressionID, 36)
+					gotRctx.LoggerImpressionID = ""
+				}
+
+				got.ModuleContext["rctx"] = gotRctx
+			}
+
+			assert.Equal(t, got, tt.want)
+		})
+	}
+}
diff --git a/modules/pubmatic/openwrap/floors.go b/modules/pubmatic/openwrap/floors.go
new file mode 100644
index 000000000..1ec5ff295
--- /dev/null
+++ b/modules/pubmatic/openwrap/floors.go
@@ -0,0 +1,40 @@
+package openwrap
+
+import (
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func setPriceFloorFetchURL(requestExt *models.RequestExt, configMap map[int]map[string]string) {
+
+	if configMap == nil || configMap[models.VersionLevelConfigID] == nil {
+		return
+	}
+
+	if requestExt != nil && requestExt.Prebid.Floors != nil && requestExt.Prebid.Floors.Enabled != nil && !(*requestExt.Prebid.Floors.Enabled) {
+		return
+	}
+
+	url, urlExists := configMap[models.VersionLevelConfigID][models.PriceFloorURL]
+	if urlExists {
+		if requestExt.Prebid.Floors == nil {
+			requestExt.Prebid.Floors = &openrtb_ext.PriceFloorRules{}
+		}
+		if requestExt.Prebid.Floors.Enabled == nil {
+			requestExt.Prebid.Floors.Enabled = new(bool)
+		}
+		*requestExt.Prebid.Floors.Enabled = true
+
+		enable, enabledExists := configMap[models.VersionLevelConfigID][models.FloorModuleEnabled]
+		if enabledExists && enable != "1" {
+			*requestExt.Prebid.Floors.Enabled = false
+			return
+		}
+
+		if requestExt.Prebid.Floors.Location == nil {
+			requestExt.Prebid.Floors.Location = new(openrtb_ext.PriceFloorEndpoint)
+		}
+		requestExt.Prebid.Floors.Location.URL = url
+	}
+
+}
diff --git a/modules/pubmatic/openwrap/logger.go b/modules/pubmatic/openwrap/logger.go
new file mode 100644
index 000000000..956bfa930
--- /dev/null
+++ b/modules/pubmatic/openwrap/logger.go
@@ -0,0 +1,43 @@
+package openwrap
+
+import (
+	"fmt"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+func getIncomingSlots(imp openrtb2.Imp) []string {
+	sizes := map[string]struct{}{}
+	if imp.Banner != nil {
+		if imp.Banner.W != nil && imp.Banner.H != nil {
+			sizes[fmt.Sprintf("%dx%d", *imp.Banner.W, *imp.Banner.H)] = struct{}{}
+		}
+
+		for _, format := range imp.Banner.Format {
+			sizes[fmt.Sprintf("%dx%d", format.W, format.H)] = struct{}{}
+		}
+	}
+
+	if imp.Video != nil {
+		sizes[fmt.Sprintf("%dx%dv", imp.Video.W, imp.Video.H)] = struct{}{}
+	}
+
+	var s []string
+	for k := range sizes {
+		s = append(s, k)
+	}
+	return s
+}
+
+func getDefaultImpBidCtx(request openrtb2.BidRequest) map[string]models.ImpCtx {
+	impBidCtx := make(map[string]models.ImpCtx)
+	for _, imp := range request.Imp {
+		incomingSlots := getIncomingSlots(imp)
+
+		impBidCtx[imp.ID] = models.ImpCtx{
+			IncomingSlots: incomingSlots,
+		}
+	}
+	return impBidCtx
+}
diff --git a/modules/pubmatic/openwrap/marketplace.go b/modules/pubmatic/openwrap/marketplace.go
new file mode 100644
index 000000000..182a763fd
--- /dev/null
+++ b/modules/pubmatic/openwrap/marketplace.go
@@ -0,0 +1,37 @@
+package openwrap
+
+import (
+	"strings"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// TODO: Make this generic implementation
+func getMarketplaceBidders(reqABC *openrtb_ext.ExtAlternateBidderCodes, partnerConfigMap map[int]map[string]string) (*openrtb_ext.ExtAlternateBidderCodes, map[string]struct{}) {
+	if reqABC != nil {
+		return reqABC, nil
+	}
+
+	// string validations, etc will be done by api-wrapper-tag. Not need to repetitively do the typical string validations
+	marketplaceBiddersDB := partnerConfigMap[models.VersionLevelConfigID][models.MarketplaceBidders]
+	if len(marketplaceBiddersDB) == 0 {
+		return nil, nil
+	}
+	marketplaceBidders := strings.Split(marketplaceBiddersDB, ",")
+
+	bidderMap := make(map[string]struct{})
+	for _, bidder := range marketplaceBidders {
+		bidderMap[bidder] = struct{}{}
+	}
+
+	return &openrtb_ext.ExtAlternateBidderCodes{
+		Enabled: true,
+		Bidders: map[string]openrtb_ext.ExtAdapterAlternateBidderCodes{
+			string(openrtb_ext.BidderPubmatic): { // How do we get non-pubmatic bidders?. Does core-platform even have it?
+				Enabled:            true,
+				AllowedBidderCodes: marketplaceBidders,
+			},
+		},
+	}, bidderMap
+}
diff --git a/modules/pubmatic/openwrap/matchedimpression.go b/modules/pubmatic/openwrap/matchedimpression.go
new file mode 100644
index 000000000..cfbbc3696
--- /dev/null
+++ b/modules/pubmatic/openwrap/matchedimpression.go
@@ -0,0 +1,42 @@
+package openwrap
+
+import (
+	"encoding/json"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/adapters"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/usersync"
+)
+
+func getMatchedImpression(rctx models.RequestCtx) json.RawMessage {
+	var parsed *usersync.Cookie
+	if rctx.UidCookie == nil {
+		parsed = usersync.NewCookie()
+	} else {
+		parsed = usersync.ParseCookie(rctx.UidCookie)
+	}
+
+	cookieFlagMap := make(map[string]int)
+	for _, partnerConfig := range rctx.PartnerConfigMap { // TODO: original code deos not handle throttled partners
+		if partnerConfig[models.SERVER_SIDE_FLAG] != "1" {
+			continue
+		}
+
+		partnerName := partnerConfig[models.PREBID_PARTNER_NAME]
+
+		syncerCode := adapters.ResolveOWBidder(partnerName)
+
+		status := 0
+		if uid, _, _ := parsed.GetUID(syncerCode); uid != "" {
+			status = 1
+		}
+		cookieFlagMap[partnerConfig[models.BidderCode]] = status
+	}
+
+	matchedImpression, err := json.Marshal(cookieFlagMap)
+	if err != nil {
+		return nil
+	}
+
+	return json.RawMessage(matchedImpression)
+}
diff --git a/modules/pubmatic/openwrap/metrics/metrics.go b/modules/pubmatic/openwrap/metrics/metrics.go
new file mode 100644
index 000000000..af163a027
--- /dev/null
+++ b/modules/pubmatic/openwrap/metrics/metrics.go
@@ -0,0 +1,60 @@
+package metrics
+
+// MetricsEngine is a generic interface to record PBS metrics into the desired backend
+type MetricsEngine interface {
+	RecordOpenWrapServerPanicStats()
+	RecordPublisherPartnerStats(publisher, partner string)
+	RecordPublisherPartnerImpStats(publisher, partner string, impCount int)
+	RecordPublisherPartnerNoCookieStats(publisher, partner string)
+	RecordPartnerTimeoutErrorStats(publisher, partner string)
+	RecordNobiderStatusErrorStats(publisher, partner string)
+	RecordNobidErrorStats(publisher, partner string)
+	RecordUnkownPrebidErrorStats(publisher, partner string)
+	RecordSlotNotMappedErrorStats(publisher, partner string)
+	RecordMisConfigurationErrorStats(publisher, partner string)
+	RecordPublisherProfileRequests(publisher, profileID string)
+	RecordPublisherInvalidProfileImpressions(publisher, profileID string, impCount int)
+	RecordPublisherNoConsentRequests(publisher string)
+	RecordPublisherNoConsentImpressions(publisher string, impCount int)
+	RecordPublisherRequestStats(publisher string)
+	RecordNobidErrPrebidServerRequests(publisher string)
+	RecordNobidErrPrebidServerResponse(publisher string)
+	RecordInvalidCreativeStats(publisher, partner string)
+	RecordPlatformPublisherPartnerReqStats(platform, publisher, partner string)
+	RecordPlatformPublisherPartnerResponseStats(platform, publisher, partner string)
+	RecordPublisherResponseEncodingErrorStats(publisher string)
+	RecordPartnerResponseTimeStats(publisher, partner string, responseTime int)
+	RecordPublisherResponseTimeStats(publisher string, responseTime int)
+	RecordPublisherWrapperLoggerFailure(publisher, profileID, versionID string)
+	RecordCacheErrorRequests(endpoint string, publisher string, profileID string)
+	RecordPublisherInvalidProfileRequests(endpoint, publisher, profileID string)
+	RecordBadRequests(endpoint string, errorCode int)
+	RecordPrebidTimeoutRequests(publisher, profileID string)
+	RecordSSTimeoutRequests(publisher, profileID string)
+	RecordUidsCookieNotPresentErrorStats(publisher, profileID string)
+	RecordVideoInstlImpsStats(publisher, profileID string)
+	RecordImpDisabledViaConfigStats(impType, publisher, profileID string)
+	RecordPreProcessingTimeStats(publisher string, processingTime int)
+	RecordStatsKeyCTVPrebidFailedImpression(errorcode int, publisher string, profile string)
+	RecordCTVRequests(endpoint string, platform string)
+	RecordPublisherRequests(endpoint string, publisher string, platform string)
+	RecordCTVHTTPMethodRequests(endpoint string, publisher string, method string)
+	RecordCTVInvalidReasonCount(errorCode int, publisher string)
+	RecordCTVIncompleteAdPodsCount(impCount int, reason string, publisher string)
+	RecordCTVReqImpsWithDbConfigCount(publisher string)
+	RecordCTVReqImpsWithReqConfigCount(publisher string)
+	RecordAdPodGeneratedImpressionsCount(impCount int, publisher string)
+	RecordRequestAdPodGeneratedImpressionsCount(impCount int, publisher string)
+	RecordAdPodSecondsMissedCount(seconds int, publisher string)
+	RecordReqImpsWithAppContentCount(publisher string)
+	RecordReqImpsWithSiteContentCount(publisher string)
+	RecordAdPodImpressionYield(maxDuration int, minDuration int, publisher string)
+	RecordCTVReqCountWithAdPod(publisherID, profileID string)
+	RecordCTVKeyBidDuration(duration int, publisherID, profileID string)
+	RecordPBSAuctionRequestsStats()
+	RecordInjectTrackerErrorCount(adformat, publisher, partner string)
+	RecordBidResponseByDealCountInPBS(publisher, profile, aliasBidder, dealId string)
+	RecordBidResponseByDealCountInHB(publisher, profile, aliasBidder, dealId string)
+	RecordPartnerTimeoutInPBS(publisher, profile, aliasBidder string)
+	RecordVideoImpDisabledViaConnTypeStats(publisher, profileID string)
+}
diff --git a/modules/pubmatic/openwrap/metrics/stats/client.go b/modules/pubmatic/openwrap/metrics/stats/client.go
new file mode 100644
index 000000000..3f0466107
--- /dev/null
+++ b/modules/pubmatic/openwrap/metrics/stats/client.go
@@ -0,0 +1,167 @@
+package stats
+
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"net"
+	"net/http"
+	"time"
+
+	"github.com/alitto/pond"
+	"github.com/golang/glog"
+)
+
+type HttpClient interface {
+	Do(req *http.Request) (*http.Response, error)
+}
+
+// TrySubmit attempts to send a task to this worker pool for execution. If the queue is full,
+// it will not wait for a worker to become idle. It returns true if it was able to dispatch
+// the task and false otherwise.
+type WorkerPool interface {
+	TrySubmit(task func()) bool
+}
+
+// Client is a StatClient. All stats related operation will be done using this.
+type Client struct {
+	config       *config
+	httpClient   HttpClient
+	endpoint     string
+	pubChan      chan stat
+	pubTicker    *time.Ticker
+	statMap      map[string]int
+	shutDownChan chan struct{}
+	pool         WorkerPool
+}
+
+// NewClient will validate the Config provided and return a new Client
+func NewClient(cfg *config) (*Client, error) {
+	if err := cfg.validate(); err != nil {
+		return nil, fmt.Errorf("invalid stats client configurations:%s", err.Error())
+	}
+
+	client := &http.Client{
+		Transport: &http.Transport{
+			DialContext: (&net.Dialer{
+				Timeout:   time.Duration(cfg.DialTimeout) * time.Second,
+				KeepAlive: time.Duration(cfg.KeepAliveDuration) * time.Minute,
+			}).DialContext,
+			MaxIdleConns:          cfg.MaxIdleConns,
+			MaxIdleConnsPerHost:   cfg.MaxIdleConnsPerHost,
+			ResponseHeaderTimeout: time.Duration(cfg.ResponseHeaderTimeout) * time.Second,
+		},
+	}
+
+	c := &Client{
+		config:       cfg,
+		httpClient:   client,
+		endpoint:     cfg.Endpoint,
+		pubChan:      make(chan stat, cfg.MaxChannelLength),
+		pubTicker:    time.NewTicker(time.Duration(cfg.PublishingInterval) * time.Minute),
+		statMap:      make(map[string]int),
+		shutDownChan: make(chan struct{}),
+		pool:         pond.New(cfg.PoolMaxWorkers, cfg.PoolMaxCapacity),
+	}
+
+	go c.process()
+
+	return c, nil
+}
+
+// ShutdownProcess will perform the graceful shutdown operation
+func (sc *Client) ShutdownProcess() {
+	sc.shutDownChan <- struct{}{}
+}
+
+// PublishStat will push a stat to pubChan channel.
+func (sc *Client) PublishStat(key string, value int) {
+	sc.pubChan <- stat{Key: key, Value: value}
+}
+
+// process function will keep listening on the pubChan
+// It will publish the stats to server if
+// (1) number of stats reaches the PublishingThreshold or,
+// (2) PublishingInterval timeout occurs
+func (sc *Client) process() {
+
+	for {
+		select {
+		case stat := <-sc.pubChan:
+			sc.statMap[stat.Key] = sc.statMap[stat.Key] + stat.Value
+			if len(sc.statMap) >= sc.config.PublishingThreshold {
+				sc.prepareStatsForPublishing()
+				sc.pubTicker.Reset(time.Duration(sc.config.PublishingInterval) * time.Minute)
+			}
+
+		case <-sc.pubTicker.C:
+			sc.prepareStatsForPublishing()
+
+		case <-sc.shutDownChan:
+			sc.prepareStatsForPublishing()
+			return
+		}
+	}
+}
+
+// prepareStatsForPublishing creates copy of map containing stat-key and value
+// and calls publishStatsToServer to publishes it to the stat-server
+func (sc *Client) prepareStatsForPublishing() {
+	if len(sc.statMap) != 0 {
+		collectedStats := sc.statMap
+		sc.statMap = map[string]int{}
+		status := sc.pool.TrySubmit(func() {
+			sc.publishStatsToServer(collectedStats)
+		})
+		if !status {
+			glog.Errorf("[stats_fail] Failed to submit the publishStatsToServer task containing %d record to pool", len(collectedStats))
+		}
+	}
+}
+
+// publishStatsToServer sends the stats to the stat-server
+// in case of failure, it retries to send for Client.config.Retries number of times.
+func (sc *Client) publishStatsToServer(statMap map[string]int) int {
+
+	sb, err := json.Marshal(statMap)
+	if err != nil {
+		glog.Errorf("[stats_fail] Json unmarshal fail: %v", err)
+		return statusSetupFail
+	}
+
+	req, err := http.NewRequest(http.MethodPost, sc.endpoint, bytes.NewBuffer(sb))
+	if err != nil {
+		glog.Errorf("[stats_fail] Failed to form request to sent stats to server: %v", err)
+		return statusSetupFail
+	}
+
+	req.Header.Add(contentType, applicationJSON)
+	for retry := 0; retry < sc.config.Retries; retry++ {
+
+		startTime := time.Now()
+		resp, err := sc.httpClient.Do(req)
+		elapsedTime := time.Since(startTime)
+
+		code := 0
+		if resp != nil {
+			code = resp.StatusCode
+			defer resp.Body.Close()
+		}
+
+		if err == nil && code == http.StatusOK {
+			glog.Infof("[stats_success] retry:[%d] nstats:[%d] time:[%v]", retry, len(statMap), elapsedTime)
+			return statusPublishSuccess
+		}
+
+		if retry == (sc.config.Retries - 1) {
+			glog.Errorf("[stats_fail] retry:[%d] status:[%d] nstats:[%d] time:[%v] error:[%v]", retry, code, len(statMap), elapsedTime, err)
+			break
+		}
+
+		if sc.config.retryInterval > 0 {
+			time.Sleep(time.Duration(sc.config.retryInterval) * time.Second)
+		}
+	}
+
+	return statusPublishFail
+}
diff --git a/modules/pubmatic/openwrap/metrics/stats/client_config.go b/modules/pubmatic/openwrap/metrics/stats/client_config.go
new file mode 100644
index 000000000..8c8cf90f8
--- /dev/null
+++ b/modules/pubmatic/openwrap/metrics/stats/client_config.go
@@ -0,0 +1,81 @@
+package stats
+
+import (
+	"errors"
+)
+
+// config will have the information required to initialise a stats client
+type config struct {
+	Endpoint              string // stat-server's endpoint
+	PublishingInterval    int    // interval (in minutes) to publish stats to server
+	PublishingThreshold   int    // publish stats if number of stat-records present in map is higher than this threshold
+	Retries               int    // max retries to publish stats to server
+	DialTimeout           int    // http connection dial-timeout (in seconds)
+	KeepAliveDuration     int    // http connection keep-alive-duration (in minutes)
+	MaxIdleConns          int    // maximum idle connections across all hosts
+	MaxIdleConnsPerHost   int    // maximum idle connections per host
+	retryInterval         int    // if failed to publish stat then wait for retryInterval seconds for next attempt
+	ResponseHeaderTimeout int    // amount of time (in seconds) to wait for server's response header
+	MaxChannelLength      int    // max number of stat keys
+	PoolMaxWorkers        int    // max number of workers that will actually send the data to stats-server
+	PoolMaxCapacity       int    // number of tasks that can be submitted to the pool without blocking
+}
+
+func (c *config) validate() (err error) {
+	if c.Endpoint == "" {
+		return errors.New("stat server endpoint cannot be empty")
+	}
+
+	if c.PublishingInterval < minPublishingInterval {
+		c.PublishingInterval = minPublishingInterval
+	} else if c.PublishingInterval > maxPublishingInterval {
+		c.PublishingInterval = maxPublishingInterval
+	}
+
+	if c.Retries > 0 {
+		if c.Retries > (c.PublishingInterval*60)/minRetryDuration {
+			c.Retries = (c.PublishingInterval * 60) / minRetryDuration
+			c.retryInterval = minRetryDuration
+		} else {
+			c.retryInterval = (c.PublishingInterval * 60) / c.Retries
+		}
+	}
+
+	if c.DialTimeout < minDialTimeout {
+		c.DialTimeout = minDialTimeout
+	}
+
+	if c.KeepAliveDuration < minKeepAliveDuration {
+		c.KeepAliveDuration = minKeepAliveDuration
+	}
+
+	if c.MaxIdleConns < 0 {
+		c.MaxIdleConns = 0
+	}
+
+	if c.MaxIdleConnsPerHost < 0 {
+		c.MaxIdleConnsPerHost = 0
+	}
+
+	if c.PublishingThreshold < minPublishingThreshold {
+		c.PublishingThreshold = minPublishingThreshold
+	}
+
+	if c.ResponseHeaderTimeout < minResponseHeaderTimeout {
+		c.ResponseHeaderTimeout = minResponseHeaderTimeout
+	}
+
+	if c.MaxChannelLength < minChannelLength {
+		c.MaxChannelLength = minChannelLength
+	}
+
+	if c.PoolMaxWorkers < minPoolWorker {
+		c.PoolMaxWorkers = minPoolWorker
+	}
+
+	if c.PoolMaxCapacity < minPoolCapacity {
+		c.PoolMaxCapacity = minPoolCapacity
+	}
+
+	return nil
+}
diff --git a/modules/pubmatic/openwrap/metrics/stats/client_config_test.go b/modules/pubmatic/openwrap/metrics/stats/client_config_test.go
new file mode 100644
index 000000000..f3a6393d0
--- /dev/null
+++ b/modules/pubmatic/openwrap/metrics/stats/client_config_test.go
@@ -0,0 +1,159 @@
+package stats
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+)
+
+func TestValidate(t *testing.T) {
+
+	type args struct {
+		cfg *config
+	}
+
+	type want struct {
+		err error
+		cfg *config
+	}
+
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "empty_endpoint",
+			args: args{
+				cfg: &config{
+					Endpoint: "",
+				},
+			},
+			want: want{
+				err: fmt.Errorf("stat server endpoint cannot be empty"),
+				cfg: &config{
+					Endpoint: "",
+				},
+			},
+		},
+		{
+			name: "lower_values_than_min_limit",
+			args: args{
+				cfg: &config{
+					Endpoint:            "10.10.10.10/stat",
+					PublishingInterval:  0,
+					DialTimeout:         0,
+					KeepAliveDuration:   0,
+					MaxIdleConns:        -1,
+					MaxIdleConnsPerHost: -1,
+					PublishingThreshold: 0,
+				},
+			},
+			want: want{
+				err: nil,
+				cfg: &config{
+					Endpoint:              "10.10.10.10/stat",
+					PublishingInterval:    minPublishingInterval,
+					DialTimeout:           minDialTimeout,
+					KeepAliveDuration:     minKeepAliveDuration,
+					MaxIdleConns:          0,
+					MaxIdleConnsPerHost:   0,
+					PublishingThreshold:   minPublishingThreshold,
+					MaxChannelLength:      minChannelLength,
+					ResponseHeaderTimeout: minResponseHeaderTimeout,
+					PoolMaxWorkers:        minPoolWorker,
+					PoolMaxCapacity:       minPoolCapacity,
+				},
+			},
+		},
+		{
+			name: "high_PublishingInterval_than_max_limit",
+			args: args{
+				cfg: &config{
+					Endpoint:           "10.10.10.10/stat",
+					PublishingInterval: 10,
+				},
+			},
+			want: want{
+				err: nil,
+				cfg: &config{
+					Endpoint:              "10.10.10.10/stat",
+					PublishingInterval:    maxPublishingInterval,
+					DialTimeout:           minDialTimeout,
+					KeepAliveDuration:     minKeepAliveDuration,
+					MaxIdleConns:          0,
+					MaxIdleConnsPerHost:   0,
+					PublishingThreshold:   minPublishingThreshold,
+					MaxChannelLength:      minChannelLength,
+					ResponseHeaderTimeout: minResponseHeaderTimeout,
+					PoolMaxWorkers:        minPoolWorker,
+					PoolMaxCapacity:       minPoolCapacity,
+				},
+			},
+		},
+		{
+			name: "high_Retries_than_maxRetriesAllowed",
+			args: args{
+				cfg: &config{
+					Endpoint:           "10.10.10.10/stat",
+					PublishingInterval: 3,
+					Retries:            100,
+				},
+			},
+			want: want{
+				err: nil,
+				cfg: &config{
+					Endpoint:              "10.10.10.10/stat",
+					PublishingInterval:    3,
+					DialTimeout:           minDialTimeout,
+					KeepAliveDuration:     minKeepAliveDuration,
+					MaxIdleConns:          0,
+					MaxIdleConnsPerHost:   0,
+					PublishingThreshold:   minPublishingThreshold,
+					Retries:               5,
+					retryInterval:         minRetryDuration,
+					MaxChannelLength:      minChannelLength,
+					ResponseHeaderTimeout: minResponseHeaderTimeout,
+					PoolMaxWorkers:        minPoolWorker,
+					PoolMaxCapacity:       minPoolCapacity,
+				},
+			},
+		},
+		{
+			name: "valid_Retries_value",
+			args: args{
+				cfg: &config{
+					Endpoint:           "10.10.10.10/stat",
+					PublishingInterval: 3,
+					Retries:            5,
+				},
+			},
+			want: want{
+				err: nil,
+				cfg: &config{
+					Endpoint:              "10.10.10.10/stat",
+					PublishingInterval:    3,
+					DialTimeout:           minDialTimeout,
+					KeepAliveDuration:     minKeepAliveDuration,
+					MaxIdleConns:          0,
+					MaxIdleConnsPerHost:   0,
+					PublishingThreshold:   minPublishingThreshold,
+					Retries:               5,
+					retryInterval:         36,
+					MaxChannelLength:      minChannelLength,
+					ResponseHeaderTimeout: minResponseHeaderTimeout,
+					PoolMaxWorkers:        minPoolWorker,
+					PoolMaxCapacity:       minPoolCapacity,
+				},
+			},
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			err := tt.args.cfg.validate()
+			assert.Equal(t, err, tt.want.err, "Mismatched error")
+			assert.Equal(t, tt.args.cfg, tt.want.cfg, "Mismatched config")
+		})
+	}
+}
diff --git a/modules/pubmatic/openwrap/metrics/stats/client_test.go b/modules/pubmatic/openwrap/metrics/stats/client_test.go
new file mode 100644
index 000000000..cb6dc0a8c
--- /dev/null
+++ b/modules/pubmatic/openwrap/metrics/stats/client_test.go
@@ -0,0 +1,439 @@
+package stats
+
+import (
+	"bytes"
+	"fmt"
+	"io"
+	"net"
+	"net/http"
+	"sync"
+	"testing"
+	"time"
+
+	"github.com/alitto/pond"
+	"github.com/golang/mock/gomock"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/metrics/stats/mock"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestNewClient(t *testing.T) {
+
+	type args struct {
+		cfg *config
+	}
+
+	type want struct {
+		err        error
+		statClient *Client
+	}
+
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "invalid_config",
+			args: args{
+				cfg: &config{
+					Endpoint: "",
+				},
+			},
+			want: want{
+				err:        fmt.Errorf("invalid stats client configurations:stat server endpoint cannot be empty"),
+				statClient: nil,
+			},
+		},
+		{
+			name: "valid_config",
+			args: args{
+				cfg: &config{
+					Endpoint:            "10.10.10.10:8080/stat",
+					PublishingInterval:  3,
+					DialTimeout:         minDialTimeout,
+					KeepAliveDuration:   minKeepAliveDuration,
+					MaxIdleConns:        0,
+					MaxIdleConnsPerHost: 0,
+					PublishingThreshold: minPublishingThreshold,
+					Retries:             5,
+					retryInterval:       36,
+				},
+			},
+			want: want{
+				err: nil,
+				statClient: &Client{
+					config: &config{
+						Endpoint:              "10.10.10.10:8080/stat",
+						PublishingInterval:    3,
+						DialTimeout:           minDialTimeout,
+						KeepAliveDuration:     minKeepAliveDuration,
+						MaxIdleConns:          0,
+						MaxIdleConnsPerHost:   0,
+						PublishingThreshold:   minPublishingThreshold,
+						Retries:               5,
+						retryInterval:         36,
+						MaxChannelLength:      minChannelLength,
+						ResponseHeaderTimeout: minResponseHeaderTimeout,
+						PoolMaxWorkers:        minPoolWorker,
+						PoolMaxCapacity:       minPoolCapacity,
+					},
+					httpClient: &http.Client{
+						Transport: &http.Transport{
+							DialContext: (&net.Dialer{
+								Timeout:   time.Duration(minDialTimeout) * time.Second,
+								KeepAlive: time.Duration(minKeepAliveDuration) * time.Minute,
+							}).DialContext,
+							MaxIdleConns:          0,
+							MaxIdleConnsPerHost:   0,
+							ResponseHeaderTimeout: 30 * time.Second,
+						},
+					},
+					endpoint:  "10.10.10.10:8080/stat",
+					pubChan:   make(chan stat, minChannelLength),
+					pubTicker: time.NewTicker(time.Duration(3) * time.Minute),
+					statMap:   map[string]int{},
+				},
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			client, err := NewClient(tt.args.cfg)
+			assert.Equal(t, tt.want.err, err, "Mismatched error")
+			compareClient(tt.want.statClient, client, t)
+		})
+	}
+}
+
+func compareClient(expectedClient, actualClient *Client, t *testing.T) {
+
+	if expectedClient != nil && actualClient != nil {
+		assert.Equal(t, expectedClient.endpoint, actualClient.endpoint, "Mismatched endpoint")
+		assert.Equal(t, expectedClient.config, actualClient.config, "Mismatched config")
+		assert.Equal(t, cap(expectedClient.pubChan), cap(actualClient.pubChan), "Mismatched pubChan capacity")
+		assert.Equal(t, expectedClient.statMap, actualClient.statMap, "Mismatched statMap")
+	}
+
+	if expectedClient != nil && actualClient == nil {
+		t.Errorf("actualClient is expected to be non-nil")
+	}
+
+	if actualClient != nil && expectedClient == nil {
+		t.Errorf("actualClient is expected to be nil")
+	}
+}
+
+func TestPublishStat(t *testing.T) {
+
+	type args struct {
+		keyVal      map[string]int
+		maxChanSize int
+	}
+
+	type want struct {
+		keyVal      map[string]int
+		channelSize int
+	}
+
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "push_multiple_stat",
+			args: args{
+				keyVal: map[string]int{
+					"key1": 10,
+					"key2": 20,
+				},
+				maxChanSize: 2,
+			},
+			want: want{
+				keyVal: map[string]int{
+					"key1": 10,
+					"key2": 20,
+				},
+				channelSize: 2,
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			client := Client{
+				pubChan: make(chan stat, tt.args.maxChanSize),
+			}
+			for k, v := range tt.args.keyVal {
+				client.PublishStat(k, v)
+			}
+
+			close(client.pubChan)
+			assert.Equal(t, tt.want.channelSize, len(client.pubChan))
+			for stat := range client.pubChan {
+				assert.Equal(t, stat.Value, tt.want.keyVal[stat.Key])
+			}
+		})
+	}
+}
+
+func TestPrepareStatsForPublishing(t *testing.T) {
+
+	type args struct {
+		client *Client
+	}
+
+	tests := []struct {
+		name           string
+		args           args
+		expectedLength int
+	}{
+		{
+			name: "statMap_should_be_empty",
+			args: args{
+				client: &Client{
+					statMap: map[string]int{
+						"key1": 10,
+						"key2": 20,
+					},
+					config: &config{
+						Retries: 1,
+					},
+					httpClient: http.DefaultClient,
+					pool:       pond.New(2, 2),
+				},
+			},
+			expectedLength: 0,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			tt.args.client.prepareStatsForPublishing()
+			assert.Equal(t, len(tt.args.client.statMap), tt.expectedLength)
+		})
+	}
+}
+
+func TestPublishStatsToServer(t *testing.T) {
+
+	ctrl := gomock.NewController(t)
+	defer ctrl.Finish()
+	mockClient := mock.NewMockHttpClient(ctrl)
+
+	type args struct {
+		statClient *Client
+		statsMap   map[string]int
+	}
+
+	tests := []struct {
+		name          string
+		args          args
+		expStatusCode int
+		setup         func()
+	}{
+		{
+			name: "invalid_url",
+			args: args{
+				statClient: &Client{
+					endpoint: "%%invalid%%url",
+				},
+				statsMap: map[string]int{
+					"key": 10,
+				},
+			},
+			setup:         func() {},
+			expStatusCode: statusSetupFail,
+		},
+		{
+			name: "server_responds_with_error",
+			args: args{
+				statClient: &Client{
+					endpoint: "http://any-random-server.com",
+					config: &config{
+						Retries: 1,
+					},
+					httpClient: mockClient,
+				},
+				statsMap: map[string]int{
+					"key": 10,
+				},
+			},
+			setup: func() {
+				mockClient.EXPECT().Do(gomock.Any()).Return(&http.Response{StatusCode: 500, Body: io.NopCloser(bytes.NewReader(nil))}, nil)
+			},
+			expStatusCode: statusPublishFail,
+		},
+		{
+			name: "server_responds_with_error_multi_retries",
+			args: args{
+				statClient: &Client{
+					endpoint: "http://any-random-server.com",
+					config: &config{
+						Retries:       3,
+						retryInterval: 1,
+					},
+					httpClient: mockClient,
+				},
+				statsMap: map[string]int{
+					"key": 10,
+				},
+			},
+			setup: func() {
+				mockClient.EXPECT().Do(gomock.Any()).Return(&http.Response{StatusCode: 500, Body: io.NopCloser(bytes.NewReader(nil))}, nil).Times(3)
+			},
+			expStatusCode: statusPublishFail,
+		},
+		{
+			name: "first_attempt_fail_second_attempt_success",
+			args: args{
+				statClient: &Client{
+					endpoint: "http://any-random-server.com",
+					config: &config{
+						Retries:       3,
+						retryInterval: 1,
+					},
+					httpClient: mockClient,
+				},
+				statsMap: map[string]int{
+					"key": 10,
+				},
+			},
+			setup: func() {
+				gomock.InOrder(
+					mockClient.EXPECT().Do(gomock.Any()).Return(&http.Response{StatusCode: 500, Body: io.NopCloser(bytes.NewReader(nil))}, nil),
+					mockClient.EXPECT().Do(gomock.Any()).Return(&http.Response{StatusCode: 200, Body: io.NopCloser(bytes.NewReader(nil))}, nil),
+				)
+			},
+			expStatusCode: statusPublishSuccess,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			tt.setup()
+			statusCode := tt.args.statClient.publishStatsToServer(tt.args.statsMap)
+			assert.Equal(t, tt.expStatusCode, statusCode)
+		})
+	}
+}
+
+func TestProcess(t *testing.T) {
+	type args struct {
+		client *Client
+	}
+
+	tests := []struct {
+		name        string
+		args        args
+		setup       func(*Client)
+		getMockPool func(wg *sync.WaitGroup) (*gomock.Controller, WorkerPool)
+	}{
+		{
+			name: "PublishingThreshold_limit_reached",
+			args: args{
+				client: &Client{
+					statMap: map[string]int{},
+					config: &config{
+						Retries:             1,
+						PublishingInterval:  1,
+						PublishingThreshold: 2,
+					},
+					pubChan:      make(chan stat, 2),
+					pubTicker:    time.NewTicker(1 * time.Minute),
+					shutDownChan: make(chan struct{}),
+				},
+			},
+			setup: func(client *Client) {
+				client.PublishStat("key1", 1)
+				client.PublishStat("key2", 2)
+			},
+			getMockPool: func(wg *sync.WaitGroup) (*gomock.Controller, WorkerPool) {
+				ctrl := gomock.NewController(t)
+				mockWorkerPool := mock.NewMockWorkerPool(ctrl)
+				mockWorkerPool.EXPECT().TrySubmit(gomock.Any()).DoAndReturn(func(task func()) bool {
+					wg.Done()
+					return true
+				})
+				return ctrl, mockWorkerPool
+			},
+		},
+		{
+			name: "PublishingInterval_timer_timeouts",
+			args: args{
+				client: &Client{
+					statMap: map[string]int{},
+					config: &config{
+						Retries:             1,
+						PublishingInterval:  1,
+						PublishingThreshold: 10,
+					},
+					pubChan:      make(chan stat, 10),
+					pubTicker:    time.NewTicker(1 * time.Second),
+					shutDownChan: make(chan struct{}),
+				},
+			},
+			setup: func(client *Client) {
+				client.PublishStat("key1", 1)
+				client.PublishStat("key2", 2)
+			},
+			getMockPool: func(wg *sync.WaitGroup) (*gomock.Controller, WorkerPool) {
+				ctrl := gomock.NewController(t)
+				mockWorkerPool := mock.NewMockWorkerPool(ctrl)
+				mockWorkerPool.EXPECT().TrySubmit(gomock.Any()).DoAndReturn(func(task func()) bool {
+					wg.Done()
+					return true
+				})
+				return ctrl, mockWorkerPool
+			},
+		},
+		{
+			name: "graceful_shutdown_process",
+			args: args{
+				client: &Client{
+					statMap: map[string]int{},
+					config: &config{
+						Retries:             1,
+						PublishingThreshold: 5,
+					},
+					pubChan:      make(chan stat, 10),
+					pubTicker:    time.NewTicker(1 * time.Minute),
+					shutDownChan: make(chan struct{}),
+				},
+			},
+			setup: func(client *Client) {
+				client.PublishStat("key1", 1)
+				time.Sleep(1 * time.Second)
+				client.ShutdownProcess()
+			},
+			getMockPool: func(wg *sync.WaitGroup) (*gomock.Controller, WorkerPool) {
+				ctrl := gomock.NewController(t)
+				mockWorkerPool := mock.NewMockWorkerPool(ctrl)
+				mockWorkerPool.EXPECT().TrySubmit(gomock.Any()).DoAndReturn(func(task func()) bool {
+					wg.Done()
+					return true
+				})
+				return ctrl, mockWorkerPool
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			var wg sync.WaitGroup
+			wg.Add(1)
+
+			client := tt.args.client
+			ctrl, mockPool := tt.getMockPool(&wg)
+			defer ctrl.Finish()
+			client.pool = mockPool
+
+			go client.process()
+
+			tt.setup(client)
+
+			wg.Wait()
+		})
+	}
+}
diff --git a/modules/pubmatic/openwrap/metrics/stats/constants.go b/modules/pubmatic/openwrap/metrics/stats/constants.go
new file mode 100644
index 000000000..361e552a7
--- /dev/null
+++ b/modules/pubmatic/openwrap/metrics/stats/constants.go
@@ -0,0 +1,250 @@
+package stats
+
+const (
+	minPublishingInterval = 2  // In minutes
+	maxPublishingInterval = 5  // In minutes
+	minRetryDuration      = 35 // In seconds
+
+	minDialTimeout       = 2  // In seconds
+	minKeepAliveDuration = 15 // In seconds
+
+	contentType     = "Content-Type"
+	applicationJSON = "application/json;charset=utf-8"
+
+	minPublishingThreshold   = 1000
+	minResponseHeaderTimeout = 30
+	minChannelLength         = 1000
+	minPoolWorker            = 10
+	minPoolCapacity          = 1000
+)
+
+const (
+	// ADD NEW STATS ID HERE
+
+	//statsKeyOpenWrapServerPanic stats Key for Server Panic Hits
+	statsKeyOpenWrapServerPanic = iota
+
+	//statsKeyPublisherNoConsentRequests stats Key for Counting requests for Publisher with no GDPR consent request respective publisher
+	statsKeyPublisherNoConsentRequests
+
+	//statsKeyPublisherNoConsentImpressions stats Key for Counting number of impressions lost in request due to no  GDPR consent for respective publisher
+	statsKeyPublisherNoConsentImpressions
+
+	//statsKeyPublisherPrebidRequests stats Key to count Requests to Prebid Server for respective publisher
+	statsKeyPublisherPrebidRequests
+
+	//statsKeyNobidErrPrebidServerRequests stats Key to count  Prebid Server Requests with  No AdUnit for respective publisher
+	statsKeyNobidErrPrebidServerRequests
+
+	//statsKeyNobidErrPrebidServerResponse stats Key to count  requests with No bid from prebid server response for respective publisher
+	statsKeyNobidErrPrebidServerResponse
+
+	//statsKeyContentObjectPresent for tracking the usage of content object in requests
+	statsKeyContentObjectPresent
+
+	//statsKeyPublisherProfileRequests stats Key for Counting requests for a Profile Id for respective publisher
+	statsKeyPublisherProfileRequests
+
+	//statsKeyPublisherInvProfileRequests stats Key for Counting requests with Invalid Profile Id for respective publisher
+	statsKeyPublisherInvProfileRequests
+
+	//statsKeyPublisherInvProfileImpressions stats Key for Counting number of impressions lost in request with Invalid Profile Id for respective publisher
+	statsKeyPublisherInvProfileImpressions
+
+	//statsKeyPrebidTORequests stats Key to count no of requests in which prebid timeouts
+	statsKeyPrebidTORequests
+
+	//statsKeySsTORequests stats Key for Counting requests in which server side timeouts
+	statsKeySsTORequests
+
+	//statsKeyNoUIDSErrorRequest stats Key for Counting requests with uids cookie not present
+	statsKeyNoUIDSErrorRequest
+
+	//statsKeyVideoInterstitialImpressions stats Key for Counting video interstitial impressions for a publisher/profile
+	statsKeyVideoInterstitialImpressions
+
+	//statsKeyVideoImpDisabledViaConfig stats Key for Counting video interstitial impressions that are disabled via config for a publisher/profile
+	statsKeyVideoImpDisabledViaConfig
+
+	//statsKeyVideoImpDisabledViaConnType stats Key for Counting video interstitial impressions that are disabled because of connection type for a publisher/profile
+	statsKeyVideoImpDisabledViaConnType
+
+	//statsKeyPublisherPartnerRequests stats Key for counting Publisher Partner level Requests
+	statsKeyPublisherPartnerRequests
+
+	//statsKeyPublisherPartnerImpressions stats Key for counting Publisher Partner level Impressions
+	statsKeyPublisherPartnerImpressions
+
+	//statsKeyPublisherPartnerNoCookieRequests stats Key for counting requests without cookie at Publisher Partner level
+	statsKeyPublisherPartnerNoCookieRequests
+
+	//statsKeySlotunMappedErrorRequests stats Key for counting Unmapped Slot impressions  for respective Publisher Partner
+	statsKeySlotunMappedErrorRequests
+
+	//statsKeyMisConfErrorRequests stats Key for counting  missing configuration impressions for Publisher Partner
+	statsKeyMisConfErrorRequests
+
+	//statsKeyPartnerTimeoutErrorRequests stats Key for counting Partner Timeout Requests for Parnter
+	statsKeyPartnerTimeoutErrorRequests
+
+	//statsKeyUnknownPrebidErrorResponse stats Key for counting Unknown Error from Prebid Server for respective partner
+	statsKeyUnknownPrebidErrorResponse
+
+	//statsKeyNobidErrorRequests stats Key for counting No Bid cases from respective partner
+	statsKeyNobidErrorRequests
+
+	//statsKeyNobidderStatusErrorRequests stats Key for counting No Bidders Status present in Prebid  Server response
+	statsKeyNobidderStatusErrorRequests
+
+	//statsKeyLoggerErrorRequests stats Key for counting number of Wrapper logger failures for a given publisher,profile  and version
+	statsKeyLoggerErrorRequests
+
+	//statsKey24PublisherRequests stats key to count no of 2.4 requests for a publisher
+	statsKey24PublisherRequests
+
+	//statsKey25BadRequests stats key to count no of bad requests at 2.5 endpoint
+	statsKey25BadRequests
+
+	//statsKey25PublisherRequests stats key to count no of 2.5 requests for a publisher
+	statsKey25PublisherRequests
+
+	//statsKeyAMPBadRequests stats Key for counting number of AMP bad Requests
+	statsKeyAMPBadRequests
+
+	//statsKeyAMPPublisherRequests stats Key for counting number of AMP Request for a publisher
+	statsKeyAMPPublisherRequests
+
+	//statsKeyAMPCacheError stats Key for counting cache error for given pub and profile
+	statsKeyAMPCacheError
+
+	//statsKeyPublisherInvProfileAMPRequests stats Key for Counting AMP requests with Invalid Profile Id for respective publisher
+	statsKeyPublisherInvProfileAMPRequests
+
+	//statsKeyVideoBadRequests stats Key for counting number of Video Request
+	statsKeyVideoBadRequests
+
+	//statsKeyVideoPublisherRequests stats Key for counting number of Video Request for a publisher
+	statsKeyVideoPublisherRequests
+
+	//statsKeyVideoCacheError stats Key for counting cache error
+	statsKeyVideoCacheError
+
+	//statsKeyPublisherInvProfileVideoRequests stats Key for Counting Video requests with Invalid Profile Id for respective publisher
+	statsKeyPublisherInvProfileVideoRequests
+
+	//statsKeyInvalidCreatives stats Key for counting invalid creatives for Publisher Partner
+	statsKeyInvalidCreatives
+
+	//statsKeyPlatformPublisherPartnerRequests stats Key for counting Platform Publisher Partner level Requests
+	statsKeyPlatformPublisherPartnerRequests
+
+	//statsKeyPlatformPublisherPartnerResponses stats Key for counting Platform Publisher Partner level Responses
+	statsKeyPlatformPublisherPartnerResponses
+
+	//statsKeyPublisherResponseEncodingErrors stats Key to count errors during response encoding at Publisher level
+	statsKeyPublisherResponseEncodingErrors
+
+	//Bucketwise latency related Stats Keys for publisher partner level for response time
+
+	//statsKeyA2000 response time above 2000ms
+	statsKeyA2000
+	//statsKeyA1500 response time between 1500ms and 2000ms
+	statsKeyA1500
+	//statsKeyA1000 response time between 1000ms and 1500ms
+	statsKeyA1000
+	//statsKeyA900 response time between 900ms and 1000ms
+	statsKeyA900
+	//statsKeyA800 response time between 800ms and 900ms
+	statsKeyA800
+	//statsKeyA700 response time between 700ms and 800ms
+	statsKeyA700
+	//statsKeyA600 response time between 600ms and 700ms
+	statsKeyA600
+	//statsKeyA500 response time between 500ms and 600ms
+	statsKeyA500
+	//statsKeyA400 response time between 400ms and 500ms
+	statsKeyA400
+	//statsKeyA300 response time between 300ms and 400ms
+	statsKeyA300
+	//statsKeyA200 response time between 200ms and 300ms
+	statsKeyA200
+	//statsKeyA100 response time between 100ms and 200ms
+	statsKeyA100
+	//statsKeyA50 response time between 50ms and 100ms
+	statsKeyA50
+	//statsKeyL50 response time less than 50ms
+	statsKeyL50
+
+	//Bucketwise latency related Stats Keys for a publisher for pre-processing time
+
+	//statsKeyPrTimeAbv100 bucket for pre processing time above 100ms
+	statsKeyPrTimeAbv100
+	//statsKeyPrTimeAbv50 bucket for pre processing time bw 50ms anb 100ms
+	statsKeyPrTimeAbv50
+	//statsKeyPrTimeAbv10 bucket for pre processing time bw 10ms anb 50ms
+	statsKeyPrTimeAbv10
+	//statsKeyPrTimeAbv1 bucket for pre processing time bw 1ms anb 10ms
+	statsKeyPrTimeAbv1
+	//statsKeyPrTimeBlw1 bucket for pre processing time below 1ms
+	statsKeyPrTimeBlw1
+
+	//statsKeyBannerImpDisabledViaConfig stats Key for Counting banner impressions that are disabled via config for a publisher/profile
+	statsKeyBannerImpDisabledViaConfig
+
+	// ********************* CTV Stats *********************
+
+	//statsKeyCTVPrebidFailedImpression for counting number of CTV prebid side failed impressions
+	statsKeyCTVPrebidFailedImpression
+	//statsKeyCTVRequests for counting number of CTV  Requests
+	statsKeyCTVRequests
+	//statsKeyCTVBadRequests for counting number of CTV  Bad Requests
+	statsKeyCTVBadRequests
+	//statsKeyCTVPublisherRequests for counting number of CTV  Publisher Requests
+	statsKeyCTVPublisherRequests
+	//statsKeyCTVHTTPMethodRequests for counting number of CTV  Publisher GET/POST Requests
+	statsKeyCTVHTTPMethodRequests
+	//statsKeyCTVValidationDetail for tracking error with granularity
+	statsKeyCTVValidationErr
+	//statsKeyIncompleteAdPods for tracking incomplete AdPods because of any reason
+	statsKeyIncompleteAdPods
+	//statsKeyCTVReqImpstWithConfig for tracking requests that had config and were not overwritten by database config
+	statsKeyCTVReqImpstWithConfig
+	//statsKeyTotalAdPodImpression for tracking no of AdPod impressions
+	statsKeyTotalAdPodImpression
+	//statsKeyAdPodSecondsMissed for tracking no pf seconds that were missed because of our algos
+	statsKeyReqTotalAdPodImpression
+	//statsKeyReqAdPodSecondsMissed for tracking no pf seconds that were missed because of our algos
+	statsKeyAdPodSecondsMissed
+	//statsKeyReqImpDurationYield is for tracking the number on adpod impressions generated for give min and max request imp durations
+	statsKeyReqImpDurationYield
+	//statsKeyReqWithAdPodCount if for counting requests with AdPods
+	statsKeyReqWithAdPodCount
+	//statsKeyBidDuration for counting number of bids of video duration
+	statsKeyBidDuration
+
+	//statsKeyPBSAuctionRequests stats Key for counting PBS Auction endpoint Requests
+	statsKeyPBSAuctionRequests
+
+	//statsKeyInjectTrackerErrorCount stats key for counting error during injecting tracker in Creative
+	statsKeyInjectTrackerErrorCount
+
+	//statsBidResponsesByDealUsingPBS stats key for counting number of bids received which for given deal id, profile id, publisherid
+	statsBidResponsesByDealUsingPBS
+
+	//statsBidResponsesByDealUsingHB stats key for counting number of bids received which for given deal id, profile id, publisherid
+	statsBidResponsesByDealUsingHB
+
+	// statsPartnerTimeoutInPBS stats key for countiing number of timeouts occured for given publisher and profile
+	statsPartnerTimeoutInPBS
+
+	// This is to declare the array of stats, add new stats above this
+	maxNumOfStats
+	// NOTE - DON'T ADD NEW STATS KEY BELOW THIS. NEW STATS SHOULD BE ADDED ABOVE maxNumOfStats
+)
+
+// constant to defines status-code used while sending stats to server
+const (
+	statusSetupFail = iota
+	statusPublishSuccess
+	statusPublishFail
+)
diff --git a/modules/pubmatic/openwrap/metrics/stats/init.go b/modules/pubmatic/openwrap/metrics/stats/init.go
new file mode 100644
index 000000000..0cead3602
--- /dev/null
+++ b/modules/pubmatic/openwrap/metrics/stats/init.go
@@ -0,0 +1,293 @@
+package stats
+
+import (
+	"sync"
+)
+
+type statKeyName = string
+
+var (
+	statKeys   [maxNumOfStats]statKeyName
+	once       sync.Once
+	owStats    *StatsTCP
+	owStatsErr error
+)
+
+// stat represents a single stat-key along with its value
+type stat struct {
+	Key   string
+	Value int
+}
+
+// InitStatsClient initializes stats client
+func InitStatsClient(endpoint, defaultHost, actualHost, dcName string,
+	pubInterval, pubThreshold, retries, dialTimeout, keepAliveDuration,
+	maxIdleConnes, maxIdleConnesPerHost, respHeaderTimeout, maxChannelLength,
+	poolMaxWorkers, poolMaxCapacity int) (*StatsTCP, error) {
+
+	once.Do(func() {
+		initStatKeys(dcName+":"+defaultHost, dcName+":"+actualHost)
+		owStats, owStatsErr = initTCPStatsClient(endpoint, pubInterval, pubThreshold,
+			retries, dialTimeout, keepAliveDuration, maxIdleConnes, maxIdleConnesPerHost,
+			respHeaderTimeout, maxChannelLength, poolMaxWorkers, poolMaxCapacity)
+	})
+
+	return owStats, owStatsErr
+}
+
+// initStatKeys sets the key-name for all stats
+// defaultServerName will be "actualDCName:N:P"
+// actualServerName will be "actualDCName:actualNode:actualPod"
+func initStatKeys(defaultServerName, actualServerName string) {
+
+	//server level stats
+	statKeys[statsKeyOpenWrapServerPanic] = "hb:panic:" + actualServerName
+	//hb:panic:<dc:node:pod>
+
+	//publisher level stats
+	statKeys[statsKeyPublisherNoConsentRequests] = "hb:pubnocnsreq:%s:" + defaultServerName
+	//hb:pubnocnsreq:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyPublisherNoConsentImpressions] = "hb:pubnocnsimp:%s:" + defaultServerName
+	//hb:pubnocnsimp:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyPublisherPrebidRequests] = "hb:pubrq:%s:" + defaultServerName
+
+	// statKeys[statsKeyNobidErrPrebidServerRequests] = "hb:pubnbreq:%s:", SendThresh: criticalThreshold, SendTimeInterval: time.Minute * time.Duration(criticalInterval)}
+	statKeys[statsKeyNobidErrPrebidServerRequests] = "hb:pubnbreq:%s:" + defaultServerName
+	//hb:pubnbreq:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyNobidErrPrebidServerResponse] = "hb:pubnbres:%s:" + defaultServerName
+	//hb:pubnbres:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyContentObjectPresent] = "hb:cnt:%s:%s:" + defaultServerName
+	//hb:cnt:<app|site>:<pub>:<dc:node:pod>
+
+	//publisher and profile level stats
+	statKeys[statsKeyPublisherProfileRequests] = "hb:pprofrq:%s:%s:" + defaultServerName
+	//hb:pprofrq:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyPublisherInvProfileRequests] = "hb:pubinp:%s:%s:" + defaultServerName
+	//hb:pubinp:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyPublisherInvProfileImpressions] = "hb:pubinpimp:%s:%s:" + defaultServerName
+	//hb:pubinpimp:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyPrebidTORequests] = "hb:prebidto:%s:%s:" + defaultServerName
+	//hb:prebidto:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeySsTORequests] = "hb:ssto:%s:%s:" + defaultServerName
+	//hb:ssto:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyNoUIDSErrorRequest] = "hb:nouids:%s:%s:" + defaultServerName
+	//hb:nouids:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyVideoInterstitialImpressions] = "hb:ppvidinstlimps:%s:%s:" + defaultServerName
+	//hb:ppvidinstlimps:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyVideoImpDisabledViaConfig] = "hb:ppdisimpcfg:%s:%s:" + defaultServerName
+	//hb:ppdisimpcfg:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyVideoImpDisabledViaConnType] = "hb:ppdisimpct:%s:%s:" + defaultServerName
+	//hb:ppdisimpct:<pub>:<prof>:<dc:node:pod>
+
+	//publisher-partner level stats
+	statKeys[statsKeyPublisherPartnerRequests] = "hb:pprq:%s:%s:" + defaultServerName
+	//hb:pprq:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyPublisherPartnerImpressions] = "hb:ppimp:%s:%s:" + defaultServerName
+	//hb:ppimp:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyPublisherPartnerNoCookieRequests] = "hb:ppnc:%s:%s:" + defaultServerName
+	//hb:ppnc:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeySlotunMappedErrorRequests] = "hb:sler:%s:%s:" + defaultServerName
+	//hb:sler:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyMisConfErrorRequests] = "hb:cfer:%s:%s:" + defaultServerName
+	//hb:cfer:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyPartnerTimeoutErrorRequests] = "hb:toer:%s:%s:" + defaultServerName
+	//hb:toer:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyUnknownPrebidErrorResponse] = "hb:uner:%s:%s:" + defaultServerName
+	//hb:uner:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyNobidErrorRequests] = "hb:nber:%s:%s:" + defaultServerName
+	//hb:nber:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyNobidderStatusErrorRequests] = "hb:nbse:%s:%s:" + defaultServerName
+	//hb:nbse:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyLoggerErrorRequests] = "hb:wle:%s:%s:%s:" + defaultServerName
+	//hb:nber:<pub>:<prof>:<version>:<dc:node:pod>
+
+	statKeys[statsKey24PublisherRequests] = "hb:2.4:%s:pbrq:%s:" + defaultServerName
+	//hb:2.4:<disp/app>:pbrq:<pub>:<dc:node:pod>
+
+	statKeys[statsKey25BadRequests] = "hb:2.5:badreq:" + defaultServerName
+	//hb:2.5:badreq:<dc:node:pod>
+
+	statKeys[statsKey25PublisherRequests] = "hb:2.5:%s:pbrq:%s:" + defaultServerName
+	//hb:2.5:<disp/app>:pbrq:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyAMPBadRequests] = "hb:amp:badreq:" + defaultServerName
+	//hb:amp:badreq:<dc:node:pod>
+
+	statKeys[statsKeyAMPPublisherRequests] = "hb:amp:pbrq:%s:" + defaultServerName
+	//hb:amp:pbrq:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyAMPCacheError] = "hb:amp:ce:%s:%s:" + defaultServerName
+	//hb:amp:ce:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyPublisherInvProfileAMPRequests] = "hb:amp:pubinp:%s:%s:" + defaultServerName
+	//hb:amp:pubinp:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyVideoBadRequests] = "hb:vid:badreq:" + defaultServerName
+	//hb:vid:badreq:<dc:node:pod>
+
+	statKeys[statsKeyVideoPublisherRequests] = "hb:vid:pbrq:%s:" + defaultServerName
+	//hb:vid:pbrq:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyVideoCacheError] = "hb:vid:ce:%s:%s:" + defaultServerName
+	//hb:vid:ce:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyPublisherInvProfileVideoRequests] = "hb:vid:pubinp:%s:%s:" + defaultServerName
+	//hb:vid:pubinp:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyInvalidCreatives] = "hb:invcr:%s:%s:" + defaultServerName
+	//hb:invcr:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyPlatformPublisherPartnerRequests] = "hb:pppreq:%s:%s:%s:" + defaultServerName
+	//hb:pppreq:<platform>:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyPlatformPublisherPartnerResponses] = "hb:pppres:%s:%s:%s:" + defaultServerName
+	//hb:pppres:<platform>:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyPublisherResponseEncodingErrors] = "hb:encerr:%s:" + defaultServerName
+	//hb:vid:encerr:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyA2000] = "hb:latabv_2000:%s:%s:" + defaultServerName
+	//hb:latabv_2000:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyA1500] = "hb:latabv_1500:%s:%s:" + defaultServerName
+	//hb:latabv_1500:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyA1000] = "hb:latabv_1000:%s:%s:" + defaultServerName
+	//hb:latabv_1000:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyA900] = "hb:latabv_900:%s:%s:" + defaultServerName
+	//hb:latabv_900:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyA800] = "hb:latabv_800:%s:%s:" + defaultServerName
+	//hb:latabv_800:<pub>:<partner>:<dc:node:pod>
+
+	// TBD : @viral key-change ???
+	// statKeys[statsKeyA800] = statsclient.Stats{Fmt: "hb:latabv_800:%s:%s:%s", SendThresh: standardThreshold, SendTimeInterval: time.Minute * time.Duration(standardInterval)}
+	//hb:latabv_800:<pub>:<partner>:<dc>
+	// statKeys[statsKeyA700] = statsclient.Stats{Fmt: "hb:latabv_800:%s:%s:%s", SendThresh: standardThreshold, SendTimeInterval: time.Minute * time.Duration(standardInterval)}
+	//hb:latabv_700:<pub>:<partner>:<dc>
+	statKeys[statsKeyA700] = "hb:latabv_700:%s:%s:" + defaultServerName
+	//hb:latabv_700:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyA600] = "hb:latabv_600:%s:%s:" + defaultServerName
+	//hb:latabv_600:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyA500] = "hb:latabv_500:%s:%s:" + defaultServerName
+	//hb:latabv_500:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyA400] = "hb:latabv_400:%s:%s:" + defaultServerName
+	//hb:latabv_400:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyA300] = "hb:latabv_300:%s:%s:" + defaultServerName
+	//hb:latabv_300:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyA200] = "hb:latabv_200:%s:%s:" + defaultServerName
+	//hb:latabv_200:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyA100] = "hb:latabv_100:%s:%s:" + defaultServerName
+	//hb:latabv_100:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyA50] = "hb:latabv_50:%s:%s:" + defaultServerName
+	//hb:latabv_50:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyL50] = "hb:latblw_50:%s:%s:" + defaultServerName
+	//hb:latblw_50:<pub>:<partner>:<dc:node:pod>
+
+	statKeys[statsKeyPrTimeAbv100] = "hb:ptabv_100:%s:" + defaultServerName
+	//hb:ptabv_100:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyPrTimeAbv50] = "hb:ptabv_50:%s:" + defaultServerName
+	//hb:ptabv_50:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyPrTimeAbv10] = "hb:ptabv_10:%s:" + defaultServerName
+	//hb:ptabv_10:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyPrTimeAbv1] = "hb:ptabv_1:%s:" + defaultServerName
+	//hb:ptabv_1:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyPrTimeBlw1] = "hb:ptblw_1:%s:" + defaultServerName
+	//hb:ptblw_1:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyBannerImpDisabledViaConfig] = "hb:bnrdiscfg:%s:%s:" + defaultServerName
+	//hb:bnrdiscfg:<pub>:<prof>:<dc:node:pod>
+
+	//CTV Specific Keys
+
+	statKeys[statsKeyCTVPrebidFailedImpression] = "hb:lfv:badimp:%v:%v:%v:" + defaultServerName
+	//hb:lfv:badimp:<errorcode>:<pub>:<profile>:<dc:node:pod>
+
+	statKeys[statsKeyCTVRequests] = "hb:lfv:%v:%v:req:" + defaultServerName
+	//hb:lfv:<ortb/vast/json>:<platform>:req:<dc:node:pod>
+
+	statKeys[statsKeyCTVBadRequests] = "hb:lfv:%v:badreq:%d:" + defaultServerName
+	//hb:lfv:<ortb/vast/json>:badreq:<badreq-code>:<dc:node:pod>
+
+	statKeys[statsKeyCTVPublisherRequests] = "hb:lfv:%v:%v:pbrq:%v:" + defaultServerName
+	//hb:lfv:<ortb/vast/json>:<platform>:pbrq:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyCTVHTTPMethodRequests] = "hb:lfv:%v:mtd:%v:%v:" + defaultServerName
+	//hb:lfv:<ortb/vast/json>:mtd:<pub>:<get/post>:<dc:node:pod>
+
+	statKeys[statsKeyCTVValidationErr] = "hb:lfv:ivr:%d:%s:" + defaultServerName
+	//hb:lfv:ivr:<error_code>:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyIncompleteAdPods] = "hb:lfv:nip:%s:%s:" + defaultServerName
+	//hb:lfv:nip:<reason>:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyCTVReqImpstWithConfig] = "hb:lfv:rwc:%s:%s:" + defaultServerName
+	//hb:lfv:rwc:<req:db>:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyTotalAdPodImpression] = "hb:lfv:tpi:%s:%s:" + defaultServerName
+	//hb:lfv:tpi:<imp-range>:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyReqTotalAdPodImpression] = "hb:lfv:rtpi:%s:" + defaultServerName
+	//hb:lfv:rtpi:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyAdPodSecondsMissed] = "hb:lfv:sm:%s:" + defaultServerName
+	//hb:lfv:sm:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyReqImpDurationYield] = "hb:lfv:impy:%d:%d:%s:" + defaultServerName
+	//hb:lfv:impy:<max_duration>:<min_duration>:<pub>:<dc:node:pod>
+
+	statKeys[statsKeyReqWithAdPodCount] = "hb:lfv:rwap:%s:%s:" + defaultServerName
+	//hb:lfv:rwap:<pub>:<prof>:<dc:node:pod>
+
+	statKeys[statsKeyBidDuration] = "hb:lfv:dur:%d:%s:%s:" + defaultServerName
+	//hb:lfv:dur:<duration>:<pub>:<prof>:<dc:node:pod>:
+
+	statKeys[statsKeyPBSAuctionRequests] = "hb:pbs:auc:" + defaultServerName
+	//hb:pbs:auc:<dc:node:pod> - no of PBS auction endpoint requests
+
+	statKeys[statsKeyInjectTrackerErrorCount] = "hb:mistrack:%s:%s:%s:" + defaultServerName
+	//hb:mistrack:<adformat>:<pubid>:<partner>:<dc:node:pod> - Error during Injecting Tracker
+
+	statKeys[statsBidResponsesByDealUsingPBS] = "hb:pbs:dbc:%s:%s:%s:%s:" + defaultServerName
+	//hb:pbs:dbc:<pub>:<profile>:<aliasbidder>:<dealid>:<dc:node:pod> - PubMatic-OpenWrap to count number of responses received from aliasbidder per publisher profile
+
+	statKeys[statsBidResponsesByDealUsingHB] = "hb:dbc:%s:%s:%s:%s:" + defaultServerName
+	//hb:dbc:<pub>:<profile>:<aliasbidder>:<dealid>:<dc:node:pod> - header-bidding to count number of responses received from aliasbidder per publisher profile
+
+	statKeys[statsPartnerTimeoutInPBS] = "hb:pbs:pto:%s:%s:%s:" + defaultServerName
+	//hb:pbs:pto:<pub>:<profile>:<aliasbidder>:<dc:node:pod> - count timeout by aliasbidder per publisher profile
+}
diff --git a/modules/pubmatic/openwrap/metrics/stats/init_test.go b/modules/pubmatic/openwrap/metrics/stats/init_test.go
new file mode 100644
index 000000000..49a023f89
--- /dev/null
+++ b/modules/pubmatic/openwrap/metrics/stats/init_test.go
@@ -0,0 +1,184 @@
+package stats
+
+import (
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+)
+
+func TestInitStatKeys(t *testing.T) {
+
+	type args struct {
+		defaultServerName, actualServerName string
+	}
+
+	type want struct {
+		testKeys [maxNumOfStats]string
+	}
+
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "test_init_stat_keys",
+			args: args{
+				defaultServerName: "sv3:N:P",
+				actualServerName:  "sv3:node123.sv3:ssheaderbidding",
+			},
+			want: want{
+				testKeys: [maxNumOfStats]string{
+					"hb:panic:sv3:node123.sv3:ssheaderbidding",
+					"hb:pubnocnsreq:%s:sv3:N:P",
+					"hb:pubnocnsimp:%s:sv3:N:P",
+					"hb:pubrq:%s:sv3:N:P",
+					"hb:pubnbreq:%s:sv3:N:P",
+					"hb:pubnbres:%s:sv3:N:P",
+					"hb:cnt:%s:%s:sv3:N:P",
+					"hb:pprofrq:%s:%s:sv3:N:P",
+					"hb:pubinp:%s:%s:sv3:N:P",
+					"hb:pubinpimp:%s:%s:sv3:N:P",
+					"hb:prebidto:%s:%s:sv3:N:P",
+					"hb:ssto:%s:%s:sv3:N:P",
+					"hb:nouids:%s:%s:sv3:N:P",
+					"hb:ppvidinstlimps:%s:%s:sv3:N:P",
+					"hb:ppdisimpcfg:%s:%s:sv3:N:P",
+					"hb:ppdisimpct:%s:%s:sv3:N:P",
+					"hb:pprq:%s:%s:sv3:N:P",
+					"hb:ppimp:%s:%s:sv3:N:P",
+					"hb:ppnc:%s:%s:sv3:N:P",
+					"hb:sler:%s:%s:sv3:N:P",
+					"hb:cfer:%s:%s:sv3:N:P",
+					"hb:toer:%s:%s:sv3:N:P",
+					"hb:uner:%s:%s:sv3:N:P",
+					"hb:nber:%s:%s:sv3:N:P",
+					"hb:nbse:%s:%s:sv3:N:P",
+					"hb:wle:%s:%s:%s:sv3:N:P",
+					"hb:2.4:%s:pbrq:%s:sv3:N:P",
+					"hb:2.5:badreq:sv3:N:P",
+					"hb:2.5:%s:pbrq:%s:sv3:N:P",
+					"hb:amp:badreq:sv3:N:P",
+					"hb:amp:pbrq:%s:sv3:N:P",
+					"hb:amp:ce:%s:%s:sv3:N:P",
+					"hb:amp:pubinp:%s:%s:sv3:N:P",
+					"hb:vid:badreq:sv3:N:P",
+					"hb:vid:pbrq:%s:sv3:N:P",
+					"hb:vid:ce:%s:%s:sv3:N:P",
+					"hb:vid:pubinp:%s:%s:sv3:N:P",
+					"hb:invcr:%s:%s:sv3:N:P",
+					"hb:pppreq:%s:%s:%s:sv3:N:P",
+					"hb:pppres:%s:%s:%s:sv3:N:P",
+					"hb:encerr:%s:sv3:N:P",
+					"hb:latabv_2000:%s:%s:sv3:N:P",
+					"hb:latabv_1500:%s:%s:sv3:N:P",
+					"hb:latabv_1000:%s:%s:sv3:N:P",
+					"hb:latabv_900:%s:%s:sv3:N:P",
+					"hb:latabv_800:%s:%s:sv3:N:P",
+					"hb:latabv_700:%s:%s:sv3:N:P",
+					"hb:latabv_600:%s:%s:sv3:N:P",
+					"hb:latabv_500:%s:%s:sv3:N:P",
+					"hb:latabv_400:%s:%s:sv3:N:P",
+					"hb:latabv_300:%s:%s:sv3:N:P",
+					"hb:latabv_200:%s:%s:sv3:N:P",
+					"hb:latabv_100:%s:%s:sv3:N:P",
+					"hb:latabv_50:%s:%s:sv3:N:P",
+					"hb:latblw_50:%s:%s:sv3:N:P",
+					"hb:ptabv_100:%s:sv3:N:P",
+					"hb:ptabv_50:%s:sv3:N:P",
+					"hb:ptabv_10:%s:sv3:N:P",
+					"hb:ptabv_1:%s:sv3:N:P",
+					"hb:ptblw_1:%s:sv3:N:P",
+					"hb:bnrdiscfg:%s:%s:sv3:N:P",
+					"hb:lfv:badimp:%v:%v:%v:sv3:N:P",
+					"hb:lfv:%v:%v:req:sv3:N:P",
+					"hb:lfv:%v:badreq:%d:sv3:N:P",
+					"hb:lfv:%v:%v:pbrq:%v:sv3:N:P",
+					"hb:lfv:%v:mtd:%v:%v:sv3:N:P",
+					"hb:lfv:ivr:%d:%s:sv3:N:P",
+					"hb:lfv:nip:%s:%s:sv3:N:P",
+					"hb:lfv:rwc:%s:%s:sv3:N:P",
+					"hb:lfv:tpi:%s:%s:sv3:N:P",
+					"hb:lfv:rtpi:%s:sv3:N:P",
+					"hb:lfv:sm:%s:sv3:N:P",
+					"hb:lfv:impy:%d:%d:%s:sv3:N:P",
+					"hb:lfv:rwap:%s:%s:sv3:N:P",
+					"hb:lfv:dur:%d:%s:%s:sv3:N:P",
+					"hb:pbs:auc:sv3:N:P",
+					"hb:mistrack:%s:%s:%s:sv3:N:P",
+					"hb:pbs:dbc:%s:%s:%s:%s:sv3:N:P",
+					"hb:dbc:%s:%s:%s:%s:sv3:N:P",
+					"hb:pbs:pto:%s:%s:%s:sv3:N:P",
+				},
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			initStatKeys(tt.args.defaultServerName, tt.args.actualServerName)
+			assert.Equal(t, statKeys, tt.want.testKeys)
+		})
+	}
+}
+
+func TestInitStat(t *testing.T) {
+
+	type args struct {
+		endpoint, defaultHost, actualHost, dcName string
+		pubInterval, pubThreshold, retries, dialTimeout, keepAliveDuration,
+		maxIdleConnes, maxIdleConnesPerHost, respHeaderTimeout, maxChannelLength,
+		poolMaxWorkers, poolMaxCapacity int
+	}
+
+	type want struct {
+		client *StatsTCP
+		err    error
+	}
+
+	tests := []struct {
+		name  string
+		args  args
+		want  want
+		setup func() want
+	}{
+		{
+			name: "singleton_instance",
+			args: args{
+				endpoint:             "10.10.10.10",
+				defaultHost:          "N:P",
+				actualHost:           "node1.sv3:ssheader",
+				dcName:               "sv3",
+				pubInterval:          10,
+				pubThreshold:         10,
+				retries:              3,
+				dialTimeout:          10,
+				keepAliveDuration:    10,
+				maxIdleConnes:        10,
+				maxIdleConnesPerHost: 10,
+				respHeaderTimeout:    10,
+				maxChannelLength:     10,
+				poolMaxWorkers:       10,
+				poolMaxCapacity:      10,
+			},
+			setup: func() want {
+				st, err := InitStatsClient("10.10.10.10/stats", "N:P", "node1.sv3:ssheader", "sv3", 10, 10, 3, 10, 10, 10, 10, 10, 10, 10, 10)
+				return want{client: st, err: err}
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			tt.want = tt.setup()
+
+			InitStatsClient(tt.args.endpoint, tt.args.defaultHost, tt.args.actualHost, tt.args.dcName,
+				tt.args.pubInterval, tt.args.pubThreshold, tt.args.retries, tt.args.dialTimeout, tt.args.keepAliveDuration,
+				tt.args.maxIdleConnes, tt.args.maxIdleConnesPerHost, tt.args.respHeaderTimeout,
+				tt.args.maxChannelLength, tt.args.poolMaxWorkers, tt.args.poolMaxCapacity)
+
+			assert.Equal(t, tt.want.client, owStats)
+			assert.Equal(t, tt.want.err, owStatsErr)
+		})
+	}
+}
diff --git a/modules/pubmatic/openwrap/metrics/stats/mock/mock.go b/modules/pubmatic/openwrap/metrics/stats/mock/mock.go
new file mode 100644
index 000000000..2fbbe2dde
--- /dev/null
+++ b/modules/pubmatic/openwrap/metrics/stats/mock/mock.go
@@ -0,0 +1,86 @@
+// Code generated by MockGen. DO NOT EDIT.
+// Source: github.com/PubMatic-OpenWrap/prebid-server/modules/pubmatic/openwrap/metrics/stats (interfaces: HttpClient,WorkerPool)
+
+// Package mock_stats is a generated GoMock package.
+package mock
+
+import (
+	gomock "github.com/golang/mock/gomock"
+	http "net/http"
+	reflect "reflect"
+)
+
+// MockHttpClient is a mock of HttpClient interface
+type MockHttpClient struct {
+	ctrl     *gomock.Controller
+	recorder *MockHttpClientMockRecorder
+}
+
+// MockHttpClientMockRecorder is the mock recorder for MockHttpClient
+type MockHttpClientMockRecorder struct {
+	mock *MockHttpClient
+}
+
+// NewMockHttpClient creates a new mock instance
+func NewMockHttpClient(ctrl *gomock.Controller) *MockHttpClient {
+	mock := &MockHttpClient{ctrl: ctrl}
+	mock.recorder = &MockHttpClientMockRecorder{mock}
+	return mock
+}
+
+// EXPECT returns an object that allows the caller to indicate expected use
+func (m *MockHttpClient) EXPECT() *MockHttpClientMockRecorder {
+	return m.recorder
+}
+
+// Do mocks base method
+func (m *MockHttpClient) Do(arg0 *http.Request) (*http.Response, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "Do", arg0)
+	ret0, _ := ret[0].(*http.Response)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// Do indicates an expected call of Do
+func (mr *MockHttpClientMockRecorder) Do(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockHttpClient)(nil).Do), arg0)
+}
+
+// MockWorkerPool is a mock of WorkerPool interface
+type MockWorkerPool struct {
+	ctrl     *gomock.Controller
+	recorder *MockWorkerPoolMockRecorder
+}
+
+// MockWorkerPoolMockRecorder is the mock recorder for MockWorkerPool
+type MockWorkerPoolMockRecorder struct {
+	mock *MockWorkerPool
+}
+
+// NewMockWorkerPool creates a new mock instance
+func NewMockWorkerPool(ctrl *gomock.Controller) *MockWorkerPool {
+	mock := &MockWorkerPool{ctrl: ctrl}
+	mock.recorder = &MockWorkerPoolMockRecorder{mock}
+	return mock
+}
+
+// EXPECT returns an object that allows the caller to indicate expected use
+func (m *MockWorkerPool) EXPECT() *MockWorkerPoolMockRecorder {
+	return m.recorder
+}
+
+// TrySubmit mocks base method
+func (m *MockWorkerPool) TrySubmit(arg0 func()) bool {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "TrySubmit", arg0)
+	ret0, _ := ret[0].(bool)
+	return ret0
+}
+
+// TrySubmit indicates an expected call of TrySubmit
+func (mr *MockWorkerPoolMockRecorder) TrySubmit(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TrySubmit", reflect.TypeOf((*MockWorkerPool)(nil).TrySubmit), arg0)
+}
diff --git a/modules/pubmatic/openwrap/metrics/stats/tcp_stats.go b/modules/pubmatic/openwrap/metrics/stats/tcp_stats.go
new file mode 100644
index 000000000..b2372fa95
--- /dev/null
+++ b/modules/pubmatic/openwrap/metrics/stats/tcp_stats.go
@@ -0,0 +1,358 @@
+package stats
+
+import (
+	"fmt"
+
+	"github.com/golang/glog"
+)
+
+type StatsTCP struct {
+	statsClient *Client
+}
+
+func initTCPStatsClient(endpoint string,
+	pubInterval, pubThreshold, retries, dialTimeout, keepAliveDur, maxIdleConn,
+	maxIdleConnPerHost, respHeaderTimeout, maxChannelLength, poolMaxWorkers, poolMaxCapacity int) (*StatsTCP, error) {
+
+	cfg := config{
+		Endpoint:              endpoint,
+		PublishingInterval:    pubInterval,
+		PublishingThreshold:   pubThreshold,
+		Retries:               retries,
+		DialTimeout:           dialTimeout,
+		KeepAliveDuration:     keepAliveDur,
+		MaxIdleConns:          maxIdleConn,
+		MaxIdleConnsPerHost:   maxIdleConnPerHost,
+		ResponseHeaderTimeout: respHeaderTimeout,
+		MaxChannelLength:      maxChannelLength,
+		PoolMaxWorkers:        poolMaxWorkers,
+		PoolMaxCapacity:       poolMaxCapacity,
+	}
+
+	sc, err := NewClient(&cfg)
+	if err != nil {
+		glog.Errorf("[stats_fail] Failed to initialize stats client : %v", err.Error())
+		return nil, err
+	}
+
+	return &StatsTCP{statsClient: sc}, nil
+}
+
+func (st *StatsTCP) RecordOpenWrapServerPanicStats() {
+	st.statsClient.PublishStat(statKeys[statsKeyOpenWrapServerPanic], 1)
+}
+
+func (st *StatsTCP) RecordPublisherPartnerStats(publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherPartnerRequests], publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordPublisherPartnerImpStats(publisher, partner string, impCount int) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherPartnerImpressions], publisher, partner), impCount)
+}
+
+func (st *StatsTCP) RecordPublisherPartnerNoCookieStats(publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherPartnerNoCookieRequests], publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordPartnerTimeoutErrorStats(publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPartnerTimeoutErrorRequests], publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordNobiderStatusErrorStats(publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyNobidderStatusErrorRequests], publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordNobidErrorStats(publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyNobidErrorRequests], publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordUnkownPrebidErrorStats(publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyUnknownPrebidErrorResponse], publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordSlotNotMappedErrorStats(publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeySlotunMappedErrorRequests], publisher, partner), 1)
+
+}
+
+func (st *StatsTCP) RecordMisConfigurationErrorStats(publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyMisConfErrorRequests], publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordPublisherProfileRequests(publisher, profileID string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherProfileRequests], publisher, profileID), 1)
+}
+
+func (st *StatsTCP) RecordPublisherInvalidProfileRequests(endpoint, publisher, profileID string) {
+	switch endpoint {
+	case "video":
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherInvProfileVideoRequests], publisher, profileID), 1)
+	case "amp":
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherInvProfileAMPRequests], publisher, profileID), 1)
+	default:
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherInvProfileRequests], publisher, profileID), 1)
+	}
+}
+
+func (st *StatsTCP) RecordPublisherInvalidProfileImpressions(publisher, profileID string, impCount int) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherInvProfileImpressions], publisher, profileID), impCount)
+	//TODO @viral ;previously by 1 but now by impCount
+}
+
+func (st *StatsTCP) RecordPublisherNoConsentRequests(publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherNoConsentRequests], publisher), 1)
+}
+
+func (st *StatsTCP) RecordPublisherNoConsentImpressions(publisher string, impCount int) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherNoConsentImpressions], publisher), impCount)
+}
+
+func (st *StatsTCP) RecordPublisherRequestStats(publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherPrebidRequests], publisher), 1)
+}
+
+func (st *StatsTCP) RecordNobidErrPrebidServerRequests(publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyNobidErrPrebidServerRequests], publisher), 1)
+}
+
+func (st *StatsTCP) RecordNobidErrPrebidServerResponse(publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyNobidErrPrebidServerResponse], publisher), 1)
+}
+
+func (st *StatsTCP) RecordInvalidCreativeStats(publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyInvalidCreatives], publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordPlatformPublisherPartnerReqStats(platform, publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPlatformPublisherPartnerRequests], platform, publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordPlatformPublisherPartnerResponseStats(platform, publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPlatformPublisherPartnerResponses], platform, publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordPublisherResponseEncodingErrorStats(publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPublisherResponseEncodingErrors], publisher), 1)
+}
+
+func (st *StatsTCP) RecordPartnerResponseTimeStats(publisher, partner string, responseTime int) {
+	statKeyIndex := getStatsKeyIndexForResponseTime(responseTime)
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statKeyIndex], publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordPublisherResponseTimeStats(publisher string, responseTime int) {
+	statKeyIndex := getStatsKeyIndexForResponseTime(responseTime)
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statKeyIndex], publisher, "overall"), 1)
+}
+
+func (st *StatsTCP) RecordPublisherWrapperLoggerFailure(publisher, profileID, versionID string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyLoggerErrorRequests], publisher, profileID, versionID), 1)
+}
+
+func (st *StatsTCP) RecordPrebidTimeoutRequests(publisher, profileID string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyPrebidTORequests], publisher, profileID), 1)
+}
+
+func (st *StatsTCP) RecordSSTimeoutRequests(publisher, profileID string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeySsTORequests], publisher, profileID), 1)
+}
+
+func (st *StatsTCP) RecordUidsCookieNotPresentErrorStats(publisher, profileID string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyNoUIDSErrorRequest], publisher, profileID), 1)
+}
+
+func (st *StatsTCP) RecordVideoInstlImpsStats(publisher, profileID string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyVideoInterstitialImpressions], publisher, profileID), 1)
+}
+
+func (st *StatsTCP) RecordImpDisabledViaConfigStats(impType, publisher, profileID string) {
+	switch impType {
+	case "video":
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyVideoImpDisabledViaConfig], publisher, profileID), 1)
+	case "banner":
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyBannerImpDisabledViaConfig], publisher, profileID), 1)
+	}
+}
+
+func (st *StatsTCP) RecordVideoImpDisabledViaConnTypeStats(publisher, profileID string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyVideoImpDisabledViaConnType], publisher, profileID), 1)
+}
+
+func (st *StatsTCP) RecordPreProcessingTimeStats(publisher string, processingTime int) {
+	statKeyIndex := 0
+	switch {
+	case processingTime >= 100:
+		statKeyIndex = statsKeyPrTimeAbv100
+	case processingTime >= 50:
+		statKeyIndex = statsKeyPrTimeAbv50
+	case processingTime >= 10:
+		statKeyIndex = statsKeyPrTimeAbv10
+	case processingTime >= 1:
+		statKeyIndex = statsKeyPrTimeAbv1
+	default: // below 1ms
+		statKeyIndex = statsKeyPrTimeBlw1
+	}
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statKeyIndex], publisher), 1)
+}
+
+func (st *StatsTCP) RecordStatsKeyCTVPrebidFailedImpression(errorcode int, publisher string, profile string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyCTVPrebidFailedImpression], errorcode, publisher, profile), 1)
+}
+
+func (st *StatsTCP) RecordCTVRequests(endpoint string, platform string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyCTVRequests], endpoint, platform), 1)
+}
+
+func (st *StatsTCP) RecordBadRequests(endpoint string, errorCode int) {
+	switch endpoint {
+	case "amp":
+		st.statsClient.PublishStat(statKeys[statsKeyAMPBadRequests], 1)
+	case "video":
+		st.statsClient.PublishStat(statKeys[statsKeyVideoBadRequests], 1)
+	case "v25":
+		st.statsClient.PublishStat(statKeys[statsKey25BadRequests], 1)
+	case "vast", "ortb", "json", "openwrap":
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyCTVBadRequests], endpoint, errorCode), 1)
+	}
+}
+
+func (st *StatsTCP) RecordCTVHTTPMethodRequests(endpoint string, publisher string, method string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyCTVHTTPMethodRequests], endpoint, publisher, method), 1)
+}
+
+func (st *StatsTCP) RecordCTVInvalidReasonCount(errorCode int, publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyCTVValidationErr], errorCode, publisher), 1)
+}
+
+func (st *StatsTCP) RecordCTVIncompleteAdPodsCount(impCount int, reason string, publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyIncompleteAdPods], reason, publisher), 1)
+}
+
+func (st *StatsTCP) RecordCTVReqImpsWithDbConfigCount(publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyCTVReqImpstWithConfig], "db", publisher), 1)
+}
+
+func (st *StatsTCP) RecordCTVReqImpsWithReqConfigCount(publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyCTVReqImpstWithConfig], "req", publisher), 1)
+}
+
+func (st *StatsTCP) RecordAdPodGeneratedImpressionsCount(impCount int, publisher string) {
+	var impRange string
+	if impCount <= 3 {
+		impRange = "1-3"
+	} else if impCount <= 6 {
+		impRange = "4-6"
+	} else if impCount <= 9 {
+		impRange = "7-9"
+	} else {
+		impRange = "9+"
+	}
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyTotalAdPodImpression], impRange, publisher), 1)
+}
+
+func (st *StatsTCP) RecordRequestAdPodGeneratedImpressionsCount(impCount int, publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyReqTotalAdPodImpression], publisher), impCount)
+}
+
+func (st *StatsTCP) RecordAdPodSecondsMissedCount(seconds int, publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyAdPodSecondsMissed], publisher), seconds)
+}
+
+func (st *StatsTCP) RecordReqImpsWithAppContentCount(publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyContentObjectPresent], "app", publisher), 1)
+}
+
+func (st *StatsTCP) RecordReqImpsWithSiteContentCount(publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyContentObjectPresent], "site", publisher), 1)
+}
+
+func (st *StatsTCP) RecordAdPodImpressionYield(maxDuration int, minDuration int, publisher string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyReqImpDurationYield], maxDuration, minDuration, publisher), 1)
+}
+
+func (st *StatsTCP) RecordCTVReqCountWithAdPod(publisherID, profileID string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyReqWithAdPodCount], publisherID, profileID), 1)
+}
+
+func (st *StatsTCP) RecordCTVKeyBidDuration(duration int, publisherID, profileID string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyBidDuration], duration, publisherID, profileID), 1)
+}
+
+func (st *StatsTCP) RecordPBSAuctionRequestsStats() {
+	st.statsClient.PublishStat(statKeys[statsKeyPBSAuctionRequests], 1)
+}
+
+func (st *StatsTCP) RecordInjectTrackerErrorCount(adformat, publisher, partner string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyInjectTrackerErrorCount], adformat, publisher, partner), 1)
+}
+
+func (st *StatsTCP) RecordBidResponseByDealCountInPBS(publisher, profile, aliasBidder, dealId string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsBidResponsesByDealUsingPBS], publisher, profile, aliasBidder, dealId), 1)
+}
+
+func (st *StatsTCP) RecordBidResponseByDealCountInHB(publisher, profile, aliasBidder, dealId string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsBidResponsesByDealUsingHB], publisher, profile, aliasBidder, dealId), 1)
+}
+
+func (st *StatsTCP) RecordPartnerTimeoutInPBS(publisher, profile, aliasBidder string) {
+	st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsPartnerTimeoutInPBS], publisher, profile, aliasBidder), 1)
+}
+
+func (st *StatsTCP) RecordPublisherRequests(endpoint, publisher, platform string) {
+
+	switch endpoint {
+	case "amp":
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyAMPPublisherRequests], publisher), 1)
+	case "video":
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyVideoPublisherRequests], publisher), 1)
+	case "v25":
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKey25PublisherRequests], platform, publisher), 1)
+	case "vast", "ortb", "json":
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyCTVPublisherRequests], endpoint, platform, publisher), 1)
+	}
+}
+
+func (st *StatsTCP) RecordCacheErrorRequests(endpoint, publisher, profileID string) {
+	switch endpoint {
+	case "amp":
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyAMPCacheError], publisher, profileID), 1)
+	case "video":
+		st.statsClient.PublishStat(fmt.Sprintf(statKeys[statsKeyVideoCacheError], publisher, profileID), 1)
+	}
+}
+
+// getStatsKeyIndexForResponseTime returns respective stats key for a given responsetime
+func getStatsKeyIndexForResponseTime(responseTime int) int {
+	statKey := 0
+	switch {
+	case responseTime >= 2000:
+		statKey = statsKeyA2000
+	case responseTime >= 1500:
+		statKey = statsKeyA1500
+	case responseTime >= 1000:
+		statKey = statsKeyA1000
+	case responseTime >= 900:
+		statKey = statsKeyA900
+	case responseTime >= 800:
+		statKey = statsKeyA800
+	case responseTime >= 700:
+		statKey = statsKeyA700
+	case responseTime >= 600:
+		statKey = statsKeyA600
+	case responseTime >= 500:
+		statKey = statsKeyA500
+	case responseTime >= 400:
+		statKey = statsKeyA400
+	case responseTime >= 300:
+		statKey = statsKeyA300
+	case responseTime >= 200:
+		statKey = statsKeyA200
+	case responseTime >= 100:
+		statKey = statsKeyA100
+	case responseTime >= 50:
+		statKey = statsKeyA50
+	default: // below 50 ms
+		statKey = statsKeyL50
+	}
+	return statKey
+}
diff --git a/modules/pubmatic/openwrap/metrics/stats/tcp_stats_test.go b/modules/pubmatic/openwrap/metrics/stats/tcp_stats_test.go
new file mode 100644
index 000000000..71f685d4d
--- /dev/null
+++ b/modules/pubmatic/openwrap/metrics/stats/tcp_stats_test.go
@@ -0,0 +1,1290 @@
+package stats
+
+import (
+	"fmt"
+	"net"
+	"net/http"
+	"testing"
+	"time"
+
+	"github.com/stretchr/testify/assert"
+)
+
+func TestInitTCPStatsClient(t *testing.T) {
+
+	type args struct {
+		endpoint string
+		pubInterval, pubThreshold, retries, dialTimeout,
+		keepAliveDur, maxIdleConn, maxIdleConnPerHost, respHeaderTimeout,
+		maxChannelLength, poolMaxWorkers, poolMaxCapacity int
+	}
+
+	type want struct {
+		client *StatsTCP
+		err    error
+	}
+
+	tests := []struct {
+		name string
+		args args
+		want want
+	}{
+		{
+			name: "returns_error",
+			args: args{
+				endpoint:           "",
+				pubInterval:        10,
+				pubThreshold:       10,
+				retries:            3,
+				dialTimeout:        10,
+				keepAliveDur:       10,
+				maxIdleConn:        10,
+				maxIdleConnPerHost: 10,
+			},
+			want: want{
+				client: nil,
+				err:    fmt.Errorf("invalid stats client configurations:stat server endpoint cannot be empty"),
+			},
+		},
+		{
+			name: "returns_valid_client",
+			args: args{
+				endpoint:           "http://10.10.10.10:8000/stat",
+				pubInterval:        10,
+				pubThreshold:       10,
+				retries:            3,
+				dialTimeout:        10,
+				keepAliveDur:       10,
+				maxIdleConn:        10,
+				maxIdleConnPerHost: 10,
+			},
+			want: want{
+				client: &StatsTCP{
+					statsClient: &Client{
+						endpoint: "http://10.10.10.10:8000/stat",
+						httpClient: &http.Client{
+							Transport: &http.Transport{
+								DialContext: (&net.Dialer{
+									Timeout:   10 * time.Second,
+									KeepAlive: 10 * time.Minute,
+								}).DialContext,
+								MaxIdleConns:          10,
+								MaxIdleConnsPerHost:   10,
+								ResponseHeaderTimeout: 30 * time.Second,
+							},
+						},
+						config: &config{
+							Endpoint:              "http://10.10.10.10:8000/stat",
+							PublishingInterval:    5,
+							PublishingThreshold:   1000,
+							Retries:               3,
+							DialTimeout:           10,
+							KeepAliveDuration:     15,
+							MaxIdleConns:          10,
+							MaxIdleConnsPerHost:   10,
+							retryInterval:         100,
+							MaxChannelLength:      1000,
+							ResponseHeaderTimeout: 30,
+							PoolMaxWorkers:        minPoolWorker,
+							PoolMaxCapacity:       minPoolCapacity,
+						},
+						pubChan: make(chan stat, 1000),
+						statMap: map[string]int{},
+					},
+				},
+				err: nil,
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			client, err := initTCPStatsClient(tt.args.endpoint,
+				tt.args.pubInterval, tt.args.pubThreshold, tt.args.retries, tt.args.dialTimeout, tt.args.keepAliveDur,
+				tt.args.maxIdleConn, tt.args.maxIdleConnPerHost, tt.args.respHeaderTimeout, tt.args.maxChannelLength,
+				tt.args.poolMaxWorkers, tt.args.poolMaxCapacity)
+
+			assert.Equal(t, tt.want.err, err)
+			if err == nil {
+				compareClient(tt.want.client.statsClient, client.statsClient, t)
+			}
+		})
+	}
+}
+
+func TestRecordFunctions(t *testing.T) {
+
+	initStatKeys("N:P", "N:P")
+
+	type args struct {
+		statTCP *StatsTCP
+	}
+
+	type want struct {
+		expectedkeyVal map[string]int
+		channelSize    int
+	}
+
+	tests := []struct {
+		name       string
+		args       args
+		want       want
+		callRecord func(*StatsTCP)
+	}{
+		{
+			name: "RecordOpenWrapServerPanicStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					statKeys[statsKeyOpenWrapServerPanic]: 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordOpenWrapServerPanicStats()
+			},
+		},
+		{
+			name: "RecordPublisherPartnerStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPublisherPartnerRequests], "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherPartnerStats("5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordPublisherPartnerImpStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPublisherPartnerImpressions], "5890", "pubmatic"): 10,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherPartnerImpStats("5890", "pubmatic", 10)
+			},
+		},
+		{
+			name: "RecordPublisherPartnerNoCookieStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPublisherPartnerNoCookieRequests], "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherPartnerNoCookieStats("5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordPartnerTimeoutErrorStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPartnerTimeoutErrorRequests], "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPartnerTimeoutErrorStats("5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordNobiderStatusErrorStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyNobidderStatusErrorRequests], "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordNobiderStatusErrorStats("5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordNobidErrorStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyNobidErrorRequests], "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordNobidErrorStats("5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordUnkownPrebidErrorStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyUnknownPrebidErrorResponse], "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordUnkownPrebidErrorStats("5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordSlotNotMappedErrorStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeySlotunMappedErrorRequests], "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordSlotNotMappedErrorStats("5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordMisConfigurationErrorStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyMisConfErrorRequests], "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordMisConfigurationErrorStats("5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordPublisherProfileRequests",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPublisherProfileRequests], "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherProfileRequests("5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordPublisherInvalidProfileRequests",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 3),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPublisherInvProfileVideoRequests], "5890", "pubmatic"): 1,
+					fmt.Sprintf(statKeys[statsKeyPublisherInvProfileAMPRequests], "5890", "pubmatic"):   1,
+					fmt.Sprintf(statKeys[statsKeyPublisherInvProfileRequests], "5890", "pubmatic"):      1,
+				},
+				channelSize: 3,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherInvalidProfileRequests("video", "5890", "pubmatic")
+				st.RecordPublisherInvalidProfileRequests("amp", "5890", "pubmatic")
+				st.RecordPublisherInvalidProfileRequests("", "5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordPublisherInvalidProfileImpressions",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPublisherInvProfileImpressions], "5890", "pubmatic"): 10,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherInvalidProfileImpressions("5890", "pubmatic", 10)
+			},
+		},
+		{
+			name: "RecordPublisherNoConsentRequests",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPublisherNoConsentRequests], "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherNoConsentRequests("5890")
+			},
+		},
+		{
+			name: "RecordPublisherNoConsentImpressions",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPublisherNoConsentImpressions], "5890"): 11,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherNoConsentImpressions("5890", 11)
+			},
+		},
+		{
+			name: "RecordPublisherRequestStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPublisherPrebidRequests], "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherRequestStats("5890")
+			},
+		},
+		{
+			name: "RecordNobidErrPrebidServerRequests",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyNobidErrPrebidServerRequests], "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordNobidErrPrebidServerRequests("5890")
+			},
+		},
+		{
+			name: "RecordNobidErrPrebidServerResponse",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyNobidErrPrebidServerResponse], "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordNobidErrPrebidServerResponse("5890")
+			},
+		},
+		{
+			name: "RecordInvalidCreativeStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyInvalidCreatives], "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordInvalidCreativeStats("5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordPlatformPublisherPartnerReqStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPlatformPublisherPartnerRequests], "web", "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPlatformPublisherPartnerReqStats("web", "5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordPlatformPublisherPartnerResponseStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPlatformPublisherPartnerResponses], "web", "5890", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPlatformPublisherPartnerResponseStats("web", "5890", "pubmatic")
+			},
+		},
+		{
+			name: "RecordPublisherResponseEncodingErrorStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPublisherResponseEncodingErrors], "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherResponseEncodingErrorStats("5890")
+			},
+		},
+		{
+			name: "RecordPartnerResponseTimeStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 20),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyL50], "5890", "pubmatic"):   1,
+					fmt.Sprintf(statKeys[statsKeyA50], "5890", "pubmatic"):   1,
+					fmt.Sprintf(statKeys[statsKeyA100], "5890", "pubmatic"):  1,
+					fmt.Sprintf(statKeys[statsKeyA200], "5890", "pubmatic"):  1,
+					fmt.Sprintf(statKeys[statsKeyA300], "5890", "pubmatic"):  1,
+					fmt.Sprintf(statKeys[statsKeyA400], "5890", "pubmatic"):  1,
+					fmt.Sprintf(statKeys[statsKeyA500], "5890", "pubmatic"):  1,
+					fmt.Sprintf(statKeys[statsKeyA600], "5890", "pubmatic"):  1,
+					fmt.Sprintf(statKeys[statsKeyA700], "5890", "pubmatic"):  1,
+					fmt.Sprintf(statKeys[statsKeyA800], "5890", "pubmatic"):  1,
+					fmt.Sprintf(statKeys[statsKeyA900], "5890", "pubmatic"):  1,
+					fmt.Sprintf(statKeys[statsKeyA1000], "5890", "pubmatic"): 1,
+					fmt.Sprintf(statKeys[statsKeyA1500], "5890", "pubmatic"): 1,
+					fmt.Sprintf(statKeys[statsKeyA2000], "5890", "pubmatic"): 1,
+				},
+				channelSize: 14,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 10)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 60)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 110)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 210)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 310)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 410)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 510)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 610)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 710)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 810)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 910)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 1010)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 1510)
+				st.RecordPartnerResponseTimeStats("5890", "pubmatic", 2010)
+			},
+		},
+		{
+			name: "RecordPublisherResponseTimeStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 20),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyL50], "5890", "overall"):   1,
+					fmt.Sprintf(statKeys[statsKeyA50], "5890", "overall"):   1,
+					fmt.Sprintf(statKeys[statsKeyA100], "5890", "overall"):  1,
+					fmt.Sprintf(statKeys[statsKeyA200], "5890", "overall"):  1,
+					fmt.Sprintf(statKeys[statsKeyA300], "5890", "overall"):  1,
+					fmt.Sprintf(statKeys[statsKeyA400], "5890", "overall"):  1,
+					fmt.Sprintf(statKeys[statsKeyA500], "5890", "overall"):  1,
+					fmt.Sprintf(statKeys[statsKeyA600], "5890", "overall"):  1,
+					fmt.Sprintf(statKeys[statsKeyA700], "5890", "overall"):  1,
+					fmt.Sprintf(statKeys[statsKeyA800], "5890", "overall"):  1,
+					fmt.Sprintf(statKeys[statsKeyA900], "5890", "overall"):  1,
+					fmt.Sprintf(statKeys[statsKeyA1000], "5890", "overall"): 1,
+					fmt.Sprintf(statKeys[statsKeyA1500], "5890", "overall"): 1,
+					fmt.Sprintf(statKeys[statsKeyA2000], "5890", "overall"): 1,
+				},
+				channelSize: 14,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherResponseTimeStats("5890", 10)
+				st.RecordPublisherResponseTimeStats("5890", 60)
+				st.RecordPublisherResponseTimeStats("5890", 110)
+				st.RecordPublisherResponseTimeStats("5890", 210)
+				st.RecordPublisherResponseTimeStats("5890", 310)
+				st.RecordPublisherResponseTimeStats("5890", 410)
+				st.RecordPublisherResponseTimeStats("5890", 510)
+				st.RecordPublisherResponseTimeStats("5890", 610)
+				st.RecordPublisherResponseTimeStats("5890", 710)
+				st.RecordPublisherResponseTimeStats("5890", 810)
+				st.RecordPublisherResponseTimeStats("5890", 910)
+				st.RecordPublisherResponseTimeStats("5890", 1010)
+				st.RecordPublisherResponseTimeStats("5890", 1510)
+				st.RecordPublisherResponseTimeStats("5890", 2010)
+			},
+		},
+		{
+			name: "RecordPublisherWrapperLoggerFailure",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyLoggerErrorRequests], "5890", "1234", "0"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherWrapperLoggerFailure("5890", "1234", "0")
+			},
+		},
+		{
+			name: "RecordPrebidTimeoutRequests",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPrebidTORequests], "5890", "1234"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPrebidTimeoutRequests("5890", "1234")
+			},
+		},
+		{
+			name: "RecordSSTimeoutRequests",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeySsTORequests], "5890", "1234"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordSSTimeoutRequests("5890", "1234")
+			},
+		},
+		{
+			name: "RecordUidsCookieNotPresentErrorStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyNoUIDSErrorRequest], "5890", "1234"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordUidsCookieNotPresentErrorStats("5890", "1234")
+			},
+		},
+		{
+			name: "RecordVideoInstlImpsStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyVideoInterstitialImpressions], "5890", "1234"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordVideoInstlImpsStats("5890", "1234")
+			},
+		},
+		{
+			name: "RecordImpDisabledViaConfigStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 2),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyVideoImpDisabledViaConfig], "5890", "1234"):  1,
+					fmt.Sprintf(statKeys[statsKeyBannerImpDisabledViaConfig], "5890", "1234"): 1,
+				},
+				channelSize: 2,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordImpDisabledViaConfigStats("video", "5890", "1234")
+				st.RecordImpDisabledViaConfigStats("banner", "5890", "1234")
+			},
+		},
+		{
+			name: "RecordVideoImpDisabledViaConnTypeStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 2),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyVideoImpDisabledViaConnType], "5890", "1234"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordVideoImpDisabledViaConnTypeStats("5890", "1234")
+			},
+		},
+		{
+			name: "RecordPreProcessingTimeStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 5),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPrTimeAbv100], "5890"): 1,
+					fmt.Sprintf(statKeys[statsKeyPrTimeAbv50], "5890"):  1,
+					fmt.Sprintf(statKeys[statsKeyPrTimeAbv10], "5890"):  1,
+					fmt.Sprintf(statKeys[statsKeyPrTimeAbv1], "5890"):   1,
+					fmt.Sprintf(statKeys[statsKeyPrTimeBlw1], "5890"):   1,
+				},
+				channelSize: 5,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPreProcessingTimeStats("5890", 0)
+				st.RecordPreProcessingTimeStats("5890", 5)
+				st.RecordPreProcessingTimeStats("5890", 15)
+				st.RecordPreProcessingTimeStats("5890", 75)
+				st.RecordPreProcessingTimeStats("5890", 105)
+			},
+		},
+		{
+			name: "RecordStatsKeyCTVPrebidFailedImpression",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 5),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyCTVPrebidFailedImpression], 1, "5890", "1234"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordStatsKeyCTVPrebidFailedImpression(1, "5890", "1234")
+			},
+		},
+		{
+			name: "RecordCTVRequests",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 5),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyCTVRequests], "5890", "web"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordCTVRequests("5890", "web")
+			},
+		},
+		{
+			name: "RecordBadRequests",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 7),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyAMPBadRequests]):                  1,
+					fmt.Sprintf(statKeys[statsKeyVideoBadRequests]):                1,
+					fmt.Sprintf(statKeys[statsKey25BadRequests]):                   1,
+					fmt.Sprintf(statKeys[statsKeyCTVBadRequests], "json", 100):     1,
+					fmt.Sprintf(statKeys[statsKeyCTVBadRequests], "openwrap", 200): 1,
+					fmt.Sprintf(statKeys[statsKeyCTVBadRequests], "ortb", 300):     1,
+					fmt.Sprintf(statKeys[statsKeyCTVBadRequests], "vast", 400):     1,
+				},
+				channelSize: 7,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordBadRequests("amp", 1)
+				st.RecordBadRequests("video", 1)
+				st.RecordBadRequests("v25", 1)
+				st.RecordBadRequests("json", 100)
+				st.RecordBadRequests("openwrap", 200)
+				st.RecordBadRequests("ortb", 300)
+				st.RecordBadRequests("vast", 400)
+			},
+		},
+		{
+			name: "RecordCTVHTTPMethodRequests",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyCTVHTTPMethodRequests], "ortb", "5890", "GET"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordCTVHTTPMethodRequests("ortb", "5890", "GET")
+			},
+		},
+		{
+			name: "RecordCTVInvalidReasonCount",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 5),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyCTVValidationErr], 100, "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordCTVInvalidReasonCount(100, "5890")
+			},
+		},
+		{
+			name: "RecordCTVIncompleteAdPodsCount",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 5),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyIncompleteAdPods], "reason", "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordCTVIncompleteAdPodsCount(1, "reason", "5890")
+			},
+		},
+		{
+			name: "RecordCTVReqImpsWithDbConfigCount",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 5),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyCTVReqImpstWithConfig], "db", "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordCTVReqImpsWithDbConfigCount("5890")
+			},
+		},
+		{
+			name: "RecordCTVReqImpsWithReqConfigCount",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 5),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyCTVReqImpstWithConfig], "req", "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordCTVReqImpsWithReqConfigCount("5890")
+			},
+		},
+		{
+			name: "RecordAdPodGeneratedImpressionsCount",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 4),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyTotalAdPodImpression], "1-3", "5890"): 1,
+					fmt.Sprintf(statKeys[statsKeyTotalAdPodImpression], "4-6", "5890"): 1,
+					fmt.Sprintf(statKeys[statsKeyTotalAdPodImpression], "7-9", "5890"): 1,
+					fmt.Sprintf(statKeys[statsKeyTotalAdPodImpression], "9+", "5890"):  1,
+				},
+				channelSize: 4,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordAdPodGeneratedImpressionsCount(3, "5890")
+				st.RecordAdPodGeneratedImpressionsCount(6, "5890")
+				st.RecordAdPodGeneratedImpressionsCount(9, "5890")
+				st.RecordAdPodGeneratedImpressionsCount(11, "5890")
+			},
+		},
+		{
+			name: "RecordAdPodSecondsMissedCount",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 4),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyAdPodSecondsMissed], "5890"): 3,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordAdPodSecondsMissedCount(3, "5890")
+			},
+		},
+		{
+			name: "RecordRequestAdPodGeneratedImpressionsCount",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyReqTotalAdPodImpression], "5890"): 2,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordRequestAdPodGeneratedImpressionsCount(2, "5890")
+			},
+		},
+		{
+			name: "RecordReqImpsWithAppContentCount",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyContentObjectPresent], "app", "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordReqImpsWithAppContentCount("5890")
+			},
+		},
+		{
+			name: "RecordReqImpsWithSiteContentCount",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyContentObjectPresent], "site", "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordReqImpsWithSiteContentCount("5890")
+			},
+		},
+		{
+			name: "RecordAdPodImpressionYield",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyReqImpDurationYield], 10, 1, "5890"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordAdPodImpressionYield(10, 1, "5890")
+			},
+		},
+		{
+			name: "RecordCTVReqCountWithAdPod",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyReqWithAdPodCount], "5890", "1234"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordCTVReqCountWithAdPod("5890", "1234")
+			},
+		},
+		{
+			name: "RecordCTVKeyBidDuration",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyBidDuration], 10, "5890", "1234"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordCTVKeyBidDuration(10, "5890", "1234")
+			},
+		},
+		{
+			name: "RecordPBSAuctionRequestsStats",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyPBSAuctionRequests]): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPBSAuctionRequestsStats()
+			},
+		},
+		{
+			name: "RecordInjectTrackerErrorCount",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyInjectTrackerErrorCount], "banner", "5890", "1234"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordInjectTrackerErrorCount("banner", "5890", "1234")
+			},
+		},
+		{
+			name: "RecordBidResponseByDealCountInPBS",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsBidResponsesByDealUsingPBS], "5890", "1234", "pubmatic", "pubdeal"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordBidResponseByDealCountInPBS("5890", "1234", "pubmatic", "pubdeal")
+			},
+		},
+		{
+			name: "RecordBidResponseByDealCountInHB",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsBidResponsesByDealUsingHB], "5890", "1234", "pubmatic", "pubdeal"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordBidResponseByDealCountInHB("5890", "1234", "pubmatic", "pubdeal")
+			},
+		},
+		{
+			name: "RecordPartnerTimeoutInPBS",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 1),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsPartnerTimeoutInPBS], "5890", "1234", "pubmatic"): 1,
+				},
+				channelSize: 1,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPartnerTimeoutInPBS("5890", "1234", "pubmatic")
+			},
+		},
+		{
+			name: "RecordPublisherRequests",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 6),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyAMPPublisherRequests], "5890"):                   1,
+					fmt.Sprintf(statKeys[statsKeyVideoPublisherRequests], "5890"):                 1,
+					fmt.Sprintf(statKeys[statsKey25PublisherRequests], "banner", "5890"):          1,
+					fmt.Sprintf(statKeys[statsKeyCTVPublisherRequests], "ortb", "banner", "5890"): 1,
+					fmt.Sprintf(statKeys[statsKeyCTVPublisherRequests], "json", "banner", "5890"): 1,
+					fmt.Sprintf(statKeys[statsKeyCTVPublisherRequests], "vast", "banner", "5890"): 1,
+				},
+				channelSize: 6,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordPublisherRequests("amp", "5890", "")
+				st.RecordPublisherRequests("video", "5890", "")
+				st.RecordPublisherRequests("v25", "5890", "banner")
+				st.RecordPublisherRequests("ortb", "5890", "banner")
+				st.RecordPublisherRequests("json", "5890", "banner")
+				st.RecordPublisherRequests("vast", "5890", "banner")
+			},
+		},
+		{
+			name: "RecordCacheErrorRequests",
+			args: args{
+				statTCP: &StatsTCP{
+					&Client{
+						pubChan: make(chan stat, 2),
+					},
+				},
+			},
+			want: want{
+				expectedkeyVal: map[string]int{
+					fmt.Sprintf(statKeys[statsKeyAMPCacheError], "5890", "1234"):   1,
+					fmt.Sprintf(statKeys[statsKeyVideoCacheError], "5890", "1234"): 1,
+				},
+				channelSize: 2,
+			},
+			callRecord: func(st *StatsTCP) {
+				st.RecordCacheErrorRequests("amp", "5890", "1234")
+				st.RecordCacheErrorRequests("video", "5890", "1234")
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+
+			tt.callRecord(tt.args.statTCP)
+
+			close(tt.args.statTCP.statsClient.pubChan)
+			assert.Equal(t, tt.want.channelSize, len(tt.args.statTCP.statsClient.pubChan))
+			for stat := range tt.args.statTCP.statsClient.pubChan {
+				assert.Equalf(t, tt.want.expectedkeyVal[stat.Key], stat.Value,
+					"Mismatched value for key [%s]", stat.Key)
+			}
+		})
+	}
+}
diff --git a/modules/pubmatic/openwrap/models/adcom.go b/modules/pubmatic/openwrap/models/adcom.go
new file mode 100644
index 000000000..22326cc90
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/adcom.go
@@ -0,0 +1,130 @@
+package models
+
+import "github.com/prebid/openrtb/v19/adcom1"
+
+func GetAPIFramework(api []int) []adcom1.APIFramework {
+	if api == nil {
+		return nil
+	}
+	adComAPIs := make([]adcom1.APIFramework, len(api))
+
+	for index, value := range api {
+		adComAPIs[index] = adcom1.APIFramework(value)
+	}
+
+	return adComAPIs
+}
+
+func GetPlaybackMethod(playbackMethods []int) []adcom1.PlaybackMethod {
+	if playbackMethods == nil {
+		return nil
+	}
+	methods := make([]adcom1.PlaybackMethod, len(playbackMethods))
+
+	for index, value := range playbackMethods {
+		methods[index] = adcom1.PlaybackMethod(value)
+	}
+
+	return methods
+}
+
+func GetDeliveryMethod(deliveryMethods []int) []adcom1.DeliveryMethod {
+	if deliveryMethods == nil {
+		return nil
+	}
+	methods := make([]adcom1.DeliveryMethod, len(deliveryMethods))
+
+	for index, value := range deliveryMethods {
+		methods[index] = adcom1.DeliveryMethod(value)
+	}
+
+	return methods
+}
+
+func GetCompanionType(companionTypes []int) []adcom1.CompanionType {
+	if companionTypes == nil {
+		return nil
+	}
+	adcomCompanionTypes := make([]adcom1.CompanionType, len(companionTypes))
+
+	for index, value := range companionTypes {
+		adcomCompanionTypes[index] = adcom1.CompanionType(value)
+	}
+
+	return adcomCompanionTypes
+}
+
+func GetCreativeAttributes(creativeAttributes []int) []adcom1.CreativeAttribute {
+	if creativeAttributes == nil {
+		return nil
+	}
+	adcomCreatives := make([]adcom1.CreativeAttribute, len(creativeAttributes))
+
+	for index, value := range creativeAttributes {
+		adcomCreatives[index] = adcom1.CreativeAttribute(value)
+	}
+
+	return adcomCreatives
+}
+
+func GetProtocol(protocols []int) []adcom1.MediaCreativeSubtype {
+	if protocols == nil {
+		return nil
+	}
+	adComProtocols := make([]adcom1.MediaCreativeSubtype, len(protocols))
+
+	for index, value := range protocols {
+		adComProtocols[index] = adcom1.MediaCreativeSubtype(value)
+	}
+
+	return adComProtocols
+}
+
+// BannerAdType
+// Types of ads that can be accepted by the exchange unless restricted by publisher site settings.
+type BannerAdType int8
+
+const (
+	BannerAdTypeXHTMLTextAd   BannerAdType = 1 // XHTML Text Ad (usually mobile)
+	BannerAdTypeXHTMLBannerAd BannerAdType = 2 // XHTML Banner Ad. (usually mobile)
+	BannerAdTypeJavaScriptAd  BannerAdType = 3 // JavaScript Ad; must be valid XHTML (i.e., Script Tags Included)
+	BannerAdTypeIframe        BannerAdType = 4 // iframe
+)
+
+func GetBannderAdType(adTypes []int) []BannerAdType {
+	if adTypes == nil {
+		return nil
+	}
+	bannerAdTypes := make([]BannerAdType, len(adTypes))
+
+	for index, value := range adTypes {
+		bannerAdTypes[index] = BannerAdType(value)
+	}
+
+	return bannerAdTypes
+}
+
+func GetExpandableDirection(expdirs []int) []adcom1.ExpandableDirection {
+	if expdirs == nil {
+		return nil
+	}
+	adComExDir := make([]adcom1.ExpandableDirection, len(expdirs))
+
+	for index, value := range expdirs {
+		adComExDir[index] = adcom1.ExpandableDirection(value)
+	}
+
+	return adComExDir
+}
+
+func GetConnectionType(connectionType []int) []adcom1.ConnectionType {
+	if connectionType == nil {
+		return nil
+	}
+	adComExDir := make([]adcom1.ConnectionType, len(connectionType))
+	for index, value := range connectionType {
+		adComExDir[index] = adcom1.ConnectionType(value)
+	}
+
+	return adComExDir
+}
diff --git a/modules/pubmatic/openwrap/models/adunitconfig/adunitconfig.go b/modules/pubmatic/openwrap/models/adunitconfig/adunitconfig.go
new file mode 100644
index 000000000..178c6d382
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/adunitconfig/adunitconfig.go
@@ -0,0 +1,81 @@
+package adunitconfig
+
+import (
+	"encoding/json"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// AdUnitConfig type definition for Ad Unit config parsed from stored config JSON
+type AdUnitConfig struct {
+	ConfigPattern string               `json:"configPattern,omitempty"`
+	Regex         bool                 `json:"regex,omitempty"`
+	Config        map[string]*AdConfig `json:"config"`
+	// TODO add seperate default field
+	// Default map[string]*AdConfig `json:"default"`
+}
+type Content struct {
+	Mappings  map[string]openrtb_ext.TransparencyRule `json:"mappings,omitempty"`
+	Dimension []string                                `json:"dimension,omitempty"`
+}
+type Transparency struct {
+	Content Content `json:"content,omitempty"`
+}
+
+type BannerConfig struct {
+	openrtb2.Banner
+	ClientConfig json.RawMessage `json:"clientconfig,omitempty"`
+}
+
+type Banner struct {
+	Enabled *bool         `json:"enabled,omitempty"`
+	Config  *BannerConfig `json:"config,omitempty"`
+}
+
+type VideoConfig struct {
+	openrtb2.Video
+	ConnectionType []int           `json:"connectiontype,omitempty"`
+	ClientConfig   json.RawMessage `json:"clientconfig,omitempty"`
+}
+
+type Native struct {
+	Enabled *bool         `json:"enabled,omitempty"`
+	Config  *NativeConfig `json:"config,omitempty"`
+}
+
+type NativeConfig struct {
+	openrtb2.Native
+	ClientConfig json.RawMessage `json:"clientconfig,omitempty"`
+}
+
+type Video struct {
+	Enabled *bool        `json:"enabled,omitempty"`
+	Config  *VideoConfig `json:"config,omitempty"`
+}
+
+// Struct for UniversalPixel
+type UniversalPixel struct {
+	Id        int      `json:"id,omitempty"`
+	Pixel     string   `json:"pixel,omitempty"`
+	PixelType string   `json:"pixeltype,omitempty"`
+	Pos       string   `json:"pos,omitempty"`
+	MediaType string   `json:"mediatype,omitempty"`
+	Partners  []string `json:"partners,omitempty"`
+}
+
+type AdConfig struct {
+	BidFloor    *float64                     `json:"bidfloor,omitempty"`
+	BidFloorCur *string                      `json:"bidfloorcur,omitempty"`
+	Floors      *openrtb_ext.PriceFloorRules `json:"floors,omitempty"`
+
+	Exp            *int             `json:"exp,omitempty"`
+	Banner         *Banner          `json:"banner,omitempty"`
+	Native         *Native          `json:"native,omitempty"`
+	Video          *Video           `json:"video,omitempty"`
+	App            *openrtb2.App    `json:"app,omitempty"`
+	Device         *openrtb2.Device `json:"device,omitempty"`
+	Transparency   *Transparency    `json:"transparency,omitempty"`
+	Regex          *bool            `json:"regex,omitempty"`
+	UniversalPixel []UniversalPixel `json:"universalpixel,omitempty"`
+}
diff --git a/modules/pubmatic/openwrap/models/bidders.go b/modules/pubmatic/openwrap/models/bidders.go
new file mode 100644
index 000000000..87ff60fe9
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/bidders.go
@@ -0,0 +1,23 @@
+package models
+
+// Bidder Names
+const (
+	BidderVASTBidder = "vastbidder"
+)
+
+// S2S Hard Coded Alias Bidder Name
+const (
+	BidderAdGenerationAlias      = "adg"
+	BidderAndBeyondAlias         = "andbeyond"
+	BidderDistrictmAlias         = "districtm"
+	BidderDistrictmDMXAlias      = "districtmDMX"
+	BidderPubMaticSecondaryAlias = "pubmatic2"
+)
+
+const (
+	SS_PM_ADSLOT     = "adSlot"
+	SS_PM_WRAPPER    = "wrapper"
+	SS_PM_PUBID      = "publisherId"
+	SS_PM_PROFILE_ID = "profile"
+	SS_PM_VERSION_ID = "version"
+)
diff --git a/modules/pubmatic/openwrap/models/constants.go b/modules/pubmatic/openwrap/models/constants.go
new file mode 100755
index 000000000..ae4efba47
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/constants.go
@@ -0,0 +1,399 @@
+package models
+
+const (
+	DEFAULT_PUB_ID             = 34576 // Default PubID to get generic data like regex for browsers etc
+	PARTNER_ID                 = "partnerId"
+	ADAPTER_ID                 = "adapterId"
+	PARTNER_ACCOUNT_NAME       = "partnerName"
+	ADAPTER_NAME               = "adapterName"
+	PREBID_PARTNER_NAME        = "prebidPartnerName"
+	BidderCode                 = "bidderCode"
+	IsAlias                    = "isAlias"
+	PROTOCOL                   = "protocol"
+	SERVER_SIDE_FLAG           = "serverSideEnabled"
+	DisplayVersionID           = "displayVersionId"
+	KEY_PUBLISHER_ID           = "publisherId"
+	KEY_PROFILE_ID             = "profileId"
+	KEY_SLOT_NAME              = "slotName"
+	LEVEL                      = "level"
+	KEY_GEN_PATTERN            = "kgp"
+	TIMEOUT                    = "timeout"
+	AdserverKey                = "adserver"
+	MopubAdserver              = "MoPub"
+	CustomAdserver             = "CUSTOM"
+	PriceGranularityKey        = "priceGranularity"
+	VideoAdDurationKey         = "videoAdDuration"
+	VideoAdDurationMatchingKey = "videoAdDurationMatching"
+	REVSHARE                   = "rev_share"
+	THROTTLE                   = "throttle"
+	REFRESH_INTERVAL           = "refreshInterval"
+	CreativeType               = "crtype"
+	GDPR_ENABLED               = "gdpr"
+	PLATFORM_KEY               = "platform"
+	SendAllBidsKey             = "sendAllBids"
+	SSTimeoutKey               = "ssTimeout"
+	PWC                        = "awc"
+	MAX_SLOT_COUNT             = 5000
+	SITE_CACHE_KEY             = "site"
+	TAG_CACHE_KEY              = "adtag"
+	GA_ID_CACHE_KEY            = "gaid"
+	FLOOR_CACHE_KEY            = "floor"
+	PUBMATIC                   = "PubMatic"
+	PUBMATIC_TIMEOUT           = "PubmaticTimeout"
+	PUBMATIC_PROTOCOL          = "/gads"
+	PUBMATIC_LEVEL             = "multi"
+	PUBMATIC_SS_FLAG           = "1"
+	PUBMATIC_PARTNER_ID_STRING = "1"
+	PUBMATIC_ADAPTER_ID_STRING = "1"
+	VersionLevelConfigID       = -1
+	ERROR_CODE                 = "ErrorCode"
+	ERROR_STRING               = "Error"
+	PUBMATIC_PARTNER_ID        = 1
+	PUBMATIC_ADAPTER_ID        = 1
+	DEFAULT_STRING             = ""
+	DEFAULT_INT                = 0
+	DEFAULT_FLOAT              = 0.00
+	BID_PRECISION              = 2
+	Debug                      = "debug"
+	WrapperLoggerDebug         = "owLoggerDebug"
+	KEY_OW_SLOT_NAME           = "owSlotName"
+	VENDORID                   = "vendorId"
+	//ADSERVER_URL used by S2S to redirect the OW bids if owredirect parameter is not found in video/json
+	ADSERVER_URL = "adServerUrl"
+
+	AdServerCurrency = "adServerCurrency"
+
+	MarketplaceBidders = "marketplaceBidders"
+
+	UserAgent   = "UserAgent"
+	IP          = "ip"
+	StoreURL    = "StoreURL"
+	Consent     = "consent"
+	GDPR        = "gdpr"
+	PublisherID = "pubid"
+	ProfileID   = "profileID"
+	VersionID   = "versionID"
+	Origin      = "origin"
+
+	DEFAULT_DEALCHANNEL = "PMP"
+
+	WLPUBID           = "pubid"
+	WLJSON            = "json"
+	WLGDPR            = "gdEn"
+	USER_AGENT_HEADER = "User-Agent"
+	IP_HEADER         = "SOURCE_IP"
+
+	GADS_UNMAPPED_SLOT_ERROR_MSG    = "Slot not mapped"
+	GADS_MISSING_CONF_ERROR_MSG     = "Missing Configuration"
+	TIMEOUT_ERROR_MSG               = "Timeout Error"
+	NO_BID_PREBID_MSG               = "No Bid"
+	PARTNER_TIMEOUT_ERR_MSG         = "Partner Timed out"
+	PREBID_DEFAULT_TIMEOUT_ERR_MSG  = "Timed out"
+	INVALID_CONFIGURATION_ERR_MSG   = "Invalid Configuration"
+	NO_GDPR_CONSENT_ERR_MSG         = "No Consent Present"
+	API_RESPONSE_ERROR_MSG          = "API Error"
+	INVALID_IMPRESSION_ERR_MSG      = "No Valid Impression Found"
+	CACHE_PUT_FAILED_ERROR_MSG      = "Cache PUT Failed"
+	INVALID_PARAMETERS_ERROR_MSG    = "Invalid Parameters"
+	BANNER_VIDEO_DISABLED_ERROR_MSG = "Banner/Video disabled through config"
+	// PrebidUnknownErrorMsg is the Error message for Unknown Error returned from prebid-server
+	PrebidUnknownErrorMsg = "Unknown error received from Prebid"
+
+	ALL_PARTNERS_THROTTLED_ERROR_MSG = "All partners throttled"
+	PARTNER_THROTTLED_ERROR_MSG      = "Partner throttled"
+	PriceGranularityCustom           = "custom"                       //  contains `custom` price granularity as value
+	PriceGranularityCustomConfig     = "customPriceGranularityConfig" // key which holds configurations around custom price granularity
+
+	// Below is added for Comapring error returned by Prebid Server
+	PARTNER_CONTEXT_DEADLINE   = "context deadline exceeded"
+	INVALID_CREATIVE_ERROR_MSG = "Invalid Creative"
+
+	//constants for macros of logger/tracker keys
+	MacroPartnerName = "${PARTNER_NAME}"
+	MacroBidderCode  = "${BIDDER_CODE}"
+	MacroKGPV        = "${KGPV}"
+	MacroGrossECPM   = "${G_ECPM}"
+	MacroNetECPM     = "${N_ECPM}"
+	MacroBidID       = "${BID_ID}"
+	MacroOrigBidID   = "${ORIGBID_ID}"
+	MacroSlotID      = "${SLOT_ID}"
+	MacroAdunit      = "${ADUNIT}"
+	MacroRewarded    = "${REWARDED}"
+
+	//constants for targetting keys in AMP
+	PWT_PUBID      = "pwtpubid"
+	PWT_PROFILEID  = "pwtprofid"
+	PWT_VERSIONID  = "pwtverid"
+	PWT_ECPM       = "pwtecp"
+	PWT_BIDSTATUS  = "pwtbst"
+	PWT_DEALID     = "pwtdid"
+	PWT_SLOTID     = "pwtsid"
+	PWT_PARTNERID  = "pwtpid"
+	PWT_CACHEID    = "pwtcid"
+	PWT_CACHEURL   = "pwtcurl"
+	PWT_CACHE_PATH = "pwtcpath"
+	PWT_PLATFORM   = "pwtplt"
+	PWT_SZ         = "pwtsz"
+	PWT_DURATION   = "pwtdur"
+	PwtBidID       = "pwtbidid" // Represents bid.id value from oRTB response
+	PwtPb          = "pwtpb"
+	PwtCat         = "pwtcat"
+	PwtPbCatDur    = "pwtpb_cat_dur"
+
+	//constants for query params in AMP request
+	PUBID_KEY         = "pubId"
+	PROFILEID_KEY     = "profId"
+	ADUNIT_KEY        = "auId"
+	MULTISIZE_KEY     = "ms"
+	PAGEURL_KEY       = "purl"
+	WIDTH_KEY         = "w"
+	HEIGHT_KEY        = "h"
+	VERSION_KEY       = "pwtv"
+	DEBUG_KEY         = "pwtvc"
+	ResponseFormatKey = "f"
+	ConsentStringKey  = "consent_string"
+	GDPRAppliesKey    = "gdpr_applies"
+	ConsentTypeKey    = "consent_type"
+	CanonicalUrl      = "curl"
+	TargetingKey      = "targeting"
+
+	AMP_CACHE_PATH         = "/cache"
+	AMP_ORIGIN             = "__amp_source_origin"
+	ResponseFormatJSON     = "json"
+	ResponseFormatRedirect = "redirect"
+	Test                   = "test"
+	PubmaticTest           = "pubmaticTest"
+
+	// constants for query params in Video request
+	OWRedirectURLKey      = "owredirect"
+	CustParams            = "cust_params"
+	MimeTypes             = "pwtmime"
+	InventoryUnitKey      = "iu"
+	InventoryUnitMacroKey = "pwtm_iu"
+	Correlator            = "correlator"
+	MacroPrefix           = "pwtm_"
+	GDPRFlag              = "pwtgdpr"
+	CCPAUSPrivacyKey      = "pwtccpa"
+	ConsentString         = "pwtcnst"
+	AppId                 = "pwtappid"
+	AppRequest            = "pwtapp"
+	DeviceLMT             = "pwtlmt"
+	DeviceDNT             = "pwtdnt"
+	UserID                = "pwtuid"
+	ContentTransparency   = "owcontenttransparency"
+	FloorValue            = "floor_val"
+	FloorCurrency         = "floor_cur"
+
+	// constants for error related query params to be added to DFP call
+	ErrorKey                 = "pwterr"
+	ErrorMsg                 = "pwterrmsg"
+	PartnerConfigNotFoundErr = "1"
+	CachePutFailedErr        = "2"
+	TimeoutErr               = "3"
+	ParameterValidationErr   = "4"
+	SlotNotMappedErr         = "5"
+
+	//constants for video
+	VIDEO_CACHE_PATH          = "/cache"
+	VideoSizeSuffix           = "v"
+	PartnerURLPlaceholder     = "$PARTNER_URL_PLACEHOLDER"
+	TrackerPlaceholder        = "$TRACKER_PLACEHOLDER"
+	ErrorPlaceholder          = "$ERROR_PLACEHOLDER"
+	ImpressionElement         = "Impression"
+	ErrorElement              = "Error"
+	VASTAdElement             = ".//VAST/Ad"
+	AdWrapperElement          = "./Wrapper"
+	AdInlineElement           = "./InLine"
+	VASTAdWrapperElement      = ".//VAST/Ad/Wrapper"
+	VASTAdInlineElement       = ".//VAST/Ad/InLine"
+	CdataPrefix               = "<![CDATA["
+	CdataSuffix               = "]]>"
+	HTTPProtocol              = "http"
+	HTTPSProtocol             = "https"
+	VASTImpressionURLTemplate = `<Impression><![CDATA[` + TrackerPlaceholder + `]]></Impression>`
+	VASTErrorURLTemplate      = `<Error><![CDATA[` + ErrorPlaceholder + `]]></Error>`
+	VastWrapper               = `<VAST version="3.0"><Ad id="1"><Wrapper><AdSystem>PubMatic Wrapper</AdSystem><VASTAdTagURI><![CDATA[$PARTNER_URL_PLACEHOLDER]]></VASTAdTagURI>` + VASTImpressionURLTemplate + VASTErrorURLTemplate + `</Wrapper></Ad></VAST>`
+
+	//constants for wrapper platforms
+	PLATFORM_DISPLAY        = "display"
+	PLATFORM_AMP            = "amp"
+	PLATFORM_APP            = "in-app"
+	PLATFORM_VIDEO          = "video"
+	PlatformAppTargetingKey = "inapp"
+
+	//constants for headers
+	ORIGIN             = "origin"
+	KADUSERCOOKIE      = "KADUSERCOOKIE"
+	COOKIE             = "Cookie"
+	WrapperLoggerImpID = "wiid"
+	UidCookieName      = "uids"
+
+	//constant for gzip response
+	AcceptEncodingHeader = "Accept-Encoding"
+	GZIPEncoding         = "gzip"
+
+	//bidresponse extension
+	ResponseTime       = "responsetimemillis"
+	ResponseExtAdPod   = "adpod"
+	MatchedImpression  = "matchedimpression"
+	LogInfoKey         = "loginfo"
+	LogInfoLoggerKey   = "logger"
+	LogInfoTrackerKey  = "tracker"
+	SendAllBidsFlagKey = "sendallbids"
+	LoggerKey          = "owlogger"
+
+	//keys for reading values from Impression Extension JSON
+	SKAdnetwork = "skadn"
+	PrebidKey   = "prebid"
+	ImpExtData  = "data"
+
+	//Node and Pod names for K8S
+	DEFAULT_NODENAME  = "Default_Node"
+	DEFAULT_PODNAME   = "Default_Pod"
+	ENV_VAR_NODE_NAME = "MY_NODE_NAME"
+	ENV_VAR_POD_NAME  = "MY_POD_NAME"
+
+	// PrebidTargetingKeyPrefix is Prebid's prefix for ext.Prebid.targeting keys
+	PrebidTargetingKeyPrefix = "hb_"
+	// OWTargetingKeyPrefix is OpenWrap's prefix for ext.Prebid.targeting keys
+	OWTargetingKeyPrefix = "pwt"
+
+	//constants for reading adunit Config JSON
+	AdunitConfigDefaultKey       = "default"
+	AdunitConfigSlotConfigKey    = "slotConfig"
+	AdunitConfigSlotNameKey      = "slotname"
+	AdunitConfigSlotBannerKey    = "banner"
+	AdunitConfigSlotVideoKey     = "video"
+	AdunitConfigEnabledKey       = "enabled"
+	AdUnitConfigClientConfigKey  = "clientconfig"
+	AdunitConfigConfigKey        = "config"
+	AdunitConfigConfigPatternKey = "configPattern"
+	AdunitConfigExpKey           = "exp"
+	AdunitConfigExtKey           = "ext"
+
+	AdunitConfigBidFloor    = "bidfloor"
+	AdunitConfigBidFloorCur = "bidfloorcur"
+	AdunitConfigFloorJSON   = "floors"
+	AdunitConfigRegex       = "regex"
+
+	OpenRTBDeviceOsIosRegexPattern     string = `(ios).*`
+	OpenRTBDeviceOsAndroidRegexPattern string = `(android).*`
+	IosUARegexPattern                  string = `(iphone|ipad|darwin).*`
+	AndroidUARegexPattern              string = `android.*`
+	MobileDeviceUARegexPattern         string = `(mobi|tablet|ios).*`
+
+	HbBuyIdPrefix               = "hb_buyid_"
+	HbBuyIdPubmaticConstantKey  = "hb_buyid_pubmatic"
+	PwtBuyIdPubmaticConstantKey = "pwtbuyid_pubmatic"
+
+	SChainDBKey       = "sChain"
+	SChainObjectDBKey = "sChainObj"
+	SChainKey         = "schain"
+	SChainConfigKey   = "config"
+
+	PriceFloorURL      = "jsonUrl"
+	FloorModuleEnabled = "floorPriceModuleEnabled"
+
+	//include brand categories values
+	IncludeNoCategory            = 0
+	IncludeIABBranchCategory     = 1
+	IncludeAdServerBrandCategory = 2
+
+	//OpenWrap Primary AdServer DFP
+	OWPrimaryAdServerDFP = "DFP"
+
+	//Prebid Primary AdServers
+	PrebidPrimaryAdServerFreeWheel = "freewheel"
+	PrebidPrimaryAdServerDFP       = "dfp"
+
+	//Prebid Primary AdServer ID's
+	PrebidPrimaryAdServerFreeWheelID = 1
+	PrebidPrimaryAdServerDFPID       = 2
+
+	//ab test constants
+	AbTestEnabled              = "abTestEnabled"
+	TestGroupSize              = "testGroupSize"
+	TestType                   = "testType"
+	PartnerTestEnabledKey      = "testEnabled"
+	TestTypeAuctionTimeout     = "Auction Timeout"
+	TestTypePartners           = "Partners"
+	TestTypeClientVsServerPath = "Client-side vs. Server-side Path"
+
+	DataTypeUnknown         = 0
+	DataTypeInteger         = 1
+	DataTypeFloat           = 2
+	DataTypeString          = 3
+	DataTypeBoolean         = 4
+	DataTypeArrayOfIntegers = 5
+	DataTypeArrayOfFloats   = 6
+	DataTypeArrayOfStrings  = 7
+
+	Device     = "device"
+	DeviceType = "deviceType"
+)
+
+const (
+	MACRO_WIDTH         = "_W_"
+	MACRO_HEIGHT        = "_H_"
+	MACRO_AD_UNIT_ID    = "_AU_"
+	MACRO_AD_UNIT_INDEX = "_AUI_"
+	MACRO_INTEGER       = "_I_"
+	MACRO_DIV           = "_DIV_"
+	MACRO_SOURCE        = "_SRC_"
+	MACRO_VASTTAG       = "_VASTTAG_"
+
+	ADUNIT_SIZE_KGP           = "_AU_@_W_x_H_"
+	REGEX_KGP                 = "_AU_@_DIV_@_W_x_H_"
+	DIV_SIZE_KGP              = "_DIV_@_W_x_H_"
+	ADUNIT_SOURCE_VASTTAG_KGP = "_AU_@_SRC_@_VASTTAG_"
+	SIZE_KGP                  = "_W_x_H_@_W_x_H_"
+)
+
+var (
+	//EmptyVASTResponse Empty VAST Response
+	EmptyVASTResponse = []byte(`<VAST version="2.0"/>`)
+	//EmptyString to check for empty value
+	EmptyString = ""
+	//HeaderOpenWrapStatus Status of OW Request
+	HeaderOpenWrapStatus = "X-Ow-Status"
+	//ErrorFormat parsing error format
+	ErrorFormat = `{"` + ERROR_CODE + `":%v,"` + ERROR_STRING + `":"%s"}`
+	//ContentType HTTP Response Header Content Type
+	ContentType = `Content-Type`
+	//ContentTypeApplicationJSON HTTP Header Content-Type Value
+	ContentTypeApplicationJSON = `application/json`
+	//ContentTypeApplicationXML HTTP Header Content-Type Value
+	ContentTypeApplicationXML = `application/xml`
+	//EmptyJSONResponse Empty JSON Response
+	EmptyJSONResponse = []byte{}
+	//VASTErrorResponse VAST Error Response
+	VASTErrorResponse = `<VAST version="2.0"><Ad><InLine><Extensions><Extension><OWStatus><Error code="%v">%v</Error></OWStatus></Extension></Extensions></InLine></Ad></VAST>`
+	//TrackerCallWrap
+	TrackerCallWrap = `<div style="position:absolute;left:0px;top:0px;visibility:hidden;"><img src="${escapedUrl}"></div>`
+	//TrackerCallWrapOMActive for Open Measurement in In-App Banner
+	TrackerCallWrapOMActive = `<script id="OWPubOMVerification" data-owurl="${escapedUrl}" src="${OMScript}"></script>`
+)
+
+// LogOnlyWinBidArr is an array containing Partners who only want winning bids to be logged
+var LogOnlyWinBidArr = []string{"facebook"}
+
+// contextKey will be used to pass the object through request.Context
+type contextKey string
+
+const (
+	ContextOWLoggerKey contextKey = "owlogger"
+)
+
+const Pipe = "|"
+
+const (
+	EndpointV25   = "v25"
+	EndpointAMP   = "amp"
+	EndpointVideo = "video"
+	EndpointJson  = "json"
+	EndpointORTB  = "ortb"
+	EndpointVAST  = "vast"
+	Openwrap      = "openwrap"
+	ImpTypeBanner = "banner"
+	ImpTypeVideo  = "video"
+)
diff --git a/modules/pubmatic/openwrap/models/db.go b/modules/pubmatic/openwrap/models/db.go
new file mode 100644
index 000000000..119ca6bbe
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/db.go
@@ -0,0 +1,55 @@
+package models
+
+import "strings"
+
+// VASTTag contains tag details of VASTBidders
+type VASTTag struct {
+	ID        int     `json:"id,omitempty"`
+	PartnerID int     `json:"partnerId,omitempty"`
+	URL       string  `json:"url,omitempty"`
+	Duration  int     `json:"dur,omitempty"`
+	Price     float64 `json:"price,omitempty"`
+}
+
+// PublisherVASTTags holds publisher level vast tag entries
+type PublisherVASTTags = map[int]*VASTTag
+
+/*SlotMappingInfo contains the ordered list of slot names and a map of slot names to their hash values*/
+type SlotMappingInfo struct {
+	OrderedSlotList []string
+	HashValueMap    map[string]string
+}
+
+type SlotInfo struct {
+	SlotName string
+	AdSize   string
+	AdWidth  int
+	AdHeight int
+	SiteId   int
+	AdTagId  int
+	GId      int // Gauanteed Id
+	Floor    float64
+}
+
+/*SlotMapping object contains information for a given slot*/
+type SlotMapping struct {
+	PartnerId    int64
+	AdapterId    int64
+	VersionId    int64
+	SlotName     string
+	MappingJson  string
+	SlotMappings map[string]interface{}
+	Hash         string
+	OrderID      int64
+}
+
+type BySlotName []*SlotInfo
+
+func (t BySlotName) Len() int { return len(t) }
+func (t BySlotName) Compare(i int, element interface{}) int {
+	slotname := element.(string)
+	return strings.Compare(t[i].SlotName, slotname)
+}
+
+// AdUnitConfig type definition for Ad Unit config parsed from stored config JSON
+type AdUnitConfig map[string]interface{}
diff --git a/modules/pubmatic/openwrap/models/device.go b/modules/pubmatic/openwrap/models/device.go
new file mode 100644
index 000000000..7b066c5a6
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/device.go
@@ -0,0 +1,63 @@
+package models
+
+import "github.com/prebid/prebid-server/openrtb_ext"
+
+const (
+	//Device.DeviceType values as per OpenRTB-API-Specification-Version-2-5
+	DeviceTypeMobile           = 1
+	DeviceTypePersonalComputer = 2
+	DeviceTypeConnectedTv      = 3
+	DeviceTypePhone            = 4
+	DeviceTypeTablet           = 5
+	DeviceTypeConnectedDevice  = 6
+	DeviceTypeSetTopBox        = 7
+)
+
+// DevicePlatform defines enums as per int values from KomliAdServer.platform table
+type DevicePlatform int
+
+const (
+	DevicePlatformUnknown          DevicePlatform = -1
+	DevicePlatformDesktop          DevicePlatform = 1 //Desktop Web
+	DevicePlatformMobileWeb        DevicePlatform = 2 //Mobile Web
+	DevicePlatformNotDefined       DevicePlatform = 3
+	DevicePlatformMobileAppIos     DevicePlatform = 4 //In-App iOS
+	DevicePlatformMobileAppAndroid DevicePlatform = 5 //In-App Android
+	DevicePlatformMobileAppWindows DevicePlatform = 6
+	DevicePlatformConnectedTv      DevicePlatform = 7 //Connected TV
+)
+
+// DeviceIFAType defines respective logger int id for device type
+type DeviceIFAType = int
+
+// DeviceIFATypeID
+var DeviceIFATypeID = map[string]DeviceIFAType{
+	DeviceIFATypeDPID:      1,
+	DeviceIFATypeRIDA:      2,
+	DeviceIFATypeAAID:      3,
+	DeviceIFATypeIDFA:      4,
+	DeviceIFATypeAFAI:      5,
+	DeviceIFATypeMSAI:      6,
+	DeviceIFATypePPID:      7,
+	DeviceIFATypeSSPID:     8,
+	DeviceIFATypeSESSIONID: 9,
+}
+
+// Device Ifa type constants
+const (
+	DeviceIFATypeDPID      = "dpid"
+	DeviceIFATypeRIDA      = "rida"
+	DeviceIFATypeAAID      = "aaid"
+	DeviceIFATypeIDFA      = "idfa"
+	DeviceIFATypeAFAI      = "afai"
+	DeviceIFATypeMSAI      = "msai"
+	DeviceIFATypePPID      = "ppid"
+	DeviceIFATypeSSPID     = "sspid"
+	DeviceIFATypeSESSIONID = "sessionid"
+)
+
+type ExtDevice struct {
+	*openrtb_ext.ExtDevice
+	SessionID string `json:"session_id,omitempty"`
+	IDFV      string `json:"idfv,omitempty"`
+}
diff --git a/modules/pubmatic/openwrap/models/gocommon.go b/modules/pubmatic/openwrap/models/gocommon.go
new file mode 100644
index 000000000..3b868ba82
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/gocommon.go
@@ -0,0 +1,393 @@
+package models
+
+import (
+	"net/url"
+)
+
+type RequestAPI int
+
+const (
+	ADMIN_API RequestAPI = iota
+	GADS_API
+	OpenRTB_V23_API
+	OpenRTB_V24_API
+	OpenRTB_V241_API
+	OpenRTB_V25_API
+	OpenRTB_AMP_API
+	OpenRTB_VIDEO_API
+	OpenRTB_VIDEO_OPENRTB_API
+	OpenRTB_VIDEO_VAST_API
+	OpenRTB_VIDEO_JSON_API
+)
+
+const (
+	SLOT_KEY                 = "slot"
+	KEY_VALUE_KEY            = "keyValue"
+	ID_KEY                   = "id"
+	DIV_KEY                  = "div"
+	SLOT_INDEX_KEY           = "slotIndex"
+	PROFILE_KEY              = "profileid"
+	GA_ID_KEY                = "gaId"
+	SITE_ID                  = "siteId"
+	ADTAG_ID                 = "adTagId"
+	BID_REQUEST_ID           = "bidRequestId"
+	IMPRESSION_ID            = "impId"
+	DM_KEY                   = "dm"
+	AS_KEY                   = "as"
+	WRAPPER_KEY              = "wrapper"
+	ADPOD_KEY                = "adpod"
+	BIDDER_KEY               = "bidder"
+	RESPONSE_TYPE_KEY        = "rs"
+	PM_CB_KEY                = "pm_cb"
+	SERVER_SIDE_AUCTION_FLAG = "ssauction"
+	SUMMERY_DISABLE_FLAG     = "sumry_disable"
+	KVAL_PARAM_KEY           = "kval_param"
+	SA_VERSION_KEY           = "SAVersion"
+	PAGE_URL_KEY             = "pageURL"
+	REF_URL_KEY              = "refurl"
+	IN_IFRAME_KEY            = "inIframe"
+	KAD_PAGE_URL_KEY         = "kadpageurl"
+	RAN_REQ_KEY              = "ranreq"
+	KLT_STAMP_KEY            = "kltstamp"
+	TIMEZONE_KEY             = "timezone"
+	SCREEN_RESOLUTION_KEY    = "screenResolution"
+	ADTYPE_KEY               = "adType"
+	ADPOSITION_KEY           = "adPosition"
+	ADVISIBILITY_KEY         = "adVisibility"
+	IABCAT_KEY               = "iabcat"
+	AWT_KEY                  = "awt"
+	ZONEID_KEY               = "pmZoneId"
+	SITECODE_KEY             = "sitecode"
+	UDID_KEY                 = "udid"
+	UDID_TYPE_KEY            = "udidtype"
+	UDID_HASH_KEY            = "udidhash"
+	ORMMA_KEY                = "ormma"
+	AD_ORIENTATION_KEY       = "adOrientation"
+	DEVICE_ORIENTATION_KEY   = "deviceOrientation"
+	LOCCAT_KEY               = "loccat"
+	LOCBRAND_KEY             = "locbrand"
+	KADFLOOR_KEY             = "kadfloor"
+	RID_KEY                  = "rid"
+	LOC_SOURCE_KEY           = "loc_source"
+	ETHN_KEY                 = "ethn"
+	KEYWORDS_KEY             = "keywords"
+	LOC_KEY                  = "loc"
+	CAT_KEY                  = "cat"
+	API_KEY                  = "api"
+	NETTYPE_KEY              = "nettype"
+	CONSENT                  = "consent"
+	GET_METHOD_QUERY_PARAM   = "json"
+	PAGE_URL_HEADER          = "Referer"
+	SKAdnetworkKey           = "skadn"
+	OmidpvKey                = "omidpv"
+	OmidpnKey                = "omidpn"
+	RewardKey                = "reward"
+	DataKey                  = "data"
+	DEAL_TIER_KEY            = "dealtier"
+	FluidStr                 = "fluid"
+	DeviceSessionID          = "session_id"
+	DeviceIfaType            = "ifa_type"
+)
+
+type ResponseType int
+
+const (
+	ORTB_RESPONSE   ResponseType = 1 + iota //openRTB default response
+	GADS_RESPONSE_1                         //gshow ad response
+	GADS_RESPONSE_2                         //DM gpt generic response
+)
+
+const (
+	// USD denotes currency USD
+	USD = "USD"
+)
+
+// constants related to Video request
+const (
+	PlayerSizeKey         = "sz"
+	SizeStringSeparator   = "x"
+	DescriptionURLKey     = "description_url"
+	URLKey                = "url"
+	MimesSeparator        = ","
+	MultipleSizeSeparator = "|"
+	AppRequestURLKey      = "pwtapp"
+	Comma                 = ","
+)
+
+// OpenWrap Video request params
+const (
+	OWMimeTypes      = "pwtmime"
+	OWMinAdDuration  = "pwtvmnd"
+	OWMaxAdDuration  = "pwtvmxd"
+	OWStartDelay     = "pwtdly"
+	OWPlaybackMethod = "pwtplbk"
+	OWAPI            = "pwtvapi"
+	OWProtocols      = "pwtprots"
+	OWSize           = "pwtvsz"
+	OWBAttr          = "pwtbatr"
+	OWLinearity      = "pwtvlin"
+	OWPlacement      = "pwtvplc"
+	OWMaxBitrate     = "pwtmxbr"
+	OWMinBitrate     = "pwtmnbr"
+	OWSkippable      = "pwtskp"
+	OWProtocol       = "pwtprot"
+	OWSkipMin        = "pwtskmn"
+	OWSkipAfter      = "pwtskat"
+	OWSequence       = "pwtseq"
+	OWMaxExtended    = "pwtmxex"
+	OWDelivery       = "pwtdvry"
+	OWPos            = "pwtvpos"
+	OWBoxingAllowed  = "pwtbox"
+	OWBidderParams   = "pwtbidrprm"
+	OwAppKeywords    = "pwtappkw"
+	OWUserEids       = "pwteids"
+)
+
+// OpenWrap Mobile params
+const (
+	OWAppId              = "pwtappid"
+	OWAppName            = "pwtappname"
+	OWAppDomain          = "pwtappdom"
+	OWAppBundle          = "pwtappbdl"
+	OWAppStoreURL        = "pwtappurl"
+	OWAppCat             = "pwtappcat"
+	OWAppPaid            = "pwtapppd"
+	OWDeviceUA           = "pwtua"
+	OWDeviceLMT          = "pwtlmt"
+	OWDeviceDNT          = "pwtdnt"
+	OWDeviceIP           = "pwtip"
+	OWDeviceJS           = "pwtjs"
+	OWDeviceIfa          = "pwtifa"
+	OWDeviceDidsha1      = "pwtdidsha1"
+	OWDeviceDidmd5       = "pwtdidmd5"
+	OWDeviceDpidsha1     = "pwtdpidsha1"
+	OWDeviceDpidmd5      = "pwtdpidmd5"
+	OWDeviceMacsha1      = "pwtmacsha1"
+	OWDeviceMacmd5       = "pwtmacmd5"
+	OWUserID             = "pwtuid"
+	OWGeoLat             = "pwtlat"
+	OWGeoLon             = "pwtlon"
+	OWGeoType            = "pwtgtype"
+	OWGeoCountry         = "pwtcntr"
+	OWGeoCity            = "pwtcity"
+	OWGeoMetro           = "pwtmet"
+	OWGeoZip             = "pwtzip"
+	OWUTOffset           = "pwtuto"
+	OWContentGenre       = "pwtgenre"
+	OWContentTitle       = "pwttitle"
+	OWUserYob            = "pwtyob"
+	OWUserGender         = "pwtgender"
+	OWSourceOmidPv       = "pwtomidpv"
+	OWSourceOmidPn       = "pwtomidpn"
+	OWDeviceExtIfaType   = "pwtifatype"
+	OWDeviceExtSessionID = "pwtsessionid"
+	OWImpPrebidExt       = "pwtimpprebidext"
+)
+
+// constants for DFP Video request parameters
+const (
+	DFPMinAdDuration = "min_ad_duration"
+	DFPMaxAdDuration = "max_ad_duration"
+	DFPSize          = PlayerSizeKey
+	DFPVAdType       = "vad_type"
+	DFPVPos          = "vpos"
+	DFPVpmute        = "vpmute"
+	DFPVpa           = "vpa"
+)
+
+// constants for oRTB Request Video parameters
+const (
+	MimeORTBParam           = "Mimes"
+	MinDurationORTBParam    = "MinDuration"
+	MaxDurationORTBParam    = "MaxDuration"
+	ProtocolsORTBParam      = "Protocols"
+	ProtocolORTBParam       = "Protocol"
+	WORTBParam              = "W"
+	HORTBParam              = "H"
+	SizeORTBParam           = "sz"
+	StartDelayORTBParam     = "StartDelay"
+	PlacementORTBParam      = "Placement"
+	LinearityORTBParam      = "Linearity"
+	SkipORTBParam           = "Skip"
+	SkipMinORTBParam        = "SkipMin"
+	SkipAfterORTBParam      = "SkipAfter"
+	SequenceORTBParam       = "Sequence"
+	BAttrORTBParam          = "BAttr"
+	MaxExtendedORTBParam    = "MaxExtended"
+	MinBitrateORTBParam     = "MinBitrate"
+	MaxBitrateORTBParam     = "MaxBitrate"
+	BoxingAllowedORTBParam  = "BoxingAllowed"
+	PlaybackMethodORTBParam = "PlaybackMethod"
+	DeliveryORTBParam       = "Delivery"
+	PosORTBParam            = "Pos"
+	CompanionadORTBParam    = "Companionad"
+	APIORTBParam            = "API"
+	CompanionTypeORTBParam  = "CompanionType"
+	AppIDORTBParam          = "AppID"
+	AppNameORTBParam        = "AppName"
+	AppBundleORTBParam      = "AppBundle"
+	AppStoreURLORTBParam    = "AppStoreURL"
+	AppDomainORTBParam      = "AppDomain"
+	AppCatORTBParam         = "AppCat"
+	AppPaidORTBParam        = "AppPaid"
+	DeviceUAORTBParam       = "DeviceUA"
+	DeviceDNTORTBParam      = "DeviceDNT"
+	DeviceLMTORTBParam      = "DeviceLMT"
+	DeviceJSORTBParam       = "DeviceJS"
+	DeviceIPORTBParam       = "DeviceIP"
+	DeviceIfaORTBParam      = "DeviceIfa"
+	DeviceDidsha1ORTBParam  = "DeviceDidsha1"
+	DeviceDidmd5ORTBParam   = "DeviceDidmd5"
+	DeviceDpidsha1ORTBParam = "DeviceDpidsha1"
+	DeviceDpidmd5ORTBParam  = "DeviceDpidmd5"
+	DeviceMacsha1ORTBParam  = "DeviceMacsha1"
+	DeviceMacmd5ORTBParam   = "DeviceMacmd5"
+	GeoLatORTBParam         = "GeoLat"
+	GeoLonORTBParam         = "GeoLon"
+	GeoTypeORTBParam        = "GeoType"
+	GeoCountryORTBParam     = "GeoCountry"
+	GeoCityORTBParam        = "GeoCity"
+	GeoMetroORTBParam       = "GeoMetro"
+	GeoZipORTBParam         = "GeoZip"
+	GeoUTOffsetORTBParam    = "GeoUTOffset"
+	UserIDORTBParam         = "UserId"
+	UserYobORTBParam        = "UserYob"
+	UserGenderORTBParam     = "UserGender"
+	SourceOmidpvORTBParam   = "SourceOmidpv"
+	SourceOmidpnORTBParam   = "SourceOmidpn"
+	ContentGenreORTBParam   = "Genre"
+	ContentTitleORTBParam   = "Title"
+	BidderParams            = "BidderParams"
+	DeviceExtSessionID      = "DeviceExtSessionID"
+	DeviceExtIfaType        = "DeviceExtIfaType"
+	ImpPrebidExt            = "ImpPrebidExt"
+)
+
+// ORTBToDFPOWMap is Map of ORTB params to DFP and OW params. 0th position in map value denotes DFP param and 1st position in value denotes OW param. To populate a given ORTB parameter, preference would be given to DFP value and if its not present, OW value would be used
+var ORTBToDFPOWMap = map[string][]string{
+	MimeORTBParam:           {OWMimeTypes, ""},
+	MinDurationORTBParam:    {OWMinAdDuration, DFPMinAdDuration},
+	MaxDurationORTBParam:    {OWMaxAdDuration, DFPMaxAdDuration},
+	StartDelayORTBParam:     {OWStartDelay, DFPVPos},
+	PlaybackMethodORTBParam: {OWPlaybackMethod, ""},
+	APIORTBParam:            {OWAPI, ""},
+	ProtocolsORTBParam:      {OWProtocols, ""},
+	SizeORTBParam:           {OWSize, DFPSize},
+	BAttrORTBParam:          {OWBAttr, ""},
+	LinearityORTBParam:      {OWLinearity, DFPVAdType},
+	PlacementORTBParam:      {OWPlacement, ""},
+	MaxBitrateORTBParam:     {OWMaxBitrate, ""},
+	MinBitrateORTBParam:     {OWMinBitrate, ""},
+	SkipORTBParam:           {OWSkippable, ""},
+	SkipMinORTBParam:        {OWSkipMin, ""},
+	SkipAfterORTBParam:      {OWSkipAfter, ""},
+	ProtocolORTBParam:       {OWProtocol, ""},
+	SequenceORTBParam:       {OWSequence, ""},
+	MaxExtendedORTBParam:    {OWMaxExtended, ""},
+	BoxingAllowedORTBParam:  {OWBoxingAllowed, ""},
+	DeliveryORTBParam:       {OWDelivery, ""},
+	PosORTBParam:            {OWPos, ""},
+	AppIDORTBParam:          {OWAppId, ""},
+	AppNameORTBParam:        {OWAppName, ""},
+	AppBundleORTBParam:      {OWAppBundle, ""},
+	AppStoreURLORTBParam:    {OWAppStoreURL, ""},
+	AppCatORTBParam:         {OWAppCat, ""},
+	AppPaidORTBParam:        {OWAppPaid, ""},
+	AppDomainORTBParam:      {OWAppDomain, ""},
+	DeviceUAORTBParam:       {OWDeviceUA, ""},
+	DeviceDNTORTBParam:      {OWDeviceDNT, ""},
+	DeviceLMTORTBParam:      {OWDeviceLMT, ""},
+	DeviceJSORTBParam:       {OWDeviceJS, ""},
+	DeviceIPORTBParam:       {OWDeviceIP, ""},
+	DeviceIfaORTBParam:      {OWDeviceIfa, ""},
+	DeviceDidsha1ORTBParam:  {OWDeviceDidsha1, ""},
+	DeviceDidmd5ORTBParam:   {OWDeviceDidmd5, ""},
+	DeviceDpidsha1ORTBParam: {OWDeviceDpidsha1, ""},
+	DeviceDpidmd5ORTBParam:  {OWDeviceDpidmd5, ""},
+	DeviceMacsha1ORTBParam:  {OWDeviceMacsha1, ""},
+	DeviceMacmd5ORTBParam:   {OWDeviceMacmd5, ""},
+	GeoLatORTBParam:         {OWGeoLat, ""},
+	GeoLonORTBParam:         {OWGeoLon, ""},
+	GeoTypeORTBParam:        {OWGeoType, ""},
+	UserIDORTBParam:         {OWUserID, ""},
+	GeoCountryORTBParam:     {OWGeoCountry, ""},
+	GeoCityORTBParam:        {OWGeoCity, ""},
+	GeoMetroORTBParam:       {OWGeoMetro, ""},
+	GeoZipORTBParam:         {OWGeoZip, ""},
+	GeoUTOffsetORTBParam:    {OWUTOffset, ""},
+	ContentGenreORTBParam:   {OWContentGenre, ""},
+	ContentTitleORTBParam:   {OWContentTitle, ""},
+	UserYobORTBParam:        {OWUserYob, ""},
+	UserGenderORTBParam:     {OWUserGender, ""},
+	SourceOmidpvORTBParam:   {OWSourceOmidPv, ""},
+	SourceOmidpnORTBParam:   {OWSourceOmidPn, ""},
+	BidderParams:            {OWBidderParams, ""},
+	DeviceExtSessionID:      {OWDeviceExtSessionID, ""},
+	DeviceExtIfaType:        {OWDeviceExtIfaType, ""},
+	ImpPrebidExt:            {OWImpPrebidExt, ""},
+}
+
+// DFP Video positions constants
+const (
+	Preroll  = "preroll"
+	Midroll  = "midroll"
+	Postroll = "postroll"
+)
+
+// VideoPositionToStartDelayMap is a map of DFP Video positions to Start Delay integer values in oRTB request
+var VideoPositionToStartDelayMap = map[string]string{
+	Preroll:  "0",
+	Midroll:  "-1",
+	Postroll: "-2",
+}
+
+// DFP Video linearity (vad_type) constants
+const (
+	Linear    = "linear"
+	Nonlinear = "nonlinear"
+)
+
+// LinearityMap is a map of DFP Linearity values to oRTB values
+var LinearityMap = map[string]string{
+	Linear:    "1",
+	Nonlinear: "2",
+}
+
+// Mime types
+const (
+	All        = "0"
+	VideoMP4   = "1" // video/mp4
+	VPAIDFlash = "2" // application/x-shockwave-flash (VPAID - FLASH)
+	VideoWMV   = "3" // video/wmv
+	VideoH264  = "4" // video/h264
+	VideoWebm  = "5" // video/webm
+	VPAIDJS    = "6" // application/javascript (VPAID - JS)
+	VideoOGG   = "7" // video/ogg
+	VideoFLV   = "8" // video/flv (Flash Video)
+)
+
+// MimeIDToValueMap is a map of Mime IDs to string values
+var MimeIDToValueMap = map[string]string{
+	All:        "All",
+	VideoMP4:   "video/mp4",
+	VPAIDFlash: "application/x-shockwave-flash",
+	VideoWMV:   "video/wmv",
+	VideoH264:  "video/h264",
+	VideoWebm:  "video/webm",
+	VPAIDJS:    "application/javascript",
+	VideoOGG:   "video/ogg",
+	VideoFLV:   "video/flv",
+}
+
+// CheckIfValidQueryParamFlag checks if given query parameter has a valid flag value(i.e. 0 or 1)
+func CheckIfValidQueryParamFlag(values url.Values, key string) bool {
+	validationFailed := false
+	paramValue := values.Get(key)
+	if paramValue == "" {
+		return validationFailed
+	}
+	if paramValue != "0" && paramValue != "1" {
+		validationFailed = true
+	}
+	return validationFailed
+}
diff --git a/modules/pubmatic/openwrap/models/iso6391.go b/modules/pubmatic/openwrap/models/iso6391.go
new file mode 100644
index 000000000..1f22b0746
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/iso6391.go
@@ -0,0 +1,203 @@
+package models
+
+// Language is an ISO 639-1 language with code, name and native name.
+type Language struct {
+	Code       string
+	Name       string
+	NativeName string
+}
+
+// Languages is a map of all ISO 639-1 languages using the two character lowercase language code as key.
+var Languages = map[string]Language{
+	"ls": {Code: "aa", Name: "Afar", NativeName: "Afaraf"},
+	"ab": {Code: "ab", Name: "Abkhaz", NativeName: "аҧсуа бызшәа"},
+	"ae": {Code: "ae", Name: "Avestan", NativeName: "avesta"},
+	"af": {Code: "af", Name: "Afrikaans", NativeName: "Afrikaans"},
+	"ak": {Code: "ak", Name: "Akan", NativeName: "Akan"},
+	"am": {Code: "am", Name: "Amharic", NativeName: "አማርኛ"},
+	"an": {Code: "an", Name: "Aragonese", NativeName: "aragonés"},
+	"ar": {Code: "ar", Name: "Arabic", NativeName: "اللغة العربية"},
+	"as": {Code: "as", Name: "Assamese", NativeName: "অসমীয়া"},
+	"av": {Code: "av", Name: "Avaric", NativeName: "авар мацӀ"},
+	"ay": {Code: "ay", Name: "Aymara", NativeName: "aymar aru"},
+	"az": {Code: "az", Name: "Azerbaijani", NativeName: "azərbaycan dili"},
+	"ba": {Code: "ba", Name: "Bashkir", NativeName: "башҡорт теле"},
+	"be": {Code: "be", Name: "Belarusian", NativeName: "беларуская мова"},
+	"bg": {Code: "bg", Name: "Bulgarian", NativeName: "български език"},
+	"bh": {Code: "bh", Name: "Bihari", NativeName: "भोजपुरी"},
+	"bi": {Code: "bi", Name: "Bislama", NativeName: "Bislama"},
+	"bm": {Code: "bm", Name: "Bambara", NativeName: "bamanankan"},
+	"bn": {Code: "bn", Name: "Bengali", NativeName: "বাংলা"},
+	"bo": {Code: "bo", Name: "Tibetan Standard", NativeName: "བོད་ཡིག"},
+	"br": {Code: "br", Name: "Breton", NativeName: "brezhoneg"},
+	"bs": {Code: "bs", Name: "Bosnian", NativeName: "bosanski jezik"},
+	"ca": {Code: "ca", Name: "Catalan", NativeName: "català"},
+	"ce": {Code: "ce", Name: "Chechen", NativeName: "нохчийн мотт"},
+	"ch": {Code: "ch", Name: "Chamorro", NativeName: "Chamoru"},
+	"co": {Code: "co", Name: "Corsican", NativeName: "corsu"},
+	"cr": {Code: "cr", Name: "Cree", NativeName: "ᓀᐦᐃᔭᐍᐏᐣ"},
+	"cs": {Code: "cs", Name: "Czech", NativeName: "čeština"},
+	"cu": {Code: "cu", Name: "Old Church Slavonic", NativeName: "ѩзыкъ словѣньскъ"},
+	"cv": {Code: "cv", Name: "Chuvash", NativeName: "чӑваш чӗлхи"},
+	"cy": {Code: "cy", Name: "Welsh", NativeName: "Cymraeg"},
+	"da": {Code: "da", Name: "Danish", NativeName: "dansk"},
+	"de": {Code: "de", Name: "German", NativeName: "Deutsch"},
+	"dv": {Code: "dv", Name: "Divehi", NativeName: "Dhivehi"},
+	"dz": {Code: "dz", Name: "Dzongkha", NativeName: "རྫོང་ཁ"},
+	"ee": {Code: "ee", Name: "Ewe", NativeName: "Eʋegbe"},
+	"el": {Code: "el", Name: "Greek", NativeName: "Ελληνικά"},
+	"en": {Code: "en", Name: "English", NativeName: "English"},
+	"eo": {Code: "eo", Name: "Esperanto", NativeName: "Esperanto"},
+	"es": {Code: "es", Name: "Spanish", NativeName: "Español"},
+	"et": {Code: "et", Name: "Estonian", NativeName: "eesti"},
+	"eu": {Code: "eu", Name: "Basque", NativeName: "euskara"},
+	"fa": {Code: "fa", Name: "Persian", NativeName: "فارسی"},
+	"ff": {Code: "ff", Name: "Fula", NativeName: "Fulfulde"},
+	"fi": {Code: "fi", Name: "Finnish", NativeName: "suomi"},
+	"fj": {Code: "fj", Name: "Fijian", NativeName: "Vakaviti"},
+	"fo": {Code: "fo", Name: "Faroese", NativeName: "føroyskt"},
+	"fr": {Code: "fr", Name: "French", NativeName: "Français"},
+	"fy": {Code: "fy", Name: "Western Frisian", NativeName: "Frysk"},
+	"ga": {Code: "ga", Name: "Irish", NativeName: "Gaeilge"},
+	"gd": {Code: "gd", Name: "Scottish Gaelic", NativeName: "Gàidhlig"},
+	"gl": {Code: "gl", Name: "Galician", NativeName: "galego"},
+	"gn": {Code: "gn", Name: "Guaraní", NativeName: "Avañeẽ"},
+	"gu": {Code: "gu", Name: "Gujarati", NativeName: "ગુજરાતી"},
+	"gv": {Code: "gv", Name: "Manx", NativeName: "Gaelg"},
+	"ha": {Code: "ha", Name: "Hausa", NativeName: "هَوُسَ"},
+	"he": {Code: "he", Name: "Hebrew", NativeName: "עברית"},
+	"hi": {Code: "hi", Name: "Hindi", NativeName: "हिन्दी"},
+	"ho": {Code: "ho", Name: "Hiri Motu", NativeName: "Hiri Motu"},
+	"hr": {Code: "hr", Name: "Croatian", NativeName: "hrvatski jezik"},
+	"ht": {Code: "ht", Name: "Haitian", NativeName: "Kreyòl ayisyen"},
+	"hu": {Code: "hu", Name: "Hungarian", NativeName: "magyar"},
+	"hy": {Code: "hy", Name: "Armenian", NativeName: "Հայերեն"},
+	"hz": {Code: "hz", Name: "Herero", NativeName: "Otjiherero"},
+	"ia": {Code: "ia", Name: "Interlingua", NativeName: "Interlingua"},
+	"id": {Code: "id", Name: "Indonesian", NativeName: "Indonesian"},
+	"ie": {Code: "ie", Name: "Interlingue", NativeName: "Interlingue"},
+	"ig": {Code: "ig", Name: "Igbo", NativeName: "Asụsụ Igbo"},
+	"ii": {Code: "ii", Name: "Nuosu", NativeName: "ꆈꌠ꒿ Nuosuhxop"},
+	"ik": {Code: "ik", Name: "Inupiaq", NativeName: "Iñupiaq"},
+	"io": {Code: "io", Name: "Ido", NativeName: "Ido"},
+	"is": {Code: "is", Name: "Icelandic", NativeName: "Íslenska"},
+	"it": {Code: "it", Name: "Italian", NativeName: "Italiano"},
+	"iu": {Code: "iu", Name: "Inuktitut", NativeName: "ᐃᓄᒃᑎᑐᑦ"},
+	"ja": {Code: "ja", Name: "Japanese", NativeName: "日本語"},
+	"jv": {Code: "jv", Name: "Javanese", NativeName: "basa Jawa"},
+	"ka": {Code: "ka", Name: "Georgian", NativeName: "ქართული"},
+	"kg": {Code: "kg", Name: "Kongo", NativeName: "Kikongo"},
+	"ki": {Code: "ki", Name: "Kikuyu", NativeName: "Gĩkũyũ"},
+	"kj": {Code: "kj", Name: "Kwanyama", NativeName: "Kuanyama"},
+	"kk": {Code: "kk", Name: "Kazakh", NativeName: "қазақ тілі"},
+	"kl": {Code: "kl", Name: "Kalaallisut", NativeName: "kalaallisut"},
+	"km": {Code: "km", Name: "Khmer", NativeName: "ខេមរភាសា"},
+	"kn": {Code: "kn", Name: "Kannada", NativeName: "ಕನ್ನಡ"},
+	"ko": {Code: "ko", Name: "Korean", NativeName: "한국어"},
+	"kr": {Code: "kr", Name: "Kanuri", NativeName: "Kanuri"},
+	"ks": {Code: "ks", Name: "Kashmiri", NativeName: "कश्मीरी"},
+	"ku": {Code: "ku", Name: "Kurdish", NativeName: "Kurdî"},
+	"kv": {Code: "kv", Name: "Komi", NativeName: "коми кыв"},
+	"kw": {Code: "kw", Name: "Cornish", NativeName: "Kernewek"},
+	"ky": {Code: "ky", Name: "Kyrgyz", NativeName: "Кыргызча"},
+	"la": {Code: "la", Name: "Latin", NativeName: "latine"},
+	"lb": {Code: "lb", Name: "Luxembourgish", NativeName: "Lëtzebuergesch"},
+	"lg": {Code: "lg", Name: "Ganda", NativeName: "Luganda"},
+	"li": {Code: "li", Name: "Limburgish", NativeName: "Limburgs"},
+	"ln": {Code: "ln", Name: "Lingala", NativeName: "Lingála"},
+	"lo": {Code: "lo", Name: "Lao", NativeName: "ພາສາ"},
+	"lt": {Code: "lt", Name: "Lithuanian", NativeName: "lietuvių kalba"},
+	"lu": {Code: "lu", Name: "Luba-Katanga", NativeName: "Tshiluba"},
+	"lv": {Code: "lv", Name: "Latvian", NativeName: "latviešu valoda"},
+	"mg": {Code: "mg", Name: "Malagasy", NativeName: "fiteny malagasy"},
+	"mh": {Code: "mh", Name: "Marshallese", NativeName: "Kajin M̧ajeļ"},
+	"mi": {Code: "mi", Name: "Māori", NativeName: "te reo Māori"},
+	"mk": {Code: "mk", Name: "Macedonian", NativeName: "македонски јазик"},
+	"ml": {Code: "ml", Name: "Malayalam", NativeName: "മലയാളം"},
+	"mn": {Code: "mn", Name: "Mongolian", NativeName: "Монгол хэл"},
+	"mr": {Code: "mr", Name: "Marathi", NativeName: "मराठी"},
+	"ms": {Code: "ms", Name: "Malay", NativeName: "هاس ملايو\u200e"},
+	"mt": {Code: "mt", Name: "Maltese", NativeName: "Malti"},
+	"my": {Code: "my", Name: "Burmese", NativeName: "ဗမာစာ"},
+	"na": {Code: "na", Name: "Nauru", NativeName: "Ekakairũ Naoero"},
+	"nb": {Code: "nb", Name: "Norwegian Bokmål", NativeName: "Norsk bokmål"},
+	"nd": {Code: "nd", Name: "Northern Ndebele", NativeName: "isiNdebele"},
+	"ne": {Code: "ne", Name: "Nepali", NativeName: "नेपाली"},
+	"ng": {Code: "ng", Name: "Ndonga", NativeName: "Owambo"},
+	"nl": {Code: "nl", Name: "Dutch", NativeName: "Nederlands"},
+	"nn": {Code: "nn", Name: "Norwegian Nynorsk", NativeName: "Norsk nynorsk"},
+	"no": {Code: "no", Name: "Norwegian", NativeName: "Norsk"},
+	"nr": {Code: "nr", Name: "Southern Ndebele", NativeName: "isiNdebele"},
+	"nv": {Code: "nv", Name: "Navajo", NativeName: "Diné bizaad"},
+	"ny": {Code: "ny", Name: "Chichewa", NativeName: "chiCheŵa"},
+	"oc": {Code: "oc", Name: "Occitan", NativeName: "occitan"},
+	"oj": {Code: "oj", Name: "Ojibwe", NativeName: "ᐊᓂᔑᓈᐯᒧᐎᓐ"},
+	"om": {Code: "om", Name: "Oromo", NativeName: "Afaan Oromoo"},
+	"or": {Code: "or", Name: "Oriya", NativeName: "ଓଡ଼ିଆ"},
+	"os": {Code: "os", Name: "Ossetian", NativeName: "ирон æвзаг"},
+	"pa": {Code: "pa", Name: "Panjabi", NativeName: "ਪੰਜਾਬੀ"},
+	"pi": {Code: "pi", Name: "Pāli", NativeName: "पाऴि"},
+	"pl": {Code: "pl", Name: "Polish", NativeName: "język polski"},
+	"ps": {Code: "ps", Name: "Pashto", NativeName: "پښتو"},
+	"pt": {Code: "pt", Name: "Portuguese", NativeName: "Português"},
+	"qu": {Code: "qu", Name: "Quechua", NativeName: "Runa Simi"},
+	"rm": {Code: "rm", Name: "Romansh", NativeName: "rumantsch grischun"},
+	"rn": {Code: "rn", Name: "Kirundi", NativeName: "Ikirundi"},
+	"ro": {Code: "ro", Name: "Romanian", NativeName: "Română"},
+	"ru": {Code: "ru", Name: "Russian", NativeName: "Русский"},
+	"rw": {Code: "rw", Name: "Kinyarwanda", NativeName: "Ikinyarwanda"},
+	"sa": {Code: "sa", Name: "Sanskrit", NativeName: "संस्कृतम्"},
+	"sc": {Code: "sc", Name: "Sardinian", NativeName: "sardu"},
+	"sd": {Code: "sd", Name: "Sindhi", NativeName: "सिन्धी"},
+	"se": {Code: "se", Name: "Northern Sami", NativeName: "Davvisámegiella"},
+	"sg": {Code: "sg", Name: "Sango", NativeName: "yângâ tî sängö"},
+	"si": {Code: "si", Name: "Sinhala", NativeName: "සිංහල"},
+	"sk": {Code: "sk", Name: "Slovak", NativeName: "slovenčina"},
+	"sl": {Code: "sl", Name: "Slovene", NativeName: "slovenski jezik"},
+	"sm": {Code: "sm", Name: "Samoan", NativeName: "gagana faa Samoa"},
+	"sn": {Code: "sn", Name: "Shona", NativeName: "chiShona"},
+	"so": {Code: "so", Name: "Somali", NativeName: "Soomaaliga"},
+	"sq": {Code: "sq", Name: "Albanian", NativeName: "Shqip"},
+	"sr": {Code: "sr", Name: "Serbian", NativeName: "српски језик"},
+	"ss": {Code: "ss", Name: "Swati", NativeName: "SiSwati"},
+	"st": {Code: "st", Name: "Southern Sotho", NativeName: "Sesotho"},
+	"su": {Code: "su", Name: "Sundanese", NativeName: "Basa Sunda"},
+	"sv": {Code: "sv", Name: "Swedish", NativeName: "svenska"},
+	"sw": {Code: "sw", Name: "Swahili", NativeName: "Kiswahili"},
+	"ta": {Code: "ta", Name: "Tamil", NativeName: "தமிழ்"},
+	"te": {Code: "te", Name: "Telugu", NativeName: "తెలుగు"},
+	"tg": {Code: "tg", Name: "Tajik", NativeName: "тоҷикӣ"},
+	"th": {Code: "th", Name: "Thai", NativeName: "ไทย"},
+	"ti": {Code: "ti", Name: "Tigrinya", NativeName: "ትግርኛ"},
+	"tk": {Code: "tk", Name: "Turkmen", NativeName: "Türkmen"},
+	"tl": {Code: "tl", Name: "Tagalog", NativeName: "Wikang Tagalog"},
+	"tn": {Code: "tn", Name: "Tswana", NativeName: "Setswana"},
+	"to": {Code: "to", Name: "Tonga", NativeName: "faka Tonga"},
+	"tr": {Code: "tr", Name: "Turkish", NativeName: "Türkçe"},
+	"ts": {Code: "ts", Name: "Tsonga", NativeName: "Xitsonga"},
+	"tt": {Code: "tt", Name: "Tatar", NativeName: "татар теле"},
+	"tw": {Code: "tw", Name: "Twi", NativeName: "Twi"},
+	"ty": {Code: "ty", Name: "Tahitian", NativeName: "Reo Tahiti"},
+	"ug": {Code: "ug", Name: "Uyghur", NativeName: "ئۇيغۇرچە\u200e"},
+	"uk": {Code: "uk", Name: "Ukrainian", NativeName: "Українська"},
+	"ur": {Code: "ur", Name: "Urdu", NativeName: "اردو"},
+	"uz": {Code: "uz", Name: "Uzbek", NativeName: "Ўзбек"},
+	"ve": {Code: "ve", Name: "Venda", NativeName: "Tshivenḓa"},
+	"vi": {Code: "vi", Name: "Vietnamese", NativeName: "Tiếng Việt"},
+	"vo": {Code: "vo", Name: "Volapük", NativeName: "Volapük"},
+	"wa": {Code: "wa", Name: "Walloon", NativeName: "walon"},
+	"wo": {Code: "wo", Name: "Wolof", NativeName: "Wollof"},
+	"xh": {Code: "xh", Name: "Xhosa", NativeName: "isiXhosa"},
+	"yi": {Code: "yi", Name: "Yiddish", NativeName: "ייִדיש"},
+	"yo": {Code: "yo", Name: "Yoruba", NativeName: "Yorùbá"},
+	"za": {Code: "za", Name: "Zhuang", NativeName: "Saɯ cueŋƅ"},
+	"zh": {Code: "zh", Name: "Chinese", NativeName: "中文"},
+	"zu": {Code: "zu", Name: "Zulu", NativeName: "isiZulu"},
+}
+
+// ValidCode returns true if the given code is a valid ISO 639-1 language code.
+// The code must be passed in lowercase.
+func ValidCode(code string) bool {
+	_, ok := Languages[code]
+	return ok
+}
diff --git a/modules/pubmatic/openwrap/models/nbr/codes.go b/modules/pubmatic/openwrap/models/nbr/codes.go
new file mode 100644
index 000000000..0f5bb0a26
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/nbr/codes.go
@@ -0,0 +1,23 @@
+package nbr
+
+const (
+	// Refer below link for standard codes.
+	// https://github.com/InteractiveAdvertisingBureau/openrtb/blob/2c3bf2bb2bc81ce0b5260f2e82c59938ea05b74a/extensions/community_extensions/seat-non-bid.md#list-non-bid-status-codes
+
+	//  Internal Technical Error
+	InternalError int = 1
+	// Invalid Request
+	InvalidRequest int = 2
+
+	// 500+ Vendor-specific codes.
+	InvalidRequestWrapperExtension int = 500 + iota
+	InvalidPublisherID
+	InvalidProfileID
+	InvalidProfileConfiguration
+	AllPartnerThrottled
+	InvalidPriceGranularityConfig
+	InvalidImpressionTagID
+	ServerSidePartnerNotConfigured
+	AllSlotsDisabled
+	InvalidVideoRequest
+)
diff --git a/modules/pubmatic/openwrap/models/openwrap.go b/modules/pubmatic/openwrap/models/openwrap.go
new file mode 100644
index 000000000..bf24a7227
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/openwrap.go
@@ -0,0 +1,130 @@
+package models
+
+import (
+	"encoding/json"
+	"net/http"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models/adunitconfig"
+)
+
+type RequestCtx struct {
+	PubID, ProfileID, DisplayID, VersionID int
+	SSAuction                              int
+	SummaryDisable                         int
+	LogInfoFlag                            int
+	SSAI                                   string
+	PartnerConfigMap                       map[int]map[string]string
+	SupportDeals                           bool
+	Platform                               string
+	LoggerImpressionID                     string
+	ClientConfigFlag                       int
+
+	IP   string
+	TMax int64
+
+	//NYC_TODO: use enum?
+	IsTestRequest                     int8
+	ABTestConfig, ABTestConfigApplied int
+	IsCTVRequest                      bool
+
+	TrackerEndpoint, VideoErrorTrackerEndpoint string
+
+	UA            string
+	Cookies       string
+	UidCookie     *http.Cookie
+	KADUSERCookie *http.Cookie
+	OriginCookie  string
+
+	Debug bool
+	Trace bool
+
+	//tracker
+	PageURL        string
+	StartTime      int64
+	DevicePlatform DevicePlatform
+
+	//trackers per bid
+	Trackers map[string]OWTracker
+
+	//prebid-biddercode to seat/alias mapping
+	PrebidBidderCode map[string]string
+
+	// imp-bid ctx to avoid computing same thing for bidder params, logger and tracker
+	ImpBidCtx          map[string]ImpCtx
+	Aliases            map[string]string
+	NewReqExt          json.RawMessage
+	ResponseExt        json.RawMessage
+	MarketPlaceBidders map[string]struct{}
+
+	AdapterThrottleMap map[string]struct{}
+
+	AdUnitConfig *adunitconfig.AdUnitConfig
+
+	Source, Origin string
+
+	SendAllBids bool
+	WinningBids map[string]OwBid
+	DroppedBids map[string][]openrtb2.Bid
+	NoSeatBids  map[string]map[string][]openrtb2.Bid
+
+	BidderResponseTimeMillis map[string]int
+}
+
+type OwBid struct {
+	ID                   string
+	NetEcpm              float64
+	BidDealTierSatisfied bool
+}
+
+func (r RequestCtx) GetVersionLevelKey(key string) (string, bool) {
+	if len(r.PartnerConfigMap) == 0 || len(r.PartnerConfigMap[VersionLevelConfigID]) == 0 {
+		return "", false
+	}
+	v, ok := r.PartnerConfigMap[VersionLevelConfigID][key]
+	return v, ok
+}
+
+type ImpCtx struct {
+	ImpID             string
+	TagID             string
+	Div               string
+	Secure            int
+	IsRewardInventory *int8
+	Banner            bool
+	Video             *openrtb2.Video
+	IncomingSlots     []string
+	Type              string // banner, video, native, etc
+	Bidders           map[string]PartnerData
+	NonMapped         map[string]struct{}
+
+	NewExt json.RawMessage
+	BidCtx map[string]BidCtx
+
+	BannerAdUnitCtx AdUnitCtx
+	VideoAdUnitCtx  AdUnitCtx
+}
+
+type PartnerData struct {
+	PartnerID        int
+	PrebidBidderCode string
+	MatchedSlot      string
+	KGP              string
+	KGPV             string
+	IsRegex          bool
+	Params           json.RawMessage
+}
+
+type BidCtx struct {
+	BidExt
+}
+
+type AdUnitCtx struct {
+	MatchedSlot              string
+	IsRegex                  bool
+	MatchedRegex             string
+	SelectedSlotAdUnitConfig *adunitconfig.AdConfig
+	AppliedSlotAdUnitConfig  *adunitconfig.AdConfig
+	UsingDefaultConfig       bool
+	AllowedConnectionTypes   []int
+}
diff --git a/modules/pubmatic/openwrap/models/ortb.go b/modules/pubmatic/openwrap/models/ortb.go
new file mode 100644
index 000000000..df1a7961c
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/ortb.go
@@ -0,0 +1,72 @@
+package models
+
+// OpenRTB Constants
+const (
+	//constant for adformat
+	Banner = "banner"
+	Video  = "video"
+	Native = "native"
+
+	//constants for reading video keys from adunit Config
+	VideoMinDuration    = "minduration"
+	VideoMaxDuration    = "maxduration"
+	VideoSkip           = "skip"
+	VideoSkipMin        = "skipmin"
+	VideoSkipAfter      = "skipafter"
+	VideoBattr          = "battr"
+	VideoConnectionType = "connectiontype"
+	VideoMinBitRate     = "minbitrate"
+	VideoMaxBitRate     = "maxbitrate"
+	VideoMaxExtended    = "maxextended"
+	VideoStartDelay     = "startdelay"
+	VideoPlacement      = "placement"
+	VideoLinearity      = "linearity"
+	VideoMimes          = "mimes"
+	VideoProtocol       = "protocol"
+	VideoProtocols      = "protocols"
+	VideoW              = "w"
+	VideoH              = "h"
+	VideoSequence       = "sequence"
+	VideoBoxingAllowed  = "boxingallowed"
+	VideoPlaybackMethod = "playbackmethod"
+	VidepPlaybackEnd    = "playbackend"
+	VideoDelivery       = "delivery"
+	VideoPos            = "pos"
+	VideoAPI            = "api"
+	VideoCompanionType  = "companiontype"
+	VideoComapanionAd   = "companionad"
+
+	//banner obj
+	BannerFormat   = "format"
+	BannerW        = "w"
+	BannerH        = "h"
+	BannerWMax     = "wmax"
+	BannerHMax     = "hmax"
+	BannerWMin     = "wmin"
+	BannerHMin     = "hmin"
+	BannerBType    = "btype"
+	BannerBAttr    = "battr"
+	BannerPos      = "pos"
+	BannerMimes    = "mimes"
+	BannerTopFrame = "topframe"
+	BannerExpdir   = "expdir"
+	BannerAPI      = "api"
+	BannerID       = "id"
+	BannerVcm      = "vcm"
+
+	//format object
+	FormatW      = "w"
+	FormatH      = "h"
+	FormatWRatio = "wratio"
+	FormatHRatio = "hratio"
+	FormatWmin   = "wmin"
+)
+
+type ConsentType int
+
+const (
+	Unknown ConsentType = iota
+	TCF_V1
+	TCF_V2
+	CCPA
+)
diff --git a/modules/pubmatic/openwrap/models/reponse.go b/modules/pubmatic/openwrap/models/reponse.go
new file mode 100644
index 000000000..429e5e969
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/reponse.go
@@ -0,0 +1,85 @@
+package models
+
+import (
+	"encoding/json"
+
+	"github.com/prebid/openrtb/v19/adcom1"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+type BidExt struct {
+	openrtb_ext.ExtBid
+
+	ErrorCode       int    `json:"errorCode,omitempty"`
+	ErrorMsg        string `json:"errorMessage,omitempty"`
+	RefreshInterval int    `json:"refreshInterval,omitempty"`
+	CreativeType    string `json:"crtype,omitempty"`
+	// AdPod           ExtBidPrebidAdPod `json:"adpod,omitempty"`
+	Summary     []Summary       `json:"summary,omitempty"`
+	SKAdnetwork json.RawMessage `json:"skadn,omitempty"`
+	Video       *ExtBidVideo    `json:"video,omitempty"`
+	Banner      *ExtBidBanner   `json:"banner,omitempty"`
+	DspId       int             `json:"dspid,omitempty"`
+	Winner      int             `json:"winner,omitempty"`
+	NetECPM     float64         `json:"netecpm,omitempty"`
+
+	OriginalBidCPM    float64 `json:"origbidcpm,omitempty"`
+	OriginalBidCur    string  `json:"origbidcur,omitempty"`
+	OriginalBidCPMUSD float64 `json:"origbidcpmusd,omitempty"`
+}
+
+// ExtBidVideo defines the contract for bidresponse.seatbid.bid[i].ext.video
+type ExtBidVideo struct {
+	MinDuration    int64                      `json:"minduration,omitempty"`    // Minimum video ad duration in seconds.
+	MaxDuration    int64                      `json:"maxduration,omitempty"`    // Maximum video ad duration in seconds.
+	Skip           *int8                      `json:"skip,omitempty"`           // Indicates if the player will allow the video to be skipped,where 0 = no, 1 = yes.
+	SkipMin        int64                      `json:"skipmin,omitempty"`        // Videos of total duration greater than this number of seconds can be skippable; only applicable if the ad is skippable.
+	SkipAfter      int64                      `json:"skipafter,omitempty"`      // Number of seconds a video must play before skipping is enabled; only applicable if the ad is skippable.
+	BAttr          []adcom1.CreativeAttribute `json:"battr,omitempty"`          // Blocked creative attributes
+	PlaybackMethod []adcom1.PlaybackMethod    `json:"playbackmethod,omitempty"` // Allowed playback methods
+	ClientConfig   json.RawMessage            `json:"clientconfig,omitempty"`
+}
+
+// ExtBidBanner defines the contract for bidresponse.seatbid.bid[i].ext.banner
+type ExtBidBanner struct {
+	ClientConfig json.RawMessage `json:"clientconfig,omitempty"`
+}
+
+// ExtBidPrebidCache defines the contract for  bidresponse.seatbid.bid[i].ext.prebid.cache
+type ExtBidPrebidCache struct {
+	Key string `json:"key"`
+	Url string `json:"url"`
+}
+
+// Prebid Response Ext with DspId
+type OWExt struct {
+	openrtb_ext.ExtOWBid
+	DspId int `json:"dspid,omitempty"`
+
+	OriginalBidCPM    float64 `json:"origbidcpm,omitempty"`
+	OriginalBidCur    string  `json:"origbidcur,omitempty"`
+	OriginalBidCPMUSD float64 `json:"origbidcpmusd,omitempty"`
+}
+
+// ExtBidderMessage defines an error object to be returned, consiting of a machine readable error code, and a human readable error message string.
+type ExtBidderMessage struct {
+	Code    int    `json:"code"`
+	Message string `json:"message"`
+}
+
+// BidType describes the allowed values for bidresponse.seatbid.bid[i].ext.prebid.type
+type BidType string
+
+// Targeting map of string of strings
+type Targeting map[string]string
+
+type Summary struct {
+	VastTagID    string  `json:"vastTagID,omitempty"`
+	Bidder       string  `json:"bidder,omitempty"`
+	Bid          float64 `json:"bid,omitempty"`
+	ErrorCode    int     `json:"errorCode,omitempty"`
+	ErrorMessage string  `json:"errorMessage,omitempty"`
+	Width        int     `json:"width,omitempty"`
+	Height       int     `json:"height,omitempty"`
+	Regex        string  `json:"regex,omitempty"`
+}
diff --git a/modules/pubmatic/openwrap/models/request.go b/modules/pubmatic/openwrap/models/request.go
new file mode 100644
index 000000000..43a5f2c80
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/request.go
@@ -0,0 +1,113 @@
+package models
+
+import (
+	"encoding/json"
+
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+type ExtRegs struct {
+	// GDPR should be "1" if the caller believes the user is subject to GDPR laws, "0" if not, and undefined
+	// if it's unknown. For more info on this parameter, see: https://iabtechlab.com/wp-content/uploads/2018/02/OpenRTB_Advisory_GDPR_2018-02.pdf
+	Gdpr *int `json:"gdpr,omitempty"`
+	// USPrivacy should be a four character string, see: https://iabtechlab.com/wp-content/uploads/2019/11/OpenRTB-Extension-U.S.-Privacy-IAB-Tech-Lab.pdf
+	USPrivacy *string `json:"us_privacy,omitempty"`
+}
+
+// ExtRequestAdPod holds AdPod specific extension parameters at request level
+type ExtRequestAdPod struct {
+	AdPod
+	CrossPodAdvertiserExclusionPercent  *int `json:"crosspodexcladv,omitempty"`    //Percent Value - Across multiple impression there will be no ads from same advertiser. Note: These cross pod rule % values can not be more restrictive than per pod
+	CrossPodIABCategoryExclusionPercent *int `json:"crosspodexcliabcat,omitempty"` //Percent Value - Across multiple impression there will be no ads from same advertiser
+	IABCategoryExclusionWindow          *int `json:"excliabcatwindow,omitempty"`   //Duration in minute between pods where exclusive IAB rule needs to be applied
+	AdvertiserExclusionWindow           *int `json:"excladvwindow,omitempty"`      //Duration in minute between pods where exclusive advertiser rule needs to be applied
+}
+
+// AdPod holds Video AdPod specific extension parameters at impression level
+type AdPod struct {
+	MinAds                      *int `json:"minads,omitempty"`        //Default 1 if not specified
+	MaxAds                      *int `json:"maxads,omitempty"`        //Default 1 if not specified
+	MinDuration                 *int `json:"adminduration,omitempty"` // (adpod.adminduration * adpod.minads) should be greater than or equal to video.minduration
+	MaxDuration                 *int `json:"admaxduration,omitempty"` // (adpod.admaxduration * adpod.maxads) should be less than or equal to video.maxduration + video.maxextended
+	AdvertiserExclusionPercent  *int `json:"excladv,omitempty"`       // Percent value 0 means none of the ads can be from same advertiser 100 means can have all same advertisers
+	IABCategoryExclusionPercent *int `json:"excliabcat,omitempty"`    // Percent value 0 means all ads should be of different IAB categories.
+}
+
+// ImpExtension - Impression Extension
+type ImpExtension struct {
+	Wrapper *ExtImpWrapper `json:"wrapper,omitempty"`
+	Reward  *int8          `json:"reward,omitempty"`
+
+	Bidder map[string]*BidderExtension `json:"bidder,omitempty"`
+
+	SKAdnetwork json.RawMessage          `json:"skadn,omitempty"`
+	Data        json.RawMessage          `json:"data,omitempty"`
+	Prebid      openrtb_ext.ExtImpPrebid `json:"prebid,omitempty"`
+}
+
+// BidderExtension - Bidder specific items
+type BidderExtension struct {
+	KeyWords []KeyVal              `json:"keywords,omitempty"`
+	DealTier *openrtb_ext.DealTier `json:"dealtier,omitempty"`
+}
+
+// ExtImpWrapper - Impression wrapper Extension
+type ExtImpWrapper struct {
+	Div string `json:"div,omitempty"`
+}
+
+// ExtVideo structure to accept video specific more parameters like adpod
+type ExtVideo struct {
+	Offset *int   `json:"offset,omitempty"` // Minutes from start where this ad is intended to show
+	AdPod  *AdPod `json:"adpod,omitempty"`
+}
+
+// RequestExt Request Extension
+type RequestExt struct {
+	openrtb_ext.ExtRequest
+
+	// Move this to bidder params
+	Wrapper *RequestExtWrapper                `json:"wrapper,omitempty"`
+	Bidder  map[string]map[string]interface{} `json:"bidder,omitempty"`
+	AdPod   *ExtRequestAdPod                  `json:"adpod,omitempty"`
+}
+
+// pbopenrtb_ext alias for prebid server openrtb_ext
+// type PriceFloorRules = openrtb_ext.PriceFloorRules
+
+// TransparencyRule contains transperancy rule for a single bidder
+type TransparencyRule struct {
+	Include bool     `json:"include,omitempty"`
+	Keys    []string `json:"keys,omitempty"`
+}
+
+// ExtTransparency holds bidder level content transparency rules
+type ExtTransparency struct {
+	Content map[string]TransparencyRule `json:"content,omitempty"`
+}
+
+// KeyVal structure to store bidder related custom key-values
+type KeyVal struct {
+	Key    string   `json:"key,omitempty"`
+	Values []string `json:"value,omitempty"`
+}
+
+// RequestExtWrapper holds wrapper specific extension parameters
+type RequestExtWrapper struct {
+	ProfileId            int    `json:"profileid,omitempty"`
+	VersionId            int    `json:"versionid,omitempty"`
+	SSAuctionFlag        int    `json:"ssauction,omitempty"`
+	SumryDisableFlag     int    `json:"sumry_disable,omitempty"`
+	ClientConfigFlag     int    `json:"clientconfig,omitempty"`
+	LogInfoFlag          int    `json:"loginfo,omitempty"`
+	SupportDeals         bool   `json:"supportdeals,omitempty"`
+	IncludeBrandCategory int    `json:"includebrandcategory,omitempty"`
+	ABTestConfig         int    `json:"abtest,omitempty"`
+	LoggerImpressionID   string `json:"wiid,omitempty"`
+	SSAI                 string `json:"ssai,omitempty"`
+}
+
+type BidderWrapper struct {
+	Flag        bool
+	VASTagFlags map[string]bool
+}
diff --git a/modules/pubmatic/openwrap/models/source.go b/modules/pubmatic/openwrap/models/source.go
new file mode 100644
index 000000000..fbba90277
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/source.go
@@ -0,0 +1,9 @@
+package models
+
+import "github.com/prebid/prebid-server/openrtb_ext"
+
+type ExtSource struct {
+	*openrtb_ext.ExtSource
+	OMIDPV string `json:"omidpv,omitempty"`
+	OMIDPN string `json:"omidpn,omitempty"`
+}
diff --git a/modules/pubmatic/openwrap/models/tracker.go b/modules/pubmatic/openwrap/models/tracker.go
new file mode 100644
index 000000000..cdd7dca58
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/tracker.go
@@ -0,0 +1,47 @@
+package models
+
+// OWTracker vast video parameters to be injected
+type OWTracker struct {
+	Tracker       Tracker
+	TrackerURL    string
+	ErrorURL      string
+	Price         float64
+	PriceModel    string
+	PriceCurrency string
+	BidType       string `json:"-"` // video, banner, native
+	DspId         int    `json:"-"` // dsp id
+}
+
+// Tracker tracker url creation parameters
+type Tracker struct {
+	PubID             int
+	PageURL           string
+	Timestamp         int64
+	IID               string
+	ProfileID         string
+	VersionID         string
+	SlotID            string
+	Adunit            string
+	PartnerInfo       Partner
+	RewardedInventory int
+	SURL              string // contains either req.site.domain or req.app.bundle value
+	Platform          int
+	Advertiser        string
+	// SSAI identifies the name of the SSAI vendor
+	// Applicable only in case of incase of video/json endpoint.
+	SSAI string
+
+	ImpID  string `json:"-"`
+	Secure int    `json:"-"`
+}
+
+// Partner partner information to be logged in tracker object
+type Partner struct {
+	PartnerID  string
+	BidderCode string
+	KGPV       string
+	GrossECPM  float64
+	NetECPM    float64
+	BidID      string
+	OrigBidID  string
+}
diff --git a/modules/pubmatic/openwrap/models/tracking.go b/modules/pubmatic/openwrap/models/tracking.go
new file mode 100644
index 000000000..047a74fae
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/tracking.go
@@ -0,0 +1,66 @@
+package models
+
+// impression tracker url parameters
+const (
+	// constants for query parameter names for tracker call
+	TRKPubID             = "pubid"
+	TRKPageURL           = "purl"
+	TRKTimestamp         = "tst"
+	TRKIID               = "iid"
+	TRKProfileID         = "pid"
+	TRKVersionID         = "pdvid"
+	TRKIP                = "ip"
+	TRKUserAgent         = "ua"
+	TRKSlotID            = "slot"
+	TRKAdunit            = "au"
+	TRKRewardedInventory = "rwrd"
+	TRKPartnerID         = "pn"
+	TRKBidderCode        = "bc"
+	TRKKGPV              = "kgpv"
+	TRKGrossECPM         = "eg"
+	TRKNetECPM           = "en"
+	TRKBidID             = "bidid"
+	TRKOrigBidID         = "origbidid"
+	TRKQMARK             = "?"
+	TRKAmpersand         = "&"
+	TRKSSAI              = "ssai"
+)
+
+// video error tracker url parameters
+const (
+	ERROperIDValue    = "8"
+	ERROperID         = "operId"
+	ERROperIDParam    = ERROperID + "=" + ERROperIDValue
+	ERRPubID          = "p"
+	ERRProfileID      = "pid"
+	ERRVersionID      = "v"
+	ERRTimestamp      = "ts"
+	ERRPartnerID      = "pn"
+	ERRBidderCode     = "bc"
+	ERRAdunit         = "au"
+	ERRCreativeID     = "crId"
+	ERRErrorCode      = "ier"
+	ERRErrorCodeMacro = "[ERRORCODE]"
+	ERRErrorCodeParam = ERRErrorCode + "=" + ERRErrorCodeMacro
+	ERRSUrl           = "sURL" // key represents either domain or bundle from request
+	ERRPlatform       = "pfi"
+	ERRAdvertiser     = "adv"
+	ERRSSAI           = "ssai"
+)
+
+// EventTrackingMacros Video Event Tracker's custom macros
+type EventTrackingMacros string
+
+const (
+	MacroProfileID           EventTrackingMacros = "[PROFILE_ID]"            // Pass Profile ID using this macro
+	MacroProfileVersionID    EventTrackingMacros = "[PROFILE_VERSION]"       // Pass Profile's version ID using this macro
+	MacroUnixTimeStamp       EventTrackingMacros = "[UNIX_TIMESTAMP]"        // Pass Current Unix Time when Event Tracking URL is generated using this macro
+	MacroPlatform            EventTrackingMacros = "[PLATFORM]"              // Pass PubMatic's Platform using this macro
+	MacroWrapperImpressionID EventTrackingMacros = "[WRAPPER_IMPRESSION_ID]" // Pass Wrapper Impression ID using this macro
+	MacroSSAI                EventTrackingMacros = "[SSAI]"                  // Pass SSAI vendor name using this macro
+)
+
+// DspId for Pixel Based Open Measurement
+const (
+	DspId_DV360 = 80
+)
diff --git a/modules/pubmatic/openwrap/models/utils.go b/modules/pubmatic/openwrap/models/utils.go
new file mode 100644
index 000000000..705534dd0
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/utils.go
@@ -0,0 +1,194 @@
+package models
+
+import (
+	"encoding/json"
+	"fmt"
+	"math"
+	"net"
+	"net/http"
+	"net/url"
+	"regexp"
+	"strconv"
+	"strings"
+
+	"github.com/buger/jsonparser"
+)
+
+// IsCTVAPIRequest will return true if reqAPI is from CTV EndPoint
+func IsCTVAPIRequest(api string) bool {
+	return api == "/video/json" || api == "/video/vast" || api == "/video/openrtb"
+}
+
+func GetRequestExtWrapper(request []byte, wrapperLocation ...string) (RequestExtWrapper, error) {
+	extWrapper := RequestExtWrapper{
+		SSAuctionFlag: -1,
+	}
+
+	if len(wrapperLocation) == 0 {
+		wrapperLocation = []string{"ext", "prebid", "bidderparams", "pubmatic", "wrapper"}
+	}
+
+	extWrapperBytes, _, _, err := jsonparser.Get(request, wrapperLocation...)
+	if err != nil {
+		return extWrapper, fmt.Errorf("request.ext.wrapper not found: %v", err)
+	}
+
+	err = json.Unmarshal(extWrapperBytes, &extWrapper)
+	if err != nil {
+		return extWrapper, fmt.Errorf("failed to decode request.ext.wrapper : %v", err)
+	}
+
+	return extWrapper, nil
+}
+
+func GetTest(request []byte) (int64, error) {
+	test, err := jsonparser.GetInt(request, "test")
+	if err != nil {
+		return test, fmt.Errorf("request.test not found: %v", err)
+	}
+	return test, nil
+}
+
+func GetSize(width, height int64) string {
+	return fmt.Sprintf("%dx%d", width, height)
+}
+
+// CreatePartnerKey returns key with partner appended
+func CreatePartnerKey(partner, key string) string {
+	if partner == "" {
+		return key
+	}
+	return key + "_" + partner
+}
+
+// GetAdFormat gets adformat from creative(adm) of the bid
+func GetAdFormat(adm string) string {
+	adFormat := Banner
+	videoRegex, _ := regexp.Compile("<VAST\\s+")
+
+	if videoRegex.MatchString(adm) {
+		adFormat = Video
+	} else {
+		var admJSON map[string]interface{}
+		err := json.Unmarshal([]byte(strings.Replace(adm, "/\\/g", "", -1)), &admJSON)
+		if err == nil && admJSON != nil && admJSON["native"] != nil {
+			adFormat = Native
+		}
+	}
+	return adFormat
+}
+
+func GetRevenueShare(partnerConfig map[string]string) float64 {
+	var revShare float64
+
+	if val, ok := partnerConfig[REVSHARE]; ok {
+		revShare, _ = strconv.ParseFloat(val, 64)
+	}
+	return revShare
+}
+
+func GetNetEcpm(price float64, revShare float64) float64 {
+	if revShare == 0 {
+		return toFixed(price, BID_PRECISION)
+	}
+	price = price * (1 - revShare/100)
+	return toFixed(price, BID_PRECISION)
+}
+
+func GetGrossEcpm(price float64) float64 {
+	return toFixed(price, BID_PRECISION)
+}
+
+func toFixed(num float64, precision int) float64 {
+	output := math.Pow(10, float64(precision))
+	return float64(round(num*output)) / output
+}
+
+func round(num float64) int {
+	return int(num + math.Copysign(0.5, num))
+}
+
+func ExtractDomain(rawURL string) (string, error) {
+	if !strings.HasPrefix(rawURL, "http") {
+		rawURL = "http://" + rawURL
+	}
+
+	u, err := url.Parse(rawURL)
+	if err != nil {
+		return "", err
+	}
+
+	return u.Host, nil
+}
+
+// hybrid/web request would have bidder params prepopulated.
+// TODO: refer request.ext.prebid.channel.name = pbjs instead?
+func IsHybrid(body []byte) bool {
+	_, _, _, err := jsonparser.Get(body, "imp", "[0]", "ext", "prebid", "bidder", "pubmatic")
+	return err == nil
+}
+
+// GetVersionLevelPropertyFromPartnerConfig returns a Version level property from the partner config map
+func GetVersionLevelPropertyFromPartnerConfig(partnerConfigMap map[int]map[string]string, propertyName string) string {
+	if versionLevelConfig, ok := partnerConfigMap[VersionLevelConfigID]; ok && versionLevelConfig != nil {
+		return versionLevelConfig[propertyName]
+	}
+	return ""
+}
+
+const (
+	//The following are the headerds related to IP address
+	XForwarded      = "X-FORWARDED-FOR"
+	SourceIP        = "SOURCE_IP"
+	ClusterClientIP = "X_CLUSTER_CLIENT_IP"
+	RemoteAddr      = "REMOTE_ADDR"
+	RlnClientIP     = "RLNCLIENTIPADDR"
+)
+
+func GetIP(in *http.Request) string {
+	//The IP address priority is as follows:
+	//0. HTTP_RLNCLIENTIPADDR  //For API
+	//1. HTTP_X_FORWARDED_IP
+	//2. HTTP_X_CLUSTER_CLIENT_IP
+	//3. HTTP_SOURCE_IP
+	//4. REMOTE_ADDR
+	ip := in.Header.Get(RlnClientIP)
+	if ip == "" {
+		ip = in.Header.Get(SourceIP)
+		if ip == "" {
+			ip = in.Header.Get(ClusterClientIP)
+			if ip == "" {
+				ip = in.Header.Get(XForwarded)
+				if ip == "" {
+					//RemoteAddr parses the header REMOTE_ADDR
+					ip = in.Header.Get(RemoteAddr)
+					if ip == "" {
+						ip, _, _ = net.SplitHostPort(in.RemoteAddr)
+					}
+				}
+			}
+		}
+	}
+	ips := strings.Split(ip, ",")
+	if len(ips) != 0 {
+		return ips[0]
+	}
+
+	return ""
+}
+
+func Atof(value string, decimalplaces int) (float64, error) {
+
+	floatValue, err := strconv.ParseFloat(value, 64)
+	if err != nil {
+		return 0, err
+	}
+
+	value = fmt.Sprintf("%."+strconv.Itoa(decimalplaces)+"f", floatValue)
+	floatValue, err = strconv.ParseFloat(value, 64)
+	if err != nil {
+		return 0, err
+	}
+
+	return floatValue, nil
+}
diff --git a/modules/pubmatic/openwrap/models/utils_legacy.go b/modules/pubmatic/openwrap/models/utils_legacy.go
new file mode 100644
index 000000000..73bd07988
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/utils_legacy.go
@@ -0,0 +1,17 @@
+package models
+
+import (
+	"encoding/json"
+	"fmt"
+)
+
+func GetRequestExt(ext []byte) (RequestExt, error) {
+	extRequest := RequestExt{}
+
+	err := json.Unmarshal(ext, &extRequest)
+	if err != nil {
+		return extRequest, fmt.Errorf("failed to decode request.ext : %v", err)
+	}
+
+	return extRequest, nil
+}
diff --git a/modules/pubmatic/openwrap/models/video.go b/modules/pubmatic/openwrap/models/video.go
new file mode 100644
index 000000000..fa87aff6a
--- /dev/null
+++ b/modules/pubmatic/openwrap/models/video.go
@@ -0,0 +1,34 @@
+package models
+
+const (
+	//VideoVASTTag video VAST parameter constant
+	VideoVASTTag = "./VAST"
+	//VideoVASTVersion video version parameter constant
+	VideoVASTVersion = "version"
+	//VideoVASTVersion2_0 video version 2.0 parameter constant
+	VideoVASTVersion2_0 = "2.0"
+	//VideoVASTAdWrapperTag video ad/wrapper element constant
+	VideoVASTAdWrapperTag = "./Ad/Wrapper"
+	//VideoVASTAdInLineTag video ad/inline element constant
+	VideoVASTAdInLineTag = "./Ad/InLine"
+	//VideoExtensionsTag video extensions element constant
+	VideoExtensionsTag = "Extensions"
+	//VideoExtensionTag video extension element constant
+	VideoExtensionTag = "Extension"
+	//VideoPricingTag video pricing element constant
+	VideoPricingTag = "Pricing"
+	//VideoPricingModel video model attribute constant
+	VideoPricingModel = "model"
+	//VideoPricingModelCPM video cpm attribute value constant
+	VideoPricingModelCPM = "CPM"
+	//VideoPricingCurrencyUSD video USD default currency constant
+	VideoPricingCurrencyUSD = "USD"
+	//VideoPricingCurrency video currency constant
+	VideoPricingCurrency = "currency"
+	//VideoTagLookupStart video xpath constant
+	VideoTagLookupStart = "./"
+	//VideoTagForwardSlash video forward slash for xpath constant
+	VideoTagForwardSlash = "/"
+	//VideoVAST2ExtensionPriceElement video parameter constant
+	VideoVAST2ExtensionPriceElement = VideoTagLookupStart + VideoExtensionTag + VideoTagForwardSlash + VideoPricingTag
+)
diff --git a/modules/pubmatic/openwrap/module.go b/modules/pubmatic/openwrap/module.go
new file mode 100644
index 000000000..bbf43136e
--- /dev/null
+++ b/modules/pubmatic/openwrap/module.go
@@ -0,0 +1,71 @@
+package openwrap
+
+import (
+	"context"
+	"encoding/json"
+	"runtime/debug"
+
+	"github.com/golang/glog"
+	"github.com/prebid/prebid-server/hooks/hookstage"
+	"github.com/prebid/prebid-server/modules/moduledeps"
+)
+
+// init openwrap module and its dependecies like config, cache, db connection, bidder cfg, etc.
+func Builder(rawCfg json.RawMessage, deps moduledeps.ModuleDeps) (interface{}, error) {
+	return initOpenWrap(rawCfg, deps)
+}
+
+// temporary openwrap changes to support non-pbs apis like openrtb/2.5, openrtb/amp, etc
+// temporary openwrap changes to support non-ortb fields like request.ext.wrapper
+func (m OpenWrap) HandleEntrypointHook(
+	ctx context.Context,
+	miCtx hookstage.ModuleInvocationContext,
+	payload hookstage.EntrypointPayload,
+) (hookstage.HookResult[hookstage.EntrypointPayload], error) {
+	defer func() {
+		if r := recover(); r != nil {
+			glog.Error("body:" + string(payload.Body) + ". stacktrace:" + string(debug.Stack()))
+		}
+	}()
+
+	return m.handleEntrypointHook(ctx, miCtx, payload)
+}
+
+// changes to init the request ctx with profile and request details
+func (m OpenWrap) HandleBeforeValidationHook(
+	ctx context.Context,
+	miCtx hookstage.ModuleInvocationContext,
+	payload hookstage.BeforeValidationRequestPayload,
+) (hookstage.HookResult[hookstage.BeforeValidationRequestPayload], error) {
+	defer func() {
+		if r := recover(); r != nil {
+			request, err := json.Marshal(payload)
+			if err != nil {
+				glog.Error("request:" + string(request) + ". err: " + err.Error() + ". stacktrace:" + string(debug.Stack()))
+				return
+			}
+			glog.Error("request:" + string(request) + ". stacktrace:" + string(debug.Stack()))
+		}
+	}()
+
+	return m.handleBeforeValidationHook(ctx, miCtx, payload)
+}
+
+func (m OpenWrap) HandleAuctionResponseHook(
+	ctx context.Context,
+	miCtx hookstage.ModuleInvocationContext,
+	payload hookstage.AuctionResponsePayload,
+) (hookstage.HookResult[hookstage.AuctionResponsePayload], error) {
+	defer func() {
+		if r := recover(); r != nil {
+			response, err := json.Marshal(payload)
+			if err != nil {
+				glog.Error("response:" + string(response) + ". err: " + err.Error() + ". stacktrace:" + string(debug.Stack()))
+				return
+			}
+			glog.Error("response:" + string(response) + ". stacktrace:" + string(debug.Stack()))
+		}
+	}()
+
+	return m.handleAuctionResponseHook(ctx, miCtx, payload)
+}
diff --git a/modules/pubmatic/openwrap/openwrap.go b/modules/pubmatic/openwrap/openwrap.go
new file mode 100644
index 000000000..2ef08b3dc
--- /dev/null
+++ b/modules/pubmatic/openwrap/openwrap.go
@@ -0,0 +1,87 @@
+package openwrap
+
+import (
+	"database/sql"
+	"encoding/json"
+	"errors"
+	"fmt"
+	"strings"
+	"time"
+
+	"github.com/golang/glog"
+	gocache "github.com/patrickmn/go-cache"
+	"github.com/prebid/prebid-server/modules/moduledeps"
+	ow_adapters "github.com/prebid/prebid-server/modules/pubmatic/openwrap/adapters"
+	cache "github.com/prebid/prebid-server/modules/pubmatic/openwrap/cache"
+	ow_gocache "github.com/prebid/prebid-server/modules/pubmatic/openwrap/cache/gocache"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/config"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/database/mysql"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+const (
+	CACHE_EXPIRY_ROUTINE_RUN_INTERVAL = 1 * time.Minute
+)
+
+type OpenWrap struct {
+	cfg   config.Config
+	cache cache.Cache
+}
+
+func initOpenWrap(rawCfg json.RawMessage, _ moduledeps.ModuleDeps) (OpenWrap, error) {
+	cfg := config.Config{}
+
+	err := json.Unmarshal(rawCfg, &cfg)
+	if err != nil {
+		return OpenWrap{}, fmt.Errorf("invalid openwrap config: %v", err)
+	}
+	patchConfig(&cfg)
+
+	glog.Info("Connecting to OpenWrap database...")
+	mysqlDriver, err := open("mysql", cfg.Database)
+	if err != nil {
+		return OpenWrap{}, fmt.Errorf("failed to open db connection: %v", err)
+	}
+	db := mysql.New(mysqlDriver, cfg.Database)
+
+	// NYC_TODO: replace this with freecache and use concrete structure
+	cache := gocache.New(time.Duration(cfg.Cache.CacheDefaultExpiry)*time.Second, CACHE_EXPIRY_ROUTINE_RUN_INTERVAL)
+	if cache == nil {
+		return OpenWrap{}, errors.New("error while initializing cache")
+	}
+
+	// NYC_TODO: remove this dependency
+	if err := ow_adapters.InitBidders(cfg); err != nil {
+		return OpenWrap{}, errors.New("error while initializing bidder params")
+	}
+
+	return OpenWrap{
+		cfg:   cfg,
+		cache: ow_gocache.New(cache, db, cfg.Cache),
+	}, nil
+}
+
+func open(driverName string, cfg config.Database) (*sql.DB, error) {
+	dataSourceName := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s", cfg.User, cfg.Pass, cfg.Host, cfg.Port, cfg.Database)
+
+	db, err := sql.Open(driverName, dataSourceName)
+	if err != nil {
+		return nil, err
+	}
+
+	db.SetMaxIdleConns(cfg.IdleConnection)
+	db.SetMaxOpenConns(cfg.MaxConnection)
+	db.SetConnMaxLifetime(time.Second * time.Duration(cfg.ConnMaxLifeTime))
+
+	err = db.Ping()
+	if err != nil {
+		return nil, err
+	}
+
+	return db, nil
+}
+
+func patchConfig(cfg *config.Config) {
+	cfg.Server.HostName = getHostName()
+	models.TrackerCallWrapOMActive = strings.Replace(models.TrackerCallWrapOMActive, "${OMScript}", cfg.PixelView.OMScript, 1)
+}
diff --git a/modules/pubmatic/openwrap/price_granularity.go b/modules/pubmatic/openwrap/price_granularity.go
new file mode 100644
index 000000000..ccec99039
--- /dev/null
+++ b/modules/pubmatic/openwrap/price_granularity.go
@@ -0,0 +1,53 @@
+package openwrap
+
+import (
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func computePriceGranularity(rctx models.RequestCtx) (openrtb_ext.PriceGranularity, error) {
+	//Get the value of priceGranularity from config
+	priceGranularity := models.GetVersionLevelPropertyFromPartnerConfig(rctx.PartnerConfigMap, models.PriceGranularityKey)
+	//  OTT-769: determine custom pg object based on customPriceGranularityValue config
+	//  Expected that this check with be true iff platform is video / isCTVAPIRequest
+	if priceGranularity == models.PriceGranularityCustom {
+		customPriceGranularityValue := models.GetVersionLevelPropertyFromPartnerConfig(rctx.PartnerConfigMap, models.PriceGranularityCustomConfig)
+		pgObject, err := newCustomPriceGranuality(customPriceGranularityValue)
+		return pgObject, err
+	}
+
+	if priceGranularity == "" || (priceGranularity == models.PriceGranularityCustom && !rctx.IsCTVRequest) {
+		// If it is empty then use default value as 'auto'
+		// If it is custom but not CTV request then use default value as 'a
+		priceGranularity = "auto"
+	} else if rctx.IsTestRequest > 0 && rctx.IsCTVRequest {
+		//OTT-603: Adding test flag check
+		priceGranularity = "testpg"
+	}
+
+	// OTT-769: (Backword compatibilty) compute based on legacy string (auto, med)
+	pgObject, _ := openrtb_ext.NewPriceGranularityFromLegacyID(priceGranularity)
+
+	return pgObject, nil
+}
+
+// newCustomPriceGranuality constructs the Custom PriceGranularity Object based on input
+// customPGValue
+// if pg ranges are not present inside customPGValue then this function by default
+// returns Medium Price Granularity Object
+// So, caller of this function must ensure that customPGValue has valid pg ranges
+// Optimization (Not implemented) : we can think of - only do unmarshal once if haven't done before
+func newCustomPriceGranuality(customPGValue string) (openrtb_ext.PriceGranularity, error) {
+	// Assumptions
+	// 1. customPriceGranularityValue will never be empty
+	// 2. customPriceGranularityValue will not be legacy string viz. auto, dense
+	// 3. ranges are specified inside customPriceGranularityValue
+	pg := openrtb_ext.PriceGranularity{}
+	err := pg.UnmarshalJSON([]byte(customPGValue))
+	if err != nil {
+		return pg, err
+	}
+	// Overwrite always to 2
+	pg.Precision = getIntPtr(2)
+	return pg, nil
+}
diff --git a/modules/pubmatic/openwrap/processedauctionhook.go b/modules/pubmatic/openwrap/processedauctionhook.go
new file mode 100644
index 000000000..5f9c23867
--- /dev/null
+++ b/modules/pubmatic/openwrap/processedauctionhook.go
@@ -0,0 +1,38 @@
+package openwrap
+
+import (
+	"context"
+
+	"github.com/prebid/prebid-server/hooks/hookstage"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+func (m OpenWrap) HandleProcessedAuctionHook(
+	ctx context.Context,
+	moduleCtx hookstage.ModuleInvocationContext,
+	payload hookstage.ProcessedAuctionRequestPayload,
+) (hookstage.HookResult[hookstage.ProcessedAuctionRequestPayload], error) {
+	result := hookstage.HookResult[hookstage.ProcessedAuctionRequestPayload]{}
+	result.ChangeSet = hookstage.ChangeSet[hookstage.ProcessedAuctionRequestPayload]{}
+
+	if len(moduleCtx.ModuleContext) == 0 {
+		result.DebugMessages = append(result.DebugMessages, "error: module-ctx not found in handleBeforeValidationHook()")
+		return result, nil
+	}
+	rctx, ok := moduleCtx.ModuleContext["rctx"].(models.RequestCtx)
+	if !ok {
+		result.DebugMessages = append(result.DebugMessages, "error: request-ctx not found in handleBeforeValidationHook()")
+		return result, nil
+	}
+
+	ip := rctx.IP
+
+	result.ChangeSet.AddMutation(func(parp hookstage.ProcessedAuctionRequestPayload) (hookstage.ProcessedAuctionRequestPayload, error) {
+		if parp.BidRequest.Device != nil && (parp.BidRequest.Device.IP == "" && parp.BidRequest.Device.IPv6 == "") {
+			parp.BidRequest.Device.IP = ip
+		}
+		return parp, nil
+	}, hookstage.MutationUpdate, "update-device-ip")
+
+	return result, nil
+}
diff --git a/modules/pubmatic/openwrap/profiledata.go b/modules/pubmatic/openwrap/profiledata.go
new file mode 100644
index 000000000..00dc09295
--- /dev/null
+++ b/modules/pubmatic/openwrap/profiledata.go
@@ -0,0 +1,20 @@
+package openwrap
+
+import (
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+func (m OpenWrap) getProfileData(rCtx models.RequestCtx, bidRequest openrtb2.BidRequest) (map[int]map[string]string, error) {
+	if rCtx.IsTestRequest == 2 { // skip db data for test=2
+		//get platform from request, since test mode can be enabled for display and app platform only
+		var platform string // TODO: should we've some default platform value
+		if bidRequest.App != nil {
+			platform = models.PLATFORM_APP
+		}
+
+		return getTestModePartnerConfigMap(rCtx.PubID, rCtx.ProfileID, rCtx.DisplayID, platform), nil
+	}
+
+	return m.cache.GetPartnerConfigMap(rCtx.PubID, rCtx.ProfileID, rCtx.DisplayID)
+}
diff --git a/modules/pubmatic/openwrap/schain.go b/modules/pubmatic/openwrap/schain.go
new file mode 100644
index 000000000..ab493ec21
--- /dev/null
+++ b/modules/pubmatic/openwrap/schain.go
@@ -0,0 +1,30 @@
+package openwrap
+
+import (
+	"github.com/buger/jsonparser"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+func getSChainObj(partnerConfigMap map[int]map[string]string) []byte {
+	if partnerConfigMap != nil && partnerConfigMap[models.VersionLevelConfigID] != nil {
+		if partnerConfigMap[models.VersionLevelConfigID][models.SChainDBKey] == "1" {
+			sChainObjJSON := partnerConfigMap[models.VersionLevelConfigID][models.SChainObjectDBKey]
+			v, _, _, _ := jsonparser.Get([]byte(sChainObjJSON), "config")
+			return v
+		}
+	}
+	return nil
+}
+
+// setSchainInSourceObject sets schain object in source.ext.schain
+func setSchainInSourceObject(source *openrtb2.Source, schain []byte) {
+	if source.Ext == nil {
+		source.Ext = []byte("{}")
+	}
+
+	sourceExt, err := jsonparser.Set(source.Ext, schain, models.SChainKey)
+	if err != nil {
+		source.Ext = sourceExt
+	}
+}
diff --git a/modules/pubmatic/openwrap/targeting.go b/modules/pubmatic/openwrap/targeting.go
new file mode 100644
index 000000000..1ec4f911b
--- /dev/null
+++ b/modules/pubmatic/openwrap/targeting.go
@@ -0,0 +1,110 @@
+package openwrap
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+// whitelist of prebid targeting keys
+var prebidTargetingKeysWhitelist = map[string]struct{}{
+	string(openrtb_ext.HbpbConstantKey): {},
+	models.HbBuyIdPubmaticConstantKey:   {},
+	// OTT - 18 Deal priortization support
+	// this key required to send deal prefix and priority
+	string(openrtb_ext.HbCategoryDurationKey): {},
+}
+
+// check if prebid targeting keys are whitelisted
+func allowTargetingKey(key string) bool {
+	if _, ok := prebidTargetingKeysWhitelist[key]; ok {
+		return true
+	}
+	return strings.HasPrefix(key, models.HbBuyIdPrefix)
+}
+
+func addPWTTargetingForBid(rctx models.RequestCtx, bidResponse *openrtb2.BidResponse) (droppedBids map[string][]openrtb2.Bid, warnings []string) {
+	if rctx.Platform != models.PLATFORM_APP {
+		return
+	}
+
+	if !rctx.SendAllBids {
+		droppedBids = make(map[string][]openrtb2.Bid)
+	}
+
+	//setTargeting needs a seperate loop as final winner would be decided after all the bids are processed by auction
+	for _, seatBid := range bidResponse.SeatBid {
+		for _, bid := range seatBid.Bid {
+			impCtx, ok := rctx.ImpBidCtx[bid.ImpID]
+			if !ok {
+				continue
+			}
+
+			isWinningBid := false
+			if b, ok := rctx.WinningBids[bid.ImpID]; ok && b.ID == bid.ID {
+				isWinningBid = true
+			}
+
+			if !(isWinningBid || rctx.SendAllBids) {
+				droppedBids[seatBid.Seat] = append(droppedBids[seatBid.Seat], bid)
+			}
+
+			bidCtx, ok := impCtx.BidCtx[bid.ID]
+			if !ok {
+				continue
+			}
+
+			newTargeting := make(map[string]string)
+			for key, value := range bidCtx.Prebid.Targeting {
+				if allowTargetingKey(key) {
+					updatedKey := key
+					if strings.HasPrefix(key, models.PrebidTargetingKeyPrefix) {
+						updatedKey = strings.Replace(key, models.PrebidTargetingKeyPrefix, models.OWTargetingKeyPrefix, 1)
+					}
+					newTargeting[updatedKey] = value
+				}
+				delete(bidCtx.Prebid.Targeting, key)
+			}
+
+			bidCtx.Prebid.Targeting = newTargeting
+			bidCtx.Prebid.Targeting[models.CreatePartnerKey(seatBid.Seat, models.PWT_SLOTID)] = bid.ID
+			bidCtx.Prebid.Targeting[models.CreatePartnerKey(seatBid.Seat, models.PWT_SZ)] = models.GetSize(bid.W, bid.H)
+			bidCtx.Prebid.Targeting[models.CreatePartnerKey(seatBid.Seat, models.PWT_PARTNERID)] = seatBid.Seat
+			bidCtx.Prebid.Targeting[models.CreatePartnerKey(seatBid.Seat, models.PWT_ECPM)] = fmt.Sprintf("%.2f", bidCtx.NetECPM)
+			bidCtx.Prebid.Targeting[models.CreatePartnerKey(seatBid.Seat, models.PWT_PLATFORM)] = getPlatformName(rctx.Platform)
+			bidCtx.Prebid.Targeting[models.CreatePartnerKey(seatBid.Seat, models.PWT_BIDSTATUS)] = "1"
+			if len(bid.DealID) != 0 {
+				bidCtx.Prebid.Targeting[models.CreatePartnerKey(seatBid.Seat, models.PWT_DEALID)] = bid.DealID
+			}
+
+			if isWinningBid {
+				if rctx.SendAllBids {
+					bidCtx.Winner = 1
+				}
+
+				bidCtx.Prebid.Targeting[models.PWT_SLOTID] = bid.ID
+				bidCtx.Prebid.Targeting[models.PWT_BIDSTATUS] = "1"
+				bidCtx.Prebid.Targeting[models.PWT_SZ] = models.GetSize(bid.W, bid.H)
+				bidCtx.Prebid.Targeting[models.PWT_PARTNERID] = seatBid.Seat
+				bidCtx.Prebid.Targeting[models.PWT_ECPM] = fmt.Sprintf("%.2f", bidCtx.NetECPM)
+				bidCtx.Prebid.Targeting[models.PWT_PLATFORM] = getPlatformName(rctx.Platform)
+				if len(bid.DealID) != 0 {
+					bidCtx.Prebid.Targeting[models.PWT_DEALID] = bid.DealID
+				}
+			} else if !rctx.SendAllBids {
+				warnings = append(warnings, "dropping bid "+bid.ID+" as sendAllBids is disabled")
+			}
+
+			// cache for bid details for logger and tracker
+			if impCtx.BidCtx == nil {
+				impCtx.BidCtx = make(map[string]models.BidCtx)
+			}
+			impCtx.BidCtx[bid.ID] = bidCtx
+			rctx.ImpBidCtx[bid.ImpID] = impCtx
+		}
+	}
+	return
+}
diff --git a/modules/pubmatic/openwrap/tracker/banner.go b/modules/pubmatic/openwrap/tracker/banner.go
new file mode 100644
index 000000000..81de07504
--- /dev/null
+++ b/modules/pubmatic/openwrap/tracker/banner.go
@@ -0,0 +1,29 @@
+package tracker
+
+import (
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+	"github.com/prebid/prebid-server/openrtb_ext"
+)
+
+func injectBannerTracker(rctx models.RequestCtx, tracker models.OWTracker, bid openrtb2.Bid, seat string) string {
+	var replacedTrackerStr, trackerFormat string
+	trackerFormat = models.TrackerCallWrap
+	if trackerWithOM(tracker, bid, rctx.Platform, seat) {
+		trackerFormat = models.TrackerCallWrapOMActive
+	}
+	replacedTrackerStr = strings.Replace(trackerFormat, "${escapedUrl}", tracker.TrackerURL, 1)
+	return bid.AdM + replacedTrackerStr
+}
+
+// TrackerWithOM checks for OM active condition for DV360
+func trackerWithOM(tracker models.OWTracker, bid openrtb2.Bid, platform, bidderCode string) bool {
+	if platform == models.PLATFORM_APP && bidderCode == string(openrtb_ext.BidderPubmatic) {
+		if tracker.DspId == models.DspId_DV360 {
+			return true
+		}
+	}
+	return false
+}
diff --git a/modules/pubmatic/openwrap/tracker/create.go b/modules/pubmatic/openwrap/tracker/create.go
new file mode 100644
index 000000000..35303c3a1
--- /dev/null
+++ b/modules/pubmatic/openwrap/tracker/create.go
@@ -0,0 +1,300 @@
+package tracker
+
+import (
+	"bytes"
+	"fmt"
+	"net/url"
+	"strconv"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/bidderparams"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+func CreateTrackers(rctx models.RequestCtx, bidResponse *openrtb2.BidResponse) map[string]models.OWTracker {
+	trackers := make(map[string]models.OWTracker)
+
+	// pubmatic's KGP details per impression
+	type pubmaticMarketplaceMeta struct {
+		PubmaticKGP, PubmaticKGPV, PubmaticKGPSV string
+	}
+	pmMkt := make(map[string]pubmaticMarketplaceMeta)
+
+	for _, seatBid := range bidResponse.SeatBid {
+		for _, bid := range seatBid.Bid {
+			tracker := models.Tracker{
+				PubID:     rctx.PubID,
+				ProfileID: fmt.Sprintf("%d", rctx.ProfileID),
+				VersionID: fmt.Sprintf("%d", rctx.DisplayID),
+				PageURL:   rctx.PageURL,
+				Timestamp: rctx.StartTime,
+				IID:       rctx.LoggerImpressionID,
+				Platform:  int(rctx.DevicePlatform),
+				SSAI:      rctx.SSAI,
+				ImpID:     bid.ImpID,
+			}
+
+			tagid := ""
+			netECPM := float64(0)
+			matchedSlot := ""
+			price := bid.Price
+			isRewardInventory := 0
+			partnerID := seatBid.Seat
+			bidType := "banner"
+			var dspId int
+
+			var isRegex bool
+			var kgp, kgpv, kgpsv string
+
+			if impCtx, ok := rctx.ImpBidCtx[bid.ImpID]; ok {
+				if bidderMeta, ok := impCtx.Bidders[seatBid.Seat]; ok {
+					matchedSlot = bidderMeta.MatchedSlot
+					partnerID = bidderMeta.PrebidBidderCode
+				}
+
+				if bidCtx, ok := impCtx.BidCtx[bid.ID]; ok {
+					if bidResponse.Cur != "USD" {
+						price = bidCtx.OriginalBidCPMUSD
+					}
+					netECPM = bidCtx.NetECPM
+
+					// TODO do most calculation in wt
+					// marketplace/alternatebiddercodes feature
+					bidExt := bidCtx.BidExt
+					if bidExt.Prebid != nil && bidExt.Prebid.Meta != nil && len(bidExt.Prebid.Meta.AdapterCode) != 0 && seatBid.Seat != bidExt.Prebid.Meta.AdapterCode {
+						partnerID = bidExt.Prebid.Meta.AdapterCode
+
+						if aliasSeat, ok := rctx.PrebidBidderCode[partnerID]; ok {
+							if bidderMeta, ok := impCtx.Bidders[aliasSeat]; ok {
+								matchedSlot = bidderMeta.MatchedSlot
+							}
+						}
+					}
+					bidType = bidCtx.CreativeType
+					dspId = bidCtx.DspId
+				}
+
+				_ = matchedSlot
+				// --------------------------------------------------------------------------------------------------
+				// Move this code to a function. Confirm the kgp, kgpv, kgpsv relation in wt and wl.
+				// --------------------------------------------------------------------------------------------------
+				// var kgp, kgpv, kgpsv string
+
+				if bidderMeta, ok := impCtx.Bidders[seatBid.Seat]; ok {
+					partnerID = bidderMeta.PrebidBidderCode
+					kgp = bidderMeta.KGP
+					kgpv = bidderMeta.KGPV
+					kgpsv = bidderMeta.MatchedSlot
+					isRegex = bidderMeta.IsRegex
+				}
+
+				// 1. nobid
+				if bid.Price == 0 && bid.H == 0 && bid.W == 0 {
+					//NOTE: kgpsv = bidderMeta.MatchedSlot above. Use the same
+					if !isRegex && kgpv != "" { // unmapped pubmatic's slot
+						kgpsv = kgpv
+					} else if !isRegex {
+						kgpv = kgpsv
+					}
+				} else if !isRegex {
+					if kgpv != "" { // unmapped pubmatic's slot
+						kgpsv = kgpv
+					} else if bid.H != 0 && bid.W != 0 { // Check when bid.H and bid.W will be zero with Price !=0. Ex: MobileInApp-MultiFormat-OnlyBannerMapping_Criteo_Partner_Validaton
+						// 2. valid bid
+						// kgpv has regex, do not generate slotName again
+						// kgpsv could be unmapped or mapped slot, generate slotName again based on bid.H and bid.W
+						kgpsv := bidderparams.GenerateSlotName(bid.H, bid.W, kgp, impCtx.TagID, impCtx.Div, rctx.Source)
+						kgpv = kgpsv
+					}
+				}
+
+				if kgpv == "" {
+					kgpv = kgpsv
+				}
+				// --------------------------------------------------------------------------------------------------
+
+				tagid = impCtx.TagID
+				tracker.Secure = impCtx.Secure
+				isRewardInventory = getRewardedInventoryFlag(rctx.ImpBidCtx[bid.ImpID].IsRewardInventory)
+			}
+
+			if seatBid.Seat == "pubmatic" {
+				pmMkt[bid.ImpID] = pubmaticMarketplaceMeta{
+					PubmaticKGP:   kgp,
+					PubmaticKGPV:  kgpv,
+					PubmaticKGPSV: kgpsv,
+				}
+			}
+
+			tracker.Adunit = tagid
+			tracker.SlotID = fmt.Sprintf("%s_%s", bid.ImpID, tagid)
+			tracker.RewardedInventory = isRewardInventory
+			tracker.PartnerInfo = models.Partner{
+				PartnerID:  partnerID,
+				BidderCode: seatBid.Seat,
+				BidID:      bid.ID,
+				OrigBidID:  bid.ID,
+				KGPV:       kgpv,
+				NetECPM:    float64(netECPM),
+				GrossECPM:  models.GetGrossEcpm(price),
+			}
+
+			if len(bid.ADomain) != 0 {
+				if domain, err := models.ExtractDomain(bid.ADomain[0]); err == nil {
+					tracker.Advertiser = domain
+				}
+			}
+
+			var finalTrackerURL string
+			trackerURL := ConstructTrackerURL(rctx, tracker)
+			trackURL, err := url.Parse(trackerURL)
+			if err == nil {
+				trackURL.Scheme = models.HTTPSProtocol
+				finalTrackerURL = trackURL.String()
+			}
+
+			trackers[bid.ID] = models.OWTracker{
+				Tracker:       tracker,
+				TrackerURL:    finalTrackerURL,
+				Price:         price,
+				PriceModel:    models.VideoPricingModelCPM,
+				PriceCurrency: bidResponse.Cur,
+				ErrorURL:      ConstructVideoErrorURL(rctx, rctx.VideoErrorTrackerEndpoint, bid, tracker),
+				BidType:       bidType,
+				DspId:         dspId,
+			}
+		}
+	}
+
+	// overwrite marketplace bid details with that of parent bidder
+	for bidID, tracker := range trackers {
+		if _, ok := rctx.MarketPlaceBidders[tracker.Tracker.PartnerInfo.BidderCode]; ok {
+			if v, ok := pmMkt[tracker.Tracker.ImpID]; ok {
+				tracker.Tracker.PartnerInfo.PartnerID = "pubmatic"
+				tracker.Tracker.PartnerInfo.KGPV = v.PubmaticKGPV
+			}
+		}
+
+		var finalTrackerURL string
+		trackerURL := ConstructTrackerURL(rctx, tracker.Tracker)
+		trackURL, err := url.Parse(trackerURL)
+		if err == nil {
+			trackURL.Scheme = models.HTTPSProtocol
+			finalTrackerURL = trackURL.String()
+		}
+		tracker.TrackerURL = finalTrackerURL
+
+		trackers[bidID] = tracker
+	}
+
+	return trackers
+}
+
+func getRewardedInventoryFlag(reward *int8) int {
+	if reward != nil {
+		return int(*reward)
+	}
+	return 0
+}
+
+// ConstructTrackerURL constructing tracker url for impression
+func ConstructTrackerURL(rctx models.RequestCtx, tracker models.Tracker) string {
+	trackerURL, err := url.Parse(rctx.TrackerEndpoint)
+	if err != nil {
+		return ""
+	}
+
+	v := url.Values{}
+	v.Set(models.TRKPubID, strconv.Itoa(tracker.PubID))
+	v.Set(models.TRKPageURL, tracker.PageURL)
+	v.Set(models.TRKTimestamp, strconv.FormatInt(tracker.Timestamp, 10))
+	v.Set(models.TRKIID, tracker.IID)
+	v.Set(models.TRKProfileID, tracker.ProfileID)
+	v.Set(models.TRKVersionID, tracker.VersionID)
+	v.Set(models.TRKSlotID, tracker.SlotID)
+	v.Set(models.TRKAdunit, tracker.Adunit)
+	if tracker.RewardedInventory == 1 {
+		v.Set(models.TRKRewardedInventory, strconv.Itoa(tracker.RewardedInventory))
+	}
+	partner := tracker.PartnerInfo
+	v.Set(models.TRKPartnerID, partner.PartnerID)
+	v.Set(models.TRKBidderCode, partner.BidderCode)
+	v.Set(models.TRKKGPV, partner.KGPV)
+	v.Set(models.TRKGrossECPM, fmt.Sprint(partner.GrossECPM))
+	v.Set(models.TRKNetECPM, fmt.Sprint(partner.NetECPM))
+	v.Set(models.TRKBidID, partner.BidID)
+	if tracker.SSAI != "" {
+		v.Set(models.TRKSSAI, tracker.SSAI)
+	}
+	v.Set(models.TRKOrigBidID, partner.OrigBidID)
+	queryString := v.Encode()
+
+	//Code for making tracker call http/https based on secure flag for in-app platform
+	//TODO change platform to models.PLATFORM_APP once in-app platform starts populating from wrapper UI
+	if rctx.Platform == models.PLATFORM_DISPLAY {
+		if tracker.Secure == 1 {
+			trackerURL.Scheme = "https"
+		} else {
+			trackerURL.Scheme = "http"
+		}
+
+	}
+	trackerQueryStr := trackerURL.String() + models.TRKQMARK + queryString
+	return trackerQueryStr
+}
+
+// ConstructVideoErrorURL constructing video error url for video impressions
+func ConstructVideoErrorURL(rctx models.RequestCtx, errorURLString string, bid openrtb2.Bid, tracker models.Tracker) string {
+	if len(errorURLString) == 0 {
+		return ""
+	}
+
+	errorURL, err := url.Parse(errorURLString)
+	if err != nil {
+		return ""
+	}
+
+	errorURL.Scheme = models.HTTPSProtocol
+	tracker.SURL = rctx.OriginCookie
+
+	//operId Note: It should be first parameter in url otherwise it will get failed at analytics side.
+	if len(errorURL.RawQuery) > 0 {
+		errorURL.RawQuery = models.ERROperIDParam + models.TRKAmpersand + errorURL.RawQuery
+	} else {
+		errorURL.RawQuery = models.ERROperIDParam
+	}
+
+	v := url.Values{}
+	v.Set(models.ERRPubID, strconv.Itoa(tracker.PubID))                  //pubId
+	v.Set(models.ERRProfileID, tracker.ProfileID)                        //profileId
+	v.Set(models.ERRVersionID, tracker.VersionID)                        //versionId
+	v.Set(models.ERRTimestamp, strconv.FormatInt(tracker.Timestamp, 10)) //ts
+	v.Set(models.ERRPartnerID, tracker.PartnerInfo.PartnerID)            //pid
+	v.Set(models.ERRBidderCode, tracker.PartnerInfo.BidderCode)          //bc
+	v.Set(models.ERRAdunit, tracker.Adunit)                              //au
+	v.Set(models.ERRSUrl, tracker.SURL)                                  // sURL
+	v.Set(models.ERRPlatform, strconv.Itoa(tracker.Platform))            // pfi
+	v.Set(models.ERRAdvertiser, tracker.Advertiser)                      // adv
+
+	if tracker.SSAI != "" {
+		v.Set(models.ERRSSAI, tracker.SSAI) // ssai for video/json endpoint
+	}
+
+	if bid.CrID == "" {
+		v.Set(models.ERRCreativeID, "-1")
+	} else {
+		v.Set(models.ERRCreativeID, bid.CrID) //creativeId
+	}
+
+	var out bytes.Buffer
+	out.WriteString(errorURL.String())
+	out.WriteString(models.TRKAmpersand)
+	out.WriteString(v.Encode())
+	out.WriteString(models.TRKAmpersand)
+	out.WriteString(models.ERRErrorCodeParam) //ier
+
+	//queryString +=
+	errorURLQueryStr := out.String()
+
+	return errorURLQueryStr
+}
diff --git a/modules/pubmatic/openwrap/tracker/inject.go b/modules/pubmatic/openwrap/tracker/inject.go
new file mode 100644
index 000000000..fc11bd93d
--- /dev/null
+++ b/modules/pubmatic/openwrap/tracker/inject.go
@@ -0,0 +1,42 @@
+package tracker
+
+import (
+	"fmt"
+
+	"github.com/pkg/errors"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+func InjectTrackers(rctx models.RequestCtx, bidResponse *openrtb2.BidResponse) (*openrtb2.BidResponse, error) {
+	var errs error
+	for i, seatBid := range bidResponse.SeatBid {
+		for j, bid := range seatBid.Bid {
+			tracker := rctx.Trackers[bid.ID]
+			adformat := tracker.BidType
+			if rctx.Platform == models.PLATFORM_VIDEO {
+				adformat = "video"
+			}
+
+			switch adformat {
+			case models.Banner:
+				bidResponse.SeatBid[i].Bid[j].AdM = injectBannerTracker(rctx, tracker, bidResponse.SeatBid[i].Bid[j], seatBid.Seat)
+			case models.Video:
+				// trackers := make([]models.OWTracker, 0, len(rctx.Trackers))
+				// for _, tracker := range rctx.Trackers {
+				// 	trackers = append(trackers, tracker)
+				// }
+				trackers := []models.OWTracker{tracker}
+				var err error
+				bidResponse.SeatBid[i].Bid[j].AdM, err = injectVideoCreativeTrackers(bid, trackers)
+				if err != nil {
+					errs = errors.Wrap(errs, fmt.Sprintf("failed to inject tracker for bidid %s with error %s", bid.ID, err.Error()))
+				}
+			case models.Native:
+			default:
+				errs = errors.Wrap(errs, fmt.Sprintf("Invalid adformat %s for bidid %s", adformat, bid.ID))
+			}
+		}
+	}
+	return bidResponse, errs
+}
diff --git a/modules/pubmatic/openwrap/tracker/tracker.go b/modules/pubmatic/openwrap/tracker/tracker.go
new file mode 100644
index 000000000..e8e1c820c
--- /dev/null
+++ b/modules/pubmatic/openwrap/tracker/tracker.go
@@ -0,0 +1,42 @@
+package tracker
+
+import (
+	"fmt"
+	"net/url"
+
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+func GetTrackerInfo(rCtx models.RequestCtx) string {
+	tracker := models.Tracker{
+		PubID:     rCtx.PubID,
+		ProfileID: fmt.Sprintf("%d", rCtx.ProfileID),
+		VersionID: fmt.Sprintf("%d", rCtx.DisplayID),
+		PageURL:   rCtx.PageURL,
+		Timestamp: rCtx.StartTime,
+		IID:       rCtx.LoggerImpressionID,
+		Platform:  int(rCtx.DevicePlatform),
+	}
+
+	constructedURLString := ConstructTrackerURL(rCtx, tracker)
+
+	trackerURL, err := url.Parse(constructedURLString)
+	if err != nil {
+		return ""
+	}
+
+	params := trackerURL.Query()
+	params.Set(models.TRKPartnerID, models.MacroPartnerName)
+	params.Set(models.TRKBidderCode, models.MacroBidderCode)
+	params.Set(models.TRKKGPV, models.MacroKGPV)
+	params.Set(models.TRKGrossECPM, models.MacroGrossECPM)
+	params.Set(models.TRKNetECPM, models.MacroNetECPM)
+	params.Set(models.TRKBidID, models.MacroBidID)
+	params.Set(models.TRKOrigBidID, models.MacroOrigBidID)
+	params.Set(models.TRKSlotID, models.MacroSlotID)
+	params.Set(models.TRKAdunit, models.MacroAdunit)
+	params.Set(models.TRKRewardedInventory, models.MacroRewarded)
+	trackerURL.RawQuery = params.Encode()
+
+	return trackerURL.String()
+}
diff --git a/modules/pubmatic/openwrap/tracker/video.go b/modules/pubmatic/openwrap/tracker/video.go
new file mode 100644
index 000000000..9e1ef8d52
--- /dev/null
+++ b/modules/pubmatic/openwrap/tracker/video.go
@@ -0,0 +1,157 @@
+package tracker
+
+import (
+	"errors"
+	"fmt"
+	"strings"
+
+	"github.com/beevik/etree"
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+// Inject Trackers in Video Creative
+func injectVideoCreativeTrackers(bid openrtb2.Bid, videoParams []models.OWTracker) (string, error) {
+	if bid.AdM == "" || len(videoParams) == 0 {
+		return "", errors.New("bid is nil or tracker data is missing")
+	}
+
+	originalCreativeStr := bid.AdM
+	if strings.HasPrefix(originalCreativeStr, models.HTTPProtocol) {
+		originalCreativeStr = strings.Replace(models.VastWrapper, models.PartnerURLPlaceholder, originalCreativeStr, -1)
+		originalCreativeStr = strings.Replace(originalCreativeStr, models.TrackerPlaceholder, videoParams[0].TrackerURL, -1)
+		originalCreativeStr = strings.Replace(originalCreativeStr, models.ErrorPlaceholder, videoParams[0].ErrorURL, -1)
+		bid.AdM = originalCreativeStr
+	} else {
+		originalCreativeStr = strings.TrimSpace(originalCreativeStr)
+		doc := etree.NewDocument()
+		if err := doc.ReadFromString(originalCreativeStr); err != nil {
+			return bid.AdM, errors.New("invalid creative format")
+		}
+
+		//Check VAST Object
+		vast := doc.Element.FindElement(models.VideoVASTTag)
+		if vast == nil {
+			return bid.AdM, errors.New("VAST Tag Not Found")
+		}
+
+		//GetVersion
+		version := vast.SelectAttrValue(models.VideoVASTVersion, models.VideoVASTVersion2_0)
+
+		adElements := doc.FindElements(models.VASTAdElement)
+		for i, adElement := range adElements {
+			if i < len(videoParams) {
+				element := adElement.FindElement(models.AdWrapperElement)
+				isWrapper := (nil != element)
+
+				if nil == element {
+					element = adElement.FindElement(models.AdInlineElement)
+				}
+
+				if nil == element {
+					return bid.AdM, errors.New("video creative not in required VAST format")
+				}
+
+				if len(videoParams[i].TrackerURL) > 0 {
+					// set tracker URL
+					newElement := etree.NewElement(models.ImpressionElement)
+					newElement.SetText(videoParams[i].TrackerURL)
+					element.InsertChild(element.SelectElement(models.ImpressionElement), newElement)
+				}
+
+				if len(videoParams[i].ErrorURL) > 0 {
+					// set error URL
+					newElement := etree.NewElement(models.ErrorElement)
+					newElement.SetText(videoParams[i].ErrorURL)
+					element.InsertChild(element.SelectElement(models.ErrorElement), newElement)
+				}
+
+				if false == isWrapper && videoParams[i].Price != 0 {
+					if models.VideoVASTVersion2_0 == version {
+						injectPricingNodeVAST20(element, videoParams[i].Price, videoParams[i].PriceModel, videoParams[i].PriceCurrency)
+					} else {
+						injectPricingNodeVAST3x(element, videoParams[i].Price, videoParams[i].PriceModel, videoParams[i].PriceCurrency)
+					}
+				}
+			}
+		}
+
+		updatedVastStr, err := doc.WriteToString()
+		if err != nil {
+			return bid.AdM, err
+		}
+		return updatedVastStr, nil
+	}
+	return bid.AdM, nil
+}
+
+func injectPricingNodeVAST20(parent *etree.Element, price float64, model string, currency string) {
+	extensions := parent.FindElement(models.VideoTagLookupStart + models.VideoExtensionsTag)
+	if nil == extensions {
+		extensions = parent.CreateElement(models.VideoExtensionsTag)
+	}
+
+	pricing := extensions.FindElement(models.VideoVAST2ExtensionPriceElement)
+	if nil != pricing {
+		//Already Present Same Node, So Ignore It
+		updatePricingNode(pricing, price, model, currency)
+	} else {
+		extension := extensions.CreateElement(models.VideoExtensionTag)
+		extension.InsertChild(nil, newPricingNode(price, model, currency))
+	}
+}
+
+func injectPricingNodeVAST3x(parent *etree.Element, price float64, model string, currency string) {
+	//Insert into Wrapper Elements
+	pricing := parent.FindElement(models.VideoTagLookupStart + models.VideoPricingTag)
+	if nil != pricing {
+		//Already Present
+		updatePricingNode(pricing, price, model, currency)
+	} else {
+		parent.InsertChild(nil, newPricingNode(price, model, currency))
+	}
+}
+
+func updatePricingNode(node *etree.Element, price float64, model string, currency string) {
+	//Update Price
+
+	node.SetText(fmt.Sprintf("%v", price))
+
+	//Update Pricing.Model
+	if len(model) == 0 {
+		model = models.VideoPricingModelCPM
+	}
+	attrModel := node.SelectAttr(models.VideoPricingModel)
+	if nil == attrModel {
+		attrModel = node.CreateAttr(models.VideoPricingModel, model)
+	} else {
+		attrModel.Value = model
+	}
+
+	//Update Pricing.Currency
+	currencyStr := models.VideoPricingCurrencyUSD
+	if currency != "" {
+		currencyStr = currency
+	}
+	attrCurrency := node.SelectAttr(models.VideoPricingCurrency)
+	if nil == attrCurrency {
+		attrCurrency = node.CreateAttr(models.VideoPricingCurrency, currencyStr)
+	} else {
+		attrCurrency.Value = currencyStr
+	}
+}
+
+func newPricingNode(price float64, model string, currency string) *etree.Element {
+	pricing := etree.NewElement(models.VideoPricingTag)
+	pricing.SetText(fmt.Sprintf("%v", price))
+	if len(model) == 0 {
+		model = models.VideoPricingModelCPM
+	}
+	pricing.CreateAttr(models.VideoPricingModel, model)
+	currencyStr := models.VideoPricingCurrencyUSD
+	if currency != "" {
+		currencyStr = currency
+	}
+	pricing.CreateAttr(models.VideoPricingCurrency, currencyStr)
+	return pricing
+}
diff --git a/modules/pubmatic/openwrap/util.go b/modules/pubmatic/openwrap/util.go
new file mode 100644
index 000000000..94c895450
--- /dev/null
+++ b/modules/pubmatic/openwrap/util.go
@@ -0,0 +1,215 @@
+package openwrap
+
+import (
+	"net/url"
+	"os"
+	"regexp"
+	"strings"
+
+	"github.com/prebid/openrtb/v19/openrtb2"
+	"github.com/prebid/prebid-server/modules/pubmatic/openwrap/models"
+)
+
+var (
+	widthRegEx  *regexp.Regexp
+	heightRegEx *regexp.Regexp
+	auIDRegEx   *regexp.Regexp
+	divRegEx    *regexp.Regexp
+
+	openRTBDeviceOsAndroidRegex *regexp.Regexp
+	androidUARegex              *regexp.Regexp
+	iosUARegex                  *regexp.Regexp
+	openRTBDeviceOsIosRegex     *regexp.Regexp
+	mobileDeviceUARegex         *regexp.Regexp
+)
+
+const test = "_test"
+
+func init() {
+	widthRegEx = regexp.MustCompile(models.MACRO_WIDTH)
+	heightRegEx = regexp.MustCompile(models.MACRO_HEIGHT)
+	auIDRegEx = regexp.MustCompile(models.MACRO_AD_UNIT_ID)
+	//auIndexRegEx := regexp.MustCompile(models.MACRO_AD_UNIT_INDEX)
+	//integerRegEx := regexp.MustCompile(models.MACRO_INTEGER)
+	divRegEx = regexp.MustCompile(models.MACRO_DIV)
+
+	openRTBDeviceOsAndroidRegex = regexp.MustCompile(models.OpenRTBDeviceOsAndroidRegexPattern)
+	androidUARegex = regexp.MustCompile(models.AndroidUARegexPattern)
+	iosUARegex = regexp.MustCompile(models.IosUARegexPattern)
+	openRTBDeviceOsIosRegex = regexp.MustCompile(models.OpenRTBDeviceOsIosRegexPattern)
+	mobileDeviceUARegex = regexp.MustCompile(models.MobileDeviceUARegexPattern)
+}
+
+// GetDevicePlatform determines the device from which request has been generated
+func GetDevicePlatform(httpReqUAHeader string, bidRequest *openrtb2.BidRequest, platform string) models.DevicePlatform {
+	userAgentString := httpReqUAHeader
+	if userAgentString == "" && bidRequest.Device != nil && len(bidRequest.Device.UA) != 0 {
+		userAgentString = bidRequest.Device.UA
+	}
+
+	switch platform {
+	case models.PLATFORM_AMP:
+		return models.DevicePlatformMobileWeb
+
+	case models.PLATFORM_APP:
+		//Its mobile; now determine ios or android
+		var os = ""
+		if bidRequest.Device != nil && len(bidRequest.Device.OS) != 0 {
+			os = bidRequest.Device.OS
+		}
+		if isIos(os, userAgentString) {
+			return models.DevicePlatformMobileAppIos
+		} else if isAndroid(os, userAgentString) {
+			return models.DevicePlatformMobileAppAndroid
+		}
+
+	case models.PLATFORM_DISPLAY:
+		//Its web; now determine mobile or desktop
+		var deviceType int
+		if bidRequest.Device != nil && bidRequest.Device.DeviceType != 0 {
+			deviceType = int(bidRequest.Device.DeviceType)
+		}
+		if isMobile(deviceType, userAgentString) {
+			return models.DevicePlatformMobileWeb
+		}
+		return models.DevicePlatformDesktop
+
+	case models.PLATFORM_VIDEO:
+		var deviceType int
+		if bidRequest.Device != nil && bidRequest.Device.DeviceType != 0 {
+			deviceType = int(bidRequest.Device.DeviceType)
+		}
+		if deviceType == models.DeviceTypeConnectedTv || deviceType == models.DeviceTypeSetTopBox {
+			return models.DevicePlatformConnectedTv
+		}
+
+		if bidRequest.Site != nil {
+			//Its web; now determine mobile or desktop
+			if isMobile(int(bidRequest.Device.DeviceType), userAgentString) {
+				return models.DevicePlatformMobileWeb
+			}
+			return models.DevicePlatformDesktop
+		}
+
+		if bidRequest.App != nil {
+			//Its mobile; now determine ios or android
+			var os = ""
+			if bidRequest.Device != nil && len(bidRequest.Device.OS) != 0 {
+				os = bidRequest.Device.OS
+			}
+
+			if isIos(os, userAgentString) {
+				return models.DevicePlatformMobileAppIos
+			} else if isAndroid(os, userAgentString) {
+				return models.DevicePlatformMobileAppAndroid
+			}
+		}
+
+	default:
+		return models.DevicePlatformNotDefined
+
+	}
+
+	return models.DevicePlatformNotDefined
+}
+
+func isMobile(deviceType int, userAgentString string) bool {
+	if deviceType == models.DeviceTypeMobile || deviceType == models.DeviceTypeTablet ||
+		deviceType == models.DeviceTypePhone {
+		return true
+	}
+	return false
+}
+
+func isIos(os string, userAgentString string) bool {
+	if openRTBDeviceOsIosRegex.Match([]byte(strings.ToLower(os))) || iosUARegex.Match([]byte(strings.ToLower(userAgentString))) {
+		return true
+	}
+	return false
+}
+
+func isAndroid(os string, userAgentString string) bool {
+	if openRTBDeviceOsAndroidRegex.Match([]byte(strings.ToLower(os))) || androidUARegex.Match([]byte(strings.ToLower(userAgentString))) {
+		return true
+	}
+	return false
+}
+
+// GetIntArray converts interface to int array if it is compatible
+func GetIntArray(val interface{}) []int {
+	intArray := make([]int, 0)
+	valArray, ok := val.([]interface{})
+	if !ok {
+		return nil
+	}
+	for _, x := range valArray {
+		var intVal int
+		intVal = GetInt(x)
+		intArray = append(intArray, intVal)
+	}
+	return intArray
+}
+
+// GetInt converts interface to int if it is compatible
+func GetInt(val interface{}) int {
+	var result int
+	if val != nil {
+		switch val.(type) {
+		case int:
+			result = val.(int)
+		case float64:
+			val := val.(float64)
+			result = int(val)
+		case float32:
+			val := val.(float32)
+			result = int(val)
+		}
+	}
+	return result
+}
+
+func getSourceAndOrigin(bidRequest *openrtb2.BidRequest) (string, string) {
+	var source, origin string
+	if bidRequest.Site != nil {
+		if len(bidRequest.Site.Domain) != 0 {
+			source = bidRequest.Site.Domain
+			origin = source
+		} else if len(bidRequest.Site.Page) != 0 {
+			source = getDomainFromUrl(bidRequest.Site.Page)
+			origin = source
+			pageURL, err := url.Parse(source)
+			if err == nil && pageURL != nil {
+				origin = pageURL.Host
+			}
+
+		}
+	} else if bidRequest.App != nil {
+		source = bidRequest.App.Bundle
+		origin = source
+	}
+	return source, origin
+}
+
+// getHostName Generates server name from node and pod name in K8S  environment
+func getHostName() string {
+	var (
+		nodeName string
+		podName  string
+	)
+
+	if nodeName, _ = os.LookupEnv(models.ENV_VAR_NODE_NAME); nodeName == "" {
+		nodeName = models.DEFAULT_NODENAME
+	} else {
+		nodeName = strings.Split(nodeName, ".")[0]
+	}
+
+	if podName, _ = os.LookupEnv(models.ENV_VAR_POD_NAME); podName == "" {
+		podName = models.DEFAULT_PODNAME
+	} else {
+		podName = strings.TrimPrefix(podName, "ssheaderbidding-")
+	}
+
+	serverName := nodeName + ":" + podName
+
+	return serverName
+}
diff --git a/openrtb_ext/adpod.go b/openrtb_ext/adpod.go
new file mode 100644
index 000000000..ed3fef3ba
--- /dev/null
+++ b/openrtb_ext/adpod.go
@@ -0,0 +1,326 @@
+package openrtb_ext
+
+import (
+	"encoding/json"
+	"errors"
+	"strings"
+)
+
+const (
+	//BidderOWPrebidCTV for prebid adpod response
+	BidderOWPrebidCTV BidderName = "prebid_ctv"
+)
+
+var (
+	errInvalidAdPodMinDuration                    = errors.New("imp.video.minduration must be number positive number")
+	errInvalidAdPodMaxDuration                    = errors.New("imp.video.maxduration must be number positive non zero number")
+	errInvalidAdPodDuration                       = errors.New("imp.video.minduration must be less than imp.video.maxduration")
+	errInvalidCrossPodAdvertiserExclusionPercent  = errors.New("request.ext.adpod.crosspodexcladv must be a number between 0 and 100")
+	errInvalidCrossPodIABCategoryExclusionPercent = errors.New("request.ext.adpod.crosspodexcliabcat must be a number between 0 and 100")
+	errInvalidIABCategoryExclusionWindow          = errors.New("request.ext.adpod.excliabcatwindow must be postive number")
+	errInvalidAdvertiserExclusionWindow           = errors.New("request.ext.adpod.excladvwindow must be postive number")
+	errInvalidVideoAdDurationMatching             = errors.New("request.ext.adpod.videoaddurationmatching must be exact|roundup")
+	errInvalidAdPodOffset                         = errors.New("request.imp.video.ext.offset must be postive number")
+	errInvalidMinAds                              = errors.New("%key%.ext.adpod.minads must be positive number")
+	errInvalidMaxAds                              = errors.New("%key%.ext.adpod.maxads must be positive number")
+	errInvalidMinDuration                         = errors.New("%key%.ext.adpod.adminduration must be positive number")
+	errInvalidMaxDuration                         = errors.New("%key%.ext.adpod.admaxduration must be positive number")
+	errInvalidAdvertiserExclusionPercent          = errors.New("%key%.ext.adpod.excladv must be number between 0 and 100")
+	errInvalidIABCategoryExclusionPercent         = errors.New("%key%.ext.adpod.excliabcat must be number between 0 and 100")
+	errInvalidMinMaxAds                           = errors.New("%key%.ext.adpod.minads must be less than %key%.ext.adpod.maxads")
+	errInvalidMinMaxDuration                      = errors.New("%key%.ext.adpod.adminduration must be less than %key%.ext.adpod.admaxduration")
+	errInvalidMinMaxDurationRange                 = errors.New("adpod duration checks for adminduration,admaxduration,minads,maxads are not in video minduration and maxduration duration range")
+)
+
+type OWVideoAdDurationMatchingPolicy = string
+
+const (
+	OWExactVideoAdDurationMatching   OWVideoAdDurationMatchingPolicy = `exact`
+	OWRoundupVideoAdDurationMatching OWVideoAdDurationMatchingPolicy = `roundup`
+)
+
+// ExtCTVBid defines the contract for bidresponse.seatbid.bid[i].ext
+type ExtOWBid struct {
+	ExtBid
+	AdPod       *BidAdPodExt    `json:"adpod,omitempty"`
+	SKAdNetwork json.RawMessage `json:"skadn,omitempty"`
+}
+
+// BidAdPodExt defines the prebid adpod response in bidresponse.ext.adpod parameter
+type BidAdPodExt struct {
+	ReasonCode *int     `json:"aprc,omitempty"`
+	RefBids    []string `json:"refbids,omitempty"` //change refbids to bids name
+}
+
+// ExtOWRequest defines the contract for bidrequest.ext
+type ExtOWRequest struct {
+	ExtRequest
+	AdPod *ExtRequestAdPod `json:"adpod,omitempty"`
+}
+
+// ExtVideoAdPod structure to accept video specific more parameters like adpod
+type ExtVideoAdPod struct {
+	Offset *int        `json:"offset,omitempty"` // Minutes from start where this ad is intended to show
+	AdPod  *VideoAdPod `json:"adpod,omitempty"`
+}
+
+// ExtRequestAdPod holds AdPod specific extension parameters at request level
+type ExtRequestAdPod struct {
+	VideoAdPod
+	CrossPodAdvertiserExclusionPercent  *int                            `json:"crosspodexcladv,omitempty"`         //Percent Value - Across multiple impression there will be no ads from same advertiser. Note: These cross pod rule % values can not be more restrictive than per pod
+	CrossPodIABCategoryExclusionPercent *int                            `json:"crosspodexcliabcat,omitempty"`      //Percent Value - Across multiple impression there will be no ads from same advertiser
+	IABCategoryExclusionWindow          *int                            `json:"excliabcatwindow,omitempty"`        //Duration in minute between pods where exclusive IAB rule needs to be applied
+	AdvertiserExclusionWindow           *int                            `json:"excladvwindow,omitempty"`           //Duration in minute between pods where exclusive advertiser rule needs to be applied
+	VideoAdDuration                     []int                           `json:"videoadduration,omitempty"`         //Range of ad durations allowed in the response
+	VideoAdDurationMatching             OWVideoAdDurationMatchingPolicy `json:"videoaddurationmatching,omitempty"` //Flag indicating exact ad duration requirement. (default)empty/exact/round.
+}
+
+// VideoAdPod holds Video AdPod specific extension parameters at impression level
+type VideoAdPod struct {
+	MinAds                      *int `json:"minads,omitempty"`        //Default 1 if not specified
+	MaxAds                      *int `json:"maxads,omitempty"`        //Default 1 if not specified
+	MinDuration                 *int `json:"adminduration,omitempty"` // (adpod.adminduration * adpod.minads) should be greater than or equal to video.minduration
+	MaxDuration                 *int `json:"admaxduration,omitempty"` // (adpod.admaxduration * adpod.maxads) should be less than or equal to video.maxduration + video.maxextended
+	AdvertiserExclusionPercent  *int `json:"excladv,omitempty"`       // Percent value 0 means none of the ads can be from same advertiser 100 means can have all same advertisers
+	IABCategoryExclusionPercent *int `json:"excliabcat,omitempty"`    // Percent value 0 means all ads should be of different IAB categories.
+}
+
+/*
+//UnmarshalJSON will unmarshal extension into ExtVideoAdPod object
+func (ext *ExtVideoAdPod) UnmarshalJSON(b []byte) error {
+	return json.Unmarshal(b, ext)
+}
+
+//UnmarshalJSON will unmarshal extension into ExtRequestAdPod object
+func (ext *ExtRequestAdPod) UnmarshalJSON(b []byte) error {
+	return json.Unmarshal(b, ext)
+}
+*/
+//getRequestAdPodError will return request level error message
+func getRequestAdPodError(err error) error {
+	return errors.New(strings.Replace(err.Error(), "%key%", "req.ext", -1))
+}
+
+// getVideoAdPodError will return video adpod level error message
+func getVideoAdPodError(err error) error {
+	return errors.New(strings.Replace(err.Error(), "%key%", "imp.video.ext", -1))
+}
+
+func getIntPtr(v int) *int {
+	return &v
+}
+
+// Validate will validate AdPod object
+func (pod *VideoAdPod) Validate() (err []error) {
+	if nil != pod.MinAds && *pod.MinAds <= 0 {
+		err = append(err, errInvalidMinAds)
+	}
+
+	if nil != pod.MaxAds && *pod.MaxAds <= 0 {
+		err = append(err, errInvalidMaxAds)
+	}
+
+	if nil != pod.MinDuration && *pod.MinDuration <= 0 {
+		err = append(err, errInvalidMinDuration)
+	}
+
+	if nil != pod.MaxDuration && *pod.MaxDuration <= 0 {
+		err = append(err, errInvalidMaxDuration)
+	}
+
+	if nil != pod.AdvertiserExclusionPercent && (*pod.AdvertiserExclusionPercent < 0 || *pod.AdvertiserExclusionPercent > 100) {
+		err = append(err, errInvalidAdvertiserExclusionPercent)
+	}
+
+	if nil != pod.IABCategoryExclusionPercent && (*pod.IABCategoryExclusionPercent < 0 || *pod.IABCategoryExclusionPercent > 100) {
+		err = append(err, errInvalidIABCategoryExclusionPercent)
+	}
+
+	if nil != pod.MinAds && nil != pod.MaxAds && *pod.MinAds > *pod.MaxAds {
+		err = append(err, errInvalidMinMaxAds)
+	}
+
+	if nil != pod.MinDuration && nil != pod.MaxDuration && *pod.MinDuration > *pod.MaxDuration {
+		err = append(err, errInvalidMinMaxDuration)
+	}
+
+	return
+}
+
+// Validate will validate ExtRequestAdPod object
+func (ext *ExtRequestAdPod) Validate() (err []error) {
+	if nil == ext {
+		return
+	}
+
+	if nil != ext.CrossPodAdvertiserExclusionPercent &&
+		(*ext.CrossPodAdvertiserExclusionPercent < 0 || *ext.CrossPodAdvertiserExclusionPercent > 100) {
+		err = append(err, errInvalidCrossPodAdvertiserExclusionPercent)
+	}
+
+	if nil != ext.CrossPodIABCategoryExclusionPercent &&
+		(*ext.CrossPodIABCategoryExclusionPercent < 0 || *ext.CrossPodIABCategoryExclusionPercent > 100) {
+		err = append(err, errInvalidCrossPodIABCategoryExclusionPercent)
+	}
+
+	if nil != ext.IABCategoryExclusionWindow && *ext.IABCategoryExclusionWindow < 0 {
+		err = append(err, errInvalidIABCategoryExclusionWindow)
+	}
+
+	if nil != ext.AdvertiserExclusionWindow && *ext.AdvertiserExclusionWindow < 0 {
+		err = append(err, errInvalidAdvertiserExclusionWindow)
+	}
+
+	if len(ext.VideoAdDurationMatching) > 0 && !(OWExactVideoAdDurationMatching == ext.VideoAdDurationMatching || OWRoundupVideoAdDurationMatching == ext.VideoAdDurationMatching) {
+		err = append(err, errInvalidVideoAdDurationMatching)
+	}
+
+	if errL := ext.VideoAdPod.Validate(); nil != errL {
+		for _, errr := range errL {
+			err = append(err, getRequestAdPodError(errr))
+		}
+	}
+
+	return
+}
+
+// Validate will validate video extension object
+func (ext *ExtVideoAdPod) Validate() (err []error) {
+	if nil != ext.Offset && *ext.Offset < 0 {
+		err = append(err, errInvalidAdPodOffset)
+	}
+
+	if nil != ext.AdPod {
+		if errL := ext.AdPod.Validate(); nil != errL {
+			for _, errr := range errL {
+				err = append(err, getRequestAdPodError(errr))
+			}
+		}
+	}
+
+	return
+}
+
+// SetDefaultValue will set default values if not present
+func (pod *VideoAdPod) SetDefaultValue() {
+	//pod.MinAds setting default value
+	if nil == pod.MinAds {
+		pod.MinAds = getIntPtr(1)
+	}
+
+	//pod.MaxAds setting default value
+	if nil == pod.MaxAds {
+		pod.MaxAds = getIntPtr(3)
+	}
+
+	//pod.AdvertiserExclusionPercent setting default value
+	if nil == pod.AdvertiserExclusionPercent {
+		pod.AdvertiserExclusionPercent = getIntPtr(100)
+	}
+
+	//pod.IABCategoryExclusionPercent setting default value
+	if nil == pod.IABCategoryExclusionPercent {
+		pod.IABCategoryExclusionPercent = getIntPtr(100)
+	}
+}
+
+// SetDefaultValue will set default values if not present
+func (ext *ExtRequestAdPod) SetDefaultValue() {
+	//ext.VideoAdPod setting default value
+	ext.VideoAdPod.SetDefaultValue()
+
+	//ext.CrossPodAdvertiserExclusionPercent setting default value
+	if nil == ext.CrossPodAdvertiserExclusionPercent {
+		ext.CrossPodAdvertiserExclusionPercent = getIntPtr(100)
+	}
+
+	//ext.CrossPodIABCategoryExclusionPercent setting default value
+	if nil == ext.CrossPodIABCategoryExclusionPercent {
+		ext.CrossPodIABCategoryExclusionPercent = getIntPtr(100)
+	}
+
+	//ext.IABCategoryExclusionWindow setting default value
+	if nil == ext.IABCategoryExclusionWindow {
+		ext.IABCategoryExclusionWindow = getIntPtr(0)
+	}
+
+	//ext.AdvertiserExclusionWindow setting default value
+	if nil == ext.AdvertiserExclusionWindow {
+		ext.AdvertiserExclusionWindow = getIntPtr(0)
+	}
+}
+
+// SetDefaultValue will set default values if not present
+func (ext *ExtVideoAdPod) SetDefaultValue() {
+	//ext.Offset setting default values
+	if nil == ext.Offset {
+		ext.Offset = getIntPtr(0)
+	}
+
+	//ext.AdPod setting default values
+	if nil == ext.AdPod {
+		ext.AdPod = &VideoAdPod{}
+	}
+	ext.AdPod.SetDefaultValue()
+}
+
+// SetDefaultAdDuration will set default pod ad slot durations
+func (pod *VideoAdPod) SetDefaultAdDurations(podMinDuration, podMaxDuration int64) {
+	//pod.MinDuration setting default adminduration
+	if nil == pod.MinDuration {
+		duration := int(podMinDuration / 2)
+		pod.MinDuration = &duration
+	}
+
+	//pod.MaxDuration setting default admaxduration
+	if nil == pod.MaxDuration {
+		duration := int(podMaxDuration / 2)
+		pod.MaxDuration = &duration
+	}
+}
+
+// Merge VideoAdPod Values
+func (pod *VideoAdPod) Merge(parent *VideoAdPod) {
+	//pod.MinAds setting default value
+	if nil == pod.MinAds {
+		pod.MinAds = parent.MinAds
+	}
+
+	//pod.MaxAds setting default value
+	if nil == pod.MaxAds {
+		pod.MaxAds = parent.MaxAds
+	}
+
+	//pod.AdvertiserExclusionPercent setting default value
+	if nil == pod.AdvertiserExclusionPercent {
+		pod.AdvertiserExclusionPercent = parent.AdvertiserExclusionPercent
+	}
+
+	//pod.IABCategoryExclusionPercent setting default value
+	if nil == pod.IABCategoryExclusionPercent {
+		pod.IABCategoryExclusionPercent = parent.IABCategoryExclusionPercent
+	}
+}
+
+// ValidateAdPodDurations will validate adpod min,max durations
+func (pod *VideoAdPod) ValidateAdPodDurations(minDuration, maxDuration, maxExtended int64) (err []error) {
+	if minDuration < 0 {
+		err = append(err, errInvalidAdPodMinDuration)
+	}
+
+	if maxDuration <= 0 {
+		err = append(err, errInvalidAdPodMaxDuration)
+	}
+
+	if minDuration > maxDuration {
+		err = append(err, errInvalidAdPodDuration)
+	}
+
+	if pod.MinAds != nil && pod.MinDuration != nil && pod.MaxDuration != nil && pod.MaxAds != nil {
+		if ((*pod.MinAds * *pod.MinDuration) <= int(maxDuration)) && (int(minDuration) <= (*pod.MaxAds * *pod.MaxDuration)) {
+		} else {
+			err = append(err, errInvalidMinMaxDurationRange)
+		}
+	}
+	return
+}
diff --git a/openrtb_ext/adpod_test.go b/openrtb_ext/adpod_test.go
new file mode 100644
index 000000000..ecd2ebefe
--- /dev/null
+++ b/openrtb_ext/adpod_test.go
@@ -0,0 +1,315 @@
+package openrtb_ext
+
+import (
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+)
+
+func TestVideoAdPod_Validate(t *testing.T) {
+	type fields struct {
+		MinAds                      *int
+		MaxAds                      *int
+		MinDuration                 *int
+		MaxDuration                 *int
+		AdvertiserExclusionPercent  *int
+		IABCategoryExclusionPercent *int
+	}
+	tests := []struct {
+		name    string
+		fields  fields
+		wantErr []error
+	}{
+		{
+			name: "ErrInvalidMinAds",
+			fields: fields{
+				MinAds: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidMinAds},
+		},
+		{
+			name: "ZeroMinAds",
+			fields: fields{
+				MinAds: getIntPtr(0),
+			},
+			wantErr: []error{errInvalidMinAds},
+		},
+		{
+			name: "ErrInvalidMaxAds",
+			fields: fields{
+				MaxAds: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidMaxAds},
+		},
+		{
+			name: "ZeroMaxAds",
+			fields: fields{
+				MaxAds: getIntPtr(0),
+			},
+			wantErr: []error{errInvalidMaxAds},
+		},
+		{
+			name: "ErrInvalidMinDuration",
+			fields: fields{
+				MinDuration: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidMinDuration},
+		},
+		{
+			name: "ZeroMinDuration",
+			fields: fields{
+				MinDuration: getIntPtr(0),
+			},
+			wantErr: []error{errInvalidMinDuration},
+		},
+		{
+			name: "ErrInvalidMaxDuration",
+			fields: fields{
+				MaxDuration: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidMaxDuration},
+		},
+		{
+			name: "ZeroMaxDuration",
+			fields: fields{
+				MaxDuration: getIntPtr(0),
+			},
+			wantErr: []error{errInvalidMaxDuration},
+		},
+		{
+			name: "ErrInvalidAdvertiserExclusionPercent_NegativeValue",
+			fields: fields{
+				AdvertiserExclusionPercent: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidAdvertiserExclusionPercent},
+		},
+		{
+			name: "ErrInvalidAdvertiserExclusionPercent_InvalidRange",
+			fields: fields{
+				AdvertiserExclusionPercent: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidAdvertiserExclusionPercent},
+		},
+		{
+			name: "ErrInvalidIABCategoryExclusionPercent_Negative",
+			fields: fields{
+				IABCategoryExclusionPercent: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidIABCategoryExclusionPercent},
+		},
+		{
+			name: "ErrInvalidIABCategoryExclusionPercent_InvalidRange",
+			fields: fields{
+				IABCategoryExclusionPercent: getIntPtr(101),
+			},
+			wantErr: []error{errInvalidIABCategoryExclusionPercent},
+		},
+		{
+			name: "ErrInvalidMinMaxAds",
+			fields: fields{
+				MinAds: getIntPtr(5),
+				MaxAds: getIntPtr(2),
+			},
+			wantErr: []error{errInvalidMinMaxAds},
+		},
+		{
+			name: "ErrInvalidMinMaxDuration",
+			fields: fields{
+				MinDuration: getIntPtr(5),
+				MaxDuration: getIntPtr(2),
+			},
+			wantErr: []error{errInvalidMinMaxDuration},
+		},
+		{
+			name: "Valid",
+			fields: fields{
+				MinAds:                      getIntPtr(3),
+				MaxAds:                      getIntPtr(4),
+				MinDuration:                 getIntPtr(20),
+				MaxDuration:                 getIntPtr(30),
+				AdvertiserExclusionPercent:  getIntPtr(100),
+				IABCategoryExclusionPercent: getIntPtr(100),
+			},
+			wantErr: nil,
+		},
+		// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			pod := &VideoAdPod{
+				MinAds:                      tt.fields.MinAds,
+				MaxAds:                      tt.fields.MaxAds,
+				MinDuration:                 tt.fields.MinDuration,
+				MaxDuration:                 tt.fields.MaxDuration,
+				AdvertiserExclusionPercent:  tt.fields.AdvertiserExclusionPercent,
+				IABCategoryExclusionPercent: tt.fields.IABCategoryExclusionPercent,
+			}
+
+			actualErr := pod.Validate()
+			assert.Equal(t, tt.wantErr, actualErr)
+		})
+	}
+}
+
+func TestExtRequestAdPod_Validate(t *testing.T) {
+	type fields struct {
+		VideoAdPod                          VideoAdPod
+		CrossPodAdvertiserExclusionPercent  *int
+		CrossPodIABCategoryExclusionPercent *int
+		IABCategoryExclusionWindow          *int
+		AdvertiserExclusionWindow           *int
+		VideoAdDurationMatching             string
+	}
+	tests := []struct {
+		name    string
+		fields  fields
+		wantErr []error
+	}{
+		{
+			name: "ErrInvalidCrossPodAdvertiserExclusionPercent_Negative",
+			fields: fields{
+				CrossPodAdvertiserExclusionPercent: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidCrossPodAdvertiserExclusionPercent},
+		},
+		{
+			name: "ErrInvalidCrossPodAdvertiserExclusionPercent_InvalidRange",
+			fields: fields{
+				CrossPodAdvertiserExclusionPercent: getIntPtr(101),
+			},
+			wantErr: []error{errInvalidCrossPodAdvertiserExclusionPercent},
+		},
+		{
+			name: "ErrInvalidCrossPodIABCategoryExclusionPercent_Negative",
+			fields: fields{
+				CrossPodIABCategoryExclusionPercent: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidCrossPodIABCategoryExclusionPercent},
+		},
+		{
+			name: "ErrInvalidCrossPodIABCategoryExclusionPercent_InvalidRange",
+			fields: fields{
+				CrossPodIABCategoryExclusionPercent: getIntPtr(101),
+			},
+			wantErr: []error{errInvalidCrossPodIABCategoryExclusionPercent},
+		},
+		{
+			name: "ErrInvalidIABCategoryExclusionWindow",
+			fields: fields{
+				IABCategoryExclusionWindow: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidIABCategoryExclusionWindow},
+		},
+		{
+			name: "ErrInvalidAdvertiserExclusionWindow",
+			fields: fields{
+				AdvertiserExclusionWindow: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidAdvertiserExclusionWindow},
+		},
+		{
+			name: "ErrInvalidVideoAdDurationMatching",
+			fields: fields{
+				VideoAdDurationMatching: "invalid",
+			},
+			wantErr: []error{errInvalidVideoAdDurationMatching},
+		},
+		{
+			name: "InvalidAdPod",
+			fields: fields{
+				VideoAdPod: VideoAdPod{
+					MinAds: getIntPtr(-1),
+				},
+			},
+			wantErr: []error{getRequestAdPodError(errInvalidMinAds)},
+		},
+		{
+			name: "Valid",
+			fields: fields{
+				CrossPodAdvertiserExclusionPercent:  getIntPtr(100),
+				CrossPodIABCategoryExclusionPercent: getIntPtr(0),
+				IABCategoryExclusionWindow:          getIntPtr(10),
+				AdvertiserExclusionWindow:           getIntPtr(10),
+				VideoAdPod: VideoAdPod{
+					MinAds:                      getIntPtr(3),
+					MaxAds:                      getIntPtr(4),
+					MinDuration:                 getIntPtr(20),
+					MaxDuration:                 getIntPtr(30),
+					AdvertiserExclusionPercent:  getIntPtr(100),
+					IABCategoryExclusionPercent: getIntPtr(100),
+				},
+			},
+			wantErr: nil,
+		},
+		// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			ext := &ExtRequestAdPod{
+				VideoAdPod:                          tt.fields.VideoAdPod,
+				CrossPodAdvertiserExclusionPercent:  tt.fields.CrossPodAdvertiserExclusionPercent,
+				CrossPodIABCategoryExclusionPercent: tt.fields.CrossPodIABCategoryExclusionPercent,
+				IABCategoryExclusionWindow:          tt.fields.IABCategoryExclusionWindow,
+				AdvertiserExclusionWindow:           tt.fields.AdvertiserExclusionWindow,
+				VideoAdDurationMatching:             tt.fields.VideoAdDurationMatching,
+			}
+			actualErr := ext.Validate()
+			assert.Equal(t, tt.wantErr, actualErr)
+		})
+	}
+}
+
+func TestExtVideoAdPod_Validate(t *testing.T) {
+	type fields struct {
+		Offset *int
+		AdPod  *VideoAdPod
+	}
+	tests := []struct {
+		name    string
+		fields  fields
+		wantErr []error
+	}{
+		{
+			name: "ErrInvalidAdPodOffset",
+			fields: fields{
+				Offset: getIntPtr(-1),
+			},
+			wantErr: []error{errInvalidAdPodOffset},
+		},
+		{
+			name: "InvalidAdPod",
+			fields: fields{
+				AdPod: &VideoAdPod{
+					MinAds: getIntPtr(-1),
+				},
+			},
+			wantErr: []error{getRequestAdPodError(errInvalidMinAds)},
+		},
+		{
+			name: "Valid",
+			fields: fields{
+				Offset: getIntPtr(10),
+				AdPod: &VideoAdPod{
+					MinAds:                      getIntPtr(3),
+					MaxAds:                      getIntPtr(4),
+					MinDuration:                 getIntPtr(20),
+					MaxDuration:                 getIntPtr(30),
+					AdvertiserExclusionPercent:  getIntPtr(100),
+					IABCategoryExclusionPercent: getIntPtr(100),
+				},
+			},
+			wantErr: nil,
+		},
+		// TODO: Add test cases.
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			ext := &ExtVideoAdPod{
+				Offset: tt.fields.Offset,
+				AdPod:  tt.fields.AdPod,
+			}
+			actualErr := ext.Validate()
+			assert.Equal(t, tt.wantErr, actualErr)
+		})
+	}
+}
diff --git a/openrtb_ext/bid.go b/openrtb_ext/bid.go
index 20bbf0b37..0b17bc740 100644
--- a/openrtb_ext/bid.go
+++ b/openrtb_ext/bid.go
@@ -7,7 +7,8 @@ import (
 
 // ExtBid defines the contract for bidresponse.seatbid.bid[i].ext
 type ExtBid struct {
-	Prebid *ExtBidPrebid `json:"prebid,omitempty"`
+	Prebid *ExtBidPrebid   `json:"prebid,omitempty"`
+	Bidder json.RawMessage `json:"bidder,omitempty"`
 }
 
 // ExtBidPrebid defines the contract for bidresponse.seatbid.bid[i].ext.prebid
@@ -33,7 +34,8 @@ type ExtBidPrebidFloors struct {
 	FloorRule      string  `json:"floorRule,omitempty"`
 	FloorRuleValue float64 `json:"floorRuleValue,omitempty"`
 	FloorValue     float64 `json:"floorValue,omitempty"`
-	FloorCurrency  string  `json:"floorCurrency,omitempty"`
+	// FloorValueUSD  float64 `json:"floorvalueusd,omitempty"`
+	FloorCurrency string `json:"floorCurrency,omitempty"`
 }
 
 // ExtBidPrebidCache defines the contract for  bidresponse.seatbid.bid[i].ext.prebid.cache
@@ -71,6 +73,7 @@ type ExtBidPrebidMeta struct {
 type ExtBidPrebidVideo struct {
 	Duration        int    `json:"duration"`
 	PrimaryCategory string `json:"primary_category"`
+	VASTTagID       string `json:"vasttagid"`
 }
 
 // ExtBidPrebidEvents defines the contract for bidresponse.seatbid.bid[i].ext.prebid.events
@@ -185,4 +188,5 @@ const (
 	OriginalBidCpmKey       = "origbidcpm"
 	OriginalBidCurKey       = "origbidcur"
 	Passthrough             = "passthrough"
+	OriginalBidCpmUsdKey    = "origbidcpmusd"
 )
diff --git a/openrtb_ext/bidders.go b/openrtb_ext/bidders.go
index 5a342a98d..8cbdb84e0 100644
--- a/openrtb_ext/bidders.go
+++ b/openrtb_ext/bidders.go
@@ -241,6 +241,7 @@ const (
 	BidderSonobi            BidderName = "sonobi"
 	BidderSovrn             BidderName = "sovrn"
 	BidderSspBC             BidderName = "sspBC"
+	BidderSpotX             BidderName = "spotx"
 	BidderStreamkey         BidderName = "streamkey"
 	BidderStroeerCore       BidderName = "stroeerCore"
 	BidderSuntContent       BidderName = "suntContent"
@@ -257,6 +258,7 @@ const (
 	BidderUnicorn           BidderName = "unicorn"
 	BidderUnruly            BidderName = "unruly"
 	BidderValueImpression   BidderName = "valueimpression"
+	BidderVASTBidder        BidderName = "vastbidder"
 	BidderVerizonMedia      BidderName = "verizonmedia"
 	BidderVideoByte         BidderName = "videobyte"
 	BidderVideoHeroes       BidderName = "videoheroes"
@@ -432,6 +434,7 @@ func CoreBidderNames() []BidderName {
 		BidderSonobi,
 		BidderSovrn,
 		BidderSspBC,
+		BidderSpotX,
 		BidderStreamkey,
 		BidderStroeerCore,
 		BidderSuntContent,
@@ -448,6 +451,7 @@ func CoreBidderNames() []BidderName {
 		BidderUnicorn,
 		BidderUnruly,
 		BidderValueImpression,
+		BidderVASTBidder,
 		BidderVerizonMedia,
 		BidderVideoByte,
 		BidderVideoHeroes,
diff --git a/openrtb_ext/convert_down_test.go b/openrtb_ext/convert_down_test.go
index ea21468e7..a7761a0a1 100644
--- a/openrtb_ext/convert_down_test.go
+++ b/openrtb_ext/convert_down_test.go
@@ -450,7 +450,7 @@ func TestMoveRewardedFrom26ToPrebidExt(t *testing.T) {
 			if len(test.expectedErr) > 0 {
 				assert.EqualError(t, err, test.expectedErr, "error")
 			} else {
-				assert.NoError(t, w.RebuildImp(), "error")
+				assert.NoError(t, w.RebuildImpressionExt(), "error")
 				assert.Equal(t, test.expectedImp, *w.Imp, "result")
 			}
 		})
diff --git a/openrtb_ext/convert_up_test.go b/openrtb_ext/convert_up_test.go
index d3ba034d0..942df166c 100644
--- a/openrtb_ext/convert_up_test.go
+++ b/openrtb_ext/convert_up_test.go
@@ -444,7 +444,7 @@ func TestMoveRewardedFromPrebidExtTo26(t *testing.T) {
 	for _, test := range testCases {
 		w := &ImpWrapper{Imp: &test.givenImp}
 		moveRewardedFromPrebidExtTo26(w)
-		assert.NoError(t, w.RebuildImp(), test.description)
+		assert.NoError(t, w.RebuildImpressionExt(), test.description)
 		assert.Equal(t, test.expectedImp, *w.Imp, test.description)
 	}
 }
diff --git a/openrtb_ext/deal_tier.go b/openrtb_ext/deal_tier.go
index ef85b9b1d..9e46175c1 100644
--- a/openrtb_ext/deal_tier.go
+++ b/openrtb_ext/deal_tier.go
@@ -31,12 +31,11 @@ func ReadDealTiersFromImp(imp openrtb2.Imp) (DealTierBidderMap, error) {
 	var impExt map[string]struct {
 		DealTier *DealTier `json:"dealTier"`
 	}
-	if err := json.Unmarshal(imp.Ext, &impExt); err != nil {
-		return nil, err
-	}
-	for bidder, param := range impExt {
-		if param.DealTier != nil {
-			dealTiers[BidderName(bidder)] = *param.DealTier
+	if err := json.Unmarshal(imp.Ext, &impExt); err == nil {
+		for bidder, param := range impExt {
+			if param.DealTier != nil {
+				dealTiers[BidderName(bidder)] = *param.DealTier
+			}
 		}
 	}
 
diff --git a/openrtb_ext/deal_tier_test.go b/openrtb_ext/deal_tier_test.go
index 6aaebbab6..e46a06ec7 100644
--- a/openrtb_ext/deal_tier_test.go
+++ b/openrtb_ext/deal_tier_test.go
@@ -46,15 +46,25 @@ func TestReadDealTiersFromImp(t *testing.T) {
 			expectedResult: DealTierBidderMap{},
 		},
 		{
-			description:   "imp.ext - error",
-			impExt:        json.RawMessage(`{"appnexus": {"dealTier": "wrong type", "placementId": 12345}}`),
-			expectedError: "json: cannot unmarshal string into Go struct field .dealTier of type openrtb_ext.DealTier",
+			description:    "imp.ext - error",
+			impExt:         json.RawMessage(`{"appnexus": {"dealTier": "wrong type", "placementId": 12345}}`),
+			expectedResult: DealTierBidderMap{},
 		},
 		{
 			description:    "imp.ext.prebid",
 			impExt:         json.RawMessage(`{"prebid": {"bidder": {"appnexus": {"dealTier": {"minDealTier": 5, "prefix": "anyPrefix"}, "placementId": 12345}}}}`),
 			expectedResult: DealTierBidderMap{BidderAppnexus: {Prefix: "anyPrefix", MinDealTier: 5}},
 		},
+		{
+			description:    "imp.ext.prebid - tid",
+			impExt:         json.RawMessage(`{"tid": "6f3998fa-811a-4732-a6bb-dbc37a1ca617", "prebid": {"bidder": {"appnexus": {"dealTier": {"minDealTier": 5, "prefix": "anyPrefix"}, "placementId": 12345}}}}`),
+			expectedResult: DealTierBidderMap{BidderAppnexus: {Prefix: "anyPrefix", MinDealTier: 5}},
+		},
+		{
+			description:    "imp.ext - tid",
+			impExt:         json.RawMessage(`{"tid": "6f3998fa-811a-4732-a6bb-dbc37a1ca617", "appnexus": {"dealTier": {"minDealTier": 5, "prefix": "anyPrefix"}, "placementId": 12345}}`),
+			expectedResult: DealTierBidderMap{},
+		},
 		{
 			description:    "imp.ext.prebid- multiple",
 			impExt:         json.RawMessage(`{"prebid": {"bidder": {"appnexus": {"dealTier": {"minDealTier": 5, "prefix": "appnexusPrefix"}, "placementId": 12345}, "rubicon": {"dealTier": {"minDealTier": 8, "prefix": "rubiconPrefix"}, "placementId": 12345}}}}`),
diff --git a/openrtb_ext/device.go b/openrtb_ext/device.go
index 8c5b36733..f5b055698 100644
--- a/openrtb_ext/device.go
+++ b/openrtb_ext/device.go
@@ -34,6 +34,14 @@ type ExtDevice struct {
 	// Description:
 	//   Prebid extensions for the Device object.
 	Prebid ExtDevicePrebid `json:"prebid"`
+
+	// Attribute:
+	//	 ifa_type
+	// Type:
+	//	 string; optional
+	// Description:
+	//   Contains source who generated ifa value
+	IFAType string `json:"ifa_type,omitempty"`
 }
 
 // IOSAppTrackingStatus describes the values for iOS app tracking authorization status.
diff --git a/openrtb_ext/floors.go b/openrtb_ext/floors.go
index 3553946cc..33bb75b25 100644
--- a/openrtb_ext/floors.go
+++ b/openrtb_ext/floors.go
@@ -82,6 +82,7 @@ type PriceFloorData struct {
 	ModelTimestamp      int                    `json:"modeltimestamp,omitempty"`
 	ModelGroups         []PriceFloorModelGroup `json:"modelgroups,omitempty"`
 	FloorProvider       string                 `json:"floorprovider,omitempty"`
+	UseFetchDataRate    *int                   `json:"usefetchdatarate,omitempty"`
 }
 
 type PriceFloorModelGroup struct {
diff --git a/openrtb_ext/imp_pubmatic.go b/openrtb_ext/imp_pubmatic.go
index 2a45b491d..075729b74 100644
--- a/openrtb_ext/imp_pubmatic.go
+++ b/openrtb_ext/imp_pubmatic.go
@@ -9,13 +9,15 @@ import "encoding/json"
 // WrapExt needs to be sent once per bid request
 
 type ExtImpPubmatic struct {
-	PublisherId string                  `json:"publisherId"`
-	AdSlot      string                  `json:"adSlot"`
-	Dctr        string                  `json:"dctr"`
-	PmZoneID    string                  `json:"pmzoneid"`
-	WrapExt     json.RawMessage         `json:"wrapper,omitempty"`
-	Keywords    []*ExtImpPubmaticKeyVal `json:"keywords,omitempty"`
-	Kadfloor    string                  `json:"kadfloor,omitempty"`
+	PublisherId         string                  `json:"publisherId"`
+	AdSlot              string                  `json:"adSlot"`
+	Dctr                string                  `json:"dctr,omitempty"`
+	PmZoneID            string                  `json:"pmzoneid,omitempty"`
+	WrapExt             json.RawMessage         `json:"wrapper,omitempty"`
+	Keywords            []*ExtImpPubmaticKeyVal `json:"keywords,omitempty"`
+	Kadfloor            string                  `json:"kadfloor,omitempty"`
+	BidViewabilityScore map[string]interface{}  `json:"bidViewability,omitempty"`
+	DealTier            *DealTier               `json:"dealtier,omitempty"`
 }
 
 // ExtImpPubmaticKeyVal defines the contract for bidrequest.imp[i].ext.prebid.bidder.pubmatic.keywords[i]
diff --git a/openrtb_ext/imp_spotx.go b/openrtb_ext/imp_spotx.go
new file mode 100644
index 000000000..ee209b78f
--- /dev/null
+++ b/openrtb_ext/imp_spotx.go
@@ -0,0 +1,10 @@
+package openrtb_ext
+
+type ExtImpSpotX struct {
+	ChannelID  string  `json:"channel_id"`
+	AdUnit     string  `json:"ad_unit"`
+	Secure     bool    `json:"secure,omitempty"`
+	AdVolume   float64 `json:"ad_volume,omitempty"`
+	PriceFloor int     `json:"price_floor,omitempty"`
+	HideSkin   bool    `json:"hide_skin,omitempty"`
+}
diff --git a/openrtb_ext/imp_vastbidder.go b/openrtb_ext/imp_vastbidder.go
new file mode 100644
index 000000000..2923c2dd8
--- /dev/null
+++ b/openrtb_ext/imp_vastbidder.go
@@ -0,0 +1,18 @@
+package openrtb_ext
+
+// ExtImpVASTBidder defines the contract for bidrequest.imp[i].ext.vastbidder
+type ExtImpVASTBidder struct {
+	Tags    []*ExtImpVASTBidderTag `json:"tags,omitempty"`
+	Parser  string                 `json:"parser,omitempty"`
+	Headers map[string]string      `json:"headers,omitempty"`
+	Cookies map[string]string      `json:"cookies,omitempty"`
+}
+
+// ExtImpVASTBidderTag defines the contract for bidrequest.imp[i].ext.pubmatic.tags[i]
+type ExtImpVASTBidderTag struct {
+	TagID    string                 `json:"tagid"`
+	URL      string                 `json:"url"`
+	Duration int                    `json:"dur"`
+	Price    float64                `json:"price"`
+	Params   map[string]interface{} `json:"params,omitempty"`
+}
diff --git a/openrtb_ext/request.go b/openrtb_ext/request.go
index a6c7d5dc9..0be0162e1 100644
--- a/openrtb_ext/request.go
+++ b/openrtb_ext/request.go
@@ -81,6 +81,10 @@ type ExtRequestPrebid struct {
 
 	BidAdjustments    *ExtRequestPrebidBidAdjustments `json:"bidadjustments,omitempty"`
 	AdServerTargeting []AdServerTarget                `json:"adservertargeting,omitempty"`
+	// Macros specifies list of custom macros along with the values. This is used while forming
+	// the tracker URLs, where PBS will replace the Custom Macro with its value with url-encoding
+	Macros       map[string]string `json:"macros,omitempty"`
+	Transparency *TransparencyExt  `json:"transparency,omitempty"`
 }
 
 type AdServerTarget struct {
@@ -99,6 +103,15 @@ type AdsCert struct {
 	Enabled bool `json:"enabled,omitempty"`
 }
 
+type TransparencyRule struct {
+	Include bool     `json:"include,omitempty"`
+	Keys    []string `json:"keys,omitempty"`
+}
+
+type TransparencyExt struct {
+	Content map[string]TransparencyRule `json:"content,omitempty"`
+}
+
 type BidderConfig struct {
 	Bidders []string `json:"bidders,omitempty"`
 	Config  *Config  `json:"config,omitempty"`
@@ -196,10 +209,12 @@ type ExtIncludeBrandCategory struct {
 	Publisher           string `json:"publisher"`
 	WithCategory        bool   `json:"withcategory"`
 	TranslateCategories *bool  `json:"translatecategories,omitempty"`
+	SkipDedup           bool   `json:"skipdedup,omitempty"`
 }
 
 // PriceGranularity defines the allowed values for bidrequest.ext.prebid.targeting.pricegranularity
 type PriceGranularity struct {
+	Test      bool               `json:"test,omitempty"`
 	Precision *int               `json:"precision,omitempty"`
 	Ranges    []GranularityRange `json:"ranges,omitempty"`
 }
@@ -313,6 +328,23 @@ func NewPriceGranularityFromLegacyID(v string) (PriceGranularity, bool) {
 				},
 			},
 		}, true
+	case "ow-ctv-med":
+		return PriceGranularity{
+			Precision: &precision2,
+			Ranges: []GranularityRange{{
+				Min:       0,
+				Max:       100,
+				Increment: 0.5}},
+		}, true
+	case "testpg":
+		return PriceGranularity{
+			Test:      true,
+			Precision: &precision2,
+			Ranges: []GranularityRange{{
+				Min:       0,
+				Max:       50,
+				Increment: 50}},
+		}, true
 	}
 
 	return PriceGranularity{}, false
diff --git a/openrtb_ext/request_wrapper.go b/openrtb_ext/request_wrapper.go
index 5f5636d60..e28ee658b 100644
--- a/openrtb_ext/request_wrapper.go
+++ b/openrtb_ext/request_wrapper.go
@@ -176,7 +176,7 @@ func (rw *RequestWrapper) RebuildRequest() error {
 		return errors.New("Requestwrapper RebuildRequest called on a nil BidRequest")
 	}
 
-	if err := rw.rebuildImp(); err != nil {
+	if err := rw.RebuildImp(); err != nil {
 		return err
 	}
 	if err := rw.rebuildUserExt(); err != nil {
@@ -185,7 +185,7 @@ func (rw *RequestWrapper) RebuildRequest() error {
 	if err := rw.rebuildDeviceExt(); err != nil {
 		return err
 	}
-	if err := rw.rebuildRequestExt(); err != nil {
+	if err := rw.RebuildRequestExt(); err != nil {
 		return err
 	}
 	if err := rw.rebuildAppExt(); err != nil {
@@ -204,7 +204,7 @@ func (rw *RequestWrapper) RebuildRequest() error {
 	return nil
 }
 
-func (rw *RequestWrapper) rebuildImp() error {
+func (rw *RequestWrapper) RebuildImp() error {
 	if !rw.impWrappersAccessed {
 		return nil
 	}
@@ -216,7 +216,7 @@ func (rw *RequestWrapper) rebuildImp() error {
 
 	rw.Imp = make([]openrtb2.Imp, len(rw.impWrappers))
 	for i := range rw.impWrappers {
-		if err := rw.impWrappers[i].RebuildImp(); err != nil {
+		if err := rw.impWrappers[i].RebuildImpressionExt(); err != nil {
 			return err
 		}
 		rw.Imp[i] = *rw.impWrappers[i].Imp
@@ -263,7 +263,7 @@ func (rw *RequestWrapper) rebuildDeviceExt() error {
 	return nil
 }
 
-func (rw *RequestWrapper) rebuildRequestExt() error {
+func (rw *RequestWrapper) RebuildRequestExt() error {
 	if rw.requestExt == nil || !rw.requestExt.Dirty() {
 		return nil
 	}
@@ -1387,9 +1387,9 @@ func (w *ImpWrapper) GetImpExt() (*ImpExt, error) {
 	return w.impExt, w.impExt.unmarshal(w.Ext)
 }
 
-func (w *ImpWrapper) RebuildImp() error {
+func (w *ImpWrapper) RebuildImpressionExt() error {
 	if w.Imp == nil {
-		return errors.New("ImpWrapper RebuildImp called on a nil Imp")
+		return errors.New("ImpWrapper RebuildImpressionExt called on a nil Imp")
 	}
 
 	if err := w.rebuildImpExt(); err != nil {
diff --git a/openrtb_ext/request_wrapper_test.go b/openrtb_ext/request_wrapper_test.go
index e02dd7415..d55c4b71c 100644
--- a/openrtb_ext/request_wrapper_test.go
+++ b/openrtb_ext/request_wrapper_test.go
@@ -216,7 +216,7 @@ func TestRebuildImp(t *testing.T) {
 			description:       "One - Accessed - Error",
 			request:           openrtb2.BidRequest{Imp: []openrtb2.Imp{{ID: "1"}}},
 			requestImpWrapper: []*ImpWrapper{{Imp: nil, impExt: &ImpExt{}}},
-			expectedError:     "ImpWrapper RebuildImp called on a nil Imp",
+			expectedError:     "ImpWrapper RebuildImpressionExt called on a nil Imp",
 		},
 		{
 			description:       "Many - Accessed - Dirty / Not Dirty",
@@ -1643,7 +1643,7 @@ func TestImpWrapperRebuildImp(t *testing.T) {
 		test.impExtWrapper.ext = make(map[string]json.RawMessage)
 
 		w := &ImpWrapper{Imp: &test.imp, impExt: &test.impExtWrapper}
-		w.RebuildImp()
+		w.RebuildImpressionExt()
 		assert.Equal(t, test.expectedImp, *w.Imp, test.description)
 	}
 }
diff --git a/openrtb_ext/response.go b/openrtb_ext/response.go
index 9c76744fa..715f3b7ff 100644
--- a/openrtb_ext/response.go
+++ b/openrtb_ext/response.go
@@ -2,8 +2,12 @@ package openrtb_ext
 
 import (
 	"encoding/json"
+
+	"github.com/prebid/openrtb/v19/openrtb3"
 )
 
+type NonBidStatusCode openrtb3.LossReason
+
 // ExtBidResponse defines the contract for bidresponse.ext
 type ExtBidResponse struct {
 	Debug *ExtResponseDebug `json:"debug,omitempty"`
@@ -20,6 +24,11 @@ type ExtBidResponse struct {
 	Usersync map[BidderName]*ExtResponseSyncData `json:"usersync,omitempty"`
 	// Prebid defines the contract for bidresponse.ext.prebid
 	Prebid *ExtResponsePrebid `json:"prebid,omitempty"`
+
+	OwMatchedImpression json.RawMessage `json:"matchedimpression,omitempty"`
+	OwSendAllBids       int             `json:"sendallbids,omitempty"`
+	OwLogInfo           *OwLogInfo      `json:"loginfo,omitempty"`
+	OwLogger            string          `json:"owlogger,omitempty"`
 }
 
 // ExtResponseDebug defines the contract for bidresponse.ext.debug
@@ -44,6 +53,7 @@ type ExtResponsePrebid struct {
 	Modules          json.RawMessage   `json:"modules,omitempty"`
 	Fledge           *Fledge           `json:"fledge,omitempty"`
 	Targeting        map[string]string `json:"targeting,omitempty"`
+	Floors           *PriceFloorRules  `json:"floors,omitempty"`
 }
 
 // FledgeResponse defines the contract for bidresponse.ext.fledge
@@ -78,6 +88,7 @@ type ExtHttpCall struct {
 	RequestHeaders map[string][]string `json:"requestheaders"`
 	ResponseBody   string              `json:"responsebody"`
 	Status         int                 `json:"status"`
+	Params         map[string]int      `json:"params,omitempty"`
 }
 
 // CookieStatus describes the allowed values for bidresponse.ext.usersync.{bidder}.status
@@ -96,3 +107,32 @@ const (
 	UserSyncIframe UserSyncType = "iframe"
 	UserSyncPixel  UserSyncType = "pixel"
 )
+
+// SeatNonBidResponse defines the contract for bidresponse.ext.debug.seatnonbid
+type SeatNonBidResponse struct {
+	SeatNonBids []SeatNonBid `json:"seatnonbid,omitempty"`
+}
+
+// SeatNonBid defines the contract to hold all elements of single seatnonbid
+type SeatNonBid struct {
+	NonBids []NonBid `json:"nonbid,omitempty"`
+	Seat    string   `json:"seat,omitempty"`
+}
+
+// NonBid defines the contract for bidresponse.ext.debug.seatnonbid.nonbid
+type NonBid struct {
+	ImpId      string                    `json:"impid,omitempty"`
+	StatusCode openrtb3.NonBidStatusCode `json:"statuscode,omitempty"`
+	Ext        *ExtNonBid                `json:"ext,omitempty"`
+}
+
+// ExtNonBid defines the contract for bidresponse.ext.debug.seatnonbid.nonbid.ext
+type ExtNonBid struct {
+	Prebid  *ExtNonBidPrebid `json:"prebid,omitempty"`
+	IsAdPod *bool            `json:"-"` // OW specific Flag to determine if it is Ad-Pod specific nonbid
+}
+
+// ExtNonBidPrebid defines the contract for bidresponse.ext.debug.seatnonbid.nonbid.ext.prebid
+type ExtNonBidPrebid struct {
+	Bid interface{} `json:"bid,omitempty"` // To be removed once we start using single "Bid" data-type (unlike V25.Bid and openrtb2.Bid)
+}
diff --git a/openrtb_ext/response_ow.go b/openrtb_ext/response_ow.go
new file mode 100644
index 000000000..523c4a51c
--- /dev/null
+++ b/openrtb_ext/response_ow.go
@@ -0,0 +1,7 @@
+package openrtb_ext
+
+// OwLogInfo contains the logger, tracker calls to be sent in response
+type OwLogInfo struct {
+	Logger  string `json:"logger,omitempty"`
+	Tracker string `json:"tracker,omitempty"`
+}
diff --git a/openrtb_ext/user.go b/openrtb_ext/user.go
index 19c6bbc9a..586c0aba7 100644
--- a/openrtb_ext/user.go
+++ b/openrtb_ext/user.go
@@ -1,6 +1,7 @@
 package openrtb_ext
 
 import (
+	"encoding/json"
 	"strconv"
 	"strings"
 
@@ -20,6 +21,8 @@ type ExtUser struct {
 	Prebid *ExtUserPrebid `json:"prebid,omitempty"`
 
 	Eids []openrtb2.EID `json:"eids,omitempty"`
+
+	Data json.RawMessage `json:"data,omitempty"`
 }
 
 // ExtUserPrebid defines the contract for bidrequest.user.ext.prebid
diff --git a/router/router.go b/router/router.go
index de120cfe6..71a9bc774 100644
--- a/router/router.go
+++ b/router/router.go
@@ -5,6 +5,7 @@ import (
 	"crypto/tls"
 	"encoding/json"
 	"fmt"
+	"net"
 	"net/http"
 	"os"
 	"strings"
@@ -20,6 +21,7 @@ import (
 	"github.com/prebid/prebid-server/errortypes"
 	"github.com/prebid/prebid-server/exchange"
 	"github.com/prebid/prebid-server/experiment/adscert"
+	"github.com/prebid/prebid-server/floors"
 	"github.com/prebid/prebid-server/gdpr"
 	"github.com/prebid/prebid-server/hooks"
 	"github.com/prebid/prebid-server/metrics"
@@ -138,6 +140,14 @@ func New(cfg *config.Configuration, rateConvertor *currency.RateConverter) (r *R
 			MaxIdleConnsPerHost: cfg.Client.MaxIdleConnsPerHost,
 			IdleConnTimeout:     time.Duration(cfg.Client.IdleConnTimeout) * time.Second,
 			TLSClientConfig:     &tls.Config{RootCAs: certPool},
+
+			TLSHandshakeTimeout:   time.Duration(cfg.Client.TLSHandshakeTimeout) * time.Second,
+			ResponseHeaderTimeout: time.Duration(cfg.Client.ResponseHeaderTimeout) * time.Second,
+
+			Dial: (&net.Dialer{
+				Timeout:   time.Duration(cfg.Client.DialTimeout) * time.Millisecond,
+				KeepAlive: time.Duration(cfg.Client.DialKeepAlive) * time.Second,
+			}).Dial,
 		},
 	}
 
@@ -181,6 +191,10 @@ func New(cfg *config.Configuration, rateConvertor *currency.RateConverter) (r *R
 	// todo(zachbadgett): better shutdown
 	r.Shutdown = shutdown
 
+	//Price Floor Fetcher
+	priceFloorFetcher := floors.NewPriceFloorFetcher(cfg.PriceFloorFetcher.Worker, cfg.PriceFloorFetcher.Capacity,
+		cfg.AccountDefaults.PriceFloors.Fetch.Period, cfg.AccountDefaults.PriceFloors.Fetch.MaxAge, r.MetricsEngine)
+
 	pbsAnalytics := analyticsConf.NewPBSAnalytics(&cfg.Analytics)
 
 	paramsValidator, err := openrtb_ext.NewBidderParamsValidator(schemaDirectory)
@@ -201,6 +215,14 @@ func New(cfg *config.Configuration, rateConvertor *currency.RateConverter) (r *R
 	gdprPermsBuilder := gdpr.NewPermissionsBuilder(cfg.GDPR, gvlVendorIDs, vendorListFetcher)
 	tcf2CfgBuilder := gdpr.NewTCF2Config
 
+	if cfg.VendorListScheduler.Enabled {
+		vendorListScheduler, err := gdpr.GetVendorListScheduler(cfg.VendorListScheduler.Interval, cfg.VendorListScheduler.Timeout, generalHttpClient)
+		if err != nil {
+			glog.Fatal(err)
+		}
+		vendorListScheduler.Start()
+	}
+
 	cacheClient := pbc.NewClient(cacheHttpClient, &cfg.CacheURL, &cfg.ExtCacheURL, r.MetricsEngine)
 
 	adapters, adaptersErrs := exchange.BuildAdapters(generalHttpClient, cfg, cfg.BidderInfos, r.MetricsEngine)
@@ -214,7 +236,7 @@ func New(cfg *config.Configuration, rateConvertor *currency.RateConverter) (r *R
 	}
 
 	planBuilder := hooks.NewExecutionPlanBuilder(cfg.Hooks, repo)
-	theExchange := exchange.NewExchange(adapters, cacheClient, cfg, syncersByBidder, r.MetricsEngine, cfg.BidderInfos, gdprPermsBuilder, rateConvertor, categoriesFetcher, adsCertSigner)
+	theExchange := exchange.NewExchange(adapters, cacheClient, cfg, syncersByBidder, r.MetricsEngine, cfg.BidderInfos, gdprPermsBuilder, rateConvertor, categoriesFetcher, adsCertSigner, priceFloorFetcher)
 	var uuidGenerator uuidutil.UUIDRandomGenerator
 	openrtbEndpoint, err := openrtb2.NewEndpoint(uuidGenerator, theExchange, paramsValidator, fetcher, accounts, cfg, r.MetricsEngine, pbsAnalytics, disabledBidders, defReqJSON, activeBidders, storedRespFetcher, planBuilder)
 	if err != nil {
@@ -269,6 +291,27 @@ func New(cfg *config.Configuration, rateConvertor *currency.RateConverter) (r *R
 	r.POST("/optout", userSyncDeps.OptOut)
 	r.GET("/optout", userSyncDeps.OptOut)
 
+	r.registerOpenWrapEndpoints(openrtbEndpoint, ampEndpoint)
+
+	g_syncers = syncersByBidder
+	g_metrics = r.MetricsEngine
+	g_cfg = cfg
+	g_storedReqFetcher = &fetcher
+	g_accounts = &accounts
+	g_videoFetcher = &videoFetcher
+	g_storedRespFetcher = &storedRespFetcher
+	g_analytics = &pbsAnalytics
+	g_paramsValidator = &paramsValidator
+	g_activeBidders = activeBidders
+	g_disabledBidders = disabledBidders
+	g_defReqJSON = defReqJSON
+	g_cacheClient = &cacheClient
+	g_ex = &theExchange
+	g_gdprPermsBuilder = gdprPermsBuilder
+	g_tcf2CfgBuilder = tcf2CfgBuilder
+	g_planBuilder = &planBuilder
+	g_currencyConversions = rateConvertor.Rates()
+
 	return r, nil
 }
 
diff --git a/router/router_ow.go b/router/router_ow.go
new file mode 100644
index 000000000..18705d524
--- /dev/null
+++ b/router/router_ow.go
@@ -0,0 +1,37 @@
+package router
+
+import (
+	"net/http"
+
+	"github.com/julienschmidt/httprouter"
+)
+
+const (
+	OpenWrapAuction     = "/pbs/openrtb2/auction"
+	OpenWrapV25         = "/openrtb/2.5"
+	OpenWrapV25Video    = "/openrtb/2.5/video"
+	OpenWrapAmp         = "/openrtb/amp"
+	OpenWrapHealthcheck = "/healthcheck"
+)
+
+// Support legacy APIs for a grace period.
+// not implementing middleware to avoid duplicate processing like read, unmarshal, write, etc.
+// handling the temporary middleware stuff in EntryPoint hook.
+func (r *Router) registerOpenWrapEndpoints(openrtbEndpoint, ampEndpoint httprouter.Handle) {
+	//OpenWrap hybrid
+	r.POST(OpenWrapAuction, openrtbEndpoint)
+
+	// OpenWrap 2.5 in-app, etc
+	r.POST(OpenWrapV25, openrtbEndpoint)
+
+	// OpenWrap 2.5 video
+	r.GET(OpenWrapV25Video, openrtbEndpoint)
+
+	// OpenWrap AMP
+	r.POST(OpenWrapAmp, ampEndpoint)
+
+	// healthcheck used by k8s
+	r.GET(OpenWrapHealthcheck, func(w http.ResponseWriter, r *http.Request, p httprouter.Params) {
+		w.WriteHeader(http.StatusOK)
+	})
+}
diff --git a/router/router_sshb.go b/router/router_sshb.go
new file mode 100644
index 000000000..deb6df0cd
--- /dev/null
+++ b/router/router_sshb.go
@@ -0,0 +1,140 @@
+package router
+
+import (
+	"fmt"
+	"net/http"
+	"strconv"
+
+	"github.com/prebid/openrtb/v19/openrtb3"
+	"github.com/prebid/prebid-server/analytics"
+	"github.com/prebid/prebid-server/currency"
+	"github.com/prebid/prebid-server/hooks"
+
+	analyticCfg "github.com/prebid/prebid-server/analytics/config"
+	"github.com/prebid/prebid-server/config"
+	"github.com/prebid/prebid-server/endpoints"
+	"github.com/prebid/prebid-server/endpoints/openrtb2"
+	"github.com/prebid/prebid-server/exchange"
+	"github.com/prebid/prebid-server/gdpr"
+	"github.com/prebid/prebid-server/metrics"
+	metricsConf "github.com/prebid/prebid-server/metrics/config"
+	"github.com/prebid/prebid-server/openrtb_ext"
+	pbc "github.com/prebid/prebid-server/prebid_cache_client"
+	"github.com/prebid/prebid-server/stored_requests"
+	"github.com/prebid/prebid-server/usersync"
+	"github.com/prebid/prebid-server/util/uuidutil"
+	"github.com/prometheus/client_golang/prometheus"
+)
+
+// TODO: Delete router_sshb.go usage after PBS-OpenWrap module
+
+var (
+	g_syncers             map[string]usersync.Syncer
+	g_cfg                 *config.Configuration
+	g_ex                  *exchange.Exchange
+	g_accounts            *stored_requests.AccountFetcher
+	g_paramsValidator     *openrtb_ext.BidderParamValidator
+	g_storedReqFetcher    *stored_requests.Fetcher
+	g_storedRespFetcher   *stored_requests.Fetcher
+	g_metrics             metrics.MetricsEngine
+	g_analytics           *analytics.PBSAnalyticsModule
+	g_disabledBidders     map[string]string
+	g_videoFetcher        *stored_requests.Fetcher
+	g_activeBidders       map[string]openrtb_ext.BidderName
+	g_defReqJSON          []byte
+	g_cacheClient         *pbc.Client
+	g_gdprPermsBuilder    gdpr.PermissionsBuilder
+	g_tcf2CfgBuilder      gdpr.TCF2ConfigBuilder
+	g_planBuilder         *hooks.ExecutionPlanBuilder
+	g_currencyConversions currency.Conversions
+)
+
+func GetCacheClient() *pbc.Client {
+	return g_cacheClient
+}
+
+func GetPrebidCacheURL() string {
+	return g_cfg.ExternalURL
+}
+
+// RegisterAnalyticsModule function registers the PBSAnalyticsModule
+func RegisterAnalyticsModule(anlt analytics.PBSAnalyticsModule) error {
+	if g_analytics == nil {
+		return fmt.Errorf("g_analytics is nil")
+	}
+	modules, err := analyticCfg.EnableAnalyticsModule(anlt, *g_analytics)
+	if err != nil {
+		return err
+	}
+	g_analytics = &modules
+	return nil
+}
+
+// OrtbAuctionEndpointWrapper Openwrap wrapper method for calling /openrtb2/auction endpoint
+func OrtbAuctionEndpointWrapper(w http.ResponseWriter, r *http.Request) error {
+	ortbAuctionEndpoint, err := openrtb2.NewEndpoint(uuidutil.UUIDRandomGenerator{}, *g_ex, *g_paramsValidator, *g_storedReqFetcher, *g_accounts, g_cfg, g_metrics, *g_analytics, g_disabledBidders, g_defReqJSON, g_activeBidders, *g_storedRespFetcher, *g_planBuilder)
+	if err != nil {
+		return err
+	}
+	ortbAuctionEndpoint(w, r, nil)
+	return nil
+}
+
+// GetPBSCurrencyRate Openwrap wrapper method for currency conversion
+func GetPBSCurrencyConversion(from, to string, value float64) (float64, error) {
+	rate, err := g_currencyConversions.GetRate(from, to)
+	if err == nil {
+		return value * rate, nil
+	}
+	return 0, err
+}
+
+// VideoAuctionEndpointWrapper Openwrap wrapper method for calling /openrtb2/video endpoint
+func VideoAuctionEndpointWrapper(w http.ResponseWriter, r *http.Request) error {
+	videoAuctionEndpoint, err := openrtb2.NewCTVEndpoint(*g_ex, *g_paramsValidator, *g_storedReqFetcher, *g_videoFetcher, *g_accounts, g_cfg, g_metrics, *g_analytics, g_disabledBidders, g_defReqJSON, g_activeBidders)
+	if err != nil {
+		return err
+	}
+	videoAuctionEndpoint(w, r, nil)
+	return nil
+}
+
+// GetUIDSWrapper Openwrap wrapper method for calling /getuids endpoint
+func GetUIDSWrapper(w http.ResponseWriter, r *http.Request) {
+	getUID := endpoints.NewGetUIDsEndpoint(g_cfg.HostCookie)
+	getUID(w, r, nil)
+}
+
+// SetUIDSWrapper Openwrap wrapper method for calling /setuid endpoint
+func SetUIDSWrapper(w http.ResponseWriter, r *http.Request) {
+	setUID := endpoints.NewSetUIDEndpoint(g_cfg, g_syncers, g_gdprPermsBuilder, g_tcf2CfgBuilder, *g_analytics, *g_accounts, g_metrics)
+	setUID(w, r, nil)
+}
+
+// CookieSync Openwrap wrapper method for calling /cookie_sync endpoint
+func CookieSync(w http.ResponseWriter, r *http.Request) {
+	cookiesync := endpoints.NewCookieSyncEndpoint(g_syncers, g_cfg, g_gdprPermsBuilder, g_tcf2CfgBuilder, g_metrics, *g_analytics, *g_accounts, g_activeBidders)
+	cookiesync.Handle(w, r, nil)
+}
+
+// SyncerMap Returns map of bidder and its usersync info
+func SyncerMap() map[string]usersync.Syncer {
+	return g_syncers
+}
+
+func GetPrometheusGatherer() *prometheus.Registry {
+	mEngine, ok := g_metrics.(*metricsConf.DetailedMetricsEngine)
+	if !ok || mEngine == nil || mEngine.PrometheusMetrics == nil {
+		return nil
+	}
+
+	return mEngine.PrometheusMetrics.Gatherer
+}
+
+// CallRecordNonBids calls RecordRejectedBids function on prebid's metric-engine
+func CallRecordNonBids(pubId, bidder string, code openrtb3.NonBidStatusCode) {
+	if g_metrics != nil {
+		codeStr := strconv.FormatInt(int64(code), 10)
+		g_metrics.RecordRejectedBids(pubId, bidder, codeStr)
+	}
+}
diff --git a/router/router_test.go b/router/router_test.go
index 2b4ff7fd3..46143969c 100644
--- a/router/router_test.go
+++ b/router/router_test.go
@@ -7,9 +7,9 @@ import (
 	"os"
 	"testing"
 
+	_ "github.com/lib/pq"
 	"github.com/prebid/prebid-server/config"
 	"github.com/prebid/prebid-server/openrtb_ext"
-
 	"github.com/stretchr/testify/assert"
 )
 
diff --git a/scripts/coverage.sh b/scripts/coverage.sh
index 640f8022f..51f8c7a97 100755
--- a/scripts/coverage.sh
+++ b/scripts/coverage.sh
@@ -22,9 +22,13 @@ generate_cover_data() {
     for pkg in "$@"; do
         f="$workdir/$(echo $pkg | tr / -).cover"
         cover=""
-        if ! [[ "$pkg" =~ ^github\.com\/prebid\/prebid\-server$ ]]; then
+        if ! [[ "$pkg" =~ ^github\.com\/PubMatic\-OpenWrap\/prebid\-server$ ]]; then
             cover="-covermode=$mode -coverprofile=$f"
         fi
+        # util/task uses _test package name
+        if [[ "$pkg" =~ ^github\.com\/PubMatic\-OpenWrap\/prebid\-server\/util\/task$ ]]; then
+            cover+=" -coverpkg=github.com/prebid/prebid-server/util/task"
+        fi
         go test ${cover} "$pkg"
     done
 
diff --git a/scripts/upgrade-pbs.sh b/scripts/upgrade-pbs.sh
new file mode 100755
index 000000000..95596ba94
--- /dev/null
+++ b/scripts/upgrade-pbs.sh
@@ -0,0 +1,262 @@
+#!/bin/bash -e
+
+prefix="v"
+to_major=0
+to_minor=230
+to_patch=0
+upgrade_version="$prefix$to_major.$to_minor.$to_patch"
+
+attempt=4
+
+usage="
+Script starts or continues prebid upgrade to version set in 'to_minor' variable. Workspace is at /tmp/prebid-server and /tmp/pbs-patch
+
+    ./upgrade-pbs.sh [--restart]
+
+    --restart   Restart the upgrade (deletes /tmp/prebid-server and /tmp/pbs-patch)
+    -h          Help
+
+TODO:
+    - paramertrize the script
+    - create ci branch PR
+    - create header-bidding PR"
+
+RESTART=0
+for i in "$@"; do
+  case $i in
+    --restart)
+      RESTART=1
+      shift
+      ;;
+    -h)
+      echo "$usage"
+      exit 0
+      ;;
+  esac
+done
+
+# --- start ---
+CHECKLOG=/tmp/pbs-patch/checkpoints.log
+
+trap 'clear_log' EXIT
+
+log () {
+  printf "\n$(date): $1\n"
+}
+
+clear_log() {
+    major=0
+    minor=0
+    patch=0
+    get_current_tag_version major minor patch
+    current_fork_at_version="$major.$minor.$patch"
+
+    if [ "$current_fork_at_version" == "$upgrade_version" ] ; then
+        log "Upgraded to $current_fork_at_version"
+        rm -f "$CHECKLOG"
+    
+        log "Last validation before creating PR"
+        go_mod
+        checkpoint_run "./validate.sh --race 5"
+        go_discard
+
+        set +e
+        log "Commit final go.mod and go.sum"
+        git commit go.mod go.sum --amend --no-edit
+        set -e
+    else
+        log "Exiting with failure!!!"
+        exit 1
+    fi
+}
+
+get_current_tag_version() {
+    log "get_current_tag_version $*"
+
+    local -n _major=$1
+    local -n _minor=$2
+    local -n _patch=$3
+
+    # script will always start from start if origin/master is used.
+    # common_commit=$(git merge-base prebid-upstream/master origin/master)
+    # log "Common commit b/w prebid-upstream/master origin/master: $common_commit"
+
+    # remove origin for master to continue from last fixed tag's rebase.
+    common_commit=$(git merge-base prebid-upstream/master master)
+    log "Common commit b/w prebid-upstream/master master: $common_commit"
+
+    current_version=$(git tag --points-at $common_commit)
+    if [[ $current_version == v* ]] ; then
+        log "Current Version: $current_version"
+    else
+        log "Failed to detected current version. Abort."
+        exit 1
+        # abort
+        # cd prebid-server; git rebase --abort;cd -
+    fi
+
+    IFS='.' read -r -a _current_version <<< "$current_version"
+    _major=${_current_version[0]}
+    _minor=${_current_version[1]}
+    _patch=${_current_version[2]}
+}
+
+clone_repo() {
+    if [ -d "/tmp/prebid-server" ]; then
+        log "Code already cloned. Attempting to continue the upgrade!!!"
+    else
+        log "Cloning repo at /tmp"
+        cd /tmp
+        git clone https://github.com/PubMatic-OpenWrap/prebid-server.git
+        cd prebid-server
+
+        git remote add prebid-upstream https://github.com/prebid/prebid-server.git
+        git remote -v
+        git fetch --all --tags --prune
+    fi
+}
+
+checkout_branch() {
+    set +e
+    git checkout tags/$_upgrade_version -b $tag_base_branch_name
+    # git push origin $tag_base_branch_name
+
+    git checkout -b $upgrade_branch_name
+    # git push origin $upgrade_branch_name
+
+    set -e
+#    if [ "$?" -ne 0 ]
+#    then
+#        log "Failed to create branch $upgrade_branch_name. Already working on it???"
+#        exit 1
+#    fi
+}
+
+cmd_exe() {
+    cmd=$*
+    if ! $cmd; then
+        log "Failure!!! creating checkpoint $cmd"
+        echo "$cmd" > $CHECKLOG
+        exit 1
+    fi
+}
+
+checkpoint_run() {
+    cmd=$*
+    if [ -f $CHECKLOG ] ; then
+        if grep -q "$cmd" "$CHECKLOG"; then
+            log "Retry this checkpoint: $cmd"
+            rm "$CHECKLOG"
+        elif grep -q "./validate.sh --race 5" "$CHECKLOG"; then
+            log "Special checkpoint. ./validate.sh --race 5 failed for last tag update. Hence, only fixes are expected in successfully upgraded branch. (change in func() def, wrong conflict resolve, etc)"
+            cmd_exe $cmd
+            rm "$CHECKLOG"
+        else
+            log "Skip this checkpoint: $cmd"
+            return
+        fi
+    fi
+    cmd_exe $cmd
+}
+
+go_mod() {
+    go mod download all
+    go mod tidy
+    go mod tidy
+    go mod download all
+}
+
+go_discard() {
+    # discard local changes if any. manual validate, compile, etc
+    # git checkout master go.mod
+    # git checkout master go.sum
+    git checkout go.mod go.sum
+}
+
+# --- main ---
+
+if [ "$RESTART" -eq "1" ]; then
+    log "Restarting the upgrade: rm -rf /tmp/prebid-server /tmp/pbs-patch/"
+    rm -rf /tmp/prebid-server /tmp/pbs-patch/ 
+    mkdir -p /tmp/pbs-patch/
+fi
+
+log "Final Upgrade Version: $upgrade_version"
+log "Attempt: $attempt"
+
+checkpoint_run clone_repo
+cd /tmp/prebid-server
+log "At $(pwd)"
+
+# code merged in master
+# if [ "$RESTART" -eq "1" ]; then
+#     # TODO: commit this in origin/master,ci and remove it from here.
+#     git merge --squash origin/UOE-7610-1-upgrade.sh
+#     git commit --no-edit
+# fi
+
+major=0
+minor=0
+patch=0
+
+get_current_tag_version major minor patch
+current_fork_at_version="$major.$minor.$patch"
+git diff tags/$current_fork_at_version..origin/master > /tmp/pbs-patch/current_ow_patch-$current_fork_at_version-origin_master-$attempt.diff
+
+((minor++))
+log "Starting with version split major:$major, minor:$minor, patch:$patch"
+
+# how to validate with this code
+# if [ "$RESTART" -eq "1" ]; then
+#     # Solving go.mod and go.sum conflicts would be easy at last as we would need to only pick the OW-patch entries rather than resolving conflict for every version
+#     log "Using latest go.mod and go.sum. Patch OW changes at last"
+#     git checkout tags/$current_fork_at_version go.mod
+#     git checkout tags/$current_fork_at_version go.sum
+#     git commit go.mod go.sum -m "[upgrade-start-checkpoint] tags/$current_fork_at_version go.mod go.sum"
+# fi
+
+log "Checking if last failure was for test case. Need this to pick correct"
+go_mod
+checkpoint_run "./validate.sh --race 5"
+go_discard
+
+log "Starting upgrade loop..."
+while [ "$minor" -le "$to_minor" ]; do
+    # _upgrade_version="$prefix$major.$minor.$patch"
+    _upgrade_version="$major.$minor.$patch"
+    ((minor++))
+
+    log "Starting upgrade to version $_upgrade_version"
+
+    tag_base_branch_name=prebid_$_upgrade_version-$attempt-tag
+    upgrade_branch_name=prebid_$_upgrade_version-$attempt
+    log "Reference tag branch: $tag_base_branch_name"
+    log "Upgrade branch: $upgrade_branch_name"
+
+    checkpoint_run checkout_branch
+
+    checkpoint_run git merge master --no-edit
+    # Use `git commit --amend --no-edit` if you had to fix test cases, etc for wrong merge conflict resolve, etc.
+    log "Validating the master merge into current tag. Fix and commit changes if required. Use 'git commit --amend --no-edit' for consistency"
+    go_mod
+    checkpoint_run "./validate.sh --race 5"
+    go_discard
+
+    checkpoint_run git checkout master
+    checkpoint_run git merge $upgrade_branch_name --no-edit
+
+    log "Generating patch file at /tmp/pbs-patch/ for $_upgrade_version"
+    git diff tags/$_upgrade_version..master > /tmp/pbs-patch/new_ow_patch_$upgrade_version-master-1.diff
+done
+
+# TODO:
+# diff tags/v0.192.0..origin/master
+# diff tags/v0.207.0..prebid_v0.207.0
+
+# TODO: UPDATE HEADER-BIDDING GO-MOD
+
+
+# TODO: automate go.mod conflicts
+# go mod edit -replace github.com/prebid/prebid-server=./
+# go mod edit -replace github.com/mxmCherry/openrtb/v16=github.com/PubMatic-OpenWrap/openrtb/v15@v15.0.0
+# go mod edit -replace github.com/beevik/etree=github.com/PubMatic-OpenWrap/etree@latest
diff --git a/static/bidder-info/spotx.yaml b/static/bidder-info/spotx.yaml
new file mode 100644
index 000000000..518245610
--- /dev/null
+++ b/static/bidder-info/spotx.yaml
@@ -0,0 +1,10 @@
+maintainer:
+  email: "teameighties@spotx.tv"
+gvlVendorID: 165
+capabilities:
+  app:
+    mediaTypes:
+      - video
+  site:
+    mediaTypes:
+      - video
diff --git a/static/bidder-info/vastbidder.yaml b/static/bidder-info/vastbidder.yaml
new file mode 100644
index 000000000..b8eb41d4e
--- /dev/null
+++ b/static/bidder-info/vastbidder.yaml
@@ -0,0 +1,9 @@
+maintainer:
+  email: "UOEDev@pubmatic.com"
+capabilities:
+  app:
+    mediaTypes:
+      - video
+  site:
+    mediaTypes:
+      - video
diff --git a/static/bidder-params/spotx.json b/static/bidder-params/spotx.json
new file mode 100644
index 000000000..13b72f215
--- /dev/null
+++ b/static/bidder-params/spotx.json
@@ -0,0 +1,39 @@
+{
+  "$schema": "http://json-schema.org/draft-04/schema#",
+  "title": "OpenX Adapter Params",
+  "description": "A schema which validates params accepted by the OpenX adapter",
+
+  "type": "object",
+  "properties": {
+    "channel_id": {
+      "type": "string",
+      "minLength": 5,
+      "maxLength": 5,
+      "description": "A unique 5 digit ID that is generated by the SpotX publisher platform when a channel is created"
+    },
+    "ad_unit": {
+      "type": "string",
+      "description": "Token that describes which ad unit to play: instream or outstream",
+      "enum": ["instream", "outstream"]
+    },
+    "secure": {
+      "type": "boolean",
+      "description": "Boolean identifying whether the reqeusts should be https or not (used to override the protocol if the page isn’t secure."
+    },
+    "ad_volume": {
+      "type": "number",
+      "minimum": 0,
+      "maximum": 1,
+      "description": "Value between 0 and 1 to denote the volume the ad should start at."
+    },
+    "price_floor": {
+      "type": "integer",
+      "description": "Set the current channel price floor in real time."
+    },
+    "hide_skin": {
+      "type": "boolean",
+      "description": "Set to true to hide the spotx skin."
+    }
+  },
+  "required": ["channel_id", "ad_unit"]
+}
diff --git a/static/bidder-params/vastbidder.json b/static/bidder-params/vastbidder.json
new file mode 100644
index 000000000..0bef9b5fd
--- /dev/null
+++ b/static/bidder-params/vastbidder.json
@@ -0,0 +1,27 @@
+{
+  "$schema": "http://json-schema.org/draft-04/schema#",
+  "title": "Tag Bidder Base Adapter",
+  "description": "A schema which validates params accepted by the VAST tag bidders",
+
+  "type": "object",
+  "properties": {
+    "tags": {
+      "type": "array",
+      "items": {
+          "type": "object",
+          "properties": {
+            "tagid": { "type": "string" },
+            "url": { "type": "string" },
+            "dur": { "type": "integer" },
+            "price": { "type": "number" },
+            "params": { "type": "object" }
+          },
+         "required": [ "tagid", "url", "dur" ]
+      }
+    },
+    "parser": { "type": "string" },
+    "headers": { "type": "object" },
+    "cookies": { "type": "object" }
+  },
+  "required": ["tags"]
+}
\ No newline at end of file
diff --git a/usersync/chooser.go b/usersync/chooser.go
index 97fa1471b..33c02384b 100644
--- a/usersync/chooser.go
+++ b/usersync/chooser.go
@@ -132,7 +132,11 @@ func (c standardChooser) Choose(request Request, cookie *Cookie) Result {
 }
 
 func (c standardChooser) evaluate(bidder string, syncersSeen map[string]struct{}, syncTypeFilter SyncTypeFilter, privacy Privacy, cookie *Cookie) (Syncer, BidderEvaluation) {
-	syncer, exists := c.bidderSyncerLookup[bidder]
+	bidderName := bidder
+	if bidderName == "indexExchange" {
+		bidderName = "ix"
+	}
+	syncer, exists := c.bidderSyncerLookup[bidderName]
 	if !exists {
 		return nil, BidderEvaluation{Status: StatusUnknownBidder, Bidder: bidder}
 	}
diff --git a/usersync/cookie.go b/usersync/cookie.go
index 51474afdd..ada51489a 100644
--- a/usersync/cookie.go
+++ b/usersync/cookie.go
@@ -146,6 +146,7 @@ func (cookie *Cookie) GetUIDs() map[string]string {
 func (cookie *Cookie) SetCookieOnResponse(w http.ResponseWriter, setSiteCookie bool, cfg *config.HostCookie, ttl time.Duration) {
 	httpCookie := cookie.ToHTTPCookie(ttl)
 	var domain string = cfg.Domain
+	httpCookie.Secure = true
 
 	if domain != "" {
 		httpCookie.Domain = domain
@@ -171,7 +172,7 @@ func (cookie *Cookie) SetCookieOnResponse(w http.ResponseWriter, setSiteCookie b
 	}
 
 	if setSiteCookie {
-		httpCookie.Secure = true
+		// httpCookie.Secure = true
 		httpCookie.SameSite = http.SameSiteNoneMode
 	}
 	w.Header().Add("Set-Cookie", httpCookie.String())
diff --git a/util/boolutil/boolutil.go b/util/boolutil/boolutil.go
new file mode 100644
index 000000000..bc83569d0
--- /dev/null
+++ b/util/boolutil/boolutil.go
@@ -0,0 +1,6 @@
+package boolutil
+
+// BoolPtr returns pointer value of boolean input
+func BoolPtr(val bool) *bool {
+	return &val
+}
diff --git a/version/xprebidheader.go b/version/xprebidheader.go
index fc71bacb1..103642feb 100644
--- a/version/xprebidheader.go
+++ b/version/xprebidheader.go
@@ -8,7 +8,7 @@ import (
 	"github.com/prebid/prebid-server/openrtb_ext"
 )
 
-const xPrebidHeaderVersionPrefix = "pbs-go"
+const xPrebidHeaderVersionPrefix = "owpbs-go"
 
 func BuildXPrebidHeader(version string) string {
 	sb := &strings.Builder{}
diff --git a/version/xprebidheader_test.go b/version/xprebidheader_test.go
index 90aef6cb4..1843d3ea2 100644
--- a/version/xprebidheader_test.go
+++ b/version/xprebidheader_test.go
@@ -19,12 +19,12 @@ func TestBuildXPrebidHeader(t *testing.T) {
 		{
 			description: "No Version",
 			version:     "",
-			result:      "pbs-go/unknown",
+			result:      "owpbs-go/unknown",
 		},
 		{
 			description: "Version",
 			version:     "0.100.0",
-			result:      "pbs-go/0.100.0",
+			result:      "owpbs-go/0.100.0",
 		},
 	}
 
@@ -45,12 +45,12 @@ func TestBuildXPrebidHeaderForRequest(t *testing.T) {
 		{
 			description: "No versions",
 			version:     "",
-			result:      "pbs-go/unknown",
+			result:      "owpbs-go/unknown",
 		},
 		{
 			description: "pbs",
 			version:     "test-version",
-			result:      "pbs-go/test-version",
+			result:      "owpbs-go/test-version",
 		},
 		{
 			description: "prebid.js",
@@ -63,7 +63,7 @@ func TestBuildXPrebidHeaderForRequest(t *testing.T) {
 					},
 				},
 			},
-			result: "pbs-go/test-version,pbjs/test-pbjs-version",
+			result: "owpbs-go/test-version,pbjs/test-pbjs-version",
 		},
 		{
 			description: "unknown prebid.js",
@@ -75,7 +75,7 @@ func TestBuildXPrebidHeaderForRequest(t *testing.T) {
 					},
 				},
 			},
-			result: "pbs-go/test-version,pbjs/unknown",
+			result: "owpbs-go/test-version,pbjs/unknown",
 		},
 		{
 			description: "channel without a name",
@@ -87,7 +87,7 @@ func TestBuildXPrebidHeaderForRequest(t *testing.T) {
 					},
 				},
 			},
-			result: "pbs-go/test-version",
+			result: "owpbs-go/test-version",
 		},
 		{
 			description: "prebid-mobile",
@@ -98,7 +98,7 @@ func TestBuildXPrebidHeaderForRequest(t *testing.T) {
 					Version: "test-prebid-mobile-version",
 				},
 			},
-			result: "pbs-go/test-version,prebid-mobile/test-prebid-mobile-version",
+			result: "owpbs-go/test-version,prebid-mobile/test-prebid-mobile-version",
 		},
 		{
 			description: "app ext without a source",
@@ -108,7 +108,7 @@ func TestBuildXPrebidHeaderForRequest(t *testing.T) {
 					Version: "test-version",
 				},
 			},
-			result: "pbs-go/test-version",
+			result: "owpbs-go/test-version",
 		},
 		{
 			description: "Version found in both req.Ext and req.App.Ext",
@@ -127,7 +127,7 @@ func TestBuildXPrebidHeaderForRequest(t *testing.T) {
 					Version: "test-prebid-mobile-version",
 				},
 			},
-			result: "pbs-go/test-version,pbjs/test-pbjs-version,prebid-mobile/test-prebid-mobile-version",
+			result: "owpbs-go/test-version,pbjs/test-pbjs-version,prebid-mobile/test-prebid-mobile-version",
 		},
 	}
 
