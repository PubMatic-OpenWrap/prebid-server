
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pubmatic: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/PubMatic-OpenWrap/prebid-server/v2/adapters/pubmatic/pubmatic.go (93.7%)</option>
				
				<option value="file1">github.com/PubMatic-OpenWrap/prebid-server/v2/adapters/pubmatic/pubmatic_ow.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package pubmatic

import (
        "encoding/json"
        "errors"
        "fmt"
        "math"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"

        "github.com/prebid/prebid-server/v2/adapters"
        "github.com/prebid/prebid-server/v2/config"
        "github.com/prebid/prebid-server/v2/errortypes"
        "github.com/prebid/prebid-server/v2/openrtb_ext"
        "github.com/prebid/prebid-server/v2/util/ptrutil"

        "github.com/buger/jsonparser"
        "github.com/prebid/openrtb/v20/openrtb2"
)

const MAX_IMPRESSIONS_PUBMATIC = 30
const MAX_MULTIFLOORS_PUBMATIC = 3

var re = regexp.MustCompile(appLovinMaxImpressionPattern)

const (
        ae                           = "ae"
        PUBMATIC                     = "[PUBMATIC]"
        buyId                        = "buyid"
        buyIdTargetingKey            = "hb_buyid_"
        skAdnetworkKey               = "skadn"
        rewardKey                    = "reward"
        dctrKeywordName              = "dctr"
        urlEncodedEqualChar          = "%3D"
        AdServerKey                  = "adserver"
        PBAdslotKey                  = "pbadslot"
        bidViewability               = "bidViewability"
        multiFloors                  = "_mf"
        appLovinMaxImpressionPattern = "_mf.*"
)

type PubmaticAdapter struct {
        URI        string
        bidderName string
}

type pubmaticBidExt struct {
        BidType            *int                 `json:"BidType,omitempty"`
        VideoCreativeInfo  *pubmaticBidExtVideo `json:"video,omitempty"`
        Marketplace        string               `json:"marketplace,omitempty"`
        PrebidDealPriority int                  `json:"prebiddealpriority,omitempty"`
        DspId              int                  `json:"dspid,omitempty"`
        AdvertiserID       int                  `json:"advid,omitempty"`
}

type pubmaticWrapperExt struct {
        ProfileID int `json:"profile,omitempty"`
        VersionID int `json:"version,omitempty"`

        WrapperImpID string `json:"wiid,omitempty"`
}

type pubmaticBidExtVideo struct {
        Duration *int `json:"duration,omitempty"`
}

type ExtImpBidderPubmatic struct {
        adapters.ExtImpBidder
        Data        json.RawMessage `json:"data,omitempty"`
        AE          int             `json:"ae,omitempty"`
        GpId        string          `json:"gpid,omitempty"`
        SKAdnetwork json.RawMessage `json:"skadn,omitempty"`
}

type ExtAdServer struct {
        Name   string `json:"name"`
        AdSlot string `json:"adslot"`
}

type marketplaceReqExt struct {
        AllowedBidders []string `json:"allowedbidders,omitempty"`
}

type extRequestAdServer struct {
        Wrapper     *pubmaticWrapperExt `json:"wrapper,omitempty"`
        Acat        []string            `json:"acat,omitempty"`
        Marketplace *marketplaceReqExt  `json:"marketplace,omitempty"`
        openrtb_ext.ExtRequest
}

type respExt struct {
        FledgeAuctionConfigs map[string]json.RawMessage `json:"fledge_auction_configs,omitempty"`
}

const (
        dctrKeyName              = "key_val"
        pmZoneIDKeyName          = "pmZoneId"
        pmZoneIDKeyNameOld       = "pmZoneID"
        ImpExtAdUnitKey          = "dfp_ad_unit_code"
        AdServerGAM              = "gam"
        gpIdKey                  = "gpid"
        pmZoneIDRequestParamName = "pmzoneid"
)

func (a *PubmaticAdapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *adapters.ExtraRequestInfo) ([]*adapters.RequestData, []error) <span class="cov8" title="1">{
        errs := make([]error, 0, len(request.Imp))

        pubID := ""
        extractWrapperExtFromImp := true
        extractPubIDFromImp := true

        newReqExt, cookies, err := extractPubmaticExtFromRequest(request)
        if err != nil </span><span class="cov8" title="1">{
                return nil, []error{err}
        }</span>
        <span class="cov8" title="1">wrapperExt := newReqExt.Wrapper
        if wrapperExt != nil &amp;&amp; wrapperExt.ProfileID != 0 &amp;&amp; wrapperExt.VersionID != 0 </span><span class="cov8" title="1">{
                extractWrapperExtFromImp = false
        }</span>

        <span class="cov8" title="1">impFloorsMap := map[string][]float64{}

        for i := 0; i &lt; len(request.Imp); i++ </span><span class="cov8" title="1">{
                wrapperExtFromImp, pubIDFromImp, floors, err := parseImpressionObject(&amp;request.Imp[i], extractWrapperExtFromImp, extractPubIDFromImp)
                // If the parsing is failed, remove imp and add the error.
                if err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                        request.Imp = append(request.Imp[:i], request.Imp[i+1:]...)
                        i--
                        continue</span>
                }

                <span class="cov8" title="1">if len(floors) &gt; 0 </span><span class="cov8" title="1">{
                        impFloorsMap[request.Imp[i].ID] = floors
                }</span>

                <span class="cov8" title="1">if extractWrapperExtFromImp </span><span class="cov8" title="1">{
                        if wrapperExtFromImp != nil </span><span class="cov8" title="1">{
                                if wrapperExt == nil </span><span class="cov8" title="1">{
                                        wrapperExt = &amp;pubmaticWrapperExt{}
                                }</span>
                                <span class="cov8" title="1">if wrapperExt.ProfileID == 0 </span><span class="cov8" title="1">{
                                        wrapperExt.ProfileID = wrapperExtFromImp.ProfileID
                                }</span>
                                <span class="cov8" title="1">if wrapperExt.VersionID == 0 </span><span class="cov8" title="1">{
                                        wrapperExt.VersionID = wrapperExtFromImp.VersionID
                                }</span>

                                <span class="cov8" title="1">if wrapperExt.WrapperImpID == "" </span><span class="cov8" title="1">{
                                        wrapperExt.WrapperImpID = wrapperExtFromImp.WrapperImpID
                                }</span>

                                <span class="cov8" title="1">if wrapperExt != nil &amp;&amp; wrapperExt.ProfileID != 0 &amp;&amp; wrapperExt.VersionID != 0 </span><span class="cov8" title="1">{
                                        extractWrapperExtFromImp = false
                                }</span>
                        }
                }

                <span class="cov8" title="1">if extractPubIDFromImp &amp;&amp; pubIDFromImp != "" </span><span class="cov8" title="1">{
                        pubID = pubIDFromImp
                        extractPubIDFromImp = false
                }</span>
        }

        // If all the requests are invalid, Call to adaptor is skipped
        <span class="cov8" title="1">if len(request.Imp) == 0 </span><span class="cov8" title="1">{
                return nil, errs
        }</span>

        <span class="cov8" title="1">newReqExt.Wrapper = wrapperExt
        rawExt, err := json.Marshal(newReqExt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []error{err}
        }</span>
        <span class="cov8" title="1">request.Ext = rawExt

        if request.Site != nil </span><span class="cov8" title="1">{
                siteCopy := *request.Site
                if siteCopy.Publisher != nil </span><span class="cov8" title="1">{
                        publisherCopy := *siteCopy.Publisher
                        publisherCopy.ID = pubID
                        siteCopy.Publisher = &amp;publisherCopy
                }</span> else<span class="cov8" title="1"> {
                        siteCopy.Publisher = &amp;openrtb2.Publisher{ID: pubID}
                }</span>
                <span class="cov8" title="1">request.Site = &amp;siteCopy</span>
        } else<span class="cov8" title="1"> if request.App != nil </span><span class="cov8" title="1">{
                appCopy := *request.App
                if appCopy.Publisher != nil </span><span class="cov8" title="1">{
                        publisherCopy := *appCopy.Publisher
                        publisherCopy.ID = pubID
                        appCopy.Publisher = &amp;publisherCopy
                }</span> else<span class="cov8" title="1"> {
                        appCopy.Publisher = &amp;openrtb2.Publisher{ID: pubID}
                }</span>
                <span class="cov8" title="1">request.App = &amp;appCopy</span>
        }

        // move user.ext.eids to user.eids
        <span class="cov8" title="1">if request.User != nil &amp;&amp; request.User.Ext != nil </span><span class="cov8" title="1">{
                var userExt *openrtb_ext.ExtUser
                if err = json.Unmarshal(request.User.Ext, &amp;userExt); err == nil </span><span class="cov8" title="1">{
                        if userExt != nil &amp;&amp; userExt.Eids != nil </span><span class="cov8" title="1">{
                                var eidArr []openrtb2.EID
                                for _, eid := range userExt.Eids </span><span class="cov8" title="1">{
                                        newEid := &amp;openrtb2.EID{
                                                ID:     eid.ID,
                                                Source: eid.Source,
                                                Ext:    eid.Ext,
                                        }
                                        var uidArr []openrtb2.UID
                                        for _, uid := range eid.UIDs </span><span class="cov8" title="1">{
                                                newUID := &amp;openrtb2.UID{
                                                        ID:    uid.ID,
                                                        AType: uid.AType,
                                                        Ext:   uid.Ext,
                                                }
                                                uidArr = append(uidArr, *newUID)
                                        }</span>
                                        <span class="cov8" title="1">newEid.UIDs = uidArr
                                        eidArr = append(eidArr, *newEid)</span>
                                }

                                <span class="cov8" title="1">user := *request.User
                                user.EIDs = eidArr
                                userExt.Eids = nil
                                updatedUserExt, err1 := json.Marshal(userExt)
                                if err1 == nil </span><span class="cov8" title="1">{
                                        user.Ext = updatedUserExt
                                }</span>
                                <span class="cov8" title="1">request.User = &amp;user</span>
                        }
                }
        }

        //adding hack to support DNT, since hbopenbid does not support lmt
        <span class="cov8" title="1">if request.Device != nil &amp;&amp; request.Device.Lmt != nil &amp;&amp; *request.Device.Lmt != 0 </span><span class="cov0" title="0">{
                request.Device.DNT = request.Device.Lmt
        }</span>

        //Build the multi-floor requests if multiple floors are present
        <span class="cov8" title="1">if len(impFloorsMap) &gt; 0 </span><span class="cov8" title="1">{
                requestData, errData := a.buildMultiFloorRequests(request, impFloorsMap, cookies)
                if errData != nil </span><span class="cov8" title="1">{
                        errs = append(errs, errData...)
                }</span>
                <span class="cov8" title="1">return requestData, errs</span>
        }

        <span class="cov8" title="1">requestData, errData := a.buildAdapterRequest(request, cookies)
        if errData != nil </span><span class="cov0" title="0">{
                errs = append(errs, errData)
        }</span>
        <span class="cov8" title="1">return requestData, errs</span>
}

// buildMultiFloorRequests builds multiple requests for each floor value
func (a *PubmaticAdapter) buildMultiFloorRequests(request *openrtb2.BidRequest, impFloorsMap map[string][]float64, cookies []string) ([]*adapters.RequestData, []error) <span class="cov8" title="1">{
        requestData := []*adapters.RequestData{}
        errs := make([]error, 0, MAX_MULTIFLOORS_PUBMATIC*len(request.Imp))

        for i := 0; i &lt; MAX_MULTIFLOORS_PUBMATIC; i++ </span><span class="cov8" title="1">{
                isFloorsUpdated := false
                newImps := make([]openrtb2.Imp, len(request.Imp))
                copy(newImps, request.Imp)

                for j := range newImps </span><span class="cov8" title="1">{
                        floors, ok := impFloorsMap[request.Imp[j].ID]
                        if !ok || len(floors) &lt;= i </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">isFloorsUpdated = true
                        newImps[j].BidFloor = floors[i]
                        newImps[j].ID = fmt.Sprintf("%s"+multiFloors+"%d", newImps[j].ID, i+1)</span>
                }

                <span class="cov8" title="1">if !isFloorsUpdated </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">newRequest := *request
                newRequest.Imp = newImps

                newRequestData, errData := a.buildAdapterRequest(&amp;newRequest, cookies)
                if errData != nil </span><span class="cov0" title="0">{
                        errs = append(errs, errData)
                }</span>
                <span class="cov8" title="1">if len(newRequestData) &gt; 0 </span><span class="cov8" title="1">{
                        requestData = append(requestData, newRequestData...)
                }</span>
        }
        <span class="cov8" title="1">return requestData, errs</span>
}

// buildAdapterRequest builds the request for Pubmatic
func (a *PubmaticAdapter) buildAdapterRequest(request *openrtb2.BidRequest, cookies []string) ([]*adapters.RequestData, error) <span class="cov8" title="1">{
        reqJSON, err := json.Marshal(request)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">headers := http.Header{}
        headers.Add("Content-Type", "application/json;charset=utf-8")
        headers.Add("Accept", "application/json")
        for _, line := range cookies </span><span class="cov8" title="1">{
                headers.Add("Cookie", line)
        }</span>
        <span class="cov8" title="1">return []*adapters.RequestData{{
                Method:  "POST",
                Uri:     a.URI,
                Body:    reqJSON,
                Headers: headers,
                ImpIDs:  openrtb_ext.GetImpIDs(request.Imp),
        }}, err</span>
}

// validateAdslot validate the optional adslot string
// valid formats are 'adslot@WxH', 'adslot' and no adslot
func validateAdSlot(adslot string, imp *openrtb2.Imp) error <span class="cov8" title="1">{
        adSlotStr := strings.TrimSpace(adslot)

        if len(adSlotStr) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if !strings.Contains(adSlotStr, "@") </span><span class="cov0" title="0">{
                imp.TagID = adSlotStr
                return nil
        }</span>

        <span class="cov8" title="1">adSlot := strings.Split(adSlotStr, "@")
        if len(adSlot) == 2 &amp;&amp; adSlot[0] != "" &amp;&amp; adSlot[1] != "" </span><span class="cov8" title="1">{
                imp.TagID = strings.TrimSpace(adSlot[0])

                adSize := strings.Split(strings.ToLower(adSlot[1]), "x")
                if len(adSize) != 2 </span><span class="cov8" title="1">{
                        return errors.New(fmt.Sprintf("Invalid size provided in adSlot %v", adSlotStr))
                }</span>

                <span class="cov8" title="1">width, err := strconv.Atoi(strings.TrimSpace(adSize[0]))
                if err != nil </span><span class="cov8" title="1">{
                        return errors.New(fmt.Sprintf("Invalid width provided in adSlot %v", adSlotStr))
                }</span>

                <span class="cov8" title="1">heightStr := strings.Split(adSize[1], ":")
                height, err := strconv.Atoi(strings.TrimSpace(heightStr[0]))
                if err != nil </span><span class="cov8" title="1">{
                        return errors.New(fmt.Sprintf("Invalid height provided in adSlot %v", adSlotStr))
                }</span>

                //In case of video, size could be derived from the player size
                <span class="cov8" title="1">if imp.Banner != nil &amp;&amp; width != 0 &amp;&amp; height != 0 &amp;&amp; !(imp.Native != nil &amp;&amp; width == 1 &amp;&amp; height == 1) </span><span class="cov8" title="1">{
                        imp.Banner = assignBannerWidthAndHeight(imp.Banner, int64(width), int64(height))
                }</span>
        } else<span class="cov8" title="1"> {
                return errors.New(fmt.Sprintf("Invalid adSlot %v", adSlotStr))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func assignBannerSize(banner *openrtb2.Banner) (*openrtb2.Banner, error) <span class="cov8" title="1">{
        if banner.W != nil &amp;&amp; banner.H != nil </span><span class="cov8" title="1">{
                return banner, nil
        }</span>

        <span class="cov8" title="1">if len(banner.Format) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("No sizes provided for Banner %v", banner.Format))
        }</span>

        <span class="cov8" title="1">return assignBannerWidthAndHeight(banner, banner.Format[0].W, banner.Format[0].H), nil</span>
}

func assignBannerWidthAndHeight(banner *openrtb2.Banner, w, h int64) *openrtb2.Banner <span class="cov8" title="1">{
        bannerCopy := *banner
        bannerCopy.W = ptrutil.ToPtr(w)
        bannerCopy.H = ptrutil.ToPtr(h)
        return &amp;bannerCopy
}</span>

// parseImpressionObject parse the imp to get it ready to send to pubmatic
func parseImpressionObject(imp *openrtb2.Imp, extractWrapperExtFromImp, extractPubIDFromImp bool) (*pubmaticWrapperExt, string, []float64, error) <span class="cov8" title="1">{
        var wrapExt *pubmaticWrapperExt
        var pubID string
        var floors []float64

        // PubMatic supports banner and video impressions.
        if imp.Banner == nil &amp;&amp; imp.Video == nil &amp;&amp; imp.Native == nil </span><span class="cov8" title="1">{
                return wrapExt, pubID, floors, fmt.Errorf("invalid MediaType. PubMatic only supports Banner, Video and Native. Ignoring ImpID=%s", imp.ID)
        }</span>

        <span class="cov8" title="1">if imp.Audio != nil </span><span class="cov8" title="1">{
                imp.Audio = nil
        }</span>

        <span class="cov8" title="1">var bidderExt ExtImpBidderPubmatic
        if err := json.Unmarshal(imp.Ext, &amp;bidderExt); err != nil </span><span class="cov0" title="0">{
                return wrapExt, pubID, floors, err
        }</span>

        <span class="cov8" title="1">var pubmaticExt openrtb_ext.ExtImpPubmatic
        if err := json.Unmarshal(bidderExt.Bidder, &amp;pubmaticExt); err != nil </span><span class="cov0" title="0">{
                return wrapExt, pubID, floors, err
        }</span>

        <span class="cov8" title="1">if extractPubIDFromImp </span><span class="cov8" title="1">{
                pubID = strings.TrimSpace(pubmaticExt.PublisherId)
        }</span>

        // Parse Wrapper Extension only once per request
        <span class="cov8" title="1">if extractWrapperExtFromImp &amp;&amp; len(pubmaticExt.WrapExt) != 0 </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(pubmaticExt.WrapExt), &amp;wrapExt)
                if err != nil </span><span class="cov0" title="0">{
                        return wrapExt, pubID, floors, fmt.Errorf("Error in Wrapper Parameters = %v  for ImpID = %v WrapperExt = %v", err.Error(), imp.ID, string(pubmaticExt.WrapExt))
                }</span>
        }

        <span class="cov8" title="1">if err := validateAdSlot(strings.TrimSpace(pubmaticExt.AdSlot), imp); err != nil </span><span class="cov8" title="1">{
                return wrapExt, pubID, floors, err
        }</span>

        <span class="cov8" title="1">if imp.Banner != nil </span><span class="cov8" title="1">{
                bannerCopy, err := assignBannerSize(imp.Banner)
                if err != nil </span><span class="cov0" title="0">{
                        return wrapExt, pubID, floors, err
                }</span>
                <span class="cov8" title="1">imp.Banner = bannerCopy</span>
        }

        <span class="cov8" title="1">if pubmaticExt.Kadfloor != "" </span><span class="cov8" title="1">{
                bidfloor, err := strconv.ParseFloat(strings.TrimSpace(pubmaticExt.Kadfloor), 64)
                if err == nil </span><span class="cov8" title="1">{
                        // In case of valid kadfloor, select maximum of original imp.bidfloor and kadfloor
                        imp.BidFloor = math.Max(bidfloor, imp.BidFloor)
                }</span>
        }

        <span class="cov8" title="1">extMap := make(map[string]interface{}, 0)
        if pubmaticExt.Keywords != nil &amp;&amp; len(pubmaticExt.Keywords) != 0 </span><span class="cov8" title="1">{
                addKeywordsToExt(pubmaticExt.Keywords, extMap)
        }</span>
        //Give preference to direct values of 'dctr' &amp; 'pmZoneId' params in extension
        <span class="cov8" title="1">if pubmaticExt.Dctr != "" </span><span class="cov8" title="1">{
                extMap[dctrKeyName] = pubmaticExt.Dctr
        }</span>
        <span class="cov8" title="1">if pubmaticExt.PmZoneID != "" </span><span class="cov8" title="1">{
                extMap[pmZoneIDKeyName] = pubmaticExt.PmZoneID
        }</span>

        <span class="cov8" title="1">if bidderExt.SKAdnetwork != nil </span><span class="cov8" title="1">{
                extMap[skAdnetworkKey] = bidderExt.SKAdnetwork
        }</span>

        <span class="cov8" title="1">if bidderExt.Prebid != nil &amp;&amp; bidderExt.Prebid.IsRewardedInventory != nil &amp;&amp; *bidderExt.Prebid.IsRewardedInventory == 1 </span><span class="cov8" title="1">{
                extMap[rewardKey] = *bidderExt.Prebid.IsRewardedInventory
        }</span>

        <span class="cov8" title="1">if len(bidderExt.Data) &gt; 0 </span><span class="cov8" title="1">{
                populateFirstPartyDataImpAttributes(bidderExt.Data, extMap)
        }</span>
        // If bidViewabilityScore param is populated, pass it to imp[i].ext
        <span class="cov8" title="1">if pubmaticExt.BidViewabilityScore != nil </span><span class="cov8" title="1">{
                extMap[bidViewability] = pubmaticExt.BidViewabilityScore
        }</span>

        <span class="cov8" title="1">if bidderExt.AE != 0 </span><span class="cov8" title="1">{
                extMap[ae] = bidderExt.AE
        }</span>

        <span class="cov8" title="1">if bidderExt.AE != 0 </span><span class="cov8" title="1">{
                extMap[ae] = bidderExt.AE
        }</span>

        <span class="cov8" title="1">if bidderExt.GpId != "" </span><span class="cov8" title="1">{
                extMap[gpIdKey] = bidderExt.GpId
        }</span>

        <span class="cov8" title="1">imp.Ext = nil
        if len(extMap) &gt; 0 </span><span class="cov8" title="1">{
                ext, err := json.Marshal(extMap)
                if err == nil </span><span class="cov8" title="1">{
                        imp.Ext = ext
                }</span>
        }

        <span class="cov8" title="1">return wrapExt, pubID, pubmaticExt.Floors, nil</span>
}

// roundToFourDecimals retuns given value to 4 decimal points
func roundToFourDecimals(in float64) float64 <span class="cov0" title="0">{
        return math.Round(in*10000) / 10000
}</span>

// extractPubmaticExtFromRequest parse the req.ext to fetch wrapper and acat params
func extractPubmaticExtFromRequest(request *openrtb2.BidRequest) (extRequestAdServer, []string, error) <span class="cov8" title="1">{
        var cookies []string
        // req.ext.prebid would always be there and Less nil cases to handle, more safe!
        var pmReqExt extRequestAdServer

        if request == nil || len(request.Ext) == 0 </span><span class="cov8" title="1">{
                return pmReqExt, cookies, nil
        }</span>

        <span class="cov8" title="1">reqExt := &amp;openrtb_ext.ExtRequest{}
        err := json.Unmarshal(request.Ext, &amp;reqExt)
        if err != nil </span><span class="cov8" title="1">{
                return pmReqExt, cookies, fmt.Errorf("error decoding Request.ext : %s", err.Error())
        }</span>
        <span class="cov8" title="1">pmReqExt.ExtRequest = *reqExt

        reqExtBidderParams := make(map[string]json.RawMessage)
        if reqExt.Prebid.BidderParams != nil </span><span class="cov8" title="1">{
                err = json.Unmarshal(reqExt.Prebid.BidderParams, &amp;reqExtBidderParams)
                if err != nil </span><span class="cov0" title="0">{
                        return pmReqExt, cookies, err
                }</span>
        }

        //get request ext bidder params
        <span class="cov8" title="1">if wrapperObj, present := reqExtBidderParams["wrapper"]; present &amp;&amp; len(wrapperObj) != 0 </span><span class="cov8" title="1">{
                wrpExt := &amp;pubmaticWrapperExt{}
                err = json.Unmarshal(wrapperObj, wrpExt)
                if err != nil </span><span class="cov8" title="1">{
                        return pmReqExt, cookies, err
                }</span>
                <span class="cov8" title="1">pmReqExt.Wrapper = wrpExt</span>
        }

        <span class="cov8" title="1">if acatBytes, ok := reqExtBidderParams["acat"]; ok </span><span class="cov8" title="1">{
                var acat []string
                err = json.Unmarshal(acatBytes, &amp;acat)
                if err != nil </span><span class="cov8" title="1">{
                        return pmReqExt, cookies, err
                }</span>
                <span class="cov8" title="1">for i := 0; i &lt; len(acat); i++ </span><span class="cov8" title="1">{
                        acat[i] = strings.TrimSpace(acat[i])
                }</span>
                <span class="cov8" title="1">pmReqExt.Acat = acat</span>
        }

        <span class="cov8" title="1">if allowedBidders := getAlternateBidderCodesFromRequestExt(reqExt); allowedBidders != nil </span><span class="cov8" title="1">{
                pmReqExt.Marketplace = &amp;marketplaceReqExt{AllowedBidders: allowedBidders}
        }</span>

        // OW patch -start-
        <span class="cov8" title="1">if wiid, ok := reqExtBidderParams["wiid"]; ok </span><span class="cov8" title="1">{
                if pmReqExt.Wrapper == nil </span><span class="cov8" title="1">{
                        pmReqExt.Wrapper = &amp;pubmaticWrapperExt{}
                }</span>
                <span class="cov8" title="1">pmReqExt.Wrapper.WrapperImpID, _ = strconv.Unquote(string(wiid))</span>
        }
        <span class="cov8" title="1">if wrapperObj, present := reqExtBidderParams["Cookie"]; present &amp;&amp; len(wrapperObj) != 0 </span><span class="cov0" title="0">{
                err = json.Unmarshal(wrapperObj, &amp;cookies)
        }</span>
        // OW patch -end-

        <span class="cov8" title="1">return pmReqExt, cookies, nil</span>
}

func getAlternateBidderCodesFromRequestExt(reqExt *openrtb_ext.ExtRequest) []string <span class="cov8" title="1">{
        if reqExt == nil || reqExt.Prebid.AlternateBidderCodes == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">allowedBidders := []string{"pubmatic"}
        if reqExt.Prebid.AlternateBidderCodes.Enabled </span><span class="cov8" title="1">{
                if pmABC, ok := reqExt.Prebid.AlternateBidderCodes.Bidders["pubmatic"]; ok &amp;&amp; pmABC.Enabled </span><span class="cov8" title="1">{
                        if pmABC.AllowedBidderCodes == nil || (len(pmABC.AllowedBidderCodes) == 1 &amp;&amp; pmABC.AllowedBidderCodes[0] == "*") </span><span class="cov8" title="1">{
                                return []string{"all"}
                        }</span>
                        <span class="cov8" title="1">return append(allowedBidders, pmABC.AllowedBidderCodes...)</span>
                }
        }

        <span class="cov8" title="1">return allowedBidders</span>
}

func addKeywordsToExt(keywords []*openrtb_ext.ExtImpPubmaticKeyVal, extMap map[string]interface{}) <span class="cov8" title="1">{
        for _, keyVal := range keywords </span><span class="cov8" title="1">{
                if len(keyVal.Values) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> {
                        key := keyVal.Key
                        val := strings.Join(keyVal.Values[:], ",")
                        if strings.EqualFold(key, pmZoneIDRequestParamName) </span><span class="cov8" title="1">{
                                key = pmZoneIDKeyName
                        }</span> else<span class="cov8" title="1"> if key == dctrKeywordName </span><span class="cov8" title="1">{
                                key = dctrKeyName
                                // URL-decode dctr value if it is url-encoded
                                if strings.Contains(val, urlEncodedEqualChar) </span><span class="cov8" title="1">{
                                        urlDecodedVal, err := url.QueryUnescape(val)
                                        if err == nil </span><span class="cov8" title="1">{
                                                val = urlDecodedVal
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">extMap[key] = val</span>
                }
        }
}

func (a *PubmaticAdapter) MakeBids(internalRequest *openrtb2.BidRequest, externalRequest *adapters.RequestData, response *adapters.ResponseData) (*adapters.BidderResponse, []error) <span class="cov8" title="1">{
        if response.StatusCode == http.StatusNoContent </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">if response.StatusCode == http.StatusBadRequest </span><span class="cov0" title="0">{
                return nil, []error{&amp;errortypes.BadInput{
                        Message: fmt.Sprintf("Unexpected status code: %d. Run with request.debug = 1 for more info", response.StatusCode),
                }}
        }</span>

        <span class="cov8" title="1">if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, []error{fmt.Errorf("Unexpected status code: %d. Run with request.debug = 1 for more info", response.StatusCode)}
        }</span>

        <span class="cov8" title="1">var bidResp openrtb2.BidResponse
        if err := json.Unmarshal(response.Body, &amp;bidResp); err != nil </span><span class="cov0" title="0">{
                return nil, []error{err}
        }</span>

        <span class="cov8" title="1">bidResponse := adapters.NewBidderResponseWithBidsCapacity(5)

        var errs []error
        for _, sb := range bidResp.SeatBid </span><span class="cov8" title="1">{
                targets := getTargetingKeys(sb.Ext, string(externalRequest.BidderName))
                for i := 0; i &lt; len(sb.Bid); i++ </span><span class="cov8" title="1">{
                        bid := sb.Bid[i]
                        bid.ImpID = trimSuffixWithPattern(bid.ImpID)

                        // Copy SeatBid Ext to Bid.Ext
                        bid.Ext = copySBExtToBidExt(sb.Ext, bid.Ext)

                        typedBid := &amp;adapters.TypedBid{
                                Bid:        &amp;bid,
                                BidType:    openrtb_ext.BidTypeBanner,
                                BidVideo:   &amp;openrtb_ext.ExtBidPrebidVideo{},
                                BidTargets: targets,
                        }

                        var bidExt *pubmaticBidExt
                        err := json.Unmarshal(bid.Ext, &amp;bidExt)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                        }</span> else<span class="cov8" title="1"> if bidExt != nil </span><span class="cov8" title="1">{
                                typedBid.Seat = openrtb_ext.BidderName(bidExt.Marketplace)
                                typedBid.BidType = getBidType(bidExt)
                                if bidExt.PrebidDealPriority &gt; 0 </span><span class="cov8" title="1">{
                                        typedBid.DealPriority = bidExt.PrebidDealPriority
                                }</span>

                                <span class="cov8" title="1">if bidExt.VideoCreativeInfo != nil &amp;&amp; bidExt.VideoCreativeInfo.Duration != nil </span><span class="cov8" title="1">{
                                        typedBid.BidVideo.Duration = *bidExt.VideoCreativeInfo.Duration
                                }</span>
                                //prepares ExtBidPrebidMeta with Values got from bidresponse
                                <span class="cov8" title="1">typedBid.BidMeta = prepareMetaObject(bid, bidExt, sb.Seat)</span>
                        }
                        <span class="cov8" title="1">if len(bid.Cat) &gt; 1 </span><span class="cov8" title="1">{
                                bid.Cat = bid.Cat[0:1]
                        }</span>

                        <span class="cov8" title="1">if typedBid.BidType == openrtb_ext.BidTypeNative </span><span class="cov8" title="1">{
                                bid.AdM, err = getNativeAdm(bid.AdM)
                                if err != nil </span><span class="cov8" title="1">{
                                        errs = append(errs, err)
                                }</span>
                        }

                        <span class="cov8" title="1">bidResponse.Bids = append(bidResponse.Bids, typedBid)</span>
                }
        }
        <span class="cov8" title="1">if bidResp.Cur != "" </span><span class="cov8" title="1">{
                bidResponse.Currency = bidResp.Cur
        }</span>

        <span class="cov8" title="1">if bidResp.Ext != nil </span><span class="cov8" title="1">{
                var bidRespExt respExt
                if err := json.Unmarshal(bidResp.Ext, &amp;bidRespExt); err == nil &amp;&amp; bidRespExt.FledgeAuctionConfigs != nil </span><span class="cov8" title="1">{
                        bidResponse.FledgeAuctionConfigs = make([]*openrtb_ext.FledgeAuctionConfig, 0, len(bidRespExt.FledgeAuctionConfigs))
                        for impId, config := range bidRespExt.FledgeAuctionConfigs </span><span class="cov8" title="1">{
                                fledgeAuctionConfig := &amp;openrtb_ext.FledgeAuctionConfig{
                                        ImpId:  impId,
                                        Config: config,
                                }
                                bidResponse.FledgeAuctionConfigs = append(bidResponse.FledgeAuctionConfigs, fledgeAuctionConfig)
                        }</span>
                }
        }
        <span class="cov8" title="1">return bidResponse, errs</span>
}

func trimSuffixWithPattern(input string) string <span class="cov8" title="1">{
        return re.ReplaceAllString(input, "")
}</span>

func getNativeAdm(adm string) (string, error) <span class="cov8" title="1">{
        var err error
        nativeAdm := make(map[string]interface{})
        err = json.Unmarshal([]byte(adm), &amp;nativeAdm)
        if err != nil </span><span class="cov8" title="1">{
                return adm, errors.New("unable to unmarshal native adm")
        }</span>

        // move bid.adm.native to bid.adm
        <span class="cov8" title="1">if _, ok := nativeAdm["native"]; ok </span><span class="cov8" title="1">{
                //using jsonparser to avoid marshaling, encode escape, etc.
                value, _, _, err := jsonparser.Get([]byte(adm), string(openrtb_ext.BidTypeNative))
                if err != nil </span><span class="cov0" title="0">{
                        return adm, errors.New("unable to get native adm")
                }</span>
                <span class="cov8" title="1">adm = string(value)</span>
        }

        <span class="cov8" title="1">return adm, nil</span>
}

// getMapFromJSON converts JSON to map
func getMapFromJSON(source json.RawMessage) map[string]interface{} <span class="cov8" title="1">{
        if source != nil </span><span class="cov8" title="1">{
                dataMap := make(map[string]interface{})
                err := json.Unmarshal(source, &amp;dataMap)
                if err == nil </span><span class="cov8" title="1">{
                        return dataMap
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// populateFirstPartyDataImpAttributes will parse imp.ext.data and populate imp extMap
func populateFirstPartyDataImpAttributes(data json.RawMessage, extMap map[string]interface{}) <span class="cov8" title="1">{

        dataMap := getMapFromJSON(data)

        if dataMap == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">populateAdUnitKey(data, dataMap, extMap)
        populateDctrKey(dataMap, extMap)</span>
}

// populateAdUnitKey parses data object to read and populate DFP adunit key
func populateAdUnitKey(data json.RawMessage, dataMap, extMap map[string]interface{}) <span class="cov8" title="1">{

        if name, err := jsonparser.GetString(data, "adserver", "name"); err == nil &amp;&amp; name == AdServerGAM </span><span class="cov8" title="1">{
                if adslot, err := jsonparser.GetString(data, "adserver", "adslot"); err == nil &amp;&amp; adslot != "" </span><span class="cov8" title="1">{
                        extMap[ImpExtAdUnitKey] = adslot
                }</span>
        }

        //imp.ext.dfp_ad_unit_code is not set, then check pbadslot in imp.ext.data
        <span class="cov8" title="1">if extMap[ImpExtAdUnitKey] == nil &amp;&amp; dataMap[PBAdslotKey] != nil </span><span class="cov8" title="1">{
                extMap[ImpExtAdUnitKey] = dataMap[PBAdslotKey].(string)
        }</span>
}

// populateDctrKey reads key-val pairs from imp.ext.data and add it in imp.ext.key_val
func populateDctrKey(dataMap, extMap map[string]interface{}) <span class="cov8" title="1">{
        var dctr strings.Builder

        //append dctr key if already present in extMap
        if extMap[dctrKeyName] != nil </span><span class="cov8" title="1">{
                dctr.WriteString(extMap[dctrKeyName].(string))
        }</span>

        <span class="cov8" title="1">for key, val := range dataMap </span><span class="cov8" title="1">{

                //ignore 'pbaslot' and 'adserver' key as they are not targeting keys
                if key == PBAdslotKey || key == AdServerKey </span><span class="cov8" title="1">{
                        continue</span>
                }

                //separate key-val pairs in dctr string by pipe(|)
                <span class="cov8" title="1">if dctr.Len() &gt; 0 </span><span class="cov8" title="1">{
                        dctr.WriteString("|")
                }</span>

                //trimming spaces from key
                <span class="cov8" title="1">key = strings.TrimSpace(key)

                switch typedValue := val.(type) </span>{
                case string:<span class="cov8" title="1">
                        if _, err := fmt.Fprintf(&amp;dctr, "%s=%s", key, strings.TrimSpace(typedValue)); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                case float64, bool:<span class="cov8" title="1">
                        if _, err := fmt.Fprintf(&amp;dctr, "%s=%v", key, typedValue); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                case []interface{}:<span class="cov8" title="1">
                        if valStrArr := getStringArray(typedValue); len(valStrArr) &gt; 0 </span><span class="cov8" title="1">{
                                valStr := strings.Join(valStrArr[:], ",")
                                if _, err := fmt.Fprintf(&amp;dctr, "%s=%s", key, valStr); err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">if dctrStr := dctr.String(); dctrStr != "" </span><span class="cov8" title="1">{
                extMap[dctrKeyName] = strings.TrimSuffix(dctrStr, "|")
        }</span>
}

// getStringArray converts interface of type string array to string array
func getStringArray(array []interface{}) []string <span class="cov8" title="1">{
        aString := make([]string, len(array))
        for i, v := range array </span><span class="cov8" title="1">{
                if str, ok := v.(string); ok </span><span class="cov8" title="1">{
                        aString[i] = strings.TrimSpace(str)
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return aString</span>
}

// getBidType returns the bid type specified in the response bid.ext
func getBidType(bidExt *pubmaticBidExt) openrtb_ext.BidType <span class="cov8" title="1">{
        // setting "banner" as the default bid type
        bidType := openrtb_ext.BidTypeBanner
        if bidExt != nil &amp;&amp; bidExt.BidType != nil </span><span class="cov8" title="1">{
                switch *bidExt.BidType </span>{
                case 0:<span class="cov8" title="1">
                        bidType = openrtb_ext.BidTypeBanner</span>
                case 1:<span class="cov8" title="1">
                        bidType = openrtb_ext.BidTypeVideo</span>
                case 2:<span class="cov8" title="1">
                        bidType = openrtb_ext.BidTypeNative</span>
                default:<span class="cov8" title="1">
                        // default value is banner
                        bidType = openrtb_ext.BidTypeBanner</span>
                }
        }
        <span class="cov8" title="1">return bidType</span>
}

// Builder builds a new instance of the Pubmatic adapter for the given bidder with the given config.
func Builder(bidderName openrtb_ext.BidderName, config config.Adapter, server config.Server) (adapters.Bidder, error) <span class="cov8" title="1">{
        bidder := &amp;PubmaticAdapter{
                URI:        config.Endpoint,
                bidderName: string(bidderName),
        }
        return bidder, nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package pubmatic

import (
        "encoding/json"
        "strconv"

        "github.com/prebid/openrtb/v20/openrtb2"
        "github.com/prebid/prebid-server/v2/openrtb_ext"
)

func getTargetingKeys(bidExt json.RawMessage, bidderName string) map[string]string <span class="cov8" title="1">{
        targets := map[string]string{}
        if bidExt != nil </span><span class="cov8" title="1">{
                bidExtMap := make(map[string]interface{})
                err := json.Unmarshal(bidExt, &amp;bidExtMap)
                if err == nil &amp;&amp; bidExtMap[buyId] != nil </span><span class="cov8" title="1">{
                        targets[buyIdTargetingKey+bidderName], _ = bidExtMap[buyId].(string)
                }</span>
        }
        <span class="cov8" title="1">return targets</span>
}

func copySBExtToBidExt(sbExt json.RawMessage, bidExt json.RawMessage) json.RawMessage <span class="cov8" title="1">{
        if sbExt != nil </span><span class="cov8" title="1">{
                sbExtMap := getMapFromJSON(sbExt)
                bidExtMap := make(map[string]interface{})
                if bidExt != nil </span><span class="cov8" title="1">{
                        bidExtMap = getMapFromJSON(bidExt)
                }</span>
                <span class="cov8" title="1">if bidExtMap != nil &amp;&amp; sbExtMap != nil </span><span class="cov8" title="1">{
                        if sbExtMap[buyId] != nil &amp;&amp; bidExtMap[buyId] == nil </span><span class="cov8" title="1">{
                                bidExtMap[buyId] = sbExtMap[buyId]
                        }</span>
                }
                <span class="cov8" title="1">byteAra, _ := json.Marshal(bidExtMap)
                return json.RawMessage(byteAra)</span>
        }
        <span class="cov8" title="1">return bidExt</span>
}

// prepareMetaObject prepares the Meta structure using Bid Response
func prepareMetaObject(bid openrtb2.Bid, bidExt *pubmaticBidExt, seat string) *openrtb_ext.ExtBidPrebidMeta <span class="cov8" title="1">{

        meta := &amp;openrtb_ext.ExtBidPrebidMeta{
                NetworkID:    bidExt.DspId,
                AdvertiserID: bidExt.AdvertiserID,
                MediaType:    string(getBidType(bidExt)),
        }

        if meta.NetworkID != 0 </span><span class="cov8" title="1">{
                meta.DemandSource = strconv.Itoa(meta.NetworkID)
        }</span>

        <span class="cov8" title="1">if len(seat) &gt; 0 </span><span class="cov8" title="1">{
                meta.AdvertiserID, _ = strconv.Atoi(seat)
        }</span>

        <span class="cov8" title="1">meta.AgencyID = meta.AdvertiserID

        if len(bid.Cat) &gt; 0 </span><span class="cov8" title="1">{
                meta.PrimaryCategoryID = bid.Cat[0]
                meta.SecondaryCategoryIDs = bid.Cat
        }</span>

        // NOTE: We will not recieve below fields from the translator response also not sure on what will be the key names for these in the response,
        // when we needed we can add it back.
        // New fields added, assignee fields name may change
        // Assign meta.BrandId to bidExt.ADomain[0]  //BrandID is of Type int and ADomain values if string type like "mystartab.com"
        // meta.NetworkName = bidExt.NetworkName;
        // meta.AdvertiserName = bidExt.AdvertiserName;
        // meta.AgencyName = bidExt.AgencyName;
        // meta.BrandName = bidExt.BrandName;
        // meta.DChain = bidExt.DChain;

        <span class="cov8" title="1">return meta</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
