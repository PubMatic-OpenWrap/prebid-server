
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ortbbidder: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/PubMatic-OpenWrap/prebid-server/v2/adapters/ortbbidder/ortbbidder.go (0.0%)</option>
				
				<option value="file1">github.com/PubMatic-OpenWrap/prebid-server/v2/adapters/ortbbidder/requestParamMapper.go (94.3%)</option>
				
				<option value="file2">github.com/PubMatic-OpenWrap/prebid-server/v2/adapters/ortbbidder/response_builder.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ortbbidder

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/prebid/openrtb/v20/openrtb2"
        "github.com/prebid/prebid-server/v2/adapters"
        "github.com/prebid/prebid-server/v2/adapters/ortbbidder/bidderparams"
        "github.com/prebid/prebid-server/v2/config"
        "github.com/prebid/prebid-server/v2/openrtb_ext"
)

// adapter implements adapters.Bidder interface
type adapter struct {
        adapterInfo
        bidderParamsConfig *bidderparams.BidderConfig
}

const (
        RequestModeSingle string = "single"
)

// adapterInfo contains oRTB bidder specific info required in MakeRequests/MakeBids functions
type adapterInfo struct {
        config.Adapter
        extraInfo  extraAdapterInfo
        bidderName openrtb_ext.BidderName
}
type extraAdapterInfo struct {
        RequestMode string `json:"requestMode"`
}

// global instance to hold bidderParamsConfig
var g_bidderParamsConfig *bidderparams.BidderConfig

// InitBidderParamsConfig initializes a g_bidderParamsConfig instance from the files provided in dirPath.
func InitBidderParamsConfig(requestParamsDirPath, responseParamsDirPath string) (err error) <span class="cov0" title="0">{
        g_bidderParamsConfig, err = bidderparams.LoadBidderConfig(requestParamsDirPath, responseParamsDirPath, isORTBBidder)
        return err
}</span>

// makeRequest converts openrtb2.BidRequest to adapters.RequestData, sets requestParams in request if required
func (o adapterInfo) makeRequest(request *openrtb2.BidRequest, requestParams map[string]bidderparams.BidderParamMapper) (*adapters.RequestData, error) <span class="cov0" title="0">{
        if request == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("found nil request")
        }</span>
        <span class="cov0" title="0">requestBody, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request %s", err.Error())
        }</span>
        <span class="cov0" title="0">requestBody, err = setRequestParams(requestBody, requestParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;adapters.RequestData{
                Method: http.MethodPost,
                Uri:    o.Endpoint,
                Body:   requestBody,
                Headers: http.Header{
                        "Content-Type": {"application/json;charset=utf-8"},
                        "Accept":       {"application/json"},
                },
        }, nil</span>
}

// Builder returns an instance of oRTB adapter
func Builder(bidderName openrtb_ext.BidderName, config config.Adapter, server config.Server) (adapters.Bidder, error) <span class="cov0" title="0">{
        extraAdapterInfo := extraAdapterInfo{}
        if len(config.ExtraAdapterInfo) &gt; 0 </span><span class="cov0" title="0">{
                err := json.Unmarshal([]byte(config.ExtraAdapterInfo), &amp;extraAdapterInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to parse extra_info for bidder:[%s] err:[%s]", bidderName, err.Error())
                }</span>
        }
        <span class="cov0" title="0">return &amp;adapter{
                adapterInfo:        adapterInfo{config, extraAdapterInfo, bidderName},
                bidderParamsConfig: g_bidderParamsConfig,
        }, nil</span>
}

// MakeRequests prepares oRTB bidder-specific request information using which prebid server make call(s) to bidder.
func (o *adapter) MakeRequests(request *openrtb2.BidRequest, requestInfo *adapters.ExtraRequestInfo) ([]*adapters.RequestData, []error) <span class="cov0" title="0">{
        if request == nil || requestInfo == nil </span><span class="cov0" title="0">{
                return nil, []error{errors.New("found either nil request or nil requestInfo")}
        }</span>
        <span class="cov0" title="0">if o.bidderParamsConfig == nil </span><span class="cov0" title="0">{
                return nil, []error{errors.New("found nil bidderParamsConfig")}
        }</span>
        <span class="cov0" title="0">var errs []error
        adapterInfo := o.adapterInfo
        requestParams, _ := o.bidderParamsConfig.GetRequestParams(o.bidderName.String())

        // bidder request supports single impression in single HTTP call.
        if adapterInfo.extraInfo.RequestMode == RequestModeSingle </span><span class="cov0" title="0">{
                requestData := make([]*adapters.RequestData, 0, len(request.Imp))
                requestCopy := *request
                for _, imp := range request.Imp </span><span class="cov0" title="0">{
                        requestCopy.Imp = []openrtb2.Imp{imp} // requestCopy contains single impression
                        reqData, err := adapterInfo.makeRequest(&amp;requestCopy, requestParams)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">requestData = append(requestData, reqData)</span>
                }
                <span class="cov0" title="0">return requestData, errs</span>
        }
        // bidder request supports multi impressions in single HTTP call.
        <span class="cov0" title="0">requestData, err := adapterInfo.makeRequest(request, requestParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []error{err}
        }</span>
        <span class="cov0" title="0">return []*adapters.RequestData{requestData}, nil</span>
}

// MakeBids prepares bidderResponse from the oRTB bidder server's http.Response
func (o *adapter) MakeBids(request *openrtb2.BidRequest, requestData *adapters.RequestData, responseData *adapters.ResponseData) (*adapters.BidderResponse, []error) <span class="cov0" title="0">{
        if responseData == nil || adapters.IsResponseStatusCodeNoContent(responseData) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if err := adapters.CheckResponseStatusCodeForErrors(responseData); err != nil </span><span class="cov0" title="0">{
                return nil, []error{err}
        }</span>

        <span class="cov0" title="0">responseParmas, _ := o.bidderParamsConfig.GetResponseParams(o.bidderName.String())

        bidResponse, err := o.makeBids(responseData.Body, responseParmas)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []error{err}
        }</span>

        <span class="cov0" title="0">return bidResponse, nil</span>
}

// isORTBBidder returns true if the bidder is an oRTB bidder
func isORTBBidder(bidderName string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(bidderName, "owortb_")
}</span>

// MakeBids prepares bidderResponse from the oRTB bidder server's http.Response
func (o *adapter) makeBids(bidderResponseBytes json.RawMessage, responseParmas map[string]bidderparams.BidderParamMapper) (*adapters.BidderResponse, error) <span class="cov0" title="0">{

        rb := newResponseBuilder(responseParmas)
        err := rb.parseResponse(bidderResponseBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = rb.buildResponse()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return rb.convertToAdapterResponse()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package ortbbidder

import (
        "encoding/json"
        "fmt"

        "github.com/prebid/prebid-server/v2/adapters/ortbbidder/bidderparams"
        "github.com/prebid/prebid-server/v2/adapters/ortbbidder/util"
)

const (
        impKey     = "imp"
        extKey     = "ext"
        bidderKey  = "bidder"
        appsiteKey = "appsite"
        siteKey    = "site"
        appKey     = "app"
)

// setRequestParams updates the requestBody based on the requestParams mapping details.
func setRequestParams(requestBody []byte, requestParams map[string]bidderparams.BidderParamMapper) ([]byte, error) <span class="cov8" title="1">{
        if len(requestParams) == 0 </span><span class="cov8" title="1">{
                return requestBody, nil
        }</span>
        <span class="cov8" title="1">request := map[string]any{}
        err := json.Unmarshal(requestBody, &amp;request)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">imps, ok := request[impKey].([]any)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error:[invalid_imp_found_in_requestbody], imp:[%v]", request[impKey])
        }</span>
        <span class="cov8" title="1">updatedRequest := false
        for ind, imp := range imps </span><span class="cov8" title="1">{
                request[impKey] = imp
                imp, ok := imp.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error:[invalid_imp_found_in_implist], imp:[%v]", request[impKey])
                }</span>
                <span class="cov8" title="1">ext, ok := imp[extKey].(map[string]any)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">bidderParams, ok := ext[bidderKey].(map[string]any)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for paramName, paramValue := range bidderParams </span><span class="cov8" title="1">{
                        paramMapper, ok := requestParams[paramName]
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        // set the value in the request according to the mapping details and remove the parameter.
                        <span class="cov8" title="1">if util.SetValue(request, paramMapper.GetLocation(), paramValue) </span><span class="cov8" title="1">{
                                delete(bidderParams, paramName)
                                updatedRequest = true
                        }</span>
                }
                <span class="cov8" title="1">imps[ind] = request[impKey]</span>
        }
        // update the impression list in the request
        <span class="cov8" title="1">request[impKey] = imps
        // if the request was modified, marshal it back to JSON.
        if updatedRequest </span><span class="cov8" title="1">{
                requestBody, err = json.Marshal(request)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error:[fail_to_update_request_body] msg:[%s]", err.Error())
                }</span>
        }
        <span class="cov8" title="1">return requestBody, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package ortbbidder

import (
        "encoding/json"
        "fmt"

        "github.com/prebid/prebid-server/v2/adapters"
        "github.com/prebid/prebid-server/v2/adapters/ortbbidder/bidderparams"
        "github.com/prebid/prebid-server/v2/adapters/ortbbidder/resolver"
        "github.com/prebid/prebid-server/v2/adapters/ortbbidder/util"
        "github.com/prebid/prebid-server/v2/util/jsonutil"
)

type responseBuilder struct {
        bidderResponse map[string]any
        adapterRespone map[string]any
        responseParams map[string]bidderparams.BidderParamMapper
}

func newResponseBuilder(responseParams map[string]bidderparams.BidderParamMapper) *responseBuilder <span class="cov0" title="0">{
        if responseParams == nil </span><span class="cov0" title="0">{
                responseParams = make(map[string]bidderparams.BidderParamMapper)
        }</span>
        <span class="cov0" title="0">return &amp;responseBuilder{
                responseParams: responseParams,
        }</span>
}

// parseResponse parses the bidder response from the given JSON raw message.
// It unmarshals the JSON into the rb.bidderResponse struct.
func (rb *responseBuilder) parseResponse(bidderResponseBytes json.RawMessage) (err error) <span class="cov0" title="0">{
        err = jsonutil.UnmarshalValid(bidderResponseBytes, &amp;rb.bidderResponse)
        return
}</span>

// buildResponse builds the adapter response based on the given response parameters.
// It resolves the response level and bid level parameters using the provided responseParams map.
// The resolved response is stored in the adapterResponse map.
// If any invalid seatbid or bid is found in the response, an error is returned.
func (rb *responseBuilder) buildResponse() error <span class="cov0" title="0">{
        // Create a new ParamResolver with the bidder response.
        paramResolver := resolver.NewParamResolver(rb.bidderResponse)

        // Initialize the adapter response with the currency from the bidder response.
        adapterResponse := map[string]interface{}{
                "Currency": rb.bidderResponse["cur"],
        }

        // Loop over the response level parameters.
        // If the parameter exists in the response parameters, resolve it.s
        for _, paramName := range resolver.ResponseLevelParams </span><span class="cov0" title="0">{
                if paramMapper, ok := rb.responseParams[paramName]; ok </span><span class="cov0" title="0">{
                        paramResolver.Resolve(rb.bidderResponse, adapterResponse, paramMapper.GetPath(), paramName)
                }</span>
        }

        // Extract the seat bids from the bidder response.
        <span class="cov0" title="0">seatBids, ok := rb.bidderResponse["seatbid"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("error:[invalid_seatbid_found_in_responsebody], seatbid:[%v]", rb.bidderResponse["seatbid"])
        }</span>
        // Initialize the list of type bids.
        <span class="cov0" title="0">typeBids := make([]interface{}, 0)
        for seatIndex, seatBid := range seatBids </span><span class="cov0" title="0">{
                seatBid, ok := seatBid.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("error:[invalid_seatbid_found_in_seatbids_list], seatbid:[%v]", seatBids)
                }</span>
                <span class="cov0" title="0">bids, ok := seatBid["bid"].([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("error:[invalid_bid_found_in_seatbid], bid:[%v]", seatBid["bid"])
                }</span>
                <span class="cov0" title="0">for bidIndex, bid := range bids </span><span class="cov0" title="0">{
                        bid, ok := bid.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("error:[invalid_bid_found_in_bids_list], bid:[%v]", seatBid["bid"])
                        }</span>
                        // Initialize the type bid with the bid.
                        <span class="cov0" title="0">typeBid := map[string]interface{}{
                                "Bid": bid,
                        }
                        // Loop over the bid level parameters.
                        // If the parameter exists in the response parameters, resolve it.
                        for _, paramName := range resolver.BidLevelParams </span><span class="cov0" title="0">{
                                if paramMapper, ok := rb.responseParams[paramName]; ok </span><span class="cov0" title="0">{
                                        path := util.GetPath(paramMapper.GetPath(), []int{seatIndex, bidIndex})
                                        paramResolver.Resolve(bid, typeBid, path, paramName)
                                }</span>
                        }
                        // Add the type bid to the list of type bids.
                        <span class="cov0" title="0">typeBids = append(typeBids, typeBid)</span>
                }
        }
        // Add the type bids to the adapter response.
        <span class="cov0" title="0">adapterResponse["Bids"] = typeBids
        // Set the adapter response in the response builder.
        rb.adapterRespone = adapterResponse
        return nil</span>
}

// convertToAdapterResponse converts the responseBuilder's adapter response to a prebid format.
// Returns the BidderResponse and any error encountered during the conversion.
func (rb *responseBuilder) convertToAdapterResponse() (resp *adapters.BidderResponse, err error) <span class="cov0" title="0">{
        var adapterResponeBytes json.RawMessage
        adapterResponeBytes, err = jsonutil.Marshal(rb.adapterRespone)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = jsonutil.UnmarshalValid(adapterResponeBytes, &amp;resp)
        return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
